/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"tfjs-library":"tfjs-library"}[chunkId]||chunkId) + ".bundle.js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							var error = new Error('Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')');
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/codemirror/addon/fold/brace-fold.js":
/*!**********************************************************!*\
  !*** ./node_modules/codemirror/addon/fold/brace-fold.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.registerHelper("fold", "brace", function(cm, start) {
  var line = start.line, lineText = cm.getLine(line);
  var tokenType;

  function findOpening(openCh) {
    for (var at = start.ch, pass = 0;;) {
      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
      if (found == -1) {
        if (pass == 1) break;
        pass = 1;
        at = lineText.length;
        continue;
      }
      if (pass == 1 && found < start.ch) break;
      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));
      if (!/^(comment|string)/.test(tokenType)) return found + 1;
      at = found - 1;
    }
  }

  var startToken = "{", endToken = "}", startCh = findOpening("{");
  if (startCh == null) {
    startToken = "[", endToken = "]";
    startCh = findOpening("[");
  }

  if (startCh == null) return;
  var count = 1, lastLine = cm.lastLine(), end, endCh;
  outer: for (var i = line; i <= lastLine; ++i) {
    var text = cm.getLine(i), pos = i == line ? startCh : 0;
    for (;;) {
      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
      if (nextOpen < 0) nextOpen = text.length;
      if (nextClose < 0) nextClose = text.length;
      pos = Math.min(nextOpen, nextClose);
      if (pos == text.length) break;
      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {
        if (pos == nextOpen) ++count;
        else if (!--count) { end = i; endCh = pos; break outer; }
      }
      ++pos;
    }
  }
  if (end == null || line == end) return;
  return {from: CodeMirror.Pos(line, startCh),
          to: CodeMirror.Pos(end, endCh)};
});

CodeMirror.registerHelper("fold", "import", function(cm, start) {
  function hasImport(line) {
    if (line < cm.firstLine() || line > cm.lastLine()) return null;
    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
    if (start.type != "keyword" || start.string != "import") return null;
    // Now find closing semicolon, return its position
    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
      var text = cm.getLine(i), semi = text.indexOf(";");
      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};
    }
  }

  var startLine = start.line, has = hasImport(startLine), prev;
  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))
    return null;
  for (var end = has.end;;) {
    var next = hasImport(end.line + 1);
    if (next == null) break;
    end = next.end;
  }
  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};
});

CodeMirror.registerHelper("fold", "include", function(cm, start) {
  function hasInclude(line) {
    if (line < cm.firstLine() || line > cm.lastLine()) return null;
    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
    if (start.type == "meta" && start.string.slice(0, 8) == "#include") return start.start + 8;
  }

  var startLine = start.line, has = hasInclude(startLine);
  if (has == null || hasInclude(startLine - 1) != null) return null;
  for (var end = startLine;;) {
    var next = hasInclude(end + 1);
    if (next == null) break;
    ++end;
  }
  return {from: CodeMirror.Pos(startLine, has + 1),
          to: cm.clipPos(CodeMirror.Pos(end))};
});

});


/***/ }),

/***/ "./node_modules/codemirror/addon/fold/foldcode.js":
/*!********************************************************!*\
  !*** ./node_modules/codemirror/addon/fold/foldcode.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function doFold(cm, pos, options, force) {
    if (options && options.call) {
      var finder = options;
      options = null;
    } else {
      var finder = getOption(cm, options, "rangeFinder");
    }
    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);
    var minSize = getOption(cm, options, "minFoldSize");

    function getRange(allowFolded) {
      var range = finder(cm, pos);
      if (!range || range.to.line - range.from.line < minSize) return null;
      var marks = cm.findMarksAt(range.from);
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold && force !== "fold") {
          if (!allowFolded) return null;
          range.cleared = true;
          marks[i].clear();
        }
      }
      return range;
    }

    var range = getRange(true);
    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
      pos = CodeMirror.Pos(pos.line - 1, 0);
      range = getRange(false);
    }
    if (!range || range.cleared || force === "unfold") return;

    var myWidget = makeWidget(cm, options);
    CodeMirror.on(myWidget, "mousedown", function(e) {
      myRange.clear();
      CodeMirror.e_preventDefault(e);
    });
    var myRange = cm.markText(range.from, range.to, {
      replacedWith: myWidget,
      clearOnEnter: getOption(cm, options, "clearOnEnter"),
      __isFold: true
    });
    myRange.on("clear", function(from, to) {
      CodeMirror.signal(cm, "unfold", cm, from, to);
    });
    CodeMirror.signal(cm, "fold", cm, range.from, range.to);
  }

  function makeWidget(cm, options) {
    var widget = getOption(cm, options, "widget");
    if (typeof widget == "string") {
      var text = document.createTextNode(widget);
      widget = document.createElement("span");
      widget.appendChild(text);
      widget.className = "CodeMirror-foldmarker";
    } else if (widget) {
      widget = widget.cloneNode(true)
    }
    return widget;
  }

  // Clumsy backwards-compatible interface
  CodeMirror.newFoldFunction = function(rangeFinder, widget) {
    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };
  };

  // New-style interface
  CodeMirror.defineExtension("foldCode", function(pos, options, force) {
    doFold(this, pos, options, force);
  });

  CodeMirror.defineExtension("isFolded", function(pos) {
    var marks = this.findMarksAt(pos);
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold) return true;
  });

  CodeMirror.commands.toggleFold = function(cm) {
    cm.foldCode(cm.getCursor());
  };
  CodeMirror.commands.fold = function(cm) {
    cm.foldCode(cm.getCursor(), null, "fold");
  };
  CodeMirror.commands.unfold = function(cm) {
    cm.foldCode(cm.getCursor(), null, "unfold");
  };
  CodeMirror.commands.foldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");
    });
  };
  CodeMirror.commands.unfoldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");
    });
  };

  CodeMirror.registerHelper("fold", "combine", function() {
    var funcs = Array.prototype.slice.call(arguments, 0);
    return function(cm, start) {
      for (var i = 0; i < funcs.length; ++i) {
        var found = funcs[i](cm, start);
        if (found) return found;
      }
    };
  });

  CodeMirror.registerHelper("fold", "auto", function(cm, start) {
    var helpers = cm.getHelpers(start, "fold");
    for (var i = 0; i < helpers.length; i++) {
      var cur = helpers[i](cm, start);
      if (cur) return cur;
    }
  });

  var defaultOptions = {
    rangeFinder: CodeMirror.fold.auto,
    widget: "\u2194",
    minFoldSize: 0,
    scanUp: false,
    clearOnEnter: true
  };

  CodeMirror.defineOption("foldOptions", null);

  function getOption(cm, options, name) {
    if (options && options[name] !== undefined)
      return options[name];
    var editorOptions = cm.options.foldOptions;
    if (editorOptions && editorOptions[name] !== undefined)
      return editorOptions[name];
    return defaultOptions[name];
  }

  CodeMirror.defineExtension("foldOption", function(options, name) {
    return getOption(this, options, name);
  });
});


/***/ }),

/***/ "./node_modules/codemirror/addon/fold/foldgutter.css":
/*!***********************************************************!*\
  !*** ./node_modules/codemirror/addon/fold/foldgutter.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/codemirror/addon/fold/foldgutter.js":
/*!**********************************************************!*\
  !*** ./node_modules/codemirror/addon/fold/foldgutter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"), __webpack_require__(/*! ./foldcode */ "./node_modules/codemirror/addon/fold/foldcode.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption("foldGutter", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.clearGutter(cm.state.foldGutter.options.gutter);
      cm.state.foldGutter = null;
      cm.off("gutterClick", onGutterClick);
      cm.off("change", onChange);
      cm.off("viewportChange", onViewportChange);
      cm.off("fold", onFold);
      cm.off("unfold", onFold);
      cm.off("swapDoc", onChange);
    }
    if (val) {
      cm.state.foldGutter = new State(parseOptions(val));
      updateInViewport(cm);
      cm.on("gutterClick", onGutterClick);
      cm.on("change", onChange);
      cm.on("viewportChange", onViewportChange);
      cm.on("fold", onFold);
      cm.on("unfold", onFold);
      cm.on("swapDoc", onChange);
    }
  });

  var Pos = CodeMirror.Pos;

  function State(options) {
    this.options = options;
    this.from = this.to = 0;
  }

  function parseOptions(opts) {
    if (opts === true) opts = {};
    if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";
    if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";
    if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";
    return opts;
  }

  function isFolded(cm, line) {
    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];
  }

  function marker(spec) {
    if (typeof spec == "string") {
      var elt = document.createElement("div");
      elt.className = spec + " CodeMirror-guttermarker-subtle";
      return elt;
    } else {
      return spec.cloneNode(true);
    }
  }

  function updateFoldInfo(cm, from, to) {
    var opts = cm.state.foldGutter.options, cur = from;
    var minSize = cm.foldOption(opts, "minFoldSize");
    var func = cm.foldOption(opts, "rangeFinder");
    cm.eachLine(from, to, function(line) {
      var mark = null;
      if (isFolded(cm, cur)) {
        mark = marker(opts.indicatorFolded);
      } else {
        var pos = Pos(cur, 0);
        var range = func && func(cm, pos);
        if (range && range.to.line - range.from.line >= minSize)
          mark = marker(opts.indicatorOpen);
      }
      cm.setGutterMarker(line, opts.gutter, mark);
      ++cur;
    });
  }

  function updateInViewport(cm) {
    var vp = cm.getViewport(), state = cm.state.foldGutter;
    if (!state) return;
    cm.operation(function() {
      updateFoldInfo(cm, vp.from, vp.to);
    });
    state.from = vp.from; state.to = vp.to;
  }

  function onGutterClick(cm, line, gutter) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    if (gutter != opts.gutter) return;
    var folded = isFolded(cm, line);
    if (folded) folded.clear();
    else cm.foldCode(Pos(line, 0), opts.rangeFinder);
  }

  function onChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    state.from = state.to = 0;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);
  }

  function onViewportChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() {
      var vp = cm.getViewport();
      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
        updateInViewport(cm);
      } else {
        cm.operation(function() {
          if (vp.from < state.from) {
            updateFoldInfo(cm, vp.from, state.from);
            state.from = vp.from;
          }
          if (vp.to > state.to) {
            updateFoldInfo(cm, state.to, vp.to);
            state.to = vp.to;
          }
        });
      }
    }, opts.updateViewportTimeSpan || 400);
  }

  function onFold(cm, from) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var line = from.line;
    if (line >= state.from && line < state.to)
      updateFoldInfo(cm, line, line + 1);
  }
});


/***/ }),

/***/ "./node_modules/codemirror/addon/lint/lint.css":
/*!*****************************************************!*\
  !*** ./node_modules/codemirror/addon/lint/lint.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/codemirror/addon/lint/lint.js":
/*!****************************************************!*\
  !*** ./node_modules/codemirror/addon/lint/lint.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";
  var GUTTER_ID = "CodeMirror-lint-markers";

  function showTooltip(e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip";
    tt.appendChild(content.cloneNode(true));
    document.body.appendChild(tt);

    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = (e.clientX + 5) + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    if (elt.parentNode) elt.parentNode.removeChild(elt);
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function() { rm(tt); }, 600);
  }

  function showTooltipFor(e, content, node) {
    var tooltip = showTooltip(e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
    }
    var poll = setInterval(function() {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n && n.nodeType == 11) n = n.host;
        if (n == document.body) return;
        if (!n) { hide(); break; }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }

  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
    this.waitingFor = 0
  }

  function parseOptions(_cm, options) {
    if (options instanceof Function) return {getAnnotations: options};
    if (!options || options === true) options = {};
    return options;
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    for (var i = 0; i < state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function makeMarker(labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"), inner = marker;
    marker.className = "CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker-multiple";
    }

    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
      showTooltipFor(e, labels, inner);
    });

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a == "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!severity) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message-" + severity;
    if (typeof ann.messageHTML != 'undefined') {
        tip.innerHTML = ann.messageHTML;
    } else {
        tip.appendChild(document.createTextNode(ann.message));
    }
    return tip;
  }

  function lintAsync(cm, getAnnotations, passOptions) {
    var state = cm.state.lint
    var id = ++state.waitingFor
    function abort() {
      id = -1
      cm.off("change", abort)
    }
    cm.on("change", abort)
    getAnnotations(cm.getValue(), function(annotations, arg2) {
      cm.off("change", abort)
      if (state.waitingFor != id) return
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2
      cm.operation(function() {updateLinting(cm, annotations)})
    }, passOptions, cm);
  }

  function startLinting(cm) {
    var state = cm.state.lint, options = state.options;
    /*
     * Passing rules in `options` property prevents JSHint (and other linters) from complaining
     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.
     */
    var passOptions = options.options || options;
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;
    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations, passOptions)
    } else {
      var annotations = getAnnotations(cm.getValue(), passOptions, cm);
      if (!annotations) return;
      if (annotations.then) annotations.then(function(issues) {
        cm.operation(function() {updateLinting(cm, issues)})
      });
      else cm.operation(function() {updateLinting(cm, annotations)})
    }
  }

  function updateLinting(cm, annotationsNotSorted) {
    clearMarks(cm);
    var state = cm.state.lint, options = state.options;

    var annotations = groupByLine(annotationsNotSorted);

    for (var line = 0; line < annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;

      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();

      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!severity) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }

      if (state.hasGutter)
        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
                                                       state.options.tooltips));
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }

  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
  }

  function popupTooltips(annotations, e) {
    var target = e.target || e.srcElement;
    var tooltip = document.createDocumentFragment();
    for (var i = 0; i < annotations.length; i++) {
      var ann = annotations[i];
      tooltip.appendChild(annotationTooltip(ann));
    }
    showTooltipFor(e, tooltip, target);
  }

  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));

    var annotations = [];
    for (var i = 0; i < spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) annotations.push(ann);
    }
    if (annotations.length) popupTooltips(annotations, e);
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false)
        cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      if (state.options.lintOnChange !== false)
        cm.on("change", onChange);
      if (state.options.tooltips != false && state.options.tooltips != "gutter")
        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });

  CodeMirror.defineExtension("performLint", function() {
    if (this.state.lint) startLinting(this);
  });
});


/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.css":
/*!****************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.js":
/*!***************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {this.id = null;};
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range$$1;
    try {range$$1 = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range$$1 || range$$1.parentElement() != te) { return false }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
      var this$1 = this;

    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
      var this$1 = this;

    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this$1.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    for (var i = 0; i < lineView.rest.length; i++)
      { if (lineView.rest[i] == line)
        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
      { if (lineNo(lineView.rest[i$1]) > lineN)
        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
      { height += widgetHeight(lineObj.widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = true; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top || y >= coords.bottom;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        { drawSelectionCursor(cm, range$$1.head, curFragment); }
      if (!collapsed)
        { drawSelectionRange(cm, range$$1, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range$$1.from(), sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
        cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      onBlur(cm);
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
      var this$1 = this;

    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this$1.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
      var this$1 = this;

    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
      var this$1 = this;

    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
      var this$1 = this;

    for (var i = 0; i < this.ranges.length; i++)
      { if (!this$1.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
      var this$1 = this;

    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        var this$1 = this;

        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;
      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;

    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      var this$1 = this;

      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      var this$1 = this;

      for (var e = at + n; at < e; ++at)
        { if (op(this$1.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    var this$1 = this;

    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      var this$1 = this;

      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    var this$1 = this;

    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this$1[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
      var this$1 = this;

    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
      var this$1 = this;

    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    var this$1 = this;

    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this$1; }
  };

  SharedTextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this$1.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range$$1 = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range$$1.head; }
      else if (start == "anchor") { pos = range$$1.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
      else { pos = range$$1.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      var this$1 = this;

      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                           clipPos(this$1, ranges[i].head)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var this$1 = this;

      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var this$1 = this;

      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var this$1 = this;

      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this$1, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
                span.from == null && lineNo$$1 != from.line ||
                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo$$1;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo$$1;
      });
      return clipPos(this, Pos(lineNo$$1, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      var this$1 = this;

      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this$1.linked[i];
        if (link.doc != other) { continue }
        this$1.linked.splice(i, 1);
        other.unlinkDoc(this$1);
        detachSharedMarkers(findSharedMarkers(this$1));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          { return }

        var reader = new FileReader;
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
        { return lookupKey(key, map$$1.fallthrough, handle, context) }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    delayBlurEvent(cm);
    setTimeout(function () { return display.input.focus(); }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
      else
        { ourRange = range$$1; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
    var order = getOrder(anchorLine);
    if (!order) { return range$$1 }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range$$1 }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(bind(onFocus, this), 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this$1, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(), to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
          { indented = indentLine(cm, range$$1.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function(map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var this$1 = this;

        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var this$1 = this;

        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(), to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this$1, j, how); }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var this$1 = this;

        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range$$1 = this.doc.sel.primary();
        if (start == null) { pos = range$$1.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range$$1.from() : range$$1.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var this$1 = this;

        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range$$1.from() : range$$1.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range$$1) {
            var other = findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var this$1 = this;

        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this$1, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse)
            { return dir < 0 ? range$$1.from() : range$$1.to() }
          var headPos = cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range$$1 == "number") {
          range$$1 = {from: Pos(range$$1, 0), to: null};
        } else if (range$$1.from == null) {
          range$$1 = {from: range$$1, to: null};
        }
        if (!range$$1.to) { range$$1.to = range$$1.from; }
        range$$1.margin = margin || 0;

        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    function findNextLine() {
      var l = pos.line + dir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor())
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor())
      { this.pollSelection(); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find(0)))
            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, */) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.46.0";

  return CodeMirror;

})));


/***/ }),

/***/ "./node_modules/codemirror/mode/javascript/javascript.js":
/*!***************************************************************!*\
  !*** ./node_modules/codemirror/mode/javascript/javascript.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    return {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C
    };
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.match(/^(?:x[\da-f]+|o[0-7]+|b[01]+)n?/i)) {
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:n|(?:\.\d*)?(?:[eE][+\-]?\d+)?)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eat("=");
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
        if (stream.eat("=")) {
          if (ch == "!" || ch == "=") stream.eat("=")
        } else if (/[<>*+\-]/.test(ch)) {
          stream.eat(ch)
          if (ch == ">") stream.eat(ch)
        }
      }
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current()
      if (state.lastType != ".") {
        if (keywords.propertyIsEnumerable(word)) {
          var kw = keywords[word]
          return ret(kw.type, kw.style, word)
        }
        if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false))
          return ret("async", "keyword", word)
      }
      return ret("variable", "variable", word)
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
      if (m) arrow = m.index
    }

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function inList(name, list) {
    for (var v = list; v; v = v.next) if (v.name == name) return true
    return false;
  }
  function register(varname) {
    var state = cx.state;
    cx.marked = "def";
    if (state.context) {
      if (state.lexical.info == "var" && state.context && state.context.block) {
        // FIXME function decls are also not block scoped
        var newContext = registerVarScoped(varname, state.context)
        if (newContext != null) {
          state.context = newContext
          return
        }
      } else if (!inList(varname, state.localVars)) {
        state.localVars = new Var(varname, state.localVars)
        return
      }
    }
    // Fall through means this is global
    if (parserConfig.globalVars && !inList(varname, state.globalVars))
      state.globalVars = new Var(varname, state.globalVars)
  }
  function registerVarScoped(varname, context) {
    if (!context) {
      return null
    } else if (context.block) {
      var inner = registerVarScoped(varname, context.prev)
      if (!inner) return null
      if (inner == context.prev) return context
      return new Context(inner, context.vars, true)
    } else if (inList(varname, context.vars)) {
      return context
    } else {
      return new Context(context.prev, new Var(varname, context.vars), false)
    }
  }

  function isModifier(name) {
    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
  }

  // Combinators

  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }
  function Var(name, next) { this.name = name; this.next = next }

  var defaultVars = new Var("this", new Var("arguments", null))
  function pushcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)
    cx.state.localVars = defaultVars
  }
  function pushblockcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)
    cx.state.localVars = null
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars
    cx.state.context = cx.state.context.prev
  }
  popcontext.lex = true
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
    if (type == "debugger") return cont(expect(";"));
    if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "class" || (isTS && value == "interface")) {
      cx.marked = "keyword"
      return cont(pushlex("form", type == "class" ? type : value), className, poplex)
    }
    if (type == "variable") {
      if (isTS && value == "declare") {
        cx.marked = "keyword"
        return cont(statement)
      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
        cx.marked = "keyword"
        if (value == "enum") return cont(enumdef);
        else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
      } else if (isTS && value == "namespace") {
        cx.marked = "keyword"
        return cont(pushlex("form"), expression, statement, poplex)
      } else if (isTS && value == "abstract") {
        cx.marked = "keyword"
        return cont(statement)
      } else {
        return cont(pushlex("stat"), maybelabel);
      }
    }
    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
                                      block, poplex, poplex, popcontext);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "async") return cont(statement)
    if (value == "@") return cont(expression, statement)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function maybeCatchBinding(type) {
    if (type == "(") return cont(funarg, expect(")"))
  }
  function expression(type, value) {
    return expressionInner(type, value, false);
  }
  function expressionNoComma(type, value) {
    return expressionInner(type, value, true);
  }
  function parenExpr(type) {
    if (type != "(") return pass()
    return cont(pushlex(")"), expression, expect(")"), poplex)
  }
  function expressionInner(type, value, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    if (type == "import") return cont(expression);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
      if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false))
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
    if (type == "regexp") {
      cx.state.lastType = cx.marked = "operator"
      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
      return cont(expr)
    }
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "async") {
      cx.marked = "property";
      return cont(objprop);
    } else if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
        cx.state.fatArrowAt = cx.stream.pos + m[0].length
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (isTS && isModifier(value)) {
      cx.marked = "keyword"
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expressionNoComma, afterprop);
    } else if (value == "*") {
      cx.marked = "keyword";
      return cont(objprop);
    } else if (type == ":") {
      return pass(afterprop)
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end, sep) {
    function proceed(type, value) {
      if (sep ? sep.indexOf(type) > -1 : type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(function(type, value) {
          if (type == end || value == end) return pass()
          return pass(what)
        }, proceed);
      }
      if (type == end || value == end) return cont();
      if (sep && sep.indexOf(";") > -1) return pass(what)
      return cont(expect(end));
    }
    return function(type, value) {
      if (type == end || value == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type, value) {
    if (isTS) {
      if (type == ":" || value == "in") return cont(typeexpr);
      if (value == "?") return cont(maybetype);
    }
  }
  function mayberettype(type) {
    if (isTS && type == ":") {
      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
      else return cont(typeexpr)
    }
  }
  function isKW(_, value) {
    if (value == "is") {
      cx.marked = "keyword"
      return cont()
    }
  }
  function typeexpr(type, value) {
    if (value == "keyof" || value == "typeof" || value == "infer") {
      cx.marked = "keyword"
      return cont(value == "typeof" ? expressionNoComma : typeexpr)
    }
    if (type == "variable" || value == "void") {
      cx.marked = "type"
      return cont(afterType)
    }
    if (value == "|" || value == "&") return cont(typeexpr)
    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
  }
  function maybeReturnType(type) {
    if (type == "=>") return cont(typeexpr)
  }
  function typeprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property"
      return cont(typeprop)
    } else if (value == "?" || type == "number" || type == "string") {
      return cont(typeprop)
    } else if (type == ":") {
      return cont(typeexpr)
    } else if (type == "[") {
      return cont(expect("variable"), maybetype, expect("]"), typeprop)
    } else if (type == "(") {
      return pass(functiondecl, typeprop)
    }
  }
  function typearg(type, value) {
    if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
    if (type == ":") return cont(typeexpr)
    if (type == "spread") return cont(typearg)
    return pass(typeexpr)
  }
  function afterType(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
    if (type == "[") return cont(typeexpr, expect("]"), afterType)
    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
    if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
  }
  function maybeTypeArgs(_, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
  }
  function typeparam() {
    return pass(typeexpr, maybeTypeDefault)
  }
  function maybeTypeDefault(_, value) {
    if (value == "=") return cont(typeexpr)
  }
  function vardef(_, value) {
    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(eltpattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
    return cont(expect(":"), pattern, maybeAssign);
  }
  function eltpattern() {
    return pass(pattern, maybeAssign)
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type, value) {
    if (value == "await") return cont(forspec);
    if (type == "(") return cont(pushlex(")"), forspec1, poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, forspec2);
    if (type == "variable") return cont(forspec2);
    return pass(forspec2)
  }
  function forspec2(type, value) {
    if (type == ")") return cont()
    if (type == ";") return cont(forspec2)
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
    return pass(expression, forspec2)
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
  }
  function functiondecl(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
    if (type == "variable") {register(value); return cont(functiondecl);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
  }
  function typename(type, value) {
    if (type == "keyword" || type == "variable") {
      cx.marked = "type"
      return cont(typename)
    } else if (value == "<") {
      return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
    }
  }
  function funarg(type, value) {
    if (value == "@") cont(expression, funarg)
    if (type == "spread") return cont(funarg);
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
    if (isTS && type == "this") return cont(maybetype, maybeAssign)
    return pass(pattern, maybetype, maybeAssign);
  }
  function classExpression(type, value) {
    // Class expressions may have an optional name.
    if (type == "variable") return className(type, value);
    return classNameAfter(type, value);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
      if (value == "implements") cx.marked = "keyword";
      return cont(isTS ? typeexpr : expression, classNameAfter);
    }
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "async" ||
        (type == "variable" &&
         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(isTS ? classfield : functiondef, classBody);
    }
    if (type == "number" || type == "string") return cont(isTS ? classfield : functiondef, classBody);
    if (type == "[")
      return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody)
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (isTS && type == "(") return pass(functiondecl, classBody)
    if (type == ";" || type == ",") return cont(classBody);
    if (type == "}") return cont();
    if (value == "@") return cont(expression, classBody)
  }
  function classfield(type, value) {
    if (value == "?") return cont(classfield)
    if (type == ":") return cont(typeexpr, maybeAssign)
    if (value == "=") return cont(expressionNoComma)
    var context = cx.state.lexical.prev, isInterface = context && context.info == "interface"
    return pass(isInterface ? functiondecl : functiondef)
  }
  function afterExport(type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
    return pass(statement);
  }
  function exportField(type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
    if (type == "variable") return pass(expressionNoComma, exportField);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    if (type == "(") return pass(expression);
    return pass(importSpec, maybeMoreImports, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeMoreImports(type) {
    if (type == ",") return cont(importSpec, maybeMoreImports)
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(commasep(expressionNoComma, "]"));
  }
  function enumdef() {
    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
  }
  function enummember() {
    return pass(pattern, maybeAssign);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  function expressionAllowed(stream, state, backUp) {
    return state.tokenize == tokenBase &&
      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && new Context(null, null, false),
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      while ((lexical.type == "stat" || lexical.type == "form") &&
             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    blockCommentContinue: jsonMode ? null : " * ",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,

    skipExpression: function(state) {
      var top = state.cc[state.cc.length - 1]
      if (top == expression || top == expressionNoComma) state.cc.pop()
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});


/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

/***/ }),

/***/ "./node_modules/gl-matrix/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/index.js ***!
  \*********************************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ "./node_modules/gl-matrix/esm/mat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ "./node_modules/gl-matrix/esm/mat2d.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ "./node_modules/gl-matrix/esm/quat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ "./node_modules/gl-matrix/esm/vec2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });












/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2d.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2d.js ***!
  \*********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, multiply, rotateX, rotateY, rotateZ, calculateW, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat2.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat2.js ***!
  \*********************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }

  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {quat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {quat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */

function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/glsl-editor/glsl.js":
/*!******************************************!*\
  !*** ./node_modules/glsl-editor/glsl.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(CodeMirror) {
  CodeMirror.defineMode("glsl", function(config, parserConfig) {
    var indentUnit = config.indentUnit,
        keywords = parserConfig.keywords || words(glslKeywords),
        builtins = parserConfig.builtins || words(glslBuiltins),
        blockKeywords = parserConfig.blockKeywords || words("case do else for if switch while struct"),
        atoms = parserConfig.atoms || words("null"),
        hooks = parserConfig.hooks || {},
        multiLineStrings = parserConfig.multiLineStrings;
    var isOperatorChar = /[+\-*&%=<>!?|\/]/;

    var curPunc;

    function tokenBase(stream, state) {
      var ch = stream.next();
      if (hooks[ch]) {
        var result = hooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        curPunc = ch;
        return "bracket";
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (stream.eat("/")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (ch == "#") {
        stream.eatWhile(/[\S]+/);
        stream.eatWhile(/[\s]+/);
        stream.eatWhile(/[\S]+/);
        stream.eatWhile(/[\s]+/);
        return "comment";
      }
      if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
      stream.eatWhile(/[\w\$_]/);
      var cur = stream.current();
      if (keywords.propertyIsEnumerable(cur)) {
        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
        return "keyword";
      }
      if (builtins.propertyIsEnumerable(cur)) {
        return "builtin";
      }
      if (atoms.propertyIsEnumerable(cur)) return "atom";
      return "word";
    }

    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) {end = true; break;}
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = tokenBase;
        return "string";
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }

    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type) {
      return state.context = new Context(state.indented, col, type, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    // Interface

    return {
      startState: function(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },

      token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment" || style == "meta") return style;
        if (ctx.align == null) ctx.align = true;

        if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
          pushContext(state, stream.column(), "statement");
        state.startOfLine = false;
        return style;
      },

      indent: function(state, textAfter) {
        if (state.tokenize != tokenBase && state.tokenize != null) return 0;
        var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
        if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
        else if (ctx.align) return ctx.column + (closing ? 0 : 1);
        else return ctx.indented + (closing ? 0 : indentUnit);
      },

      electricChars: "{}"
    };
  });

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var glslKeywords = "attribute const uniform varying break continue " +
    "do for while if else in out inout float int void bool true false " +
    "lowp mediump highp precision invariant discard return mat2 mat3 " +
    "mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler2D " +
    "samplerCube struct gl_FragCoord gl_FragColor";
  var glslBuiltins = "radians degrees sin cos tan asin acos atan pow " +
    "exp log exp2 log2 sqrt inversesqrt abs sign floor ceil fract mod " +
    "min max clamp mix step smoothstep length distance dot cross " +
    "normalize faceforward reflect refract matrixCompMult lessThan " +
    "lessThanEqual greaterThan greaterThanEqual equal notEqual any all " +
    "not dFdx dFdy fwidth texture2D texture2DProj texture2DLod " +
    "texture2DProjLod textureCube textureCubeLod require export";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    stream.skipToEnd();
    return "meta";
  }

  ;(function() {
    // C#-style strings where "" escapes a quote.
    function tokenAtString(stream, state) {
      var next;
      while ((next = stream.next()) != null) {
        if (next == '"' && !stream.eat('"')) {
          state.tokenize = null;
          break;
        }
      }
      return "string";
    }

    CodeMirror.defineMIME("text/x-glsl", {
      name: "glsl",
      keywords: words(glslKeywords),
      builtins: words(glslBuiltins),
      blockKeywords: words("case do else for if switch while struct"),
      atoms: words("null"),
      hooks: {"#": cppHook}
    });
  }());
}


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/throttle.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/throttle.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(/*! ./debounce */ "./node_modules/lodash/debounce.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["default"] = (index);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_ui_default_viewer_setup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/ui/default_viewer_setup */ "./src/neuroglancer/ui/default_viewer_setup.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Main entry point for default neuroglancer viewer.
 */

window.addEventListener('DOMContentLoaded', () => {
    Object(neuroglancer_ui_default_viewer_setup__WEBPACK_IMPORTED_MODULE_0__["setupDefaultViewer"])();
});


/***/ }),

/***/ "./src/neuroglancer/annotation/annotation_layer_state.ts":
/*!***************************************************************!*\
  !*** ./src/neuroglancer/annotation/annotation_layer_state.ts ***!
  \***************************************************************/
/*! exports provided: AnnotationHoverState, AnnotationLayerState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationHoverState", function() { return AnnotationHoverState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationLayerState", function() { return AnnotationLayerState; });
/* harmony import */ var neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/coordinate_transform */ "./src/neuroglancer/coordinate_transform.ts");
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/trackable_boolean */ "./src/neuroglancer/trackable_boolean.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class AnnotationHoverState extends neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_3__["WatchableValue"] {
}
class AnnotationLayerState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["RefCounted"] {
    constructor(options) {
        super();
        this.transformCacheGeneration = -1;
        this.cachedObjectToGlobal = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].create();
        this.cachedGlobalToObject = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].create();
        const { transform = new neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_0__["CoordinateTransform"](), source, hoverState = new AnnotationHoverState(undefined), role = neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__["RenderLayerRole"].ANNOTATION, color, fillOpacity, segmentationState = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_3__["WatchableValue"](null), filterBySegmentation = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_2__["TrackableBoolean"](false), } = options;
        this.transform = transform;
        this.source = this.registerDisposer(source);
        this.hoverState = hoverState;
        this.role = role;
        this.color = color;
        this.fillOpacity = fillOpacity;
        this.segmentationState = segmentationState;
        this.filterBySegmentation = filterBySegmentation;
    }
    updateTransforms() {
        const { transform, transformCacheGeneration } = this;
        const generation = transform.changed.count;
        if (generation === transformCacheGeneration) {
            return;
        }
        const { cachedObjectToGlobal } = this;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].multiply(cachedObjectToGlobal, this.transform.transform, this.source.objectToLocal);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].invert(this.cachedGlobalToObject, cachedObjectToGlobal);
    }
    get objectToGlobal() {
        this.updateTransforms();
        return this.cachedObjectToGlobal;
    }
    get globalToObject() {
        this.updateTransforms();
        return this.cachedGlobalToObject;
    }
}


/***/ }),

/***/ "./src/neuroglancer/annotation/base.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/annotation/base.ts ***!
  \*********************************************/
/*! exports provided: ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID, ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID, ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID, ANNOTATION_REFERENCE_ADD_RPC_ID, ANNOTATION_REFERENCE_DELETE_RPC_ID, ANNOTATION_COMMIT_UPDATE_RPC_ID, ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, AnnotationGeometryChunkSpecification, ANNOTATION_PERSPECTIVE_RENDER_LAYER_RPC_ID, ANNOTATION_RENDER_LAYER_RPC_ID, ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID", function() { return ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID", function() { return ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID", function() { return ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_REFERENCE_ADD_RPC_ID", function() { return ANNOTATION_REFERENCE_ADD_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_REFERENCE_DELETE_RPC_ID", function() { return ANNOTATION_REFERENCE_DELETE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_COMMIT_UPDATE_RPC_ID", function() { return ANNOTATION_COMMIT_UPDATE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID", function() { return ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationGeometryChunkSpecification", function() { return AnnotationGeometryChunkSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_PERSPECTIVE_RENDER_LAYER_RPC_ID", function() { return ANNOTATION_PERSPECTIVE_RENDER_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_RENDER_LAYER_RPC_ID", function() { return ANNOTATION_RENDER_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID", function() { return ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID; });
/* harmony import */ var neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/base */ "./src/neuroglancer/sliceview/base.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID = 'annotation.MetadataChunkSource';
const ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID = 'annotation.GeometryChunkSource';
const ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID = 'annotation.SubsetGeometryChunkSource';
const ANNOTATION_REFERENCE_ADD_RPC_ID = 'annotation.reference.add';
const ANNOTATION_REFERENCE_DELETE_RPC_ID = 'annotation.reference.delete';
const ANNOTATION_COMMIT_UPDATE_RPC_ID = 'annotation.commit';
const ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID = 'annotation.commit';
class AnnotationGeometryChunkSpecification extends neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["SliceViewChunkSpecification"] {
}
const ANNOTATION_PERSPECTIVE_RENDER_LAYER_RPC_ID = 'annotation/PerspectiveRenderLayer';
const ANNOTATION_RENDER_LAYER_RPC_ID = 'annotation/RenderLayer';
const ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID = 'annotation/RenderLayer.updateSegmentation';


/***/ }),

/***/ "./src/neuroglancer/annotation/bounding_box.ts":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/annotation/bounding_box.ts ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/type_handler */ "./src/neuroglancer/annotation/type_handler.ts");
/* harmony import */ var neuroglancer_sliceview_bounding_box_shader_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/sliceview/bounding_box_shader_helper */ "./src/neuroglancer/sliceview/bounding_box_shader_helper.ts");
/* harmony import */ var neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/array */ "./src/neuroglancer/util/array.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/* harmony import */ var neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/webgl/circles */ "./src/neuroglancer/webgl/circles.ts");
/* harmony import */ var neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/webgl/lines */ "./src/neuroglancer/webgl/lines.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Support for rendering bounding box annotations.
 */









const EDGES_PER_BOX = 12;
const CORNERS_PER_BOX = 8;
const FULL_OBJECT_PICK_OFFSET = 0;
const CORNERS_PICK_OFFSET = FULL_OBJECT_PICK_OFFSET + 1;
const EDGES_PICK_OFFSET = CORNERS_PICK_OFFSET + CORNERS_PER_BOX;
const FACES_PICK_OFFSET = EDGES_PICK_OFFSET + EDGES_PER_BOX;
const PICK_IDS_PER_INSTANCE = FACES_PICK_OFFSET + 6;
const edgeBoxCornerOffsetData = Float32Array.from([
    // a1
    0, 0, 0,
    // b1
    0, 0, 1,
    // c1
    EDGES_PICK_OFFSET + 0,
    // a2
    1, 0, 0,
    // b2
    1, 0, 1,
    // c2
    EDGES_PICK_OFFSET + 1,
    // a3
    0, 1, 0,
    // b3
    0, 1, 1,
    // c3
    EDGES_PICK_OFFSET + 2,
    // a4
    1, 1, 0,
    // b4
    1, 1, 1,
    // c4
    EDGES_PICK_OFFSET + 3,
    // a5
    0, 0, 0,
    // b5
    0, 1, 0,
    // c5
    EDGES_PICK_OFFSET + 4,
    // a6
    0, 0, 1,
    // b6
    0, 1, 1,
    // c6
    EDGES_PICK_OFFSET + 5,
    // a7
    1, 0, 0,
    // b7
    1, 1, 0,
    // c7
    EDGES_PICK_OFFSET + 6,
    // a8
    1, 0, 1,
    // b8
    1, 1, 1,
    // c8
    EDGES_PICK_OFFSET + 7,
    // a9
    0, 0, 0,
    // b9
    1, 0, 0,
    // c9
    EDGES_PICK_OFFSET + 8,
    // a10
    0, 0, 1,
    // b10
    1, 0, 1,
    // c10
    EDGES_PICK_OFFSET + 9,
    // a11
    0, 1, 0,
    // b11
    1, 1, 0,
    // c11
    EDGES_PICK_OFFSET + 10,
    // a12
    0, 1, 1,
    // b12
    1, 1, 1,
    // c12
    EDGES_PICK_OFFSET + 11
]);
class RenderHelper extends neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__["AnnotationRenderHelper"] {
    defineShader(builder) {
        super.defineShader(builder);
        // Position of point in camera coordinates.
        builder.addAttribute('highp vec3', 'aLower');
        builder.addAttribute('highp vec3', 'aUpper');
    }
    enable(shader, context, callback) {
        super.enable(shader, context, () => {
            const { gl } = shader;
            const aLower = shader.attribute('aLower');
            const aUpper = shader.attribute('aUpper');
            context.buffer.bindToVertexAttrib(aLower, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 4 * 6, /*offset=*/ context.bufferOffset);
            context.buffer.bindToVertexAttrib(aUpper, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 4 * 6, /*offset=*/ context.bufferOffset + 4 * 3);
            gl.vertexAttribDivisor(aLower, 1);
            gl.vertexAttribDivisor(aUpper, 1);
            callback();
            gl.vertexAttribDivisor(aLower, 0);
            gl.vertexAttribDivisor(aUpper, 0);
            gl.disableVertexAttribArray(aLower);
            gl.disableVertexAttribArray(aUpper);
        });
    }
}
class PerspectiveViewRenderHelper extends RenderHelper {
    constructor() {
        super(...arguments);
        this.lineShader = this.registerDisposer(new neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_7__["LineShader"](this.gl, EDGES_PER_BOX));
        this.edgeBoxCornerOffsetsBuffer = this.registerDisposer(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_5__["Buffer"].fromData(this.gl, Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_3__["tile2dArray"])(edgeBoxCornerOffsetData, /*majorDimension=*/ 7, /*minorTiles=*/ 1, 
        /*majorTiles=*/ neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_7__["VERTICES_PER_LINE"])));
        this.edgeShaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_8__["emitterDependentShaderGetter"])(this, this.gl, (builder) => {
            this.defineShader(builder);
            this.lineShader.defineShader(builder);
            // XYZ corners of box ranging from [0, 0, 0] to [1, 1, 1].
            builder.addAttribute('highp vec3', 'aBoxCornerOffset1');
            // Last component of aBoxCornerOffset2 is the edge index.
            builder.addAttribute('highp vec4', 'aBoxCornerOffset2');
            builder.setVertexMain(`
vec3 vertexPosition1 = mix(aLower, aUpper, aBoxCornerOffset1);
vec3 vertexPosition2 = mix(aLower, aUpper, aBoxCornerOffset2.xyz);
emitLine(uProjection, vertexPosition1, vertexPosition2);
${this.setPartIndex(builder, 'uint(aBoxCornerOffset2.w)')};
`);
            builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, getLineAlpha()));
`);
        });
        this.circleShader = this.registerDisposer(new neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_6__["CircleShader"](this.gl, CORNERS_PER_BOX));
        this.boxCornerOffsetsBuffer = this.registerDisposer(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_5__["Buffer"].fromData(this.gl, Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_3__["tile2dArray"])(neuroglancer_sliceview_bounding_box_shader_helper__WEBPACK_IMPORTED_MODULE_2__["vertexBasePositions"], /*majorDimension=*/ 3, /*minorTiles=*/ 1, 
        /*majorTiles=*/ neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_6__["VERTICES_PER_CIRCLE"])));
        this.cornerShaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_8__["emitterDependentShaderGetter"])(this, this.gl, (builder) => {
            this.defineShader(builder);
            this.circleShader.defineShader(builder, this.targetIsSliceView);
            // XYZ corners of box ranging from [0, 0, 0] to [1, 1, 1].
            builder.addAttribute('highp vec3', 'aBoxCornerOffset');
            builder.setVertexMain(`
vec3 vertexPosition = mix(aLower, aUpper, aBoxCornerOffset);
emitCircle(uProjection * vec4(vertexPosition, 1.0));
uint cornerIndex = uint(aBoxCornerOffset.x + aBoxCornerOffset.y * 2.0 + aBoxCornerOffset.z * 4.0);
uint cornerPickOffset = ${CORNERS_PICK_OFFSET}u + cornerIndex;
${this.setPartIndex(builder, 'cornerPickOffset')};
`);
            builder.setFragmentMain(`
vec4 borderColor = vec4(0.0, 0.0, 0.0, 1.0);
emitAnnotation(getCircleColor(vColor, borderColor));
`);
        });
    }
    drawEdges(context) {
        const shader = this.edgeShaderGetter(context.renderContext.emitter);
        const { gl } = this;
        this.enable(shader, context, () => {
            const aBoxCornerOffset1 = shader.attribute('aBoxCornerOffset1');
            const aBoxCornerOffset2 = shader.attribute('aBoxCornerOffset2');
            this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(aBoxCornerOffset1, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 4 * 7, /*offset=*/ 0);
            this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(aBoxCornerOffset2, /*components=*/ 4, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 4 * 7, /*offset=*/ 4 * 3);
            this.lineShader.draw(shader, context.renderContext, /*lineWidth=*/ 1, 1, context.count);
            gl.disableVertexAttribArray(aBoxCornerOffset1);
            gl.disableVertexAttribArray(aBoxCornerOffset2);
        });
    }
    drawCorners(context) {
        const shader = this.cornerShaderGetter(context.renderContext.emitter);
        const { gl } = this;
        this.enable(shader, context, () => {
            const aBoxCornerOffset = shader.attribute('aBoxCornerOffset');
            this.boxCornerOffsetsBuffer.bindToVertexAttrib(aBoxCornerOffset, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false);
            this.circleShader.draw(shader, context.renderContext, { interiorRadiusInPixels: 1, borderWidthInPixels: 0, featherWidthInPixels: 1 }, context.count);
            gl.disableVertexAttribArray(aBoxCornerOffset);
        });
    }
    draw(context) {
        this.drawEdges(context);
        this.drawCorners(context);
    }
}
function getBaseIntersectionVertexIndexArray() {
    return new Float32Array([0, 1, 2, 3, 4, 5]);
}
function getIntersectionVertexIndexArray() {
    return Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_3__["tile2dArray"])(getBaseIntersectionVertexIndexArray(), 
    /*majorDimension=*/ 1, 
    /*minorTiles=*/ 1, 
    /*majorTiles=*/ neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_7__["VERTICES_PER_LINE"]);
}
class SliceViewRenderHelper extends RenderHelper {
    constructor(gl) {
        super(gl);
        this.gl = gl;
        this.lineShader = new neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_7__["LineShader"](this.gl, 6);
        this.intersectionVertexIndexBuffer = Object(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_5__["getMemoizedBuffer"])(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, getIntersectionVertexIndexArray)
            .value;
        this.filledIntersectionVertexIndexBuffer = Object(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_5__["getMemoizedBuffer"])(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, getBaseIntersectionVertexIndexArray)
            .value;
        this.boundingBoxCrossSectionHelper = this.registerDisposer(new neuroglancer_sliceview_bounding_box_shader_helper__WEBPACK_IMPORTED_MODULE_2__["BoundingBoxCrossSectionRenderHelper"](this.gl));
        this.faceShaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_8__["emitterDependentShaderGetter"])(this, this.gl, (builder) => {
            super.defineShader(builder);
            this.boundingBoxCrossSectionHelper.defineShader(builder);
            this.lineShader.defineShader(builder);
            builder.addAttribute('highp float', 'aVertexIndexFloat');
            builder.setVertexMain(`
int vertexIndex1 = int(aVertexIndexFloat);
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(aUpper - aLower, aLower, aLower, aUpper, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(aUpper - aLower, aLower, aLower, aUpper, vertexIndex2);
emitLine(uProjection, vertexPosition1, vertexPosition2);
${this.setPartIndex(builder)};
`);
            builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha()));
`);
        });
        this.fillShaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_8__["emitterDependentShaderGetter"])(this, this.gl, (builder) => {
            super.defineShader(builder);
            this.boundingBoxCrossSectionHelper.defineShader(builder);
            builder.addAttribute('highp float', 'aVertexIndexFloat');
            builder.addUniform('highp float', 'uFillOpacity');
            builder.setVertexMain(`
int vertexIndex = int(aVertexIndexFloat);
vec3 vertexPosition = getBoundingBoxPlaneIntersectionVertexPosition(aUpper - aLower, aLower, aLower, aUpper, vertexIndex);
gl_Position = uProjection * vec4(vertexPosition, 1);
${this.setPartIndex(builder)};
`);
            builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, uFillOpacity));
`);
        });
    }
    draw(context) {
        const fillOpacity = context.annotationLayer.state.fillOpacity.value;
        const shader = (fillOpacity ? this.fillShaderGetter : this.faceShaderGetter)(context.renderContext.emitter);
        let { gl } = this;
        this.enable(shader, context, () => {
            this.boundingBoxCrossSectionHelper.setViewportPlane(shader, context.renderContext.sliceView.viewportAxes[2], context.renderContext.sliceView.centerDataPosition, context.annotationLayer.state.globalToObject);
            const aVertexIndexFloat = shader.attribute('aVertexIndexFloat');
            (fillOpacity ? this.filledIntersectionVertexIndexBuffer : this.intersectionVertexIndexBuffer)
                .bindToVertexAttrib(aVertexIndexFloat, /*components=*/ 1, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false);
            if (fillOpacity) {
                gl.uniform1f(shader.uniform('uFillOpacity'), fillOpacity);
                gl.drawArraysInstanced(WebGL2RenderingContext.TRIANGLE_FAN, 0, 6, context.count);
            }
            else {
                const lineWidth = context.renderContext.emitColor ? 1 : 5;
                this.lineShader.draw(shader, context.renderContext, lineWidth, 1.0, context.count);
            }
            gl.disableVertexAttribArray(aVertexIndexFloat);
        });
    }
}
function getEdgeCorners(corners, edgeIndex) {
    const i = edgeIndex * 7;
    const cA = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), cB = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
    for (let j = 0; j < 3; ++j) {
        const ma = edgeBoxCornerOffsetData[i + j];
        const mb = edgeBoxCornerOffsetData[i + j + 3];
        const a = Math.min(corners[j], corners[j + 3]), b = Math.max(corners[j], corners[j + 3]);
        cA[j] = (1 - ma) * a + ma * b;
        cB[j] = (1 - mb) * a + mb * b;
    }
    return { cornerA: cA, cornerB: cB };
}
function snapPositionToEdge(position, objectToData, corners, edgeIndex) {
    let edgeCorners = getEdgeCorners(corners, edgeIndex);
    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(edgeCorners.cornerA, edgeCorners.cornerA, objectToData);
    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(edgeCorners.cornerB, edgeCorners.cornerB, objectToData);
    Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["projectPointToLineSegment"])(position, edgeCorners.cornerA, edgeCorners.cornerB, position);
}
function snapPositionToCorner(position, objectToData, corners, cornerIndex) {
    const i = cornerIndex * 3;
    for (let j = 0; j < 3; ++j) {
        const m = neuroglancer_sliceview_bounding_box_shader_helper__WEBPACK_IMPORTED_MODULE_2__["vertexBasePositions"][i + j];
        const a = Math.min(corners[j], corners[j + 3]), b = Math.max(corners[j], corners[j + 3]);
        position[j] = (1 - m) * a + m * b;
    }
    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(position, position, objectToData);
}
Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__["registerAnnotationTypeRenderHandler"])(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationType"].AXIS_ALIGNED_BOUNDING_BOX, {
    bytes: 6 * 4,
    serializer: (buffer, offset, numAnnotations) => {
        const coordinates = new Float32Array(buffer, offset, numAnnotations * 6);
        return (annotation, index) => {
            const { pointA, pointB } = annotation;
            const coordinateOffset = index * 6;
            coordinates[coordinateOffset] = Math.min(pointA[0], pointB[0]);
            coordinates[coordinateOffset + 1] = Math.min(pointA[1], pointB[1]);
            coordinates[coordinateOffset + 2] = Math.min(pointA[2], pointB[2]);
            coordinates[coordinateOffset + 3] = Math.max(pointA[0], pointB[0]);
            coordinates[coordinateOffset + 4] = Math.max(pointA[1], pointB[1]);
            coordinates[coordinateOffset + 5] = Math.max(pointA[2], pointB[2]);
        };
    },
    sliceViewRenderHelper: SliceViewRenderHelper,
    perspectiveViewRenderHelper: PerspectiveViewRenderHelper,
    pickIdsPerInstance: PICK_IDS_PER_INSTANCE,
    snapPosition: (position, objectToData, data, offset, partIndex) => {
        const corners = new Float32Array(data, offset, 6);
        if (partIndex >= CORNERS_PICK_OFFSET && partIndex < EDGES_PICK_OFFSET) {
            snapPositionToCorner(position, objectToData, corners, partIndex - CORNERS_PICK_OFFSET);
        }
        else if (partIndex >= EDGES_PICK_OFFSET && partIndex < FACES_PICK_OFFSET) {
            snapPositionToEdge(position, objectToData, corners, partIndex - EDGES_PICK_OFFSET);
        }
        else {
            // vec3.transformMat4(position, annotation.point, objectToData);
        }
    },
    getRepresentativePoint: (objectToData, ann, partIndex) => {
        let repPoint = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        // if the full object is selected pick the first corner as representative
        if (partIndex === FULL_OBJECT_PICK_OFFSET) {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(repPoint, ann.pointA, objectToData);
        }
        else if (partIndex >= CORNERS_PICK_OFFSET && partIndex < EDGES_PICK_OFFSET) {
            // picked a corner
            // FIXME: figure out how to return corner point
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(repPoint, ann.pointA, objectToData);
        }
        else if (partIndex >= EDGES_PICK_OFFSET && partIndex < FACES_PICK_OFFSET) {
            // FIXME: can't figure out how to resize based upon edge grabbed
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(repPoint, ann.pointA, objectToData);
            // snapPositionToCorner(repPoint, objectToData, corners, 5);
        }
        else { // for now faces will move the whole object so pick the first corner
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(repPoint, ann.pointA, objectToData);
        }
        return repPoint;
    },
    updateViaRepresentativePoint: (oldAnnotation, position, dataToObject, partIndex) => {
        let newPt = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), position, dataToObject);
        let baseBox = Object.assign({}, oldAnnotation);
        // if the full object is selected pick the first corner as representative
        let delta = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].sub(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), oldAnnotation.pointB, oldAnnotation.pointA);
        if (partIndex === FULL_OBJECT_PICK_OFFSET) {
            baseBox.pointA = newPt;
            baseBox.pointB = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].add(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), newPt, delta);
        }
        else if (partIndex >= CORNERS_PICK_OFFSET && partIndex < EDGES_PICK_OFFSET) {
            // picked a corner
            baseBox.pointA = newPt;
            baseBox.pointB = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].add(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), newPt, delta);
        }
        else if (partIndex >= EDGES_PICK_OFFSET && partIndex < FACES_PICK_OFFSET) {
            baseBox.pointA = newPt;
            baseBox.pointB = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].add(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), newPt, delta);
        }
        else { // for now faces will move the whole object so pick the first corner
            baseBox.pointA = newPt;
            baseBox.pointB = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].add(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), newPt, delta);
        }
        return baseBox;
    }
});


/***/ }),

/***/ "./src/neuroglancer/annotation/ellipsoid.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/annotation/ellipsoid.ts ***!
  \**************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/type_handler */ "./src/neuroglancer/annotation/type_handler.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_webgl_ellipse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/webgl/ellipse */ "./src/neuroglancer/webgl/ellipse.ts");
/* harmony import */ var neuroglancer_webgl_quad__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/webgl/quad */ "./src/neuroglancer/webgl/quad.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/* harmony import */ var neuroglancer_webgl_spheres__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/webgl/spheres */ "./src/neuroglancer/webgl/spheres.ts");
/* harmony import */ var neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/webgl/square_corners_buffer */ "./src/neuroglancer/webgl/square_corners_buffer.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Support for rendering ellipsoid annotations.
 */








const tempMat4 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat4"].create();
const DEBUG = false;
class RenderHelper extends neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__["AnnotationRenderHelper"] {
    defineShader(builder) {
        super.defineShader(builder);
        builder.addAttribute('highp vec3', 'aCenter');
        builder.addAttribute('highp vec3', 'aRadii');
    }
    enable(shader, context, callback) {
        super.enable(shader, context, () => {
            const aCenter = shader.attribute('aCenter');
            const aRadii = shader.attribute('aRadii');
            const { gl } = shader;
            context.buffer.bindToVertexAttrib(aCenter, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 4 * 6, /*offset=*/ context.bufferOffset);
            context.buffer.bindToVertexAttrib(aRadii, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 4 * 6, /*offset=*/ context.bufferOffset + 4 * 3);
            gl.vertexAttribDivisor(aCenter, 1);
            gl.vertexAttribDivisor(aRadii, 1);
            callback();
            gl.vertexAttribDivisor(aCenter, 0);
            gl.vertexAttribDivisor(aRadii, 0);
            gl.disableVertexAttribArray(aCenter);
            gl.disableVertexAttribArray(aRadii);
        });
    }
}
/**
 * Render an ellipsoid as a transformed triangulated sphere.
 */
class PerspectiveRenderHelper extends RenderHelper {
    constructor() {
        super(...arguments);
        this.sphereRenderHelper = this.registerDisposer(new neuroglancer_webgl_spheres__WEBPACK_IMPORTED_MODULE_6__["SphereRenderHelper"](this.gl, 10, 10));
        this.shaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_5__["emitterDependentShaderGetter"])(this, this.gl, (builder) => {
            this.defineShader(builder);
            this.sphereRenderHelper.defineShader(builder);
            builder.addUniform('highp vec4', 'uLightDirection');
            builder.addUniform('highp mat4', 'uNormalTransform');
            builder.setVertexMain(`
emitSphere(uProjection, uNormalTransform, aCenter, aRadii, uLightDirection);
${this.setPartIndex(builder)};
`);
            builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb * vLightingFactor, vColor.a));
`);
        });
        this.tempLightVec = new Float32Array(4);
    }
    draw(context) {
        const shader = this.shaderGetter(context.renderContext.emitter);
        this.enable(shader, context, () => {
            const { gl } = shader;
            let lightVec = this.tempLightVec;
            let { lightDirection, ambientLighting, directionalLighting } = context.renderContext;
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].scale(lightVec, lightDirection, directionalLighting);
            lightVec[3] = ambientLighting;
            gl.uniform4fv(shader.uniform('uLightDirection'), lightVec);
            gl.uniformMatrix4fv(shader.uniform('uNormalTransform'), /*transpose=*/ false, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat4"].transpose(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat4"].create(), context.annotationLayer.state.globalToObject));
            this.sphereRenderHelper.draw(shader, context.count);
        });
    }
}
/**
 * Render a cross section of an ellipsoid.
 *
 * This is done using the following steps:
 *
 * Vertex shader:
 *
 * 1. We transform the ellipsoid parameters to the cross section coordinate frame (with the z
 *    axis corresponding to the plane normal).
 *
 * 2. We then compute the quadratic form parameters of the ellipse corresponding to the intersection
 *    of the ellipsoid with the `z=0` plane.
 *
 * 3. We convert the quadratic form parameterization into the center-orient parameterization.
 *
 * 4. The vertex shader emits the 4 vertices of the bounding box of the ellipse, equal to:
 *
 *      `k +/- a*u1 +/- b*u2`,
 *
 *    where `k` is the center of the ellipse, `u1` and `u2` are the major and minor axis directions
 *    respectively, and `a` and `b` are the semi-major and semi-minor axis lengths, respectively.
 *    These four vertices are used to draw a quad (two triangles).
 *
 * Fragment shader:
 *
 * 5. The fragment shader discards fragments outside the bounds of the ellipse.
 */
class SliceViewRenderHelper extends RenderHelper {
    constructor() {
        super(...arguments);
        this.quadRenderHelper = this.registerDisposer(new neuroglancer_webgl_quad__WEBPACK_IMPORTED_MODULE_4__["QuadRenderHelper"](this.gl, 1));
        this.squareCornersBuffer = Object(neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_7__["getSquareCornersBuffer"])(this.gl, -1, -1, 1, 1, /*minorTiles=*/ 1, /*majorTiles=*/ 1);
        this.shaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_5__["emitterDependentShaderGetter"])(this, this.gl, (builder) => {
            this.defineShader(builder);
            builder.addUniform('highp mat4', 'uViewportToObject');
            builder.addUniform('highp mat4', 'uObjectToViewport');
            builder.addUniform('highp mat4', 'uViewportToDevice');
            builder.addAttribute('highp vec2', 'aCornerOffset');
            builder.addVarying('highp vec2', 'vCircleCoord');
            builder.addVertexCode(neuroglancer_webgl_ellipse__WEBPACK_IMPORTED_MODULE_3__["glsl_computeCrossSectionEllipse"]);
            builder.addVertexCode(neuroglancer_webgl_ellipse__WEBPACK_IMPORTED_MODULE_3__["glsl_computeCenterOrientEllipse"]);
            builder.setVertexMain(`
mat3 Aobject = mat3(0.0);
for (int i = 0; i < 3; ++i) {
  Aobject[i][i] = 1.0 / (aRadii[i] * aRadii[i]);
}
mat3 RviewportToObject = mat3(uViewportToObject);
mat3 Aviewport = transpose(RviewportToObject) * Aobject * RviewportToObject;
vec3 cViewport = (uObjectToViewport * vec4(aCenter, 1.0)).xyz;
EllipseQuadraticForm quadraticForm = computeCrossSectionEllipse(Aviewport, cViewport);
vec2 u1, u2;
float a, b;
CenterOrientEllipse centerOrient = computeCenterOrientEllipse(quadraticForm);
vec2 viewportCorner = centerOrient.k +
  centerOrient.u1 * aCornerOffset.x * centerOrient.a +
  centerOrient.u2 * aCornerOffset.y * centerOrient.b;
if (centerOrient.valid) {
  gl_Position = uViewportToDevice * vec4(viewportCorner, 0.0, 1.0);
} else {
  gl_Position = vec4(1.0, 1.0, 0.0, -100.0);
}
vCircleCoord = aCornerOffset;
${this.setPartIndex(builder)};
`);
            builder.setFragmentMain(`
if (dot(vCircleCoord, vCircleCoord) > 1.0) {
  discard;
}
emitAnnotation(vec4(vColor.rgb, 0.5));
`);
        });
    }
    draw(context) {
        const shader = this.shaderGetter(context.renderContext.emitter);
        this.enable(shader, context, () => {
            const { gl } = shader;
            const aCornerOffset = shader.attribute('aCornerOffset');
            this.squareCornersBuffer.bindToVertexAttrib(aCornerOffset, /*components=*/ 2);
            const viewportToObject = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat4"].multiply(tempMat4, context.annotationLayer.state.globalToObject, context.renderContext.sliceView.viewportToData);
            gl.uniformMatrix4fv(shader.uniform('uViewportToObject'), /*transpose=*/ false, viewportToObject);
            gl.uniformMatrix4fv(shader.uniform('uViewportToDevice'), /*transpose=*/ false, context.renderContext.sliceView.viewportToDevice);
            const objectToViewport = tempMat4;
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat4"].invert(objectToViewport, viewportToObject);
            gl.uniformMatrix4fv(shader.uniform('uObjectToViewport'), /*transpose=*/ false, objectToViewport);
            this.quadRenderHelper.draw(gl, context.count);
            shader.gl.disableVertexAttribArray(aCornerOffset);
            if (DEBUG) {
                const center = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].fromValues(2184, 1700, 3981);
                const radii = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].fromValues(133, 133, 133);
                const Aobject = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat3"].create();
                Aobject[0] = 1 / (radii[0] * radii[0]);
                Aobject[4] = 1 / (radii[1] * radii[1]);
                Aobject[8] = 1 / (radii[2] * radii[2]);
                const RviewportToObject = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat3"].fromMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat3"].create(), viewportToObject);
                const Aviewport = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat3"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat3"].transpose(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat3"].create(), RviewportToObject), Aobject);
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["mat3"].multiply(Aviewport, Aviewport, RviewportToObject);
                const cViewport = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create(), center, objectToViewport);
                console.log('Aviewport', Aviewport);
                console.log('cViewport', cViewport);
                const p = Object(neuroglancer_webgl_ellipse__WEBPACK_IMPORTED_MODULE_3__["computeCrossSectionEllipseDebug"])(Aviewport, cViewport);
                const centerOrient = Object(neuroglancer_webgl_ellipse__WEBPACK_IMPORTED_MODULE_3__["computeCenterOrientEllipseDebug"])(p);
                console.log(p);
                console.log(centerOrient);
            }
        });
    }
}
Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__["registerAnnotationTypeRenderHandler"])(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationType"].ELLIPSOID, {
    bytes: 6 * 4,
    serializer: (buffer, offset, numAnnotations) => {
        const coordinates = new Float32Array(buffer, offset, numAnnotations * 6);
        return (annotation, index) => {
            const { center, radii } = annotation;
            const coordinateOffset = index * 6;
            coordinates.set(center, coordinateOffset);
            coordinates.set(radii, coordinateOffset + 3);
        };
    },
    sliceViewRenderHelper: SliceViewRenderHelper,
    perspectiveViewRenderHelper: PerspectiveRenderHelper,
    pickIdsPerInstance: 1,
    snapPosition: ( /*position, objectToData, annotation, partIndex*/) => {
        // FIXME: snap to nearest point on ellipsoid surface
    },
    getRepresentativePoint: (objectToData, ann) => {
        let repPoint = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].transformMat4(repPoint, ann.center, objectToData);
        return repPoint;
    },
    updateViaRepresentativePoint: (oldAnnotation, position, dataToObject) => {
        let annotation = Object.assign({}, oldAnnotation);
        annotation.center = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create(), position, dataToObject);
        return annotation;
    }
});


/***/ }),

/***/ "./src/neuroglancer/annotation/frontend.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/annotation/frontend.ts ***!
  \*************************************************/
/*! exports provided: AnnotationHoverState, AnnotationLayerState, MultiscaleAnnotationSource, AnnotationLayer, PerspectiveViewAnnotationLayer, SliceViewAnnotationLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_annotation_annotation_layer_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation/annotation_layer_state */ "./src/neuroglancer/annotation/annotation_layer_state.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnnotationHoverState", function() { return neuroglancer_annotation_annotation_layer_state__WEBPACK_IMPORTED_MODULE_0__["AnnotationHoverState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnnotationLayerState", function() { return neuroglancer_annotation_annotation_layer_state__WEBPACK_IMPORTED_MODULE_0__["AnnotationLayerState"]; });

/* harmony import */ var neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/frontend_source */ "./src/neuroglancer/annotation/frontend_source.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MultiscaleAnnotationSource", function() { return neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_1__["MultiscaleAnnotationSource"]; });

/* harmony import */ var neuroglancer_annotation_renderlayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/annotation/renderlayer */ "./src/neuroglancer/annotation/renderlayer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnnotationLayer", function() { return neuroglancer_annotation_renderlayer__WEBPACK_IMPORTED_MODULE_2__["AnnotationLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PerspectiveViewAnnotationLayer", function() { return neuroglancer_annotation_renderlayer__WEBPACK_IMPORTED_MODULE_2__["PerspectiveViewAnnotationLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SliceViewAnnotationLayer", function() { return neuroglancer_annotation_renderlayer__WEBPACK_IMPORTED_MODULE_2__["SliceViewAnnotationLayer"]; });

/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/***/ }),

/***/ "./src/neuroglancer/annotation/frontend_source.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/annotation/frontend_source.ts ***!
  \********************************************************/
/*! exports provided: AnnotationGeometryData, AnnotationSubsetGeometryChunk, AnnotationGeometryChunk, AnnotationGeometryChunkSource, AnnotationSubsetGeometryChunkSource, AnnotationMetadataChunk, AnnotationMetadataChunkSource, MultiscaleAnnotationSource, DataFetchSliceViewRenderLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationGeometryData", function() { return AnnotationGeometryData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationSubsetGeometryChunk", function() { return AnnotationSubsetGeometryChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationGeometryChunk", function() { return AnnotationGeometryChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationGeometryChunkSource", function() { return AnnotationGeometryChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationSubsetGeometryChunkSource", function() { return AnnotationSubsetGeometryChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationMetadataChunk", function() { return AnnotationMetadataChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationMetadataChunkSource", function() { return AnnotationMetadataChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleAnnotationSource", function() { return MultiscaleAnnotationSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataFetchSliceViewRenderLayer", function() { return DataFetchSliceViewRenderLayer; });
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/base */ "./src/neuroglancer/annotation/base.ts");
/* harmony import */ var neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/annotation/type_handler */ "./src/neuroglancer/annotation/type_handler.ts");
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/segmentation_display_state/base */ "./src/neuroglancer/segmentation_display_state/base.ts");
/* harmony import */ var neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/sliceview/frontend */ "./src/neuroglancer/sliceview/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_renderlayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/sliceview/renderlayer */ "./src/neuroglancer/sliceview/renderlayer.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/array */ "./src/neuroglancer/util/array.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};












class AnnotationGeometryData {
    constructor(x) {
        this.bufferValid = false;
        this.data = x.data;
        const typeToIds = this.typeToIds = x.typeToIds;
        let numPickIds = 0;
        for (const annotationType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["annotationTypes"]) {
            numPickIds += Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeRenderHandler"])(annotationType).pickIdsPerInstance *
                typeToIds[annotationType].length;
        }
        this.numPickIds = numPickIds;
        this.typeToOffset = x.typeToOffset;
    }
    freeGPUMemory(gl) {
        gl;
        const { buffer } = this;
        if (buffer !== undefined) {
            buffer.dispose();
            this.bufferValid = false;
            this.buffer = undefined;
        }
    }
}
class AnnotationSubsetGeometryChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["Chunk"] {
    constructor(source, x) {
        super(source);
        this.data = new AnnotationGeometryData(x);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        this.data.freeGPUMemory(gl);
    }
    dispose() {
        this.data = undefined;
    }
}
class AnnotationGeometryChunk extends neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_5__["SliceViewChunk"] {
    constructor(source, x) {
        super(source, x);
        this.data = new AnnotationGeometryData(x);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        this.data.freeGPUMemory(gl);
    }
    dispose() {
        this.data = undefined;
    }
}
let AnnotationGeometryChunkSource = class AnnotationGeometryChunkSource extends neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_5__["SliceViewChunkSource"] {
    constructor(chunkManager, options) {
        super(chunkManager, options);
        this.immediateChunkUpdates = true;
        this.parent = options.parent;
        this.parameters = options.parameters;
        this.spec = options.spec;
    }
    initializeCounterpart(rpc, options) {
        options['parameters'] = this.parameters;
        options['parent'] = this.parent.rpcId;
        super.initializeCounterpart(rpc, options);
    }
    addChunk(key, chunk) {
        super.addChunk(key, chunk);
        // TODO: process local deletions
    }
    getChunk(x) {
        return new AnnotationGeometryChunk(this, x);
    }
};
AnnotationGeometryChunkSource = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__["registerSharedObjectOwner"])(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__["ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID"])
], AnnotationGeometryChunkSource);

let AnnotationSubsetGeometryChunkSource = class AnnotationSubsetGeometryChunkSource extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["ChunkSource"] {
    constructor(chunkManager, parent) {
        super(chunkManager, {});
        this.parent = parent;
        this.immediateChunkUpdates = true;
    }
    initializeCounterpart(rpc, options) {
        options['parent'] = this.parent.rpcId;
        super.initializeCounterpart(rpc, options);
    }
    addChunk(key, chunk) {
        super.addChunk(key, chunk);
        // TODO: process local deletions
    }
    getChunk(x) {
        return new AnnotationSubsetGeometryChunk(this, x);
    }
};
AnnotationSubsetGeometryChunkSource = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__["registerSharedObjectOwner"])(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__["ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID"])
], AnnotationSubsetGeometryChunkSource);

class AnnotationMetadataChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["Chunk"] {
    constructor(source, x) {
        super(source);
        this.annotation = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["deserializeAnnotation"])(x.annotation);
    }
}
let AnnotationMetadataChunkSource = class AnnotationMetadataChunkSource extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["ChunkSource"] {
    constructor(chunkManager, parent) {
        super(chunkManager);
        this.parent = parent;
    }
    getChunk(x) {
        return new AnnotationMetadataChunk(this, x);
    }
    addChunk(key, chunk) {
        super.addChunk(key, chunk);
        const { references } = this.parent;
        const reference = references.get(key);
        if (reference !== undefined) {
            reference.value = chunk.annotation;
            reference.changed.dispatch();
        }
    }
    deleteChunk(key) {
        const { references } = this.parent;
        const reference = references.get(key);
        if (reference !== undefined) {
            reference.value = undefined;
            reference.changed.dispatch();
        }
    }
    initializeCounterpart(rpc, options) {
        options['parent'] = this.parent.rpcId;
        super.initializeCounterpart(rpc, options);
    }
};
AnnotationMetadataChunkSource = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__["registerSharedObjectOwner"])(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__["ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID"])
], AnnotationMetadataChunkSource);

function updateAnnotation(chunk, annotation) {
    // Find insertion point.
    const type = annotation.type;
    let ids = chunk.typeToIds[type];
    const handler = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["getAnnotationTypeHandler"])(type);
    const numBytes = handler.serializedBytes;
    const renderHandler = Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeRenderHandler"])(type);
    let insertionPoint = Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_8__["binarySearch"])(ids, annotation.id, (a, b) => a < b ? -1 : a === b ? 0 : 1);
    let offset = 0;
    let updateOffsets = () => { };
    if (insertionPoint < 0) {
        // Doesn't already exist.
        insertionPoint = ~insertionPoint;
        ids.splice(insertionPoint, 0, annotation.id);
        const newData = new Uint8Array(chunk.data.length + numBytes);
        chunk.numPickIds += renderHandler.pickIdsPerInstance;
        offset = chunk.typeToOffset[type] + numBytes * insertionPoint;
        newData.set(chunk.data.subarray(0, offset), 0);
        newData.set(chunk.data.subarray(offset), offset + numBytes);
        chunk.data = newData;
        updateOffsets = () => {
            for (const otherType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["annotationTypes"]) {
                if (otherType > type) {
                    chunk.typeToOffset[otherType] += numBytes;
                }
            }
        };
    }
    else {
        offset = chunk.typeToOffset[type] + handler.serializedBytes * insertionPoint;
    }
    const serializer = handler.serializer(chunk.data.buffer, chunk.typeToOffset[type], ids.length);
    serializer(annotation, insertionPoint);
    updateOffsets();
    chunk.bufferValid = false;
}
function deleteAnnotation(chunk, type, id) {
    let ids = chunk.typeToIds[type];
    const handler = Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeRenderHandler"])(type);
    const numBytes = handler.bytes;
    let insertionPoint = Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_8__["binarySearch"])(ids, id, (a, b) => a < b ? -1 : a === b ? 0 : 1);
    if (insertionPoint < 0) {
        return false;
    }
    chunk.numPickIds -= handler.pickIdsPerInstance;
    ids.splice(insertionPoint, 1);
    const offset = chunk.typeToOffset[type] + handler.bytes * insertionPoint;
    const newData = new Uint8Array(chunk.data.length - numBytes);
    newData.set(chunk.data.subarray(0, offset), 0);
    newData.set(chunk.data.subarray(offset + numBytes), offset);
    chunk.data = newData;
    for (const otherType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["annotationTypes"]) {
        if (otherType > type) {
            chunk.typeToOffset[otherType] -= numBytes;
        }
    }
    chunk.bufferValid = false;
    return true;
}
function makeTemporaryChunk() {
    const typeToIds = [];
    const typeToOffset = [];
    for (const annotationType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["annotationTypes"]) {
        typeToIds[annotationType] = [];
        typeToOffset[annotationType] = 0;
    }
    return new AnnotationGeometryChunk(undefined, { data: new Uint8Array(0), numPickIds: 0, typeToOffset, typeToIds });
}
class MultiscaleAnnotationSource extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__["SharedObject"] {
    constructor(chunkManager, options) {
        super();
        this.chunkManager = chunkManager;
        this.metadataChunkSource = this.registerDisposer(new AnnotationMetadataChunkSource(this.chunkManager, this));
        this.objectToLocal = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create();
        this.temporary = makeTemporaryChunk();
        this.references = new Map();
        this.localUpdates = new Map();
        this.numCommitsInProgress = 0;
        // FIXME
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_10__["NullarySignal"]();
        this.readonly = false;
        this.sources = options.sourceSpecifications.map(alternatives => alternatives.map(({ parameters, spec }) => this.registerDisposer(new AnnotationGeometryChunkSource(chunkManager, { spec, parameters, parent: this }))));
        this.segmentFilteredSource =
            this.registerDisposer(new AnnotationSubsetGeometryChunkSource(chunkManager, this));
    }
    getSources(_options) {
        const { sources } = this;
        sources.forEach(alternatives => alternatives.forEach(source => source.addRef()));
        return sources;
    }
    initializeCounterpart(rpc, options) {
        this.metadataChunkSource.initializeCounterpart(rpc, {});
        for (const alternatives of this.sources) {
            for (const source of alternatives) {
                source.initializeCounterpart(rpc, {});
            }
        }
        this.segmentFilteredSource.initializeCounterpart(rpc, {});
        options.segmentFilteredSource = this.segmentFilteredSource.addCounterpartRef();
        options.metadataChunkSource = this.metadataChunkSource.addCounterpartRef();
        options.sources =
            this.sources.map(alternatives => alternatives.map(source => source.addCounterpartRef()));
        options.chunkManager = this.chunkManager.rpcId;
        super.initializeCounterpart(rpc, options);
    }
    add(annotation, commit = true) {
        annotation.id = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["makeAnnotationId"])();
        const reference = new neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationReference"](annotation.id);
        reference.value = annotation;
        this.references.set(reference.id, reference);
        reference.registerDisposer(() => {
            this.references.delete(reference.id);
        });
        this.applyLocalUpdate(reference, /*existing=*/ false, /*commit=*/ commit, /*newAnnotation=*/ annotation);
        return reference;
    }
    applyLocalUpdate(reference, existing, commit, newAnnotation) {
        const { localUpdates } = this;
        const { id } = reference;
        let localUpdate = this.localUpdates.get(id);
        const annotation = reference.value;
        if (annotation == null) {
            throw new Error(`Cannot create local update from null annotation`);
        }
        if (localUpdate === undefined) {
            localUpdate = {
                type: annotation.type,
                reference: reference.addRef(),
                existingAnnotation: existing ? annotation : undefined,
                pendingCommit: undefined,
                commitInProgress: undefined,
            };
            localUpdates.set(id, localUpdate);
            this.forEachPossibleChunk(annotation, chunk => {
                deleteAnnotation(chunk.data, annotation.type, id);
            });
            if (newAnnotation !== null) {
                // Add to temporary chunk.
                updateAnnotation(this.temporary.data, newAnnotation);
            }
        }
        else {
            if (newAnnotation === null) {
                // Annotation has a local update already, so we need to delete it from the temporary chunk.
                deleteAnnotation(this.temporary.data, annotation.type, annotation.id);
            }
            else {
                // Modify existing entry in temporary chunk.
                updateAnnotation(this.temporary.data, newAnnotation);
            }
            reference.value = newAnnotation;
        }
        if (commit) {
            if (localUpdate.commitInProgress !== undefined) {
                localUpdate.pendingCommit = newAnnotation;
            }
            else {
                if (newAnnotation === null && localUpdate.existingAnnotation === undefined) {
                    // Local update, which we would now like to delete, has never been committed.
                    // Therefore we can just delete it locally.
                    localUpdates.delete(id);
                    localUpdate.reference.dispose();
                    return;
                }
                this.sendCommitRequest(localUpdate, newAnnotation);
            }
        }
        this.notifyChanged(reference.id, newAnnotation || undefined);
    }
    sendCommitRequest(localUpdate, newAnnotation) {
        this.updateCommitsInProgress(1);
        localUpdate.commitInProgress = newAnnotation;
        this.rpc.invoke(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__["ANNOTATION_COMMIT_UPDATE_RPC_ID"], {
            id: this.rpcId,
            annotationId: localUpdate.existingAnnotation && localUpdate.reference.id,
            newAnnotation,
        });
    }
    delete(reference) {
        this.applyLocalUpdate(reference, /*existing=*/ true, /*commit=*/ true, /*newAnnotation=*/ null);
    }
    update(reference, newAnnotation) {
        this.applyLocalUpdate(reference, /*existing=*/ true, /*commit=*/ false, /*newAnnotation=*/ newAnnotation);
    }
    notifyChanged(id, annotation) {
        const reference = this.references.get(id);
        const chunk = this.metadataChunkSource.chunks.get(id);
        if (chunk !== undefined) {
            chunk.annotation = annotation || null;
        }
        if (reference !== undefined) {
            reference.value = annotation || null;
            reference.changed.dispatch();
        }
        this.chunkManager.chunkQueueManager.visibleChunksChanged.dispatch();
    }
    /**
     * Must be called after `add` or `update` to commit the result.
     */
    commit(reference) {
        this.applyLocalUpdate(reference, /*existing=*/ true, /*commit=*/ true, reference.value);
    }
    getReference(id) {
        let existing = this.references.get(id);
        if (existing !== undefined) {
            return existing.addRef();
        }
        existing = new neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationReference"](id);
        this.references.set(id, existing);
        this.rpc.invoke(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__["ANNOTATION_REFERENCE_ADD_RPC_ID"], { id: this.rpcId, annotation: id });
        existing.registerDisposer(() => {
            this.references.delete(id);
            this.rpc.invoke(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__["ANNOTATION_REFERENCE_DELETE_RPC_ID"], { id: this.rpcId, annotation: id });
        });
        const chunk = this.metadataChunkSource.chunks.get(id);
        if (chunk !== undefined) {
            existing.value = chunk.annotation;
        }
        return existing;
    }
    forEachPossibleChunk(annotation, callback) {
        const { sources } = this;
        if (sources.length !== 1 || sources[0].length !== 1) {
            throw new Error('Not implemented');
        }
        const source = sources[0][0];
        if (source.chunks.size > 1) {
            throw new Error('Not implemented');
        }
        annotation;
        for (const chunk of source.chunks.values()) {
            callback(chunk);
        }
        const { segments } = annotation;
        if (segments === undefined || segments.length === 0) {
            return;
        }
        const { segmentFilteredSource } = this;
        for (const segment of segments) {
            const chunk = segmentFilteredSource.chunks.get(Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_4__["getObjectKey"])(segment));
            if (chunk === undefined) {
                continue;
            }
            callback(chunk);
        }
    }
    static encodeOptions(_options) {
        return {};
    }
    handleSuccessfulUpdate(id, newAnnotation) {
        const localUpdate = this.localUpdates.get(id);
        if (localUpdate === undefined || localUpdate.commitInProgress === undefined) {
            throw new Error(`Received invalid successful update notification`);
        }
        this.updateCommitsInProgress(-1);
        if (newAnnotation !== null && localUpdate.reference.id !== newAnnotation.id) {
            if (localUpdate.commitInProgress === null) {
                throw new Error(`Received invalid successful update notification`);
            }
            localUpdate.reference.id = newAnnotation.id;
            this.references.delete(id);
            this.references.set(newAnnotation.id, localUpdate.reference);
            this.localUpdates.delete(id);
            this.localUpdates.set(newAnnotation.id, localUpdate);
            if (localUpdate.reference.value !== null) {
                localUpdate.reference.value.id = newAnnotation.id;
                deleteAnnotation(this.temporary.data, localUpdate.type, id);
                updateAnnotation(this.temporary.data, localUpdate.reference.value);
            }
            localUpdate.reference.changed.dispatch();
        }
        localUpdate.existingAnnotation = newAnnotation || undefined;
        localUpdate.commitInProgress = undefined;
        let { pendingCommit } = localUpdate;
        localUpdate.pendingCommit = undefined;
        if (newAnnotation === null) {
            pendingCommit = undefined;
        }
        if (pendingCommit !== undefined) {
            if (pendingCommit !== null) {
                pendingCommit.id = newAnnotation.id;
            }
            this.sendCommitRequest(localUpdate, pendingCommit);
        }
        else {
            this.revertLocalUpdate(localUpdate);
        }
    }
    disposed() {
        const { commitStatus } = this;
        if (commitStatus !== undefined) {
            commitStatus.dispose();
        }
    }
    updateCommitsInProgress(amount) {
        this.numCommitsInProgress += amount;
        if (this.numCommitsInProgress === 0) {
            if (this.commitStatus !== undefined) {
                this.commitStatus.dispose();
                this.commitStatus = undefined;
            }
        }
        else if (this.commitStatus === undefined) {
            const status = this.commitStatus = new neuroglancer_status__WEBPACK_IMPORTED_MODULE_7__["StatusMessage"](/*delay=*/ true);
            status.setText('Commiting annotations');
        }
    }
    handleFailedUpdate(id, message) {
        const localUpdate = this.localUpdates.get(id);
        if (localUpdate === undefined || localUpdate.commitInProgress === undefined) {
            throw new Error(`Received invalid update notification`);
        }
        const status = new neuroglancer_status__WEBPACK_IMPORTED_MODULE_7__["StatusMessage"]();
        status.setErrorMessage(`Error commiting annotation update: ${message}`);
        this.revertLocalUpdate(localUpdate);
        this.updateCommitsInProgress(-1);
    }
    revertLocalUpdate(localUpdate) {
        deleteAnnotation(this.temporary.data, localUpdate.type, localUpdate.reference.id);
        const { existingAnnotation } = localUpdate;
        if (existingAnnotation !== undefined) {
            this.forEachPossibleChunk(existingAnnotation, chunk => {
                updateAnnotation(chunk.data, existingAnnotation);
            });
        }
        const { reference } = localUpdate;
        const { id } = reference;
        reference.value = existingAnnotation || null;
        reference.changed.dispatch();
        reference.dispose();
        this.localUpdates.delete(id);
    }
    *[Symbol.iterator]() { }
}
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__["registerRPC"])(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__["ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID"], function (x) {
    const source = this.get(x.id);
    const annotationId = x.annotationId;
    const error = x.error;
    if (error !== undefined) {
        source.handleFailedUpdate(annotationId, error);
    }
    else {
        const newAnnotation = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["deserializeAnnotation"])(x.newAnnotation);
        source.handleSuccessfulUpdate(annotationId, newAnnotation);
    }
});
class DataFetchSliceViewRenderLayer extends neuroglancer_sliceview_renderlayer__WEBPACK_IMPORTED_MODULE_6__["RenderLayer"] {
    constructor(multiscaleSource) {
        super(multiscaleSource.chunkManager, multiscaleSource.getSources({}), {});
    }
    // Does nothing.
    draw() { }
}


/***/ }),

/***/ "./src/neuroglancer/annotation/index.ts":
/*!**********************************************!*\
  !*** ./src/neuroglancer/annotation/index.ts ***!
  \**********************************************/
/*! exports provided: AnnotationReference, AnnotationType, annotationTypes, getAnnotationTypeHandler, annotationToJson, restoreAnnotation, AnnotationSource, LocalAnnotationSource, DATA_BOUNDS_DESCRIPTION, makeAnnotationId, makeDataBoundsBoundingBox, serializeAnnotations, AnnotationSerializer, deserializeAnnotation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationReference", function() { return AnnotationReference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationType", function() { return AnnotationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "annotationTypes", function() { return annotationTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAnnotationTypeHandler", function() { return getAnnotationTypeHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "annotationToJson", function() { return annotationToJson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "restoreAnnotation", function() { return restoreAnnotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationSource", function() { return AnnotationSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalAnnotationSource", function() { return LocalAnnotationSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA_BOUNDS_DESCRIPTION", function() { return DATA_BOUNDS_DESCRIPTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAnnotationId", function() { return makeAnnotationId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDataBoundsBoundingBox", function() { return makeDataBoundsBoundingBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serializeAnnotations", function() { return serializeAnnotations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationSerializer", function() { return AnnotationSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deserializeAnnotation", function() { return deserializeAnnotation; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/random */ "./src/neuroglancer/util/random.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Basic annotation data structures.
 */






class AnnotationReference extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(id) {
        super();
        this.id = id;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__["NullarySignal"]();
    }
}
var AnnotationType;
(function (AnnotationType) {
    AnnotationType[AnnotationType["POINT"] = 0] = "POINT";
    AnnotationType[AnnotationType["LINE"] = 1] = "LINE";
    AnnotationType[AnnotationType["AXIS_ALIGNED_BOUNDING_BOX"] = 2] = "AXIS_ALIGNED_BOUNDING_BOX";
    AnnotationType[AnnotationType["ELLIPSOID"] = 3] = "ELLIPSOID";
})(AnnotationType || (AnnotationType = {}));
const annotationTypes = [
    AnnotationType.POINT,
    AnnotationType.LINE,
    AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,
    AnnotationType.ELLIPSOID,
];
const typeHandlers = new Map();
function getAnnotationTypeHandler(type) {
    return typeHandlers.get(type);
}
typeHandlers.set(AnnotationType.LINE, {
    icon: '',
    description: 'Line',
    toJSON: (annotation) => {
        return {
            pointA: Array.from(annotation.pointA),
            pointB: Array.from(annotation.pointB),
        };
    },
    restoreState: (annotation, obj) => {
        annotation.pointA = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'pointA', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dVec"]);
        annotation.pointB = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'pointB', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dVec"]);
    },
    serializedBytes: 6 * 4,
    serializer: (buffer, offset, numAnnotations) => {
        const coordinates = new Float32Array(buffer, offset, numAnnotations * 6);
        return (annotation, index) => {
            const { pointA, pointB } = annotation;
            const coordinateOffset = index * 6;
            coordinates[coordinateOffset] = pointA[0];
            coordinates[coordinateOffset + 1] = pointA[1];
            coordinates[coordinateOffset + 2] = pointA[2];
            coordinates[coordinateOffset + 3] = pointB[0];
            coordinates[coordinateOffset + 4] = pointB[1];
            coordinates[coordinateOffset + 5] = pointB[2];
        };
    },
});
typeHandlers.set(AnnotationType.POINT, {
    icon: '',
    description: 'Point',
    toJSON: (annotation) => {
        return {
            point: Array.from(annotation.point),
        };
    },
    restoreState: (annotation, obj) => {
        annotation.point = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'point', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dVec"]);
    },
    serializedBytes: 3 * 4,
    serializer: (buffer, offset, numAnnotations) => {
        const coordinates = new Float32Array(buffer, offset, numAnnotations * 3);
        return (annotation, index) => {
            const { point } = annotation;
            const coordinateOffset = index * 3;
            coordinates[coordinateOffset] = point[0];
            coordinates[coordinateOffset + 1] = point[1];
            coordinates[coordinateOffset + 2] = point[2];
        };
    },
});
typeHandlers.set(AnnotationType.AXIS_ALIGNED_BOUNDING_BOX, {
    icon: '',
    description: 'Bounding Box',
    toJSON: (annotation) => {
        return {
            pointA: Array.from(annotation.pointA),
            pointB: Array.from(annotation.pointB),
        };
    },
    restoreState: (annotation, obj) => {
        annotation.pointA = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'pointA', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dVec"]);
        annotation.pointB = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'pointB', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dVec"]);
    },
    serializedBytes: 6 * 4,
    serializer: (buffer, offset, numAnnotations) => {
        const coordinates = new Float32Array(buffer, offset, numAnnotations * 6);
        return (annotation, index) => {
            const { pointA, pointB } = annotation;
            const coordinateOffset = index * 6;
            coordinates[coordinateOffset] = Math.min(pointA[0], pointB[0]);
            coordinates[coordinateOffset + 1] = Math.min(pointA[1], pointB[1]);
            coordinates[coordinateOffset + 2] = Math.min(pointA[2], pointB[2]);
            coordinates[coordinateOffset + 3] = Math.max(pointA[0], pointB[0]);
            coordinates[coordinateOffset + 4] = Math.max(pointA[1], pointB[1]);
            coordinates[coordinateOffset + 5] = Math.max(pointA[2], pointB[2]);
        };
    },
});
typeHandlers.set(AnnotationType.ELLIPSOID, {
    icon: '',
    description: 'Ellipsoid',
    toJSON: (annotation) => {
        return {
            center: Array.from(annotation.center),
            radii: Array.from(annotation.radii),
        };
    },
    restoreState: (annotation, obj) => {
        annotation.center = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'center', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dVec"]);
        annotation.radii = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'radii', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dScale"]);
    },
    serializedBytes: 6 * 4,
    serializer: (buffer, offset, numAnnotations) => {
        const coordinates = new Float32Array(buffer, offset, numAnnotations * 6);
        return (annotation, index) => {
            const { center, radii } = annotation;
            const coordinateOffset = index * 6;
            coordinates.set(center, coordinateOffset);
            coordinates.set(radii, coordinateOffset + 3);
        };
    },
});
function annotationToJson(annotation) {
    const result = getAnnotationTypeHandler(annotation.type).toJSON(annotation);
    result.type = AnnotationType[annotation.type].toLowerCase();
    result.id = annotation.id;
    result.description = annotation.description || undefined;
    const { segments } = annotation;
    if (segments !== undefined && segments.length > 0) {
        result.segments = segments.map(x => x.toString());
    }
    return result;
}
function restoreAnnotation(obj, allowMissingId = false) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObject"])(obj);
    const type = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'type', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyEnumString"])(x, AnnotationType));
    const id = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'id', allowMissingId ? neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyOptionalString"] : neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyString"]) ||
        makeAnnotationId();
    const result = {
        id,
        description: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'description', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyOptionalString"]),
        segments: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'segments', x => x === undefined ? undefined : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["parseArray"])(x, y => neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__["Uint64"].parseString(y))),
        type,
    };
    getAnnotationTypeHandler(type).restoreState(result, obj);
    return result;
}
class AnnotationSource extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(objectToLocal = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["mat4"].create()) {
        super();
        this.objectToLocal = objectToLocal;
        this.annotationMap = new Map();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__["NullarySignal"]();
        this.readonly = false;
        this.childAdded = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__["Signal"]();
        this.childUpdated = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__["Signal"]();
        this.childDeleted = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__["Signal"]();
        this.pending = new Set();
        this.references = new Map();
    }
    add(annotation, commit = true) {
        if (!annotation.id) {
            annotation.id = makeAnnotationId();
        }
        else if (this.annotationMap.has(annotation.id)) {
            throw new Error(`Annotation id already exists: ${JSON.stringify(annotation.id)}.`);
        }
        this.annotationMap.set(annotation.id, annotation);
        this.changed.dispatch();
        this.childAdded.dispatch(annotation);
        if (!commit) {
            this.pending.add(annotation.id);
        }
        return this.getReference(annotation.id);
    }
    commit(reference) {
        const id = reference.id;
        this.pending.delete(id);
    }
    update(reference, annotation) {
        if (reference.value === null) {
            throw new Error(`Annotation already deleted.`);
        }
        reference.value = annotation;
        this.annotationMap.set(annotation.id, annotation);
        reference.changed.dispatch();
        this.changed.dispatch();
        this.childUpdated.dispatch(annotation);
    }
    [Symbol.iterator]() {
        return this.annotationMap.values();
    }
    get(id) {
        return this.annotationMap.get(id);
    }
    delete(reference) {
        if (reference.value === null) {
            return;
        }
        reference.value = null;
        this.annotationMap.delete(reference.id);
        this.pending.delete(reference.id);
        reference.changed.dispatch();
        this.changed.dispatch();
        this.childDeleted.dispatch(reference.id);
    }
    getReference(id) {
        let existing = this.references.get(id);
        if (existing !== undefined) {
            return existing.addRef();
        }
        existing = new AnnotationReference(id);
        existing.value = this.annotationMap.get(id) || null;
        this.references.set(id, existing);
        existing.registerDisposer(() => {
            this.references.delete(id);
        });
        return existing;
    }
    toJSON() {
        const result = [];
        const { pending } = this;
        for (const annotation of this) {
            if (pending.has(annotation.id)) {
                // Don't serialize uncommitted annotations.
                continue;
            }
            result.push(annotationToJson(annotation));
        }
        return result;
    }
    clear() {
        this.annotationMap.clear();
        this.pending.clear();
        this.changed.dispatch();
    }
    restoreState(obj) {
        const { annotationMap } = this;
        annotationMap.clear();
        this.pending.clear();
        if (obj !== undefined) {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["parseArray"])(obj, x => {
                const annotation = restoreAnnotation(x);
                annotationMap.set(annotation.id, annotation);
            });
        }
        for (const reference of this.references.values()) {
            const { id } = reference;
            const value = annotationMap.get(id);
            reference.value = value || null;
            reference.changed.dispatch();
        }
        this.changed.dispatch();
    }
    reset() {
        this.clear();
    }
}
class LocalAnnotationSource extends AnnotationSource {
}
const DATA_BOUNDS_DESCRIPTION = 'Data Bounds';
function makeAnnotationId() {
    return Object(neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_3__["getRandomHexString"])(160);
}
function makeDataBoundsBoundingBox(lowerVoxelBound, upperVoxelBound) {
    return {
        type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,
        id: 'data-bounds',
        description: DATA_BOUNDS_DESCRIPTION,
        pointA: lowerVoxelBound,
        pointB: upperVoxelBound
    };
}
function compare3WayById(a, b) {
    return a.id < b.id ? -1 : a.id === b.id ? 0 : 1;
}
function serializeAnnotations(allAnnotations) {
    let totalBytes = 0;
    const typeToOffset = [];
    const typeToSegmentListIndexOffset = [];
    let totalNumSegments = 0;
    let totalNumAnnotations = 0;
    for (const annotationType of annotationTypes) {
        typeToOffset[annotationType] = totalBytes;
        typeToSegmentListIndexOffset[annotationType] = totalNumAnnotations;
        const annotations = allAnnotations[annotationType];
        let numSegments = 0;
        for (const annotation of annotations) {
            const { segments } = annotation;
            if (segments !== undefined) {
                numSegments += segments.length;
            }
        }
        totalNumAnnotations += annotations.length;
        totalNumSegments += numSegments;
        annotations.sort(compare3WayById);
        const count = annotations.length;
        const handler = getAnnotationTypeHandler(annotationType);
        totalBytes += handler.serializedBytes * count;
    }
    const segmentListIndex = new Uint32Array(totalNumAnnotations + 1);
    const segmentList = new Uint32Array(totalNumSegments * 2);
    const typeToIds = [];
    const data = new ArrayBuffer(totalBytes);
    let segmentListOffset = 0;
    let segmentListIndexOffset = 0;
    for (const annotationType of annotationTypes) {
        const annotations = allAnnotations[annotationType];
        typeToIds[annotationType] = annotations.map(x => x.id);
        const count = annotations.length;
        const handler = getAnnotationTypeHandler(annotationType);
        const serializer = handler.serializer(data, typeToOffset[annotationType], count);
        annotations.forEach((annotation, index) => {
            serializer(annotation, index);
            segmentListIndex[segmentListIndexOffset++] = segmentListOffset;
            const { segments } = annotation;
            if (segments !== undefined) {
                for (const segment of segments) {
                    segmentList[segmentListOffset * 2] = segment.low;
                    segmentList[segmentListOffset * 2 + 1] = segment.high;
                    ++segmentListOffset;
                }
            }
        });
    }
    return { data: new Uint8Array(data), typeToIds, typeToOffset, segmentListIndex, segmentList };
}
class AnnotationSerializer {
    constructor() {
        this.annotations = [[], [], [], []];
    }
    add(annotation) {
        this.annotations[annotation.type].push(annotation);
    }
    serialize() {
        return serializeAnnotations(this.annotations);
    }
}
function deserializeAnnotation(obj) {
    if (obj == null) {
        return obj;
    }
    const segments = obj.segments;
    if (segments !== undefined) {
        obj.segments = segments.map((x) => new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__["Uint64"](x.low, x.high));
    }
    return obj;
}


/***/ }),

/***/ "./src/neuroglancer/annotation/line.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/annotation/line.ts ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/type_handler */ "./src/neuroglancer/annotation/type_handler.ts");
/* harmony import */ var neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/array */ "./src/neuroglancer/util/array.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/* harmony import */ var neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/webgl/circles */ "./src/neuroglancer/webgl/circles.ts");
/* harmony import */ var neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/webgl/lines */ "./src/neuroglancer/webgl/lines.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Support for rendering line annotations.
 */








const FULL_OBJECT_PICK_OFFSET = 0;
const ENDPOINTS_PICK_OFFSET = FULL_OBJECT_PICK_OFFSET + 1;
const PICK_IDS_PER_INSTANCE = ENDPOINTS_PICK_OFFSET + 2;
function getEndpointIndexArray() {
    return Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_2__["tile2dArray"])(new Uint8Array([0, 1]), /*majorDimension=*/ 1, /*minorTiles=*/ 1, 
    /*majorTiles=*/ neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_5__["VERTICES_PER_CIRCLE"]);
}
class RenderHelper extends neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__["AnnotationRenderHelper"] {
    constructor() {
        super(...arguments);
        this.lineShader = this.registerDisposer(new neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_6__["LineShader"](this.gl, 1));
        this.circleShader = this.registerDisposer(new neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_5__["CircleShader"](this.gl, 2));
        this.edgeShaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_7__["emitterDependentShaderGetter"])(this, this.gl, (builder) => {
            this.defineShader(builder);
            this.lineShader.defineShader(builder);
            builder.setVertexMain(`
emitLine(uProjection, aEndpointA, aEndpointB);
${this.setPartIndex(builder)};
`);
            builder.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}));
`);
        });
        this.endpointIndexBuffer = this
            .registerDisposer(Object(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_4__["getMemoizedBuffer"])(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, getEndpointIndexArray))
            .value;
        this.endpointShaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_7__["emitterDependentShaderGetter"])(this, this.gl, (builder) => {
            this.defineShader(builder);
            this.circleShader.defineShader(builder, this.targetIsSliceView);
            builder.addAttribute('highp uint', 'aEndpointIndex');
            builder.setVertexMain(`
vec3 vertexPosition = mix(aEndpointA, aEndpointB, float(aEndpointIndex));
emitCircle(uProjection * vec4(vertexPosition, 1.0));
${this.setPartIndex(builder, 'aEndpointIndex + 1u')};
`);
            builder.setFragmentMain(`
vec4 borderColor = vec4(0.0, 0.0, 0.0, 1.0);
emitAnnotation(getCircleColor(vColor, borderColor));
`);
        });
    }
    defineShader(builder) {
        super.defineShader(builder);
        // Position of endpoints in camera coordinates.
        builder.addAttribute('highp vec3', 'aEndpointA');
        builder.addAttribute('highp vec3', 'aEndpointB');
    }
    enable(shader, context, callback) {
        super.enable(shader, context, () => {
            const { gl } = shader;
            const aLower = shader.attribute('aEndpointA');
            const aUpper = shader.attribute('aEndpointB');
            context.buffer.bindToVertexAttrib(aLower, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 4 * 6, /*offset=*/ context.bufferOffset);
            context.buffer.bindToVertexAttrib(aUpper, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 4 * 6, /*offset=*/ context.bufferOffset + 4 * 3);
            gl.vertexAttribDivisor(aLower, 1);
            gl.vertexAttribDivisor(aUpper, 1);
            callback();
            gl.vertexAttribDivisor(aLower, 0);
            gl.vertexAttribDivisor(aUpper, 0);
            gl.disableVertexAttribArray(aLower);
            gl.disableVertexAttribArray(aUpper);
        });
    }
    drawEdges(context) {
        const shader = this.edgeShaderGetter(context.renderContext.emitter);
        this.enable(shader, context, () => {
            this.lineShader.draw(shader, context.renderContext, /*lineWidth=*/ 1, 1.0, context.count);
        });
    }
    drawEndpoints(context) {
        const shader = this.endpointShaderGetter(context.renderContext.emitter);
        this.enable(shader, context, () => {
            const aEndpointIndex = shader.attribute('aEndpointIndex');
            this.endpointIndexBuffer.bindToVertexAttribI(aEndpointIndex, /*components=*/ 1, 
            /*attributeType=*/ WebGL2RenderingContext.UNSIGNED_BYTE);
            this.circleShader.draw(shader, context.renderContext, { interiorRadiusInPixels: 6, borderWidthInPixels: 2, featherWidthInPixels: 1 }, context.count);
            shader.gl.disableVertexAttribArray(aEndpointIndex);
        });
    }
    draw(context) {
        this.drawEdges(context);
        this.drawEndpoints(context);
    }
}
function snapPositionToLine(position, objectToData, endpoints) {
    const cornerA = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].create(), endpoints.subarray(0, 3), objectToData);
    const cornerB = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].create(), endpoints.subarray(3, 6), objectToData);
    Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["projectPointToLineSegment"])(position, cornerA, cornerB, position);
}
function snapPositionToEndpoint(position, objectToData, endpoints, endpointIndex) {
    const startOffset = 3 * endpointIndex;
    const point = endpoints.subarray(startOffset, startOffset + 3);
    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].transformMat4(position, point, objectToData);
}
Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__["registerAnnotationTypeRenderHandler"])(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationType"].LINE, {
    bytes: 6 * 4,
    serializer: (buffer, offset, numAnnotations) => {
        const coordinates = new Float32Array(buffer, offset, numAnnotations * 6);
        return (annotation, index) => {
            const { pointA, pointB } = annotation;
            const coordinateOffset = index * 6;
            coordinates[coordinateOffset] = pointA[0];
            coordinates[coordinateOffset + 1] = pointA[1];
            coordinates[coordinateOffset + 2] = pointA[2];
            coordinates[coordinateOffset + 3] = pointB[0];
            coordinates[coordinateOffset + 4] = pointB[1];
            coordinates[coordinateOffset + 5] = pointB[2];
        };
    },
    sliceViewRenderHelper: RenderHelper,
    perspectiveViewRenderHelper: RenderHelper,
    pickIdsPerInstance: PICK_IDS_PER_INSTANCE,
    snapPosition: (position, objectToData, data, offset, partIndex) => {
        const endpoints = new Float32Array(data, offset, 6);
        if (partIndex === FULL_OBJECT_PICK_OFFSET) {
            snapPositionToLine(position, objectToData, endpoints);
        }
        else {
            snapPositionToEndpoint(position, objectToData, endpoints, partIndex - ENDPOINTS_PICK_OFFSET);
        }
    },
    getRepresentativePoint: (objectToData, ann, partIndex) => {
        let repPoint = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].create();
        // if the full object is selected just pick the first point as representative
        if (partIndex === FULL_OBJECT_PICK_OFFSET) {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].transformMat4(repPoint, ann.pointA, objectToData);
        }
        else {
            if ((partIndex - ENDPOINTS_PICK_OFFSET) === 0) {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].transformMat4(repPoint, ann.pointA, objectToData);
            }
            else {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].transformMat4(repPoint, ann.pointB, objectToData);
            }
        }
        return repPoint;
    },
    updateViaRepresentativePoint: (oldAnnotation, position, dataToObject, partIndex) => {
        let newPt = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].create(), position, dataToObject);
        let baseLine = Object.assign({}, oldAnnotation);
        switch (partIndex) {
            case FULL_OBJECT_PICK_OFFSET:
                let delta = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].sub(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].create(), oldAnnotation.pointB, oldAnnotation.pointA);
                baseLine.pointA = newPt;
                baseLine.pointB = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].add(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec3"].create(), newPt, delta);
                break;
            case FULL_OBJECT_PICK_OFFSET + 1:
                baseLine.pointA = newPt;
                baseLine.pointB = oldAnnotation.pointB;
                break;
            case FULL_OBJECT_PICK_OFFSET + 2:
                baseLine.pointA = oldAnnotation.pointA;
                baseLine.pointB = newPt;
        }
        return baseLine;
    }
});


/***/ }),

/***/ "./src/neuroglancer/annotation/point.ts":
/*!**********************************************!*\
  !*** ./src/neuroglancer/annotation/point.ts ***!
  \**********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/type_handler */ "./src/neuroglancer/annotation/type_handler.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/webgl/circles */ "./src/neuroglancer/webgl/circles.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Support for rendering point annotations.
 */





class RenderHelper extends neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__["AnnotationRenderHelper"] {
    constructor() {
        super(...arguments);
        this.circleShader = this.registerDisposer(new neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_3__["CircleShader"](this.gl));
        this.shaderGetter = Object(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_4__["emitterDependentShaderGetter"])(this, this.gl, (builder) => this.defineShader(builder));
    }
    defineShader(builder) {
        super.defineShader(builder);
        this.circleShader.defineShader(builder, /*crossSectionFade=*/ this.targetIsSliceView);
        // Position of point in camera coordinates.
        builder.addAttribute('highp vec3', 'aVertexPosition');
        builder.setVertexMain(`
emitCircle(uProjection * vec4(aVertexPosition, 1.0));
${this.setPartIndex(builder)};
`);
        builder.setFragmentMain(`
vec4 borderColor = vec4(0.0, 0.0, 0.0, 1.0);
emitAnnotation(getCircleColor(vColor, borderColor));
`);
    }
    draw(context) {
        const shader = this.shaderGetter(context.renderContext.emitter);
        this.enable(shader, context, () => {
            const { gl } = this;
            const aVertexPosition = shader.attribute('aVertexPosition');
            context.buffer.bindToVertexAttrib(aVertexPosition, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
            /*normalized=*/ false, 
            /*stride=*/ 0, /*offset=*/ context.bufferOffset);
            gl.vertexAttribDivisor(aVertexPosition, 1);
            this.circleShader.draw(shader, context.renderContext, { interiorRadiusInPixels: 6, borderWidthInPixels: 2, featherWidthInPixels: 1 }, context.count);
            gl.vertexAttribDivisor(aVertexPosition, 0);
            gl.disableVertexAttribArray(aVertexPosition);
        });
    }
}
Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_1__["registerAnnotationTypeRenderHandler"])(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationType"].POINT, {
    bytes: 3 * 4,
    serializer: (buffer, offset, numAnnotations) => {
        const coordinates = new Float32Array(buffer, offset, numAnnotations * 3);
        return (annotation, index) => {
            const { point } = annotation;
            const coordinateOffset = index * 3;
            coordinates[coordinateOffset] = point[0];
            coordinates[coordinateOffset + 1] = point[1];
            coordinates[coordinateOffset + 2] = point[2];
        };
    },
    sliceViewRenderHelper: RenderHelper,
    perspectiveViewRenderHelper: RenderHelper,
    pickIdsPerInstance: 1,
    snapPosition: (position, objectToData, data, offset) => {
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].transformMat4(position, new Float32Array(data, offset, 3), objectToData);
    },
    getRepresentativePoint: (objectToData, ann) => {
        let repPoint = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].transformMat4(repPoint, ann.point, objectToData);
        return repPoint;
    },
    updateViaRepresentativePoint: (oldAnnotation, position, dataToObject) => {
        let annotation = Object.assign({}, oldAnnotation);
        annotation.point = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create(), position, dataToObject);
        // annotation.id = '';
        return annotation;
    }
});


/***/ }),

/***/ "./src/neuroglancer/annotation/renderlayer.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/annotation/renderlayer.ts ***!
  \****************************************************/
/*! exports provided: AnnotationLayer, PerspectiveViewAnnotationLayer, SliceViewAnnotationLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationLayer", function() { return AnnotationLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveViewAnnotationLayer", function() { return PerspectiveViewAnnotationLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewAnnotationLayer", function() { return SliceViewAnnotationLayer; });
/* harmony import */ var neuroglancer_annotation_bounding_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation/bounding_box */ "./src/neuroglancer/annotation/bounding_box.ts");
/* harmony import */ var neuroglancer_annotation_line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/line */ "./src/neuroglancer/annotation/line.ts");
/* harmony import */ var neuroglancer_annotation_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/annotation/point */ "./src/neuroglancer/annotation/point.ts");
/* harmony import */ var neuroglancer_annotation_ellipsoid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/annotation/ellipsoid */ "./src/neuroglancer/annotation/ellipsoid.ts");
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/annotation/base */ "./src/neuroglancer/annotation/base.ts");
/* harmony import */ var neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/annotation/frontend_source */ "./src/neuroglancer/annotation/frontend_source.ts");
/* harmony import */ var neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/annotation/type_handler */ "./src/neuroglancer/annotation/type_handler.ts");
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/perspective_view/render_layer */ "./src/neuroglancer/perspective_view/render_layer.ts");
/* harmony import */ var neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/segmentation_display_state/base */ "./src/neuroglancer/segmentation_display_state/base.ts");
/* harmony import */ var neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/shared_watchable_value */ "./src/neuroglancer/shared_watchable_value.ts");
/* harmony import */ var neuroglancer_sliceview_panel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/sliceview/panel */ "./src/neuroglancer/sliceview/panel.ts");
/* harmony import */ var neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/util/array */ "./src/neuroglancer/util/array.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




















const tempMat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_15__["mat4"].create();
function segmentationFilter(segmentationState) {
    if (segmentationState == null) {
        return () => false;
    }
    const { visibleSegments, segmentEquivalences } = segmentationState;
    return (annotation) => {
        const { segments } = annotation;
        if (segments === undefined) {
            return false;
        }
        for (const segment of segments) {
            if (visibleSegments.has(segmentEquivalences.get(segment))) {
                return true;
            }
        }
        return false;
    };
}
function serializeAnnotationSet(annotationSet, filter) {
    const typeToIds = [];
    for (const annotationType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["annotationTypes"]) {
        typeToIds[annotationType] = [];
    }
    for (const annotation of annotationSet) {
        if (filter === undefined || filter(annotation)) {
            typeToIds[annotation.type].push(annotation.id);
        }
    }
    let totalBytes = 0;
    let numPickIds = 0;
    const typeToOffset = [];
    for (const annotationType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["annotationTypes"]) {
        typeToOffset[annotationType] = totalBytes;
        const count = typeToIds[annotationType].length;
        const handler = Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_7__["getAnnotationTypeRenderHandler"])(annotationType);
        totalBytes += count * handler.bytes;
        numPickIds += handler.pickIdsPerInstance * count;
    }
    const data = new ArrayBuffer(totalBytes);
    for (const annotationType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["annotationTypes"]) {
        const ids = typeToIds[annotationType];
        const handler = Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_7__["getAnnotationTypeRenderHandler"])(annotationType);
        const serializer = handler.serializer(data, typeToOffset[annotationType], ids.length);
        ids.forEach((id, index) => serializer(annotationSet.get(id), index));
    }
    return { typeToIds, typeToOffset, data, numPickIds };
}
let AnnotationLayerSharedObject = class AnnotationLayerSharedObject extends Object(neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_17__["withSharedVisibility"])(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_19__["SharedObject"]) {
    constructor(chunkManager, source, state, filterBySegmentation) {
        super();
        this.chunkManager = chunkManager;
        this.source = source;
        this.state = state;
        this.filterBySegmentation = filterBySegmentation;
        this.initializeCounterpart(this.chunkManager.rpc, {
            chunkManager: this.chunkManager.rpcId,
            source: source.rpcId,
            segmentationState: this.serializeDisplayState(),
        });
        const update = () => {
            const msg = { id: this.rpcId, segmentationState: this.serializeDisplayState() };
            this.rpc.invoke(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_5__["ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID"], msg);
        };
        this.registerDisposer(state.changed.add(update));
        this.registerDisposer(filterBySegmentation.changed.add(update));
    }
    serializeDisplayState() {
        const state = this.state.value;
        if (state == null) {
            return state;
        }
        if (!this.filterBySegmentation.value) {
            return null;
        }
        return {
            segmentEquivalences: state.segmentEquivalences.rpcId,
            visibleSegments: state.visibleSegments.rpcId
        };
    }
};
AnnotationLayerSharedObject = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_19__["registerSharedObjectOwner"])(neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_5__["ANNOTATION_RENDER_LAYER_RPC_ID"])
], AnnotationLayerSharedObject);
class AnnotationLayer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_14__["RefCounted"] {
    constructor(chunkManager, state) {
        super();
        this.chunkManager = chunkManager;
        this.state = state;
        /**
         * The value of this.state.annotationSet.changed.count when `buffer` was last updated.
         */
        this.generation = -1;
        this.redrawNeeded = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_16__["NullarySignal"]();
        this.handleChangeAffectingBuffer = (() => {
            this.generation = -1;
            this.redrawNeeded.dispatch();
        });
        this.handleSegmentationChanged = (() => {
            if (this.state.filterBySegmentation.value) {
                this.handleChangeAffectingBuffer();
            }
        });
        this.registerDisposer(state);
        this.buffer = this.registerDisposer(new neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_18__["Buffer"](chunkManager.gl));
        this.registerDisposer(this.source.changed.add(this.handleChangeAffectingBuffer));
        this.registerDisposer(state.filterBySegmentation.changed.add(this.handleChangeAffectingBuffer));
        this.registerDisposer(() => this.unregisterSegmentationState());
        this.registerDisposer(state.segmentationState.changed.add(() => {
            const segmentationState = state.segmentationState.value;
            if (segmentationState !== this.segmentationState) {
                this.unregisterSegmentationState();
                if (segmentationState != null) {
                    segmentationState.visibleSegments.changed.add(this.handleSegmentationChanged);
                    segmentationState.segmentEquivalences.changed.add(this.handleSegmentationChanged);
                }
                this.segmentationState = segmentationState;
                this.handleSegmentationChanged();
            }
        }));
        if (!(this.source instanceof neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["AnnotationSource"])) {
            this.sharedObject = this.registerDisposer(new AnnotationLayerSharedObject(chunkManager, this.source, state.segmentationState, state.filterBySegmentation));
        }
        this.registerDisposer(this.state.color.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(this.state.fillOpacity.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(this.hoverState.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch));
    }
    get source() {
        return this.state.source;
    }
    get transform() {
        return this.state.transform;
    }
    get hoverState() {
        return this.state.hoverState;
    }
    unregisterSegmentationState() {
        const { segmentationState } = this;
        if (segmentationState != null) {
            segmentationState.visibleSegments.changed.remove(this.handleSegmentationChanged);
            segmentationState.segmentEquivalences.changed.remove(this.handleSegmentationChanged);
            this.segmentationState = undefined;
        }
    }
    get visibility() {
        const { sharedObject } = this;
        if (sharedObject === undefined) {
            return undefined;
        }
        return sharedObject.visibility;
    }
    get gl() {
        return this.chunkManager.gl;
    }
    updateBuffer() {
        const { source } = this;
        if (source instanceof neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["AnnotationSource"]) {
            const generation = source.changed.count;
            if (this.generation !== generation) {
                this.generation = generation;
                const { data, typeToIds, typeToOffset, numPickIds } = serializeAnnotationSet(source, this.state.filterBySegmentation.value ? segmentationFilter(this.segmentationState) :
                    undefined);
                this.data = new Uint8Array(data);
                this.buffer.setData(this.data);
                this.typeToIds = typeToIds;
                this.typeToOffset = typeToOffset;
                this.numPickIds = numPickIds;
            }
        }
    }
}
class AnnotationPerspectiveRenderLayerBase extends neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_9__["PerspectiveViewRenderLayer"] {
    constructor(base) {
        super();
        this.base = base;
    }
}
class AnnotationSliceViewRenderLayerBase extends neuroglancer_sliceview_panel__WEBPACK_IMPORTED_MODULE_12__["SliceViewPanelRenderLayer"] {
    constructor(base) {
        super();
        this.base = base;
    }
}
function AnnotationRenderLayer(Base, renderHelperType) {
    class C extends Base {
        constructor(...args) {
            super(...args);
            this.renderHelpers = [];
            this.isAnnotation = true;
            const base = this.registerDisposer(this.base);
            const baseVisibility = base.visibility;
            if (baseVisibility !== undefined) {
                this.registerDisposer(baseVisibility.add(this.visibility));
            }
            this.role = base.state.role;
            const { renderHelpers, gl } = this;
            for (const annotationType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["annotationTypes"]) {
                const handler = Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_7__["getAnnotationTypeRenderHandler"])(annotationType);
                const renderHelperConstructor = handler[renderHelperType];
                const helper = renderHelpers[annotationType] =
                    this.registerDisposer(new renderHelperConstructor(gl));
                helper.pickIdsPerInstance = handler.pickIdsPerInstance;
                helper.targetIsSliceView = renderHelperType === 'sliceViewRenderHelper';
            }
            this.registerDisposer(base.redrawNeeded.add(() => {
                this.redrawNeeded.dispatch();
            }));
            this.setReady(true);
        }
        get gl() {
            return this.base.chunkManager.gl;
        }
        drawGeometryChunkData(chunk, renderContext) {
            if (!chunk.bufferValid) {
                let { buffer } = chunk;
                if (buffer === undefined) {
                    buffer = chunk.buffer = new neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_18__["Buffer"](this.gl);
                }
                buffer.setData(chunk.data);
                chunk.bufferValid = true;
            }
            this.drawGeometry(chunk, renderContext);
        }
        drawGeometry(chunk, renderContext) {
            const { base } = this;
            const typeToIds = chunk.typeToIds;
            const typeToOffset = chunk.typeToOffset;
            let pickId = 0;
            if (renderContext.emitPickID) {
                pickId = renderContext.pickIDs.register(this, chunk.numPickIds, 0, 0, chunk);
            }
            const hoverValue = base.hoverState.value;
            const projectionMatrix = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_15__["mat4"].multiply(tempMat, renderContext.dataToDevice, base.state.objectToGlobal);
            for (const annotationType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["annotationTypes"]) {
                const ids = typeToIds[annotationType];
                if (ids.length > 0) {
                    const count = ids.length;
                    const handler = Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_7__["getAnnotationTypeRenderHandler"])(annotationType);
                    let selectedIndex = 0xFFFFFFFF;
                    if (hoverValue !== undefined) {
                        const index = Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_13__["binarySearch"])(ids, hoverValue.id, (a, b) => a < b ? -1 : a === b ? 0 : 1);
                        if (index >= 0) {
                            selectedIndex = index * handler.pickIdsPerInstance;
                            // If we wanted to include the partIndex, we would add:
                            // selectedIndex += hoverValue.partIndex;
                        }
                    }
                    const context = {
                        annotationLayer: base,
                        renderContext,
                        selectedIndex,
                        basePickId: pickId,
                        buffer: chunk.buffer,
                        bufferOffset: typeToOffset[annotationType],
                        count,
                        projectionMatrix,
                    };
                    this.renderHelpers[annotationType].draw(context);
                    pickId += count * handler.pickIdsPerInstance;
                }
            }
        }
        draw(renderContext) {
            const { source } = this.base;
            if (source instanceof neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["AnnotationSource"]) {
                const { base } = this;
                base.updateBuffer();
                this.drawGeometry(base, renderContext);
            }
            else {
                this.drawGeometryChunkData(source.temporary.data, renderContext);
                if (this.base.state.filterBySegmentation.value) {
                    const segmentationState = this.base.state.segmentationState.value;
                    if (segmentationState == null) {
                        return;
                    }
                    const chunks = source.segmentFilteredSource.chunks;
                    Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_10__["forEachVisibleSegment"])(segmentationState, objectId => {
                        const key = Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_10__["getObjectKey"])(objectId);
                        const chunk = chunks.get(key);
                        if (chunk !== undefined) {
                            this.drawGeometryChunkData(chunk.data, renderContext);
                        }
                    });
                }
                else {
                    for (const alternatives of source.sources) {
                        for (const geometrySource of alternatives) {
                            for (const chunk of geometrySource.chunks.values()) {
                                if (chunk.state !== neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_8__["ChunkState"].GPU_MEMORY) {
                                    continue;
                                }
                                this.drawGeometryChunkData(chunk.data, renderContext);
                            }
                        }
                    }
                }
            }
        }
        updateMouseState(mouseState, _pickedValue, pickedOffset, data) {
            const chunk = data;
            const typeToIds = chunk.typeToIds;
            const typeToOffset = chunk.typeToOffset;
            for (const annotationType of neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_4__["annotationTypes"]) {
                const ids = typeToIds[annotationType];
                const handler = Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_7__["getAnnotationTypeRenderHandler"])(annotationType);
                const { pickIdsPerInstance } = handler;
                if (pickedOffset < ids.length * pickIdsPerInstance) {
                    const instanceIndex = Math.floor(pickedOffset / pickIdsPerInstance);
                    const id = ids[instanceIndex];
                    const partIndex = pickedOffset % pickIdsPerInstance;
                    mouseState.pickedAnnotationId = id;
                    mouseState.pickedAnnotationLayer = this.base.state;
                    mouseState.pickedOffset = partIndex;
                    mouseState.pickedAnnotationBuffer = chunk.data.buffer;
                    mouseState.pickedAnnotationBufferOffset = chunk.data.byteOffset + typeToOffset[annotationType] + instanceIndex * handler.bytes;
                    handler.snapPosition(mouseState.position, this.base.state.objectToGlobal, mouseState.pickedAnnotationBuffer, mouseState.pickedAnnotationBufferOffset, partIndex);
                    return;
                }
                pickedOffset -= ids.length * pickIdsPerInstance;
            }
        }
        transformPickedValue(_pickedValue, _pickedOffset) {
            return undefined;
        }
        isReady() {
            const { base } = this;
            const { source } = base;
            if (!(source instanceof neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_6__["MultiscaleAnnotationSource"])) {
                return true;
            }
            if (!base.state.filterBySegmentation.value) {
                return true;
            }
            const segmentationState = this.base.state.segmentationState.value;
            if (segmentationState === undefined) {
                // We are still waiting to attach segmentation.
                return false;
            }
            if (segmentationState === null) {
                return true;
            }
            const chunks = source.segmentFilteredSource.chunks;
            let missing = false;
            Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_10__["forEachVisibleSegment"])(segmentationState, objectId => {
                const key = Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_10__["getObjectKey"])(objectId);
                if (!chunks.has(key)) {
                    missing = true;
                }
            });
            return !missing;
        }
    }
    return C;
}
const PerspectiveViewAnnotationLayerBase = AnnotationRenderLayer(AnnotationPerspectiveRenderLayerBase, 'perspectiveViewRenderHelper');
class PerspectiveViewAnnotationLayer extends PerspectiveViewAnnotationLayerBase {
    constructor() {
        super(...arguments);
        this.backend = (() => {
            const { source } = this.base;
            if (source instanceof neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_6__["MultiscaleAnnotationSource"]) {
                const sharedObject = this.registerDisposer(new neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_19__["SharedObject"]());
                const rpc = source.chunkManager.rpc;
                sharedObject.RPC_TYPE_ID = neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_5__["ANNOTATION_PERSPECTIVE_RENDER_LAYER_RPC_ID"];
                sharedObject.initializeCounterpart(rpc, {
                    source: source.rpcId,
                    filterBySegmentation: this.registerDisposer(neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_11__["SharedWatchableValue"].makeFromExisting(rpc, this.base.state.filterBySegmentation))
                        .rpcId
                });
                return sharedObject;
            }
            return undefined;
        })();
    }
    isReady() {
        if (!super.isReady()) {
            return false;
        }
        const { base } = this;
        const { source } = base;
        if (source instanceof neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_6__["MultiscaleAnnotationSource"]) {
            if (!base.state.filterBySegmentation.value) {
                const geometrySource = source.sources[0][0];
                const chunk = geometrySource.chunks.get('0,0,0');
                if (chunk === undefined || chunk.state !== neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_8__["ChunkState"].GPU_MEMORY) {
                    return false;
                }
            }
        }
        return true;
    }
}
const SliceViewAnnotationLayer = AnnotationRenderLayer(AnnotationSliceViewRenderLayerBase, 'sliceViewRenderHelper');


/***/ }),

/***/ "./src/neuroglancer/annotation/selection.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/annotation/selection.ts ***!
  \**************************************************/
/*! exports provided: getSelectedAnnotation, setAnnotationHoverStateFromMouseState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedAnnotation", function() { return getSelectedAnnotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAnnotationHoverStateFromMouseState", function() { return setAnnotationHoverStateFromMouseState; });
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getSelectedAnnotation(mouseState, layerManager) {
    if (!mouseState.active) {
        return undefined;
    }
    if (mouseState.pickedAnnotationId === undefined) {
        return undefined;
    }
    const renderLayer = mouseState.pickedRenderLayer;
    if (renderLayer === null) {
        return undefined;
    }
    const annotationLayer = mouseState.pickedAnnotationLayer;
    if (annotationLayer === undefined) {
        return undefined;
    }
    const managedLayer = layerManager.renderLayerToManagedLayerMap.get(renderLayer);
    if (managedLayer === undefined) {
        return undefined;
    }
    return {
        layer: managedLayer,
        annotationLayer,
        id: mouseState.pickedAnnotationId,
        partIndex: mouseState.pickedOffset,
    };
}
function setAnnotationHoverStateFromMouseState(annotationLayer, mouseState) {
    annotationLayer.registerDisposer(mouseState.changed.add(() => {
        if (mouseState.active && mouseState.pickedAnnotationLayer === annotationLayer) {
            const existingValue = annotationLayer.hoverState.value;
            if (existingValue === undefined || existingValue.id !== mouseState.pickedAnnotationId ||
                existingValue.partIndex !== mouseState.pickedOffset) {
                annotationLayer.hoverState.value = {
                    id: mouseState.pickedAnnotationId,
                    partIndex: mouseState.pickedOffset
                };
            }
        }
        else {
            annotationLayer.hoverState.value = undefined;
        }
    }));
}


/***/ }),

/***/ "./src/neuroglancer/annotation/type_handler.ts":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/annotation/type_handler.ts ***!
  \*****************************************************/
/*! exports provided: AnnotationRenderHelper, registerAnnotationTypeRenderHandler, getAnnotationTypeRenderHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationRenderHelper", function() { return AnnotationRenderHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerAnnotationTypeRenderHandler", function() { return registerAnnotationTypeRenderHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAnnotationTypeRenderHandler", function() { return getAnnotationTypeRenderHandler; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const tempPickID = new Float32Array(4);
class AnnotationRenderHelper extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl) {
        super();
        this.gl = gl;
    }
    setPartIndex(builder, ...partIndexExpressions) {
        let s = `
void setPartIndex(${partIndexExpressions.map((_, i) => `highp uint partIndex${i}`).join()}) {
  highp uint pickID = uPickID;
  highp uint pickBaseOffset = getPickBaseOffset();
${partIndexExpressions
            .map((_, i) => `highp uint pickOffset${i} = pickBaseOffset + partIndex${i};`)
            .join('\n')}
`;
        if (partIndexExpressions.length === 0) {
            s += `
  highp uint pickOffset0 = pickBaseOffset;
`;
        }
        s += `
  vPickID = pickID + pickOffset0;
  highp uint selectedIndex = uSelectedIndex;
if (selectedIndex == pickBaseOffset${partIndexExpressions.map((_, i) => ` || selectedIndex == pickOffset${i}`).join('')}) {
    vColor = uColorSelected;
  } else {
    vColor = uColor;
  }
}
`;
        builder.addVertexCode(s);
        return `setPartIndex(${partIndexExpressions.join()})`;
    }
    getCrossSectionFadeFactor() {
        if (this.targetIsSliceView) {
            return `(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))`;
        }
        else {
            return `(1.0)`;
        }
    }
    defineShader(builder) {
        builder.addUniform('highp vec4', 'uColor');
        builder.addUniform('highp vec4', 'uColorSelected');
        builder.addUniform('highp uint', 'uSelectedIndex');
        builder.addVarying('highp vec4', 'vColor');
        // Transform from camera to clip coordinates.
        builder.addUniform('highp mat4', 'uProjection');
        builder.addUniform('highp uint', 'uPickID');
        builder.addVarying('highp uint', 'vPickID', 'flat');
        builder.addVertexCode(`
highp uint getPickBaseOffset() { return uint(gl_InstanceID) * ${this.pickIdsPerInstance}u; }
`);
        builder.addFragmentCode(`
void emitAnnotation(vec4 color) {
  emit(color, vPickID);
}
`);
    }
    enable(shader, context, callback) {
        shader.bind();
        const { gl } = this;
        const { renderContext } = context;
        const { annotationLayer } = context;
        gl.uniformMatrix4fv(shader.uniform('uProjection'), false, context.projectionMatrix);
        if (renderContext.emitPickID) {
            gl.uniform1ui(shader.uniform('uPickID'), context.basePickId);
        }
        if (renderContext.emitColor) {
            const colorVec4 = tempPickID;
            const color = annotationLayer.state.color.value;
            colorVec4[0] = color[0];
            colorVec4[1] = color[1];
            colorVec4[2] = color[2];
            colorVec4[3] = 1;
            gl.uniform4fv(shader.uniform('uColor'), colorVec4);
            const saturationAmount = 0.75;
            for (let i = 0; i < 3; ++i) {
                colorVec4[i] = saturationAmount + (1 - saturationAmount) * colorVec4[i];
            }
            gl.uniform4fv(shader.uniform('uColorSelected'), colorVec4);
            gl.uniform1ui(shader.uniform('uSelectedIndex'), context.selectedIndex);
        }
        callback();
    }
}
const annotationTypeRenderHandlers = new Map();
function registerAnnotationTypeRenderHandler(type, handler) {
    annotationTypeRenderHandlers.set(type, handler);
}
function getAnnotationTypeRenderHandler(type) {
    return annotationTypeRenderHandlers.get(type);
}


/***/ }),

/***/ "./src/neuroglancer/annotation/user_layer.css":
/*!****************************************************!*\
  !*** ./src/neuroglancer/annotation/user_layer.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/annotation/user_layer.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/annotation/user_layer.ts ***!
  \***************************************************/
/*! exports provided: AnnotationUserLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationUserLayer", function() { return AnnotationUserLayer; });
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/frontend */ "./src/neuroglancer/annotation/frontend.ts");
/* harmony import */ var neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/coordinate_transform */ "./src/neuroglancer/coordinate_transform.ts");
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/navigation_state */ "./src/neuroglancer/navigation_state.ts");
/* harmony import */ var neuroglancer_segmentation_user_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/segmentation_user_layer */ "./src/neuroglancer/segmentation_user_layer.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/trackable_boolean */ "./src/neuroglancer/trackable_boolean.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_ui_annotations__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/ui/annotations */ "./src/neuroglancer/ui/annotations.ts");
/* harmony import */ var neuroglancer_user_layer_with_coordinate_transform__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/user_layer_with_coordinate_transform */ "./src/neuroglancer/user_layer_with_coordinate_transform.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_widget_layer_reference__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/widget/layer_reference */ "./src/neuroglancer/widget/layer_reference.ts");
/* harmony import */ var _user_layer_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./user_layer.css */ "./src/neuroglancer/annotation/user_layer.css");
/* harmony import */ var _user_layer_css__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_user_layer_css__WEBPACK_IMPORTED_MODULE_15__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















const POINTS_JSON_KEY = 'points';
const ANNOTATIONS_JSON_KEY = 'annotations';
function addPointAnnotations(annotations, obj) {
    if (obj === undefined) {
        return;
    }
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["parseArray"])(obj, (x, i) => {
        annotations.add({
            type: neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationType"].POINT,
            id: '' + i,
            point: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["verify3dVec"])(x),
        });
    });
}
function isValidLinkedSegmentationLayer(layer) {
    const userLayer = layer.layer;
    if (userLayer === null) {
        return true;
    }
    if (userLayer instanceof neuroglancer_segmentation_user_layer__WEBPACK_IMPORTED_MODULE_6__["SegmentationUserLayer"]) {
        return true;
    }
    return false;
}
function getSegmentationDisplayState(layer) {
    if (layer === undefined) {
        return undefined;
    }
    const userLayer = layer.layer;
    if (userLayer === null) {
        return undefined;
    }
    if (!(userLayer instanceof neuroglancer_segmentation_user_layer__WEBPACK_IMPORTED_MODULE_6__["SegmentationUserLayer"])) {
        return undefined;
    }
    return userLayer.displayState;
}
const VOXEL_SIZE_JSON_KEY = 'voxelSize';
const SOURCE_JSON_KEY = 'source';
const LINKED_SEGMENTATION_LAYER_JSON_KEY = 'linkedSegmentationLayer';
const FILTER_BY_SEGMENTATION_JSON_KEY = 'filterBySegmentation';
const Base = Object(neuroglancer_ui_annotations__WEBPACK_IMPORTED_MODULE_10__["UserLayerWithAnnotationsMixin"])(Object(neuroglancer_user_layer_with_coordinate_transform__WEBPACK_IMPORTED_MODULE_11__["UserLayerWithCoordinateTransformMixin"])(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_3__["UserLayer"]));
class AnnotationUserLayer extends Base {
    constructor(manager, specification) {
        super(manager, specification);
        this.localAnnotations = this.registerDisposer(new neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["LocalAnnotationSource"]());
        this.voxelSize = new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_5__["VoxelSize"]();
        this.linkedSegmentationLayer = this.registerDisposer(new neuroglancer_layer__WEBPACK_IMPORTED_MODULE_3__["LayerReference"](this.manager.rootLayers.addRef(), isValidLinkedSegmentationLayer));
        this.filterBySegmentation = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_8__["TrackableBoolean"](false);
        const sourceUrl = this.sourceUrl = specification[SOURCE_JSON_KEY];
        this.linkedSegmentationLayer.restoreState(specification[LINKED_SEGMENTATION_LAYER_JSON_KEY]);
        this.filterBySegmentation.restoreState(specification[FILTER_BY_SEGMENTATION_JSON_KEY]);
        if (sourceUrl === undefined) {
            this.isReady = true;
            this.voxelSize.restoreState(specification[VOXEL_SIZE_JSON_KEY]);
            this.localAnnotations.restoreState(specification[ANNOTATIONS_JSON_KEY]);
            // Handle legacy "points" property.
            addPointAnnotations(this.localAnnotations, specification[POINTS_JSON_KEY]);
            let voxelSizeValid = false;
            const handleVoxelSizeChanged = () => {
                if (!this.voxelSize.valid && manager.voxelSize.valid) {
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].copy(this.voxelSize.size, manager.voxelSize.size);
                    this.voxelSize.setValid();
                }
                if (this.voxelSize.valid && voxelSizeValid === false) {
                    const derivedTransform = new neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_2__["CoordinateTransform"]();
                    this.registerDisposer(Object(neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_2__["makeDerivedCoordinateTransform"])(derivedTransform, this.transform, (output, input) => {
                        const voxelScalingMatrix = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat4"].fromScaling(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat4"].create(), this.voxelSize.size);
                        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat4"].multiply(output, input, voxelScalingMatrix);
                    }));
                    this.annotationLayerState.value = new neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_1__["AnnotationLayerState"](Object.assign({ transform: derivedTransform, source: this.localAnnotations.addRef() }, this.getAnnotationRenderOptions()));
                    voxelSizeValid = true;
                }
            };
            this.registerDisposer(this.localAnnotations.changed.add(this.specificationChanged.dispatch));
            this.registerDisposer(this.voxelSize.changed.add(this.specificationChanged.dispatch));
            this.registerDisposer(this.filterBySegmentation.changed.add(this.specificationChanged.dispatch));
            this.registerDisposer(this.voxelSize.changed.add(handleVoxelSizeChanged));
            this.registerDisposer(this.manager.voxelSize.changed.add(handleVoxelSizeChanged));
            handleVoxelSizeChanged();
        }
        else {
            neuroglancer_status__WEBPACK_IMPORTED_MODULE_7__["StatusMessage"]
                .forPromise(this.manager.dataSourceProvider.getAnnotationSource(this.manager.chunkManager, sourceUrl), {
                initialMessage: `Retrieving metadata for volume ${sourceUrl}.`,
                delay: true,
                errorPrefix: `Error retrieving metadata for volume ${sourceUrl}: `,
            })
                .then(source => {
                if (this.wasDisposed) {
                    return;
                }
                this.annotationLayerState.value = new neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_1__["AnnotationLayerState"](Object.assign({ transform: this.transform, source }, this.getAnnotationRenderOptions()));
                this.isReady = true;
            });
        }
        this.tabs.default = 'annotations';
    }
    getAnnotationRenderOptions() {
        const segmentationState = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_9__["WatchableValue"](undefined);
        const setSegmentationState = () => {
            const { linkedSegmentationLayer } = this;
            if (linkedSegmentationLayer.layerName === undefined) {
                segmentationState.value = null;
            }
            else {
                const { layer } = linkedSegmentationLayer;
                segmentationState.value = getSegmentationDisplayState(layer);
            }
        };
        this.registerDisposer(this.linkedSegmentationLayer.changed.add(setSegmentationState));
        setSegmentationState();
        return Object.assign({ segmentationState, filterBySegmentation: this.filterBySegmentation }, Object(neuroglancer_ui_annotations__WEBPACK_IMPORTED_MODULE_10__["getAnnotationRenderOptions"])(this));
    }
    initializeAnnotationLayerViewTab(tab) {
        const widget = tab.registerDisposer(new neuroglancer_widget_layer_reference__WEBPACK_IMPORTED_MODULE_14__["LayerReferenceWidget"](this.linkedSegmentationLayer));
        widget.element.insertBefore(document.createTextNode('Linked segmentation: '), widget.element.firstChild);
        tab.element.appendChild(widget.element);
        {
            const checkboxWidget = this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_8__["TrackableBooleanCheckbox"](tab.annotationLayer.filterBySegmentation));
            const label = document.createElement('label');
            label.textContent = 'Filter by segmentation: ';
            label.appendChild(checkboxWidget.element);
            tab.element.appendChild(label);
            tab.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_8__["ElementVisibilityFromTrackableBoolean"](this.registerDisposer(Object(neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_9__["makeDerivedWatchableValue"])(v => v !== undefined, tab.annotationLayer.segmentationState)), label));
        }
    }
    toJSON() {
        const x = super.toJSON();
        x['type'] = 'annotation';
        x[SOURCE_JSON_KEY] = this.sourceUrl;
        if (this.sourceUrl === undefined) {
            x[ANNOTATIONS_JSON_KEY] = this.localAnnotations.toJSON();
            x[VOXEL_SIZE_JSON_KEY] = this.voxelSize.toJSON();
        }
        x[LINKED_SEGMENTATION_LAYER_JSON_KEY] = this.linkedSegmentationLayer.toJSON();
        x[FILTER_BY_SEGMENTATION_JSON_KEY] = this.filterBySegmentation.toJSON();
        return x;
    }
}
Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_4__["registerLayerType"])('annotation', AnnotationUserLayer);
Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_4__["registerLayerType"])('pointAnnotation', AnnotationUserLayer);


/***/ }),

/***/ "./src/neuroglancer/axes_lines.ts":
/*!****************************************!*\
  !*** ./src/neuroglancer/axes_lines.ts ***!
  \****************************************/
/*! exports provided: AxesLineHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesLineHelper", function() { return AxesLineHelper; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/* harmony import */ var neuroglancer_webgl_trivial_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/trivial_shaders */ "./src/neuroglancer/webgl/trivial_shaders.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class AxesLineHelper extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl) {
        super();
        this.gl = gl;
        this.vertexBuffer = this.registerDisposer(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__["Buffer"].fromData(gl, new Float32Array([
            0, 0, 0, 1,
            1, 0, 0, 1,
            0, 0, 0, 1,
            0, 1, 0, 1,
            0, 0, 0, 1,
            0, 0, 1, 1,
        ]), gl.ARRAY_BUFFER, gl.STATIC_DRAW));
        let alpha = 0.5;
        this.colorBuffer = this.registerDisposer(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__["Buffer"].fromData(gl, new Float32Array([
            1, 0, 0, alpha,
            1, 0, 0, alpha,
            0, 1, 0, alpha,
            0, 1, 0, alpha,
            0, 0, 1, alpha,
            0, 0, 1, alpha,
        ]), gl.ARRAY_BUFFER, gl.STATIC_DRAW));
        this.trivialColorShader = this.registerDisposer(Object(neuroglancer_webgl_trivial_shaders__WEBPACK_IMPORTED_MODULE_2__["trivialColorShader"])(gl));
    }
    static get(gl) {
        return gl.memoize.get('SliceViewPanel:AxesLineHelper', () => new AxesLineHelper(gl));
    }
    draw(mat, blend = true) {
        let shader = this.trivialColorShader;
        let gl = this.gl;
        shader.bind();
        gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, mat);
        let aVertexPosition = shader.attribute('aVertexPosition');
        this.vertexBuffer.bindToVertexAttrib(aVertexPosition, 4);
        let aColor = shader.attribute('aColor');
        this.colorBuffer.bindToVertexAttrib(aColor, 4);
        if (blend) {
            gl.colorMask(false, false, false, true);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.colorMask(true, true, true, true);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.DST_ALPHA);
        }
        gl.lineWidth(1);
        gl.drawArrays(gl.LINES, 0, 6);
        if (blend) {
            gl.disable(gl.BLEND);
        }
        gl.disableVertexAttribArray(aVertexPosition);
        gl.disableVertexAttribArray(aColor);
    }
}


/***/ }),

/***/ "./src/neuroglancer/chunk_manager/base.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/chunk_manager/base.ts ***!
  \************************************************/
/*! exports provided: ChunkState, numChunkStates, ChunkPriorityTier, numChunkPriorityTiers, ChunkDownloadStatistics, ChunkMemoryStatistics, numChunkMemoryStatistics, numChunkDownloadStatistics, numChunkStatistics, getChunkStateStatisticIndex, getChunkDownloadStatisticIndex, PREFETCH_PRIORITY_MULTIPLIER, CHUNK_QUEUE_MANAGER_RPC_ID, CHUNK_MANAGER_RPC_ID, CHUNK_SOURCE_INVALIDATE_RPC_ID, REQUEST_CHUNK_STATISTICS_RPC_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkState", function() { return ChunkState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numChunkStates", function() { return numChunkStates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkPriorityTier", function() { return ChunkPriorityTier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numChunkPriorityTiers", function() { return numChunkPriorityTiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkDownloadStatistics", function() { return ChunkDownloadStatistics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkMemoryStatistics", function() { return ChunkMemoryStatistics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numChunkMemoryStatistics", function() { return numChunkMemoryStatistics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numChunkDownloadStatistics", function() { return numChunkDownloadStatistics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numChunkStatistics", function() { return numChunkStatistics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChunkStateStatisticIndex", function() { return getChunkStateStatisticIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChunkDownloadStatisticIndex", function() { return getChunkDownloadStatisticIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PREFETCH_PRIORITY_MULTIPLIER", function() { return PREFETCH_PRIORITY_MULTIPLIER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CHUNK_QUEUE_MANAGER_RPC_ID", function() { return CHUNK_QUEUE_MANAGER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CHUNK_MANAGER_RPC_ID", function() { return CHUNK_MANAGER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CHUNK_SOURCE_INVALIDATE_RPC_ID", function() { return CHUNK_SOURCE_INVALIDATE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REQUEST_CHUNK_STATISTICS_RPC_ID", function() { return REQUEST_CHUNK_STATISTICS_RPC_ID; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ChunkState;
(function (ChunkState) {
    // Chunk is stored in GPU memory in addition to system memory.
    ChunkState[ChunkState["GPU_MEMORY"] = 0] = "GPU_MEMORY";
    // Chunk is stored only in system memory but not in GPU memory.
    ChunkState[ChunkState["SYSTEM_MEMORY"] = 1] = "SYSTEM_MEMORY";
    // Chunk is stored in system memory on worker.
    ChunkState[ChunkState["SYSTEM_MEMORY_WORKER"] = 2] = "SYSTEM_MEMORY_WORKER";
    // Chunk is downloading.
    ChunkState[ChunkState["DOWNLOADING"] = 3] = "DOWNLOADING";
    // Chunk is not yet downloading.
    ChunkState[ChunkState["QUEUED"] = 4] = "QUEUED";
    // Chunk has just been added.
    ChunkState[ChunkState["NEW"] = 5] = "NEW";
    // Download failed.
    ChunkState[ChunkState["FAILED"] = 6] = "FAILED";
    ChunkState[ChunkState["EXPIRED"] = 7] = "EXPIRED";
    // If new states are added, keep numChangeStates in sync.
})(ChunkState || (ChunkState = {}));
const numChunkStates = 8;
var ChunkPriorityTier;
(function (ChunkPriorityTier) {
    ChunkPriorityTier[ChunkPriorityTier["FIRST_TIER"] = 0] = "FIRST_TIER";
    ChunkPriorityTier[ChunkPriorityTier["FIRST_ORDERED_TIER"] = 0] = "FIRST_ORDERED_TIER";
    ChunkPriorityTier[ChunkPriorityTier["VISIBLE"] = 0] = "VISIBLE";
    ChunkPriorityTier[ChunkPriorityTier["PREFETCH"] = 1] = "PREFETCH";
    ChunkPriorityTier[ChunkPriorityTier["LAST_ORDERED_TIER"] = 1] = "LAST_ORDERED_TIER";
    ChunkPriorityTier[ChunkPriorityTier["RECENT"] = 2] = "RECENT";
    ChunkPriorityTier[ChunkPriorityTier["LAST_TIER"] = 2] = "LAST_TIER";
})(ChunkPriorityTier || (ChunkPriorityTier = {}));
const numChunkPriorityTiers = 3;
var ChunkDownloadStatistics;
(function (ChunkDownloadStatistics) {
    ChunkDownloadStatistics[ChunkDownloadStatistics["totalTime"] = 0] = "totalTime";
    ChunkDownloadStatistics[ChunkDownloadStatistics["totalChunks"] = 1] = "totalChunks";
})(ChunkDownloadStatistics || (ChunkDownloadStatistics = {}));
var ChunkMemoryStatistics;
(function (ChunkMemoryStatistics) {
    ChunkMemoryStatistics[ChunkMemoryStatistics["numChunks"] = 0] = "numChunks";
    ChunkMemoryStatistics[ChunkMemoryStatistics["systemMemoryBytes"] = 1] = "systemMemoryBytes";
    ChunkMemoryStatistics[ChunkMemoryStatistics["gpuMemoryBytes"] = 2] = "gpuMemoryBytes";
})(ChunkMemoryStatistics || (ChunkMemoryStatistics = {}));
const numChunkMemoryStatistics = 3;
const numChunkDownloadStatistics = 2;
const numChunkStatistics = numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics + numChunkDownloadStatistics;
function getChunkStateStatisticIndex(state, priorityTier) {
    return state * numChunkPriorityTiers + priorityTier;
}
function getChunkDownloadStatisticIndex(statistic) {
    return numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics + statistic;
}
const PREFETCH_PRIORITY_MULTIPLIER = 1e13;
const CHUNK_QUEUE_MANAGER_RPC_ID = 'ChunkQueueManager';
const CHUNK_MANAGER_RPC_ID = 'ChunkManager';
const CHUNK_SOURCE_INVALIDATE_RPC_ID = 'ChunkSource.invalidate';
const REQUEST_CHUNK_STATISTICS_RPC_ID = 'ChunkQueueManager.requestChunkStatistics';


/***/ }),

/***/ "./src/neuroglancer/chunk_manager/frontend.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/chunk_manager/frontend.ts ***!
  \****************************************************/
/*! exports provided: Chunk, CapacitySpecification, ChunkQueueManager, ChunkManager, ChunkSource, WithParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Chunk", function() { return Chunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CapacitySpecification", function() { return CapacitySpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkQueueManager", function() { return ChunkQueueManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkManager", function() { return ChunkManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkSource", function() { return ChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WithParameters", function() { return WithParameters; });
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/shared_watchable_value */ "./src/neuroglancer/shared_watchable_value.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_memoize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/memoize */ "./src/neuroglancer/util/memoize.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









const DEBUG_CHUNK_UPDATES = false;
class Chunk {
    constructor(source) {
        this.source = source;
        this.state = neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].SYSTEM_MEMORY;
    }
    get gl() {
        return this.source.gl;
    }
    copyToGPU(_gl) {
        this.state = neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY;
    }
    freeGPUMemory(_gl) {
        this.state = neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].SYSTEM_MEMORY;
    }
}
function validateLimitValue(x) {
    if (typeof x !== 'number' || x < 0) {
        throw new Error(`Expected non-negative number as limit, but received: ${JSON.stringify(x)}`);
    }
    return x;
}
class CapacitySpecification {
    constructor({ defaultItemLimit = Number.POSITIVE_INFINITY, defaultSizeLimit = Number.POSITIVE_INFINITY } = {}) {
        this.sizeLimit = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_2__["TrackableValue"](defaultSizeLimit, validateLimitValue);
        this.itemLimit = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_2__["TrackableValue"](defaultItemLimit, validateLimitValue);
    }
}
let ChunkQueueManager = class ChunkQueueManager extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__["SharedObject"] {
    constructor(rpc, gl, frameNumberCounter, capacities) {
        super();
        this.gl = gl;
        this.frameNumberCounter = frameNumberCounter;
        this.capacities = capacities;
        this.visibleChunksChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_7__["NullarySignal"]();
        this.pendingChunkUpdates = null;
        this.pendingChunkUpdatesTail = null;
        /**
         * If non-null, deadline in milliseconds since epoch after which chunk copies to the GPU may not
         * start (until the next frame).
         */
        this.chunkUpdateDeadline = null;
        this.chunkUpdateDelay = 30;
        const makeCapacityCounterparts = (capacity) => {
            return {
                itemLimit: this.registerDisposer(neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_1__["SharedWatchableValue"].makeFromExisting(rpc, capacity.itemLimit))
                    .rpcId,
                sizeLimit: this.registerDisposer(neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_1__["SharedWatchableValue"].makeFromExisting(rpc, capacity.sizeLimit))
                    .rpcId,
            };
        };
        this.initializeCounterpart(rpc, {
            'gpuMemoryCapacity': makeCapacityCounterparts(capacities.gpuMemory),
            'systemMemoryCapacity': makeCapacityCounterparts(capacities.systemMemory),
            'downloadCapacity': makeCapacityCounterparts(capacities.download),
            'computeCapacity': makeCapacityCounterparts(capacities.compute)
        });
    }
    scheduleChunkUpdate() {
        let deadline = this.chunkUpdateDeadline;
        let delay;
        if (deadline === null || Date.now() < deadline) {
            delay = 0;
        }
        else {
            delay = this.chunkUpdateDelay;
        }
        setTimeout(this.processPendingChunkUpdates.bind(this), delay);
    }
    processPendingChunkUpdates() {
        let deadline = this.chunkUpdateDeadline;
        if (deadline === null) {
            deadline = Date.now() + 30;
        }
        let visibleChunksChanged = false;
        while (true) {
            if (Date.now() > deadline) {
                // No time to perform chunk update now, we will wait some more.
                this.chunkUpdateDeadline = null;
                setTimeout(() => this.processPendingChunkUpdates(), this.chunkUpdateDelay);
                break;
            }
            let update = this.pendingChunkUpdates;
            if (this.applyChunkUpdate(update)) {
                visibleChunksChanged = true;
            }
            // FIXME: do chunk update
            let nextUpdate = this.pendingChunkUpdates = update.nextUpdate;
            if (nextUpdate == null) {
                this.pendingChunkUpdatesTail = null;
                break;
            }
        }
        if (visibleChunksChanged) {
            this.visibleChunksChanged.dispatch();
        }
    }
    handleFetch_(source, update) {
        const { resolve, reject, cancellationToken } = update['promise'];
        if (cancellationToken.isCanceled) {
            reject(neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_3__["CANCELED"]);
            return;
        }
        const key = update['key'];
        const chunk = source.chunks.get(key);
        if (!chunk) {
            reject(new Error(`No chunk found at ${key} for source ${source.constructor.name}`));
            return;
        }
        const data = chunk['data'];
        if (!data) {
            reject(new Error(`At ${key} for source ${source.constructor.name}: chunk has no data`));
            return;
        }
        resolve({ value: data });
    }
    applyChunkUpdate(update) {
        let visibleChunksChanged = false;
        let { rpc } = this;
        const source = rpc.get(update['source']);
        if (DEBUG_CHUNK_UPDATES) {
            console.log(`${Date.now()} Chunk.update processed: ${source.rpcId} ` +
                `${update['id']} ${update['state']}`);
        }
        if (update['promise'] !== undefined) {
            this.handleFetch_(source, update);
        }
        else if (update['id'] === undefined) {
            // Invalidate source.
            for (const chunkKey of source.chunks.keys()) {
                source.deleteChunk(chunkKey);
            }
            visibleChunksChanged = true;
        }
        else {
            let newState = update['state'];
            if (newState === neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].EXPIRED) {
                // FIXME: maybe use freeList for chunks here
                source.deleteChunk(update['id']);
            }
            else {
                let chunk;
                let key = update['id'];
                if (update['new']) {
                    chunk = source.getChunk(update);
                    source.addChunk(key, chunk);
                }
                else {
                    chunk = source.chunks.get(key);
                }
                let oldState = chunk.state;
                if (newState !== oldState) {
                    switch (newState) {
                        case neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY:
                            // console.log("Copying to GPU", chunk);
                            chunk.copyToGPU(this.gl);
                            visibleChunksChanged = true;
                            break;
                        case neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].SYSTEM_MEMORY:
                            chunk.freeGPUMemory(this.gl);
                            break;
                        default:
                            throw new Error(`INTERNAL ERROR: Invalid chunk state: ${neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"][newState]}`);
                    }
                }
            }
        }
        return visibleChunksChanged;
    }
};
ChunkQueueManager = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__["registerSharedObjectOwner"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["CHUNK_QUEUE_MANAGER_RPC_ID"])
], ChunkQueueManager);

function updateChunk(rpc, x) {
    let source = rpc.get(x['source']);
    if (DEBUG_CHUNK_UPDATES) {
        console.log(`${Date.now()} Chunk.update received: ` +
            `${source.rpcId} ${x['id']} ${x['state']} with chunkDataSize ${x['chunkDataSize']}`);
    }
    let queueManager = source.chunkManager.chunkQueueManager;
    if (source.immediateChunkUpdates) {
        if (queueManager.applyChunkUpdate(x)) {
            queueManager.visibleChunksChanged.dispatch();
        }
        return;
    }
    let pendingTail = queueManager.pendingChunkUpdatesTail;
    if (pendingTail == null) {
        queueManager.pendingChunkUpdates = x;
        queueManager.pendingChunkUpdatesTail = x;
        queueManager.scheduleChunkUpdate();
    }
    else {
        pendingTail.nextUpdate = x;
        queueManager.pendingChunkUpdatesTail = x;
    }
}
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__["registerRPC"])('Chunk.update', function (x) {
    updateChunk(this, x);
});
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__["registerPromiseRPC"])('Chunk.retrieve', function (x, cancellationToken) {
    return new Promise((resolve, reject) => {
        x['promise'] = { resolve, reject, cancellationToken };
        updateChunk(this, x);
    });
});
let ChunkManager = class ChunkManager extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__["SharedObject"] {
    constructor(chunkQueueManager) {
        super();
        this.chunkQueueManager = chunkQueueManager;
        this.memoize = new neuroglancer_util_memoize__WEBPACK_IMPORTED_MODULE_5__["StringMemoize"]();
        this.registerDisposer(chunkQueueManager.addRef());
        this.initializeCounterpart(chunkQueueManager.rpc, { 'chunkQueueManager': chunkQueueManager.rpcId });
    }
    get gl() {
        return this.chunkQueueManager.gl;
    }
    getChunkSource(constructorFunction, options) {
        const keyObject = constructorFunction.encodeOptions(options);
        keyObject['constructorId'] = Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_6__["getObjectId"])(constructorFunction);
        const key = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["stableStringify"])(keyObject);
        return this.memoize.get(key, () => {
            const newSource = new constructorFunction(this, options);
            newSource.initializeCounterpart(this.rpc, {});
            newSource.key = keyObject;
            return newSource;
        });
    }
};
ChunkManager = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__["registerSharedObjectOwner"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["CHUNK_MANAGER_RPC_ID"])
], ChunkManager);

class ChunkSource extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__["SharedObject"] {
    constructor(chunkManager, _options = {}) {
        super();
        this.chunkManager = chunkManager;
        this.chunks = new Map();
        /**
         * If set to true, chunk updates will be applied to this source immediately, rather than queueing
         * them.  Sources that dynamically update chunks and need to ensure a consistent order of
         * processing relative to other messages between the frontend and worker should set this to true.
         */
        this.immediateChunkUpdates = false;
    }
    initializeCounterpart(rpc, options) {
        options['chunkManager'] = this.chunkManager.rpcId;
        super.initializeCounterpart(rpc, options);
    }
    get gl() {
        return this.chunkManager.chunkQueueManager.gl;
    }
    deleteChunk(key) {
        const chunk = this.chunks.get(key);
        if (chunk.state === neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY) {
            chunk.freeGPUMemory(this.gl);
        }
        this.chunks.delete(key);
    }
    addChunk(key, chunk) {
        this.chunks.set(key, chunk);
    }
    /**
     * Default implementation for use with backendOnly chunk sources.
     */
    getChunk(_x) {
        throw new Error('Not implemented.');
    }
    /**
     * Invalidates the chunk cache.  Operates asynchronously.
     */
    invalidateCache() {
        this.rpc.invoke(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["CHUNK_SOURCE_INVALIDATE_RPC_ID"], { 'id': this.rpcId });
    }
    static encodeOptions(_options) {
        return {};
    }
}
function WithParameters(Base, parametersConstructor) {
    let C = class C extends Base {
        constructor(...args) {
            super(...args);
            const options = args[1];
            this.parameters = options.parameters;
        }
        initializeCounterpart(rpc, options) {
            options['parameters'] = this.parameters;
            super.initializeCounterpart(rpc, options);
        }
        static encodeOptions(options) {
            return Object.assign({ parameters: options.parameters }, super.encodeOptions(options));
        }
    };
    C = __decorate([
        Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_8__["registerSharedObjectOwner"])(parametersConstructor.RPC_ID)
    ], C);
    return C;
}


/***/ }),

/***/ "./src/neuroglancer/coordinate_transform.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/coordinate_transform.ts ***!
  \**************************************************/
/*! exports provided: CoordinateTransform, makeDerivedCoordinateTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoordinateTransform", function() { return CoordinateTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDerivedCoordinateTransform", function() { return makeDerivedCoordinateTransform; });
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Class for representing a coordinate transform specified by a user.
 *
 * Typically it represents a transform from a local coordinate space to a global coordinate space.
 */
class CoordinateTransform {
    constructor(transform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].create()) {
        this.transform = transform;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
    }
    get value() {
        return this.transform;
    }
    /**
     * Resets to the identity transform.
     */
    reset() {
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(this.transform, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["identityMat4"]);
        this.changed.dispatch();
    }
    toJSON() {
        if (neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].equals(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["identityMat4"], this.transform)) {
            return undefined;
        }
        const m = this.transform;
        return [
            [m[0], m[4], m[8], m[12]],
            [m[1], m[5], m[9], m[13]],
            [m[2], m[6], m[10], m[14]],
            [m[3], m[7], m[11], m[15]],
        ];
    }
    restoreState(obj) {
        if (obj == null) {
            this.reset();
            return;
        }
        if (Array.isArray(obj)) {
            if (obj.length === 4) {
                try {
                    for (let i = 0; i < 4; ++i) {
                        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["parseFiniteVec"])(this.transform.subarray(i * 4, (i + 1) * 4), obj[i]);
                    }
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(this.transform, this.transform);
                }
                catch (ignoredError) {
                    this.reset();
                }
                return;
            }
            if (obj.length === 16) {
                try {
                    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["parseFiniteVec"])(this.transform, obj);
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(this.transform, this.transform);
                }
                catch (ignoredError) {
                    this.reset();
                }
                return;
            }
            // Invalid size.
            this.reset();
            return;
        }
        if (typeof obj === 'object') {
            const rotation = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
            const translation = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
            const scale = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(1, 1, 1);
            try {
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["parseFiniteVec"])(rotation, obj['rotation']);
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["quat"].normalize(rotation, rotation);
            }
            catch (ignoredError) {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["quat"].identity(rotation);
            }
            try {
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["parseFiniteVec"])(translation, obj['translation']);
            }
            catch (ignoredError) {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(translation, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["kZeroVec"]);
            }
            try {
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["parseFiniteVec"])(scale, obj['scale']);
            }
            catch (ignoredError) {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].copy(scale, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["kOneVec"]);
            }
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromRotationTranslationScale(this.transform, rotation, translation, scale);
            this.changed.dispatch();
        }
        else {
            this.reset();
        }
    }
    clone() {
        return new CoordinateTransform(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].clone(this.transform));
    }
}
function makeDerivedCoordinateTransform(derivedTransform, baseTransform, update) {
    update(derivedTransform.transform, baseTransform.transform);
    return baseTransform.changed.add(() => {
        update(derivedTransform.transform, baseTransform.transform);
        derivedTransform.changed.dispatch();
    });
}


/***/ }),

/***/ "./src/neuroglancer/credentials_provider/chunk_source_frontend.ts":
/*!************************************************************************!*\
  !*** ./src/neuroglancer/credentials_provider/chunk_source_frontend.ts ***!
  \************************************************************************/
/*! exports provided: getCredentialsProviderCounterpart, WithCredentialsProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCredentialsProviderCounterpart", function() { return getCredentialsProviderCounterpart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WithCredentialsProvider", function() { return WithCredentialsProvider; });
/* harmony import */ var neuroglancer_credentials_provider_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider/shared */ "./src/neuroglancer/credentials_provider/shared.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns a counterpart ref to be sent to the backend to retrieve a
 * SharedCredentialsProviderCounterpart that forwards to `credentialsProvider`.
 */
function getCredentialsProviderCounterpart(chunkManager, credentialsProvider) {
    const sharedCredentialsProvider = chunkManager.memoize.get({ type: 'getSharedCredentialsProvider', credentialsProvider: Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_1__["getObjectId"])(credentialsProvider) }, () => new neuroglancer_credentials_provider_shared__WEBPACK_IMPORTED_MODULE_0__["SharedCredentialsProvider"](credentialsProvider.addRef(), chunkManager.rpc));
    const counterpartRef = sharedCredentialsProvider.addCounterpartRef();
    sharedCredentialsProvider.dispose();
    return counterpartRef;
}
/**
 * Mixin for adding a credentialsProvider member to a ChunkSource.
 */
function WithCredentialsProvider() {
    return function (Base) {
        return class extends Base {
            constructor(...args) {
                super(...args);
                const options = args[1];
                this.credentialsProvider = options.credentialsProvider.addRef();
            }
            initializeCounterpart(rpc, options) {
                options['credentialsProvider'] =
                    getCredentialsProviderCounterpart(this.chunkManager, this.credentialsProvider);
                super.initializeCounterpart(rpc, options);
            }
            static encodeOptions(options) {
                const encoding = super.encodeOptions(options);
                encoding.credentialsProvider = Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_1__["getObjectId"])(options.credentialsProvider);
                return encoding;
            }
        };
    };
}


/***/ }),

/***/ "./src/neuroglancer/credentials_provider/default_manager.ts":
/*!******************************************************************!*\
  !*** ./src/neuroglancer/credentials_provider/default_manager.ts ***!
  \******************************************************************/
/*! exports provided: defaultCredentialsManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultCredentialsManager", function() { return defaultCredentialsManager; });
/* harmony import */ var neuroglancer_credentials_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider */ "./src/neuroglancer/credentials_provider/index.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file CredentialsManager for globally registering a CredentialsProvider
 */

const defaultCredentialsManager = new neuroglancer_credentials_provider__WEBPACK_IMPORTED_MODULE_0__["CachingMapBasedCredentialsManager"]();


/***/ }),

/***/ "./src/neuroglancer/credentials_provider/http_request.ts":
/*!***************************************************************!*\
  !*** ./src/neuroglancer/credentials_provider/http_request.ts ***!
  \***************************************************************/
/*! exports provided: fetchWithCredentials */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchWithCredentials", function() { return fetchWithCredentials; });
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/http_request */ "./src/neuroglancer/util/http_request.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


async function fetchWithCredentials(credentialsProvider, input, init, transformResponse, applyCredentials, errorHandler, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"]) {
    let credentials;
    credentialsLoop: while (true) {
        credentials = await credentialsProvider.get(credentials, cancellationToken);
        requestLoop: while (true) {
            try {
                return await Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_1__["cancellableFetchOk"])(input, applyCredentials(credentials.credentials, init), transformResponse, cancellationToken);
            }
            catch (error) {
                if (error instanceof neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_1__["HttpError"]) {
                    if (errorHandler(error) === 'refresh')
                        continue credentialsLoop;
                    continue requestLoop;
                }
                throw error;
            }
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/credentials_provider/index.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/credentials_provider/index.ts ***!
  \********************************************************/
/*! exports provided: CredentialsProvider, makeCachedCredentialsGetter, makeCredentialsGetter, MapBasedCredentialsManager, CachingCredentialsManager, CachingMapBasedCredentialsManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CredentialsProvider", function() { return CredentialsProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCachedCredentialsGetter", function() { return makeCachedCredentialsGetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCredentialsGetter", function() { return makeCredentialsGetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapBasedCredentialsManager", function() { return MapBasedCredentialsManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachingCredentialsManager", function() { return CachingCredentialsManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachingMapBasedCredentialsManager", function() { return CachingMapBasedCredentialsManager; });
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_memoize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/memoize */ "./src/neuroglancer/util/memoize.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Generic facility for providing authentication/authorization credentials.
 */



class CredentialsProvider extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
}
function makeCachedCredentialsGetter(getUncached) {
    let cachedCredentials;
    let pendingCredentials;
    let pendingCancellationToken;
    return (invalidCredentials, cancellationToken) => {
        if (pendingCredentials !== undefined &&
            (cachedCredentials === undefined || invalidCredentials === undefined ||
                cachedCredentials.generation !== invalidCredentials.generation)) {
            if (cachedCredentials === undefined) {
                pendingCancellationToken.addConsumer(cancellationToken);
            }
            return pendingCredentials;
        }
        cachedCredentials = undefined;
        pendingCancellationToken = new neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["MultipleConsumerCancellationTokenSource"]();
        pendingCredentials = getUncached(invalidCredentials, pendingCancellationToken)
            .then(credentials => {
            cachedCredentials = credentials;
            pendingCancellationToken = undefined;
            return credentials;
        }, reason => {
            if (pendingCancellationToken.isCanceled) {
                pendingCancellationToken = undefined;
                pendingCredentials = undefined;
            }
            throw reason;
        });
        return pendingCredentials;
    };
}
function makeCredentialsGetter(getWithoutGeneration) {
    let generation = 0;
    return makeCachedCredentialsGetter((_invalidCredentials, cancellationToken) => getWithoutGeneration(cancellationToken)
        .then(credentials => ({ generation: ++generation, credentials })));
}
/**
 * CredentialsManager that supports registration.
 */
class MapBasedCredentialsManager {
    constructor() {
        this.providers = new Map();
    }
    register(key, providerGetter) {
        this.providers.set(key, providerGetter);
    }
    getCredentialsProvider(key, parameters) {
        const getter = this.providers.get(key);
        if (getter === undefined) {
            throw new Error(`No registered credentials provider: ${JSON.stringify(key)}`);
        }
        return getter(parameters);
    }
}
/**
 * CredentialsManager that wraps another and caches the CredentialsProvider objects.
 */
class CachingCredentialsManager extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(base) {
        super();
        this.base = base;
        this.memoize = new neuroglancer_util_memoize__WEBPACK_IMPORTED_MODULE_2__["StringMemoize"]();
    }
    getCredentialsProvider(key, parameters) {
        return this.memoize.get({ key, parameters }, () => this.registerDisposer(this.base.getCredentialsProvider(key, parameters).addRef()));
    }
}
class CachingMapBasedCredentialsManager extends CachingCredentialsManager {
    constructor() {
        super(new MapBasedCredentialsManager());
    }
    register(key, providerGetter) {
        this.base.register(key, providerGetter);
    }
}


/***/ }),

/***/ "./src/neuroglancer/credentials_provider/shared.ts":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/credentials_provider/shared.ts ***!
  \*********************************************************/
/*! exports provided: SharedCredentialsProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedCredentialsProvider", function() { return SharedCredentialsProvider; });
/* harmony import */ var neuroglancer_credentials_provider_shared_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider/shared_common */ "./src/neuroglancer/credentials_provider/shared_common.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @file Permits a CredentialsProvider to be shared with another thread.
 */


let SharedCredentialsProvider = class SharedCredentialsProvider extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_1__["SharedObject"] {
    constructor(provider, rpc) {
        super();
        this.provider = provider;
        this.registerDisposer(provider);
        this.initializeCounterpart(rpc);
    }
    get(invalidCredentials, cancellationToken) {
        return this.provider.get(invalidCredentials, cancellationToken);
    }
};
SharedCredentialsProvider = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_1__["registerSharedObjectOwner"])(neuroglancer_credentials_provider_shared_common__WEBPACK_IMPORTED_MODULE_0__["CREDENTIALS_PROVIDER_RPC_ID"])
], SharedCredentialsProvider);

Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_1__["registerPromiseRPC"])(neuroglancer_credentials_provider_shared_common__WEBPACK_IMPORTED_MODULE_0__["CREDENTIALS_PROVIDER_GET_RPC_ID"], function (x, cancellationToken) {
    const obj = this.get(x.providerId);
    return obj.get(x.invalidCredentials, cancellationToken).then(credentials => ({
        value: credentials
    }));
});


/***/ }),

/***/ "./src/neuroglancer/credentials_provider/shared_common.ts":
/*!****************************************************************!*\
  !*** ./src/neuroglancer/credentials_provider/shared_common.ts ***!
  \****************************************************************/
/*! exports provided: CREDENTIALS_PROVIDER_RPC_ID, CREDENTIALS_PROVIDER_GET_RPC_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREDENTIALS_PROVIDER_RPC_ID", function() { return CREDENTIALS_PROVIDER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREDENTIALS_PROVIDER_GET_RPC_ID", function() { return CREDENTIALS_PROVIDER_GET_RPC_ID; });
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CREDENTIALS_PROVIDER_RPC_ID = 'CredentialsProvider';
const CREDENTIALS_PROVIDER_GET_RPC_ID = 'CredentialsProvider.get';


/***/ }),

/***/ "./src/neuroglancer/data_panel_layout.css":
/*!************************************************!*\
  !*** ./src/neuroglancer/data_panel_layout.css ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/data_panel_layout.ts":
/*!***********************************************!*\
  !*** ./src/neuroglancer/data_panel_layout.ts ***!
  \***********************************************/
/*! exports provided: InputEventBindings, makeSliceView, makeNamedSliceView, makeOrthogonalSliceViews, getCommonViewerState, FourPanelLayout, SliceViewPerspectiveTwoPanelLayout, SinglePanelLayout, SinglePerspectiveLayout, LAYOUTS, getLayoutByName, validateLayoutName, CrossSectionSpecification, CrossSectionSpecificationMap, DataPanelLayoutSpecification, DataPanelLayoutContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputEventBindings", function() { return InputEventBindings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeSliceView", function() { return makeSliceView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeNamedSliceView", function() { return makeNamedSliceView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeOrthogonalSliceViews", function() { return makeOrthogonalSliceViews; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCommonViewerState", function() { return getCommonViewerState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FourPanelLayout", function() { return FourPanelLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewPerspectiveTwoPanelLayout", function() { return SliceViewPerspectiveTwoPanelLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SinglePanelLayout", function() { return SinglePanelLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SinglePerspectiveLayout", function() { return SinglePerspectiveLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAYOUTS", function() { return LAYOUTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayoutByName", function() { return getLayoutByName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateLayoutName", function() { return validateLayoutName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CrossSectionSpecification", function() { return CrossSectionSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CrossSectionSpecificationMap", function() { return CrossSectionSpecificationMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataPanelLayoutSpecification", function() { return DataPanelLayoutSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataPanelLayoutContainer", function() { return DataPanelLayoutContainer; });
/* harmony import */ var neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/ui/button.css */ "./src/neuroglancer/ui/button.css");
/* harmony import */ var neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_data_panel_layout_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/data_panel_layout.css */ "./src/neuroglancer/data_panel_layout.css");
/* harmony import */ var neuroglancer_data_panel_layout_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_data_panel_layout_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/layout */ "./src/neuroglancer/layout.ts");
/* harmony import */ var neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/navigation_state */ "./src/neuroglancer/navigation_state.ts");
/* harmony import */ var neuroglancer_perspective_view_panel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/perspective_view/panel */ "./src/neuroglancer/perspective_view/panel.ts");
/* harmony import */ var neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/sliceview/frontend */ "./src/neuroglancer/sliceview/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_panel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/sliceview/panel */ "./src/neuroglancer/sliceview/panel.ts");
/* harmony import */ var neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/trackable_boolean */ "./src/neuroglancer/trackable_boolean.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_watchable_map__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/util/watchable_map */ "./src/neuroglancer/util/watchable_map.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

















class InputEventBindings {
    constructor() {
        this.perspectiveView = new neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_12__["EventActionMap"]();
        this.sliceView = new neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_12__["EventActionMap"]();
    }
}
const AXES_RELATIVE_ORIENTATION = new Map([
    ['xy', undefined],
    ['xz', neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_13__["quat"].rotateX(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_13__["quat"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_13__["quat"].create(), Math.PI / 2)],
    ['yz', neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_13__["quat"].rotateY(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_13__["quat"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_13__["quat"].create(), Math.PI / 2)],
]);
const oneSquareSymbol = '';
const LAYOUT_SYMBOLS = new Map([
    ['4panel', ''],
    ['3d', oneSquareSymbol],
]);
function makeSliceView(viewerState, baseToSelf) {
    let navigationState;
    if (baseToSelf === undefined) {
        navigationState = viewerState.navigationState;
    }
    else {
        navigationState = new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["NavigationState"](new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["Pose"](viewerState.navigationState.pose.position, neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["OrientationState"].makeRelative(viewerState.navigationState.pose.orientation, baseToSelf)), viewerState.navigationState.zoomFactor);
    }
    return new neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_6__["SliceView"](viewerState.chunkManager, viewerState.layerManager, navigationState);
}
function makeNamedSliceView(viewerState, axes) {
    return makeSliceView(viewerState, AXES_RELATIVE_ORIENTATION.get(axes));
}
function makeOrthogonalSliceViews(viewerState) {
    return new Map([
        ['xy', makeNamedSliceView(viewerState, 'xy')],
        ['xz', makeNamedSliceView(viewerState, 'xz')],
        ['yz', makeNamedSliceView(viewerState, 'yz')],
    ]);
}
function getCommonViewerState(viewer) {
    return {
        crossSectionBackgroundColor: viewer.crossSectionBackgroundColor,
        perspectiveViewBackgroundColor: viewer.perspectiveViewBackgroundColor,
        mouseState: viewer.mouseState,
        layerManager: viewer.layerManager,
        showAxisLines: viewer.showAxisLines,
        visibleLayerRoles: viewer.visibleLayerRoles,
        selectedLayer: viewer.selectedLayer,
        visibility: viewer.visibility,
        scaleBarOptions: viewer.scaleBarOptions,
    };
}
function getCommonPerspectiveViewerState(container) {
    const { viewer } = container;
    return Object.assign({}, getCommonViewerState(viewer), { navigationState: viewer.perspectiveNavigationState, inputEventMap: viewer.inputEventBindings.perspectiveView, orthographicProjection: container.specification.orthographicProjection, showScaleBar: viewer.showScaleBar, rpc: viewer.chunkManager.rpc });
}
function getCommonSliceViewerState(viewer) {
    return Object.assign({}, getCommonViewerState(viewer), { navigationState: viewer.navigationState, inputEventMap: viewer.inputEventBindings.sliceView });
}
function registerRelatedLayouts(layout, panel, relatedLayouts) {
    const controls = document.createElement('div');
    controls.className = 'neuroglancer-data-panel-layout-controls';
    layout.registerDisposer(() => Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeFromParent"])(controls));
    for (let i = 0; i < 2; ++i) {
        const relatedLayout = relatedLayouts[Math.min(relatedLayouts.length - 1, i)];
        layout.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_12__["registerActionListener"])(panel.element, i === 0 ? 'toggle-layout' : 'toggle-layout-alternative', (event) => {
            layout.container.name = relatedLayout;
            event.stopPropagation();
        }));
    }
    for (const relatedLayout of relatedLayouts) {
        const button = document.createElement('button');
        const innerDiv = document.createElement('div');
        button.appendChild(innerDiv);
        innerDiv.textContent = LAYOUT_SYMBOLS.get(relatedLayout);
        button.title = `Switch to ${relatedLayout} layout.`;
        button.addEventListener('click', () => {
            layout.container.name = relatedLayout;
        });
        controls.appendChild(button);
    }
    panel.element.appendChild(controls);
}
function makeSliceViewFromSpecification(viewer, specification) {
    const sliceView = new neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_6__["SliceView"](viewer.chunkManager, viewer.layerManager, specification.navigationState.addRef());
    const updateViewportSize = () => {
        sliceView.setViewportSizeDebounced(specification.width.value, specification.height.value);
    };
    sliceView.registerDisposer(specification.width.changed.add(updateViewportSize));
    sliceView.registerDisposer(specification.height.changed.add(updateViewportSize));
    updateViewportSize();
    return sliceView;
}
function addUnconditionalSliceViews(viewer, panel, crossSections) {
    const previouslyAdded = new Map();
    const update = () => {
        const currentCrossSections = new Set();
        // Add missing cross sections.
        for (const crossSection of crossSections.values()) {
            currentCrossSections.add(crossSection);
            if (previouslyAdded.has(crossSection)) {
                continue;
            }
            const sliceView = makeSliceViewFromSpecification(viewer, crossSection);
            panel.sliceViews.set(sliceView, true);
            previouslyAdded.set(crossSection, sliceView);
        }
        // Remove extra cross sections.
        for (const [crossSection, sliceView] of previouslyAdded) {
            if (currentCrossSections.has(crossSection)) {
                continue;
            }
            panel.sliceViews.delete(sliceView);
        }
    };
    update();
}
class FourPanelLayout extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(container, rootElement, viewer, crossSections) {
        super();
        this.container = container;
        this.rootElement = rootElement;
        this.viewer = viewer;
        let sliceViews = makeOrthogonalSliceViews(viewer);
        let { display } = viewer;
        const perspectiveViewerState = Object.assign({}, getCommonPerspectiveViewerState(container), { showSliceViews: viewer.showPerspectiveSliceViews, showSliceViewsCheckbox: true });
        const sliceViewerState = Object.assign({}, getCommonSliceViewerState(viewer), { showScaleBar: viewer.showScaleBar });
        const sliceViewerStateWithoutScaleBar = Object.assign({}, getCommonSliceViewerState(viewer), { showScaleBar: new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_8__["TrackableBoolean"](false, false) });
        const makeSliceViewPanel = (axes, element, state) => {
            const panel = this.registerDisposer(new neuroglancer_sliceview_panel__WEBPACK_IMPORTED_MODULE_7__["SliceViewPanel"](display, element, sliceViews.get(axes), state));
            registerRelatedLayouts(this, panel, [axes, `${axes}-3d`]);
            return panel;
        };
        let mainDisplayContents = [
            neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["box"]('column', [
                neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["box"]('row', [
                    neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, element => {
                        makeSliceViewPanel('xy', element, sliceViewerState);
                    }),
                    neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, element => {
                        makeSliceViewPanel('xz', element, sliceViewerStateWithoutScaleBar);
                    })
                ])),
                neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["box"]('row', [
                    neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, element => {
                        let panel = this.registerDisposer(new neuroglancer_perspective_view_panel__WEBPACK_IMPORTED_MODULE_5__["PerspectivePanel"](display, element, perspectiveViewerState));
                        for (let sliceView of sliceViews.values()) {
                            panel.sliceViews.set(sliceView.addRef(), false);
                        }
                        addUnconditionalSliceViews(viewer, panel, crossSections);
                        registerRelatedLayouts(this, panel, ['3d']);
                    }),
                    neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, element => {
                        makeSliceViewPanel('yz', element, sliceViewerStateWithoutScaleBar);
                    })
                ])),
            ]))
        ];
        neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["box"]('row', mainDisplayContents)(rootElement);
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeChildren"])(this.rootElement);
        super.disposed();
    }
}
class SliceViewPerspectiveTwoPanelLayout extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(container, rootElement, viewer, direction, axes, crossSections) {
        super();
        this.container = container;
        this.rootElement = rootElement;
        this.viewer = viewer;
        this.direction = direction;
        let sliceView = makeNamedSliceView(viewer, axes);
        let { display } = viewer;
        const perspectiveViewerState = Object.assign({}, getCommonPerspectiveViewerState(container), { showSliceViews: viewer.showPerspectiveSliceViews, showSliceViewsCheckbox: true });
        const sliceViewerState = Object.assign({}, getCommonSliceViewerState(viewer), { showScaleBar: viewer.showScaleBar });
        neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["box"](direction, [
            neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, element => {
                const panel = this.registerDisposer(new neuroglancer_sliceview_panel__WEBPACK_IMPORTED_MODULE_7__["SliceViewPanel"](display, element, sliceView, sliceViewerState));
                registerRelatedLayouts(this, panel, [axes, '4panel']);
            }),
            neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, element => {
                let panel = this.registerDisposer(new neuroglancer_perspective_view_panel__WEBPACK_IMPORTED_MODULE_5__["PerspectivePanel"](display, element, perspectiveViewerState));
                panel.sliceViews.set(sliceView.addRef(), false);
                addUnconditionalSliceViews(viewer, panel, crossSections);
                registerRelatedLayouts(this, panel, ['3d', '4panel']);
            }),
        ]))(rootElement);
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeChildren"])(this.rootElement);
        super.disposed();
    }
}
class SinglePanelLayout extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(container, rootElement, viewer, axes) {
        super();
        this.container = container;
        this.rootElement = rootElement;
        this.viewer = viewer;
        let sliceView = makeNamedSliceView(viewer, axes);
        const sliceViewerState = Object.assign({}, getCommonSliceViewerState(viewer), { showScaleBar: viewer.showScaleBar });
        neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["box"]('row', [neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, element => {
                const panel = this.registerDisposer(new neuroglancer_sliceview_panel__WEBPACK_IMPORTED_MODULE_7__["SliceViewPanel"](viewer.display, element, sliceView, sliceViewerState));
                registerRelatedLayouts(this, panel, ['4panel', `${axes}-3d`]);
            })])(rootElement);
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeChildren"])(this.rootElement);
        super.disposed();
    }
}
class SinglePerspectiveLayout extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(container, rootElement, viewer, crossSections) {
        super();
        this.container = container;
        this.rootElement = rootElement;
        this.viewer = viewer;
        let perspectiveViewerState = Object.assign({}, getCommonPerspectiveViewerState(container), { showSliceViews: new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_8__["TrackableBoolean"](false, false) });
        neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["box"]('row', [neuroglancer_layout__WEBPACK_IMPORTED_MODULE_3__["withFlex"](1, element => {
                const panel = this.registerDisposer(new neuroglancer_perspective_view_panel__WEBPACK_IMPORTED_MODULE_5__["PerspectivePanel"](viewer.display, element, perspectiveViewerState));
                addUnconditionalSliceViews(viewer, panel, crossSections);
                registerRelatedLayouts(this, panel, ['4panel']);
            })])(rootElement);
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeChildren"])(this.rootElement);
        super.disposed();
    }
}
const LAYOUTS = new Map([
    [
        '4panel', {
            factory: (container, element, viewer, crossSections) => new FourPanelLayout(container, element, viewer, crossSections)
        }
    ],
    [
        '3d', {
            factory: (container, element, viewer, crossSections) => new SinglePerspectiveLayout(container, element, viewer, crossSections)
        }
    ],
]);
for (const axes of AXES_RELATIVE_ORIENTATION.keys()) {
    LAYOUTS.set(axes, {
        factory: (container, element, viewer) => new SinglePanelLayout(container, element, viewer, axes)
    });
    const splitLayout = `${axes}-3d`;
    LAYOUT_SYMBOLS.set(axes, oneSquareSymbol);
    LAYOUT_SYMBOLS.set(splitLayout, '');
    LAYOUTS.set(splitLayout, {
        factory: (container, element, viewer, crossSections) => new SliceViewPerspectiveTwoPanelLayout(container, element, viewer, 'row', axes, crossSections)
    });
}
function getLayoutByName(obj) {
    let layout = LAYOUTS.get(obj);
    if (layout === undefined) {
        throw new Error(`Invalid layout name: ${JSON.stringify(obj)}.`);
    }
    return layout;
}
function validateLayoutName(obj) {
    getLayoutByName(obj);
    return obj;
}
class CrossSectionSpecification extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(parent) {
        super();
        this.width = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_9__["TrackableValue"](1000, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyPositiveInt"]);
        this.height = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_9__["TrackableValue"](1000, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyPositiveInt"]);
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_15__["NullarySignal"]();
        this.position = new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["LinkedSpatialPosition"](parent.position.addRef());
        this.position.changed.add(this.changed.dispatch);
        this.orientation = new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["LinkedOrientationState"](parent.pose.orientation.addRef());
        this.orientation.changed.add(this.changed.dispatch);
        this.width.changed.add(this.changed.dispatch);
        this.height.changed.add(this.changed.dispatch);
        this.zoom = new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["LinkedZoomState"](parent.zoomFactor.addRef());
        this.zoom.changed.add(this.changed.dispatch);
        this.navigationState = this.registerDisposer(new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["NavigationState"](new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["Pose"](this.position.value, this.orientation.value), this.zoom.value));
    }
    restoreState(obj) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObject"])(obj);
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObjectProperty"])(obj, 'width', x => x !== undefined && this.width.restoreState(x));
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObjectProperty"])(obj, 'height', x => x !== undefined && this.height.restoreState(x));
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObjectProperty"])(obj, 'position', x => x !== undefined && this.position.restoreState(x));
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObjectProperty"])(obj, 'orientation', x => x !== undefined && this.orientation.restoreState(x));
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObjectProperty"])(obj, 'zoom', x => x !== undefined && this.zoom.restoreState(x));
    }
    reset() {
        this.width.reset();
        this.height.reset();
        this.position.reset();
        this.orientation.reset();
        this.zoom.reset();
    }
    toJSON() {
        return {
            width: this.width.toJSON(),
            height: this.height.toJSON(),
            position: this.position.toJSON(),
            orientation: this.orientation.toJSON(),
            zoom: this.zoom.toJSON(),
        };
    }
}
class CrossSectionSpecificationMap extends neuroglancer_util_watchable_map__WEBPACK_IMPORTED_MODULE_16__["WatchableMap"] {
    constructor(parentNavigationState) {
        super(v => this.registerDisposer(this.registerDisposer(v).changed.add(this.changed.dispatch)), v => {
            v.changed.remove(this.changed.dispatch);
            v.dispose();
        });
        this.parentNavigationState = parentNavigationState;
        this.registerDisposer(parentNavigationState);
    }
    restoreState(obj) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObject"])(obj);
        for (const key of Object.keys(obj)) {
            const state = new CrossSectionSpecification(this.parentNavigationState);
            try {
                this.set(key, state.addRef());
                state.restoreState(obj[key]);
            }
            finally {
                state.dispose();
            }
        }
    }
    reset() {
        this.clear();
    }
    toJSON() {
        if (this.size === 0)
            return undefined;
        const obj = {};
        for (const [k, v] of this) {
            obj[k] = v.toJSON();
        }
        return obj;
    }
}
class DataPanelLayoutSpecification extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(parentNavigationState, defaultLayout) {
        super();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_15__["NullarySignal"]();
        this.orthographicProjection = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_8__["TrackableBoolean"](false);
        this.type = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_9__["TrackableValue"](defaultLayout, validateLayoutName);
        this.type.changed.add(this.changed.dispatch);
        this.crossSections =
            this.registerDisposer(new CrossSectionSpecificationMap(parentNavigationState));
        this.crossSections.changed.add(this.changed.dispatch);
        this.orthographicProjection.changed.add(this.changed.dispatch);
        this.registerDisposer(parentNavigationState);
    }
    reset() {
        this.crossSections.clear();
        this.orthographicProjection.reset();
        this.type.reset();
    }
    restoreState(obj) {
        this.crossSections.clear();
        this.orthographicProjection.reset();
        if (typeof obj === 'string') {
            this.type.restoreState(obj);
        }
        else {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObject"])(obj);
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObjectProperty"])(obj, 'type', x => this.type.restoreState(x));
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObjectProperty"])(obj, 'orthographicProjection', x => this.orthographicProjection.restoreState(x));
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_14__["verifyObjectProperty"])(obj, 'crossSections', x => x !== undefined && this.crossSections.restoreState(x));
        }
    }
    toJSON() {
        const { type, crossSections, orthographicProjection } = this;
        const orthographicProjectionJson = orthographicProjection.toJSON();
        if (crossSections.size === 0 && orthographicProjectionJson === undefined) {
            return type.value;
        }
        return {
            type: type.value,
            crossSections: crossSections.toJSON(),
            orthographicProjection: orthographicProjectionJson,
        };
    }
}
class DataPanelLayoutContainer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(viewer, defaultLayout) {
        super();
        this.viewer = viewer;
        this.element = document.createElement('div');
        this.specification = this.registerDisposer(new DataPanelLayoutSpecification(this.viewer.navigationState.addRef(), defaultLayout));
        this.element.style.flex = '1';
        const scheduleUpdateLayout = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default()(() => this.updateLayout(), 0));
        this.specification.type.changed.add(scheduleUpdateLayout);
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_12__["registerActionListener"])(this.element, 'toggle-orthographic-projection', () => this.specification.orthographicProjection.toggle());
        // Ensure the layout is updated before drawing begins to avoid flicker.
        this.registerDisposer(this.viewer.display.updateStarted.add(() => scheduleUpdateLayout.flush()));
        scheduleUpdateLayout();
    }
    get name() {
        return this.specification.type.value;
    }
    set name(value) {
        this.specification.type.value = value;
    }
    get changed() {
        return this.specification.changed;
    }
    toJSON() {
        return this.specification.toJSON();
    }
    restoreState(obj) {
        this.specification.restoreState(obj);
    }
    reset() {
        this.specification.reset();
    }
    disposeLayout() {
        let { layout } = this;
        if (layout !== undefined) {
            layout.dispose();
            this.layout = undefined;
        }
    }
    updateLayout() {
        this.disposeLayout();
        this.layout = getLayoutByName(this.name).factory(this, this.element, this.viewer, this.specification.crossSections);
    }
    disposed() {
        this.disposeLayout();
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/boss/api.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/datasource/boss/api.ts ***!
  \*************************************************/
/*! exports provided: credentialsKey, fetchWithBossCredentials */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "credentialsKey", function() { return credentialsKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchWithBossCredentials", function() { return fetchWithBossCredentials; });
/* harmony import */ var neuroglancer_credentials_provider_http_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider/http_request */ "./src/neuroglancer/credentials_provider/http_request.ts");
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Key used for retrieving the CredentialsProvider from a CredentialsManager.
 */
const credentialsKey = 'boss';
function fetchWithBossCredentials(credentialsProvider, input, init, transformResponse, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_1__["uncancelableToken"]) {
    return Object(neuroglancer_credentials_provider_http_request__WEBPACK_IMPORTED_MODULE_0__["fetchWithCredentials"])(credentialsProvider, input, init, transformResponse, credentials => {
        const headers = new Headers(init.headers);
        headers.set('Authorization', `Bearer ${credentials}`);
        return Object.assign({}, init, { headers });
    }, error => {
        const { status } = error;
        if (status === 403 || status === 401) {
            // Authorization needed.  Retry with refreshed token.
            return 'refresh';
        }
        if (status === 504) {
            // Gateway timeout can occur if the server takes too long to reply.  Retry.
            return 'retry';
        }
        throw error;
    }, cancellationToken);
}


/***/ }),

/***/ "./src/neuroglancer/datasource/boss/base.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/datasource/boss/base.ts ***!
  \**************************************************/
/*! exports provided: BossSourceParameters, VolumeChunkSourceParameters, MeshSourceParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BossSourceParameters", function() { return BossSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkSourceParameters", function() { return VolumeChunkSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshSourceParameters", function() { return MeshSourceParameters; });
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BossSourceParameters {
}
class VolumeChunkSourceParameters extends BossSourceParameters {
    static stringify(parameters) {
        return `boss:volume:${parameters.baseUrl}/${parameters.collection}/${parameters.experiment}/${parameters.channel}/${parameters.resolution}/${parameters.encoding}`;
    }
}
VolumeChunkSourceParameters.RPC_ID = 'boss/VolumeChunkSource';
class MeshSourceParameters {
    static stringify(parameters) {
        return `boss:mesh:${parameters.baseUrl}`;
    }
}
MeshSourceParameters.RPC_ID = 'boss/MeshChunkSource';


/***/ }),

/***/ "./src/neuroglancer/datasource/boss/credentials_provider.ts":
/*!******************************************************************!*\
  !*** ./src/neuroglancer/datasource/boss/credentials_provider.ts ***!
  \******************************************************************/
/*! exports provided: authenticateKeycloakOIDC, BossCredentialsProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "authenticateKeycloakOIDC", function() { return authenticateKeycloakOIDC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BossCredentialsProvider", function() { return BossCredentialsProvider; });
/* harmony import */ var neuroglancer_credentials_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider */ "./src/neuroglancer/credentials_provider/index.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/random */ "./src/neuroglancer/util/random.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * This implements a CredentialsProvider based on Keycloak.
 * The current implementation uses the implicit flow for ease of implementation.
 * TODO: Implement the authorization or hybrid flows.
 * TODO: Use an iframe to test for immediate login (active session).
 */






class PendingRequest {
    constructor() {
        this.finished = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_5__["Signal"]();
    }
}
class AuthHandler {
    constructor() {
        this.oidcCallbackService = `bossAuthCallback`;
        this.pendingRequests = new Map();
        this.registerListener();
    }
    registerListener() {
        addEventListener('message', (event) => {
            if (event.origin !== location.origin) {
                // Ignore messages from different origins.
                return;
            }
            try {
                let data = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyObject"])(JSON.parse(event.data));
                let service = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyString"])(data['service']);
                if (service === this.oidcCallbackService) {
                    let accessToken = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyString"])(data['access_token']);
                    let state = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyString"])(data['state']);
                    let request = this.pendingRequests.get(state);
                    if (request === undefined) {
                        // Request may have been cancelled.
                        return;
                    }
                    request.finished.dispatch(accessToken);
                }
            }
            catch (parseError) {
                // Ignore invalid message.
            }
        });
    }
    addPendingRequest(state) {
        let request = new PendingRequest();
        this.pendingRequests.set(state, request);
        request.finished.add(() => {
            this.pendingRequests.delete(state);
        });
        return request;
    }
    makeAuthRequestUrl(options) {
        let url = `${options.authServer}/realms/BOSS/protocol/openid-connect/auth?`;
        url += `client_id=${encodeURIComponent(options.clientId)}`;
        url += `&redirect_uri=${encodeURIComponent(options.redirect_uri)}`;
        url += `&response_mode=fragment`;
        url += `&response_type=code%20id_token%20token`;
        if (options.state) {
            url += `&state=${options.state}`;
        }
        if (options.nonce) {
            url += `&nonce=${options.nonce}`;
        }
        return url;
    }
}
let authHandlerInstance;
function authHandler() {
    if (authHandlerInstance === undefined) {
        authHandlerInstance = new AuthHandler();
    }
    return authHandlerInstance;
}
/**
 * Obtain a Keycloak OIDC authentication token.
 * @return A Promise that resolves to an authentication token.
 */
function authenticateKeycloakOIDC(options, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__["uncancelableToken"]) {
    const state = Object(neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_4__["getRandomHexString"])();
    const nonce = Object(neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_4__["getRandomHexString"])();
    const handler = authHandler();
    const url = handler.makeAuthRequestUrl({
        state: state,
        clientId: options.clientId,
        redirect_uri: new URL('bossauth.html', window.location.href).href,
        authServer: options.authServer,
        nonce: nonce
    });
    const request = handler.addPendingRequest(state);
    const promise = new Promise((resolve, reject) => {
        request.finished.add((token, error) => {
            if (token !== undefined) {
                resolve(token);
            }
            else {
                reject(error);
            }
        });
    });
    request.finished.add(cancellationToken.add(() => {
        request.finished.dispatch(undefined, neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__["CANCELED"]);
    }));
    if (!cancellationToken.isCanceled) {
        const newWindow = open(url);
        if (newWindow !== null) {
            request.finished.add(() => {
                newWindow.close();
            });
        }
    }
    return promise;
}
class BossCredentialsProvider extends neuroglancer_credentials_provider__WEBPACK_IMPORTED_MODULE_0__["CredentialsProvider"] {
    constructor(authServer) {
        super();
        this.authServer = authServer;
        this.get = Object(neuroglancer_credentials_provider__WEBPACK_IMPORTED_MODULE_0__["makeCredentialsGetter"])(cancellationToken => {
            const status = new neuroglancer_status__WEBPACK_IMPORTED_MODULE_1__["StatusMessage"](/*delay=*/ true);
            let cancellationSource;
            return new Promise((resolve, reject) => {
                const dispose = () => {
                    cancellationSource = undefined;
                    status.dispose();
                };
                cancellationToken.add(() => {
                    if (cancellationSource !== undefined) {
                        cancellationSource.cancel();
                        cancellationSource = undefined;
                        status.dispose();
                        reject(neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__["CANCELED"]);
                    }
                });
                function writeLoginStatus(msg = 'Boss authorization required.', linkMessage = 'Request authorization.') {
                    status.setText(msg + ' ');
                    let button = document.createElement('button');
                    button.textContent = linkMessage;
                    status.element.appendChild(button);
                    button.addEventListener('click', () => {
                        login();
                    });
                    status.setVisible(true);
                }
                let authServer = this.authServer;
                function login() {
                    if (cancellationSource !== undefined) {
                        cancellationSource.cancel();
                    }
                    cancellationSource = new neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__["CancellationTokenSource"]();
                    writeLoginStatus('Waiting for Boss authorization...', 'Retry');
                    authenticateKeycloakOIDC({ realm: 'boss', clientId: 'endpoint', authServer: authServer }, cancellationSource)
                        .then(token => {
                        if (cancellationSource !== undefined) {
                            dispose();
                            resolve(token);
                        }
                    }, reason => {
                        if (cancellationSource !== undefined) {
                            cancellationSource = undefined;
                            writeLoginStatus(`Boss authorization failed: ${reason}.`, 'Retry');
                        }
                    });
                }
                writeLoginStatus();
            });
        });
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/boss/frontend.ts":
/*!******************************************************!*\
  !*** ./src/neuroglancer/datasource/boss/frontend.ts ***!
  \******************************************************/
/*! exports provided: MultiscaleVolumeChunkSource, getExperimentInfo, getChannelInfo, getDownsampleInfoForChannel, parseDownsampleScales, parseDownsampleInfoForChannel, getVolume, getCollections, getExperiments, getCoordinateFrame, collectionExperimentChannelCompleter, BossDataSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVolumeChunkSource", function() { return MultiscaleVolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExperimentInfo", function() { return getExperimentInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChannelInfo", function() { return getChannelInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDownsampleInfoForChannel", function() { return getDownsampleInfoForChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDownsampleScales", function() { return parseDownsampleScales; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDownsampleInfoForChannel", function() { return parseDownsampleInfoForChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVolume", function() { return getVolume; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCollections", function() { return getCollections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExperiments", function() { return getExperiments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCoordinateFrame", function() { return getCoordinateFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "collectionExperimentChannelCompleter", function() { return collectionExperimentChannelCompleter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BossDataSource", function() { return BossDataSource; });
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/credentials_provider/chunk_source_frontend */ "./src/neuroglancer/credentials_provider/chunk_source_frontend.ts");
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/* harmony import */ var neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/datasource/boss/api */ "./src/neuroglancer/datasource/boss/api.ts");
/* harmony import */ var neuroglancer_datasource_boss_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/datasource/boss/base */ "./src/neuroglancer/datasource/boss/base.ts");
/* harmony import */ var neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/mesh/frontend */ "./src/neuroglancer/mesh/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/completion */ "./src/neuroglancer/util/completion.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/http_request */ "./src/neuroglancer/util/http_request.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Support for The Boss (https://github.com/jhuapl-boss) web services.
 */












class BossVolumeChunkSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(Object(neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_1__["WithCredentialsProvider"])()(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_7__["VolumeChunkSource"]), neuroglancer_datasource_boss_base__WEBPACK_IMPORTED_MODULE_4__["VolumeChunkSourceParameters"])) {
}
class BossMeshSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(Object(neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_1__["WithCredentialsProvider"])()(neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_5__["MeshSource"]), neuroglancer_datasource_boss_base__WEBPACK_IMPORTED_MODULE_4__["MeshSourceParameters"])) {
}
let serverVolumeTypes = new Map();
serverVolumeTypes.set('image', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["VolumeType"].IMAGE);
serverVolumeTypes.set('annotation', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["VolumeType"].SEGMENTATION);
const VALID_ENCODINGS = new Set(['npz', 'jpeg']);
const DEFAULT_CUBOID_SIZE = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].fromValues(512, 512, 16);
var VoxelUnitType;
(function (VoxelUnitType) {
    VoxelUnitType[VoxelUnitType["NANOMETERS"] = 0] = "NANOMETERS";
    VoxelUnitType[VoxelUnitType["MICROMETERS"] = 1] = "MICROMETERS";
    VoxelUnitType[VoxelUnitType["MILLIMETERS"] = 2] = "MILLIMETERS";
    VoxelUnitType[VoxelUnitType["CENTIMETERS"] = 3] = "CENTIMETERS";
})(VoxelUnitType || (VoxelUnitType = {}));
function getVoxelUnitInNanometers(voxelUnit) {
    switch (voxelUnit) {
        case VoxelUnitType.MICROMETERS:
            return 1.e3;
        case VoxelUnitType.MILLIMETERS:
            return 1.e6;
        case VoxelUnitType.CENTIMETERS:
            return 1.e7;
        default:
            return 1.0;
    }
}
/**
 * This function adds scaling info by processing coordinate frame object and adding it to the
 * experiment.
 */
function parseCoordinateFrame(coordFrame, experimentInfo) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(coordFrame);
    let voxelSizeBase = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), voxelOffsetBase = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), imageSizeBase = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create();
    voxelSizeBase[0] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'x_voxel_size', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    voxelSizeBase[1] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'y_voxel_size', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    voxelSizeBase[2] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'z_voxel_size', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    voxelOffsetBase[0] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'x_start', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    voxelOffsetBase[1] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'y_start', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    voxelOffsetBase[2] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'z_start', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    imageSizeBase[0] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'x_stop', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    imageSizeBase[1] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'y_stop', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    imageSizeBase[2] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'z_stop', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    let voxelUnit = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(coordFrame, 'voxel_unit', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyEnumString"])(x, VoxelUnitType));
    let voxelSizeBaseNanometers = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].scale(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), voxelSizeBase, getVoxelUnitInNanometers(voxelUnit));
    experimentInfo.coordFrame = { voxelSizeBaseNanometers, voxelOffsetBase, imageSizeBase, voxelUnit };
    return experimentInfo;
}
function getVolumeTypeFromChannelType(channelType) {
    let volumeType = serverVolumeTypes.get(channelType);
    if (volumeType === undefined) {
        volumeType = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["VolumeType"].UNKNOWN;
    }
    return volumeType;
}
function parseChannelInfo(obj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(obj);
    let channelType = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
    let downsampleStatus = false;
    let downsampleStr = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'downsample_status', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
    if (downsampleStr === 'DOWNSAMPLED') {
        downsampleStatus = true;
    }
    return {
        channelType,
        description: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'description', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]),
        volumeType: getVolumeTypeFromChannelType(channelType),
        dataType: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'datatype', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyEnumString"])(x, neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["DataType"])),
        downsampled: downsampleStatus,
        scales: [],
        key: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'name', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]),
    };
}
function parseExperimentInfo(obj, chunkManager, hostname, credentialsProvider, collection, experiment) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(obj);
    let channelPromiseArray = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'channels', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseArray"])(x, ch => getChannelInfo(chunkManager, hostname, credentialsProvider, experiment, collection, ch)));
    return Promise.all(channelPromiseArray).then(channelArray => {
        // Parse out channel information
        let channels = new Map();
        channelArray.forEach(channel => {
            channels.set(channel.key, channel);
        });
        let experimentInfo = {
            channels: channels,
            scalingLevels: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'num_hierarchy_levels', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]),
            coordFrameKey: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'coord_frame', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]),
            coordFrame: undefined,
            key: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'name', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]),
            collection: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'collection', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]),
        };
        // Get and parse the coordinate frame
        return getCoordinateFrame(chunkManager, hostname, credentialsProvider, experimentInfo);
    });
}
class MultiscaleVolumeChunkSource {
    constructor(chunkManager, baseUrl, credentialsProvider, experimentInfo, channel, parameters) {
        this.chunkManager = chunkManager;
        this.baseUrl = baseUrl;
        this.credentialsProvider = credentialsProvider;
        this.experimentInfo = experimentInfo;
        this.parameters = parameters;
        /**
         * Parameters for getting 3D meshes alongside segmentations
         */
        this.meshPath = undefined;
        this.meshUrl = undefined;
        if (channel === undefined) {
            const channelNames = Array.from(experimentInfo.channels.keys());
            if (channelNames.length !== 1) {
                throw new Error(`Experiment contains multiple channels: ${JSON.stringify(channelNames)}`);
            }
            channel = channelNames[0];
        }
        const channelInfo = experimentInfo.channels.get(channel);
        if (channelInfo === undefined) {
            throw new Error(`Specified channel ${JSON.stringify(channel)} is not one of the supported channels ${JSON.stringify(Array.from(experimentInfo.channels.keys()))}`);
        }
        this.channel = channel;
        this.channelInfo = channelInfo;
        this.scales = channelInfo.scales;
        if (experimentInfo.coordFrame === undefined) {
            throw new Error(`Specified experiment ${JSON.stringify(experimentInfo.key)} does not have a valid coordinate frame`);
        }
        this.coordinateFrame = experimentInfo.coordFrame;
        if (this.channelInfo.downsampled === false) {
            this.scales = [channelInfo.scales[0]];
        }
        this.experiment = experimentInfo.key;
        let window = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyOptionalString"])(parameters['window']);
        if (window !== undefined) {
            let windowobj = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec2"].create();
            let parts = window.split(/,/);
            if (parts.length === 2) {
                windowobj[0] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyFiniteFloat"])(parts[0]);
                windowobj[1] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyFiniteFloat"])(parts[1]);
            }
            else if (parts.length === 1) {
                windowobj[0] = 0.;
                windowobj[1] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyFiniteFloat"])(parts[1]);
            }
            else {
                throw new Error(`Invalid window. Must be either one value or two comma separated values: ${JSON.stringify(window)}`);
            }
            this.window = windowobj;
            if (this.window[0] === this.window[1]) {
                throw new Error(`Invalid window. First element must be different from second: ${JSON.stringify(window)}.`);
            }
        }
        let meshUrl = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyOptionalString"])(parameters['meshurl']);
        if (meshUrl !== undefined) {
            this.meshUrl = meshUrl;
        }
        let encoding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyOptionalString"])(parameters['encoding']);
        if (encoding === undefined) {
            encoding = this.volumeType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["VolumeType"].IMAGE ? 'jpeg' : 'npz';
        }
        else {
            if (!VALID_ENCODINGS.has(encoding)) {
                throw new Error(`Invalid encoding: ${JSON.stringify(encoding)}.`);
            }
        }
        this.encoding = encoding;
    }
    get dataType() {
        if (this.channelInfo.dataType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["DataType"].UINT16) {
            // 16-bit channels automatically rescaled to uint8 by The Boss
            return neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["DataType"].UINT8;
        }
        return this.channelInfo.dataType;
    }
    get numChannels() {
        return 1;
    }
    get volumeType() {
        return this.channelInfo.volumeType;
    }
    getSources(volumeSourceOptions) {
        return this.scales.map(scaleInfo => {
            let { voxelSizeNanometers, imageSize } = scaleInfo;
            let voxelOffset = this.coordinateFrame.voxelOffsetBase;
            let baseVoxelOffset = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create();
            for (let i = 0; i < 3; ++i) {
                baseVoxelOffset[i] = Math.ceil(voxelOffset[i]);
            }
            return neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["VolumeChunkSpecification"]
                .getDefaults({
                numChannels: this.numChannels,
                volumeType: this.volumeType,
                dataType: this.dataType,
                voxelSize: voxelSizeNanometers,
                chunkDataSizes: [DEFAULT_CUBOID_SIZE],
                transform: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].fromTranslation(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), voxelOffset, voxelSizeNanometers)),
                baseVoxelOffset,
                upperVoxelBound: imageSize,
                volumeSourceOptions,
            })
                .map(spec => this.chunkManager.getChunkSource(BossVolumeChunkSource, {
                credentialsProvider: this.credentialsProvider,
                spec,
                parameters: {
                    baseUrl: this.baseUrl,
                    collection: this.experimentInfo.collection,
                    experiment: this.experimentInfo.key,
                    channel: this.channel,
                    resolution: scaleInfo.key,
                    encoding: this.encoding,
                    window: this.window,
                }
            }));
        });
    }
    getMeshSource() {
        if (this.meshUrl !== undefined) {
            return this.chunkManager.getChunkSource(BossMeshSource, { credentialsProvider: this.credentialsProvider, parameters: { baseUrl: this.meshUrl } });
        }
        return null;
    }
}
const pathPattern = /^([^\/?]+)\/([^\/?]+)(?:\/([^\/?]+))?(?:\?(.*))?$/;
function getExperimentInfo(chunkManager, hostname, credentialsProvider, experiment, collection) {
    return chunkManager.memoize.getUncounted({
        hostname: hostname,
        collection: collection,
        experiment: experiment,
        type: 'boss:getExperimentInfo'
    }, () => Object(neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_3__["fetchWithBossCredentials"])(credentialsProvider, `${hostname}/latest/collection/${collection}/experiment/${experiment}/`, {}, neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["responseJson"])
        .then(value => parseExperimentInfo(value, chunkManager, hostname, credentialsProvider, collection, experiment)));
}
function getChannelInfo(chunkManager, hostname, credentialsProvider, experiment, collection, channel) {
    return chunkManager.memoize.getUncounted({
        hostname: hostname,
        collection: collection,
        experiment: experiment,
        channel: channel,
        type: 'boss:getChannelInfo'
    }, () => Object(neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_3__["fetchWithBossCredentials"])(credentialsProvider, `${hostname}/latest/collection/${collection}/experiment/${experiment}/channel/${channel}/`, {}, neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["responseJson"])
        .then(parseChannelInfo));
}
function getDownsampleInfoForChannel(chunkManager, hostname, credentialsProvider, collection, experimentInfo, channel) {
    return chunkManager.memoize
        .getUncounted({
        hostname: hostname,
        collection: collection,
        experiment: experimentInfo.key,
        channel: channel,
        downsample: true,
        type: 'boss:getDownsampleInfoForChannel'
    }, () => Object(neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_3__["fetchWithBossCredentials"])(credentialsProvider, `${hostname}/latest/downsample/${collection}/${experimentInfo.key}/${channel}/`, {}, neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["responseJson"]))
        .then(downsampleObj => {
        return parseDownsampleInfoForChannel(downsampleObj, experimentInfo, channel);
    });
}
function parseDownsampleScales(downsampleObj, voxelUnit) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(downsampleObj);
    let voxelSizes = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(downsampleObj, 'voxel_size', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectAsMap"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verify3dScale"]));
    let imageSizes = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(downsampleObj, 'extent', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectAsMap"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verify3dDimensions"]));
    let num_hierarchy_levels = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(downsampleObj, 'num_hierarchy_levels', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    let scaleInfo = new Array();
    for (let i = 0; i < num_hierarchy_levels; i++) {
        let key = String(i);
        const voxelSize = voxelSizes.get(key);
        const imageSize = imageSizes.get(key);
        if (voxelSize === undefined || imageSize === undefined) {
            throw new Error(`Missing voxel_size/extent for resolution ${key}.`);
        }
        let voxelSizeNanometers = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].scale(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), voxelSize, getVoxelUnitInNanometers(voxelUnit));
        scaleInfo[i] = { voxelSizeNanometers, imageSize, key };
    }
    return scaleInfo;
}
function parseDownsampleInfoForChannel(downsampleObj, experimentInfo, channel) {
    let coordFrame = experimentInfo.coordFrame;
    if (coordFrame === undefined) {
        throw new Error(`Missing coordinate frame information for experiment ${experimentInfo
            .key}. A valid coordinate frame is required to retrieve downsampling information.`);
    }
    let channelInfo = experimentInfo.channels.get(channel);
    if (channelInfo === undefined) {
        throw new Error(`Specified channel ${JSON.stringify(channel)} is not one of the supported channels ${JSON.stringify(Array.from(experimentInfo.channels.keys()))}`);
    }
    channelInfo.scales = parseDownsampleScales(downsampleObj, coordFrame.voxelUnit);
    experimentInfo.channels.set(channel, channelInfo);
    return experimentInfo;
}
function getVolume(chunkManager, hostname, credentialsProvider, path) {
    const match = path.match(pathPattern);
    if (match === null) {
        throw new Error(`Invalid volume path ${JSON.stringify(path)}`);
    }
    const collection = match[1];
    const experiment = match[2];
    const channel = match[3];
    const parameters = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseQueryStringParameters"])(match[4] || '');
    // Warning: If additional arguments are added, the cache key should be updated as well.
    return chunkManager.memoize.getUncounted({ hostname: hostname, path: path, type: 'boss:getVolume' }, () => getExperimentInfo(chunkManager, hostname, credentialsProvider, experiment, collection)
        .then(experimentInfo => {
        return getDownsampleInfoForChannel(chunkManager, hostname, credentialsProvider, collection, experimentInfo, channel)
            .then(experimentInfoWithDownsample => new MultiscaleVolumeChunkSource(chunkManager, hostname, credentialsProvider, experimentInfoWithDownsample, channel, parameters));
    }));
}
const urlPattern = /^((?:http|https):\/\/[^\/?]+)\/(.*)$/;
function getCollections(chunkManager, hostname, credentialsProvider) {
    return chunkManager.memoize.getUncounted({ hostname: hostname, type: 'boss:getCollections' }, () => Object(neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_3__["fetchWithBossCredentials"])(credentialsProvider, `${hostname}/latest/collection/`, {}, neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["responseJson"])
        .then(value => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(value, 'collections', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseArray"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]))));
}
function getExperiments(chunkManager, hostname, credentialsProvider, collection) {
    return chunkManager.memoize.getUncounted({ hostname: hostname, collection: collection, type: 'boss:getExperiments' }, () => Object(neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_3__["fetchWithBossCredentials"])(credentialsProvider, `${hostname}/latest/collection/${collection}/experiment/`, {}, neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["responseJson"])
        .then(value => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(value, 'experiments', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseArray"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]))));
}
function getCoordinateFrame(chunkManager, hostname, credentialsProvider, experimentInfo) {
    let key = experimentInfo.coordFrameKey;
    return chunkManager.memoize.getUncounted({
        hostname: hostname,
        coordinateframe: key,
        experimentInfo: experimentInfo,
        type: 'boss:getCoordinateFrame'
    }, () => Object(neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_3__["fetchWithBossCredentials"])(credentialsProvider, `${hostname}/latest/coord/${key}/`, {}, neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["responseJson"])
        .then(coordinateFrameObj => parseCoordinateFrame(coordinateFrameObj, experimentInfo)));
}
function collectionExperimentChannelCompleter(chunkManager, hostname, credentialsProvider, path) {
    let channelMatch = path.match(/^(?:([^\/]+)(?:\/?([^\/]*)(?:\/?([^\/]*)(?:\/?([^\/]*)?))?)?)?$/);
    if (channelMatch === null) {
        // URL has incorrect format, don't return any results.
        return Promise.reject(null);
    }
    if (channelMatch[1] === undefined) {
        // No collection. Reject.
        return Promise.reject(null);
    }
    if (channelMatch[2] === undefined) {
        let collectionPrefix = channelMatch[1] || '';
        // Try to complete the collection.
        return getCollections(chunkManager, hostname, credentialsProvider).then(collections => {
            return {
                offset: 0,
                completions: Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__["getPrefixMatchesWithDescriptions"])(collectionPrefix, collections, x => x + '/', () => undefined)
            };
        });
    }
    if (channelMatch[3] === undefined) {
        let experimentPrefix = channelMatch[2] || '';
        return getExperiments(chunkManager, hostname, credentialsProvider, channelMatch[1])
            .then(experiments => {
            return {
                offset: channelMatch[1].length + 1,
                completions: Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__["getPrefixMatchesWithDescriptions"])(experimentPrefix, experiments, y => y + '/', () => undefined)
            };
        });
    }
    return getExperimentInfo(chunkManager, hostname, credentialsProvider, channelMatch[2], channelMatch[1])
        .then(experimentInfo => {
        let completions = Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__["getPrefixMatchesWithDescriptions"])(channelMatch[3], experimentInfo.channels, x => x[0], x => {
            return `${x[1].channelType} (${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_6__["DataType"][x[1].dataType]})`;
        });
        return { offset: channelMatch[1].length + channelMatch[2].length + 2, completions };
    });
}
function getAuthServer(endpoint) {
    let baseHostName = endpoint.match(/^(?:https:\/\/[^.]+([^\/]+))/);
    if (baseHostName === null) {
        throw new Error(`Unable to construct auth server hostname from base hostname ${endpoint}.`);
    }
    let authServer = `https://auth${baseHostName[1]}/auth`;
    return authServer;
}
class BossDataSource extends neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_2__["DataSource"] {
    constructor(credentialsManager) {
        super();
        this.credentialsManager = credentialsManager;
    }
    get description() {
        return 'The Boss';
    }
    getCredentialsProvider(path) {
        let authServer = getAuthServer(path);
        return this.credentialsManager.getCredentialsProvider(neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_3__["credentialsKey"], authServer);
    }
    getVolume(chunkManager, path) {
        let match = path.match(urlPattern);
        if (match === null) {
            throw new Error(`Invalid boss volume path: ${JSON.stringify(path)}`);
        }
        let credentialsProvider = this.getCredentialsProvider(path);
        return getVolume(chunkManager, match[1], credentialsProvider, match[2]);
    }
    volumeCompleter(url, chunkManager) {
        let match = url.match(urlPattern);
        if (match === null) {
            // We don't yet have a full hostname.
            return Promise.reject(null);
        }
        let hostname = match[1];
        let credentialsProvider = this.getCredentialsProvider(match[1]);
        let path = match[2];
        return collectionExperimentChannelCompleter(chunkManager, hostname, credentialsProvider, path)
            .then(completions => Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__["applyCompletionOffset"])(match[1].length + 1, completions));
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/boss/register_credentials_provider.ts":
/*!***************************************************************************!*\
  !*** ./src/neuroglancer/datasource/boss/register_credentials_provider.ts ***!
  \***************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_credentials_provider_default_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider/default_manager */ "./src/neuroglancer/credentials_provider/default_manager.ts");
/* harmony import */ var neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/boss/api */ "./src/neuroglancer/datasource/boss/api.ts");
/* harmony import */ var neuroglancer_datasource_boss_credentials_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource/boss/credentials_provider */ "./src/neuroglancer/datasource/boss/credentials_provider.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



neuroglancer_credentials_provider_default_manager__WEBPACK_IMPORTED_MODULE_0__["defaultCredentialsManager"].register(neuroglancer_datasource_boss_api__WEBPACK_IMPORTED_MODULE_1__["credentialsKey"], (authServer) => new neuroglancer_datasource_boss_credentials_provider__WEBPACK_IMPORTED_MODULE_2__["BossCredentialsProvider"](authServer));


/***/ }),

/***/ "./src/neuroglancer/datasource/boss/register_default.ts":
/*!**************************************************************!*\
  !*** ./src/neuroglancer/datasource/boss/register_default.ts ***!
  \**************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_boss_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/boss/frontend */ "./src/neuroglancer/datasource/boss/frontend.ts");
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__["registerProvider"])('boss', options => new neuroglancer_datasource_boss_frontend__WEBPACK_IMPORTED_MODULE_0__["BossDataSource"](options.credentialsManager));


/***/ }),

/***/ "./src/neuroglancer/datasource/brainmaps/api.ts":
/*!******************************************************!*\
  !*** ./src/neuroglancer/datasource/brainmaps/api.ts ***!
  \******************************************************/
/*! exports provided: credentialsKey, makeRequest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "credentialsKey", function() { return credentialsKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRequest", function() { return makeRequest; });
/* harmony import */ var neuroglancer_credentials_provider_http_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider/http_request */ "./src/neuroglancer/credentials_provider/http_request.ts");
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/http_request */ "./src/neuroglancer/util/http_request.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Key used for retrieving the CredentialsProvider from a CredentialsManager.
 */
const credentialsKey = 'google-brainmaps';
function makeRequest(instance, credentialsProvider, httpCall, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_1__["uncancelableToken"]) {
    return Object(neuroglancer_credentials_provider_http_request__WEBPACK_IMPORTED_MODULE_0__["fetchWithCredentials"])(credentialsProvider, `${instance.serverUrl}${httpCall.path}`, { method: httpCall.method, body: httpCall.payload }, httpCall.responseType === 'json' ? neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_2__["responseJson"] : neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_2__["responseArrayBuffer"], (credentials, init) => {
        const headers = new Headers(init.headers);
        headers.set('Authorization', `${credentials.tokenType} ${credentials.accessToken}`);
        return Object.assign({}, init, { headers });
    }, error => {
        const { status } = error;
        if (status === 401) {
            // 401: Authorization needed.  OAuth2 token may have expired.
            return 'refresh';
        }
        else if (status === 504 || status === 503) {
            // 503: Service unavailable.  Retry.
            // 504: Gateway timeout.  Can occur if the server takes too long to reply.  Retry.
            return 'retry';
        }
        throw error;
    }, cancellationToken);
}


/***/ }),

/***/ "./src/neuroglancer/datasource/brainmaps/base.ts":
/*!*******************************************************!*\
  !*** ./src/neuroglancer/datasource/brainmaps/base.ts ***!
  \*******************************************************/
/*! exports provided: VolumeChunkEncoding, ChangeSpec, VolumeSourceParameters, MultiscaleMeshSourceParameters, MeshSourceParameters, SkeletonSourceParameters, AnnotationSourceParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkEncoding", function() { return VolumeChunkEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChangeSpec", function() { return ChangeSpec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeSourceParameters", function() { return VolumeSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleMeshSourceParameters", function() { return MultiscaleMeshSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshSourceParameters", function() { return MeshSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonSourceParameters", function() { return SkeletonSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationSourceParameters", function() { return AnnotationSourceParameters; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VolumeChunkEncoding;
(function (VolumeChunkEncoding) {
    VolumeChunkEncoding[VolumeChunkEncoding["RAW"] = 0] = "RAW";
    VolumeChunkEncoding[VolumeChunkEncoding["JPEG"] = 1] = "JPEG";
    VolumeChunkEncoding[VolumeChunkEncoding["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
})(VolumeChunkEncoding || (VolumeChunkEncoding = {}));
class ChangeSpec {
}
class VolumeSourceParameters {
}
VolumeSourceParameters.RPC_ID = 'brainmaps/VolumeChunkSource';
class MultiscaleMeshSourceParameters {
}
MultiscaleMeshSourceParameters.RPC_ID = 'brainmaps/MultiscaleMeshSource';
class MeshSourceParameters {
}
MeshSourceParameters.RPC_ID = 'brainmaps/MeshSource';
class SkeletonSourceParameters {
}
SkeletonSourceParameters.RPC_ID = 'brainmaps/SkeletonSource';
class AnnotationSourceParameters {
}
AnnotationSourceParameters.RPC_ID = 'brainmaps/Annotation';


/***/ }),

/***/ "./src/neuroglancer/datasource/brainmaps/credentials_provider.ts":
/*!***********************************************************************!*\
  !*** ./src/neuroglancer/datasource/brainmaps/credentials_provider.ts ***!
  \***********************************************************************/
/*! exports provided: BrainmapsCredentialsProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrainmapsCredentialsProvider", function() { return BrainmapsCredentialsProvider; });
/* harmony import */ var neuroglancer_util_google_oauth2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/google_oauth2 */ "./src/neuroglancer/util/google_oauth2.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file This implements a Brain Maps CredentialsProvider based on neuroglancer/util/google_auth2.
 */

const BRAINMAPS_SCOPE = 'https://www.googleapis.com/auth/brainmaps';
class BrainmapsCredentialsProvider extends neuroglancer_util_google_oauth2__WEBPACK_IMPORTED_MODULE_0__["GoogleOAuth2CredentialsProvider"] {
    constructor(clientId) {
        super({ clientId: clientId, scopes: [BRAINMAPS_SCOPE], description: 'Brain Maps' });
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/brainmaps/frontend.ts":
/*!***********************************************************!*\
  !*** ./src/neuroglancer/datasource/brainmaps/frontend.ts ***!
  \***********************************************************/
/*! exports provided: BrainmapsSkeletonSource, VolumeInfo, MultiscaleVolumeInfo, MultiscaleVolumeChunkSource, parseVolumeKey, VolumeList, parseChangeStackList, BrainmapsAnnotationSource, BrainmapsDataSource, productionInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrainmapsSkeletonSource", function() { return BrainmapsSkeletonSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeInfo", function() { return VolumeInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVolumeInfo", function() { return MultiscaleVolumeInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVolumeChunkSource", function() { return MultiscaleVolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseVolumeKey", function() { return parseVolumeKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeList", function() { return VolumeList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseChangeStackList", function() { return parseChangeStackList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrainmapsAnnotationSource", function() { return BrainmapsAnnotationSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrainmapsDataSource", function() { return BrainmapsDataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "productionInstance", function() { return productionInstance; });
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/annotation/base */ "./src/neuroglancer/annotation/base.ts");
/* harmony import */ var neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/annotation/frontend */ "./src/neuroglancer/annotation/frontend.ts");
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/credentials_provider/chunk_source_frontend */ "./src/neuroglancer/credentials_provider/chunk_source_frontend.ts");
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/* harmony import */ var neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/datasource/brainmaps/api */ "./src/neuroglancer/datasource/brainmaps/api.ts");
/* harmony import */ var neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/datasource/brainmaps/base */ "./src/neuroglancer/datasource/brainmaps/base.ts");
/* harmony import */ var neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/mesh/base */ "./src/neuroglancer/mesh/base.ts");
/* harmony import */ var neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/mesh/frontend */ "./src/neuroglancer/mesh/frontend.ts");
/* harmony import */ var neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/skeleton/frontend */ "./src/neuroglancer/skeleton/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/sliceview/base */ "./src/neuroglancer/sliceview/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/util/completion */ "./src/neuroglancer/util/completion.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



















class BrainmapsVolumeChunkSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["WithParameters"])(Object(neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_4__["WithCredentialsProvider"])()(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_13__["VolumeChunkSource"]), neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["VolumeSourceParameters"])) {
}
class BrainmapsMultiscaleMeshSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["WithParameters"])(Object(neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_4__["WithCredentialsProvider"])()(neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_9__["MultiscaleMeshSource"]), neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["MultiscaleMeshSourceParameters"])) {
}
class BrainmapsMeshSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["WithParameters"])(Object(neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_4__["WithCredentialsProvider"])()(neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_9__["MeshSource"]), neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["MeshSourceParameters"])) {
}
class BrainmapsSkeletonSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["WithParameters"])(Object(neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_4__["WithCredentialsProvider"])()(neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__["SkeletonSource"]), neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["SkeletonSourceParameters"])) {
    get skeletonVertexCoordinatesInVoxels() {
        return false;
    }
}
const SERVER_DATA_TYPES = new Map();
SERVER_DATA_TYPES.set('UINT8', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["DataType"].UINT8);
SERVER_DATA_TYPES.set('FLOAT', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["DataType"].FLOAT32);
SERVER_DATA_TYPES.set('UINT64', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["DataType"].UINT64);
function parseBoundingBox(obj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(obj);
    try {
        return {
            corner: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'corner', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseXYZ"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyFiniteFloat"])),
            size: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'size', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseXYZ"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyFinitePositiveFloat"])),
            metadata: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'metadata', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyOptionalString"]),
        };
    }
    catch (parseError) {
        throw new Error(`Failed to parse bounding box: ${parseError.message}`);
    }
}
class VolumeInfo {
    constructor(obj) {
        try {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(obj);
            this.numChannels = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'channelCount', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyPositiveInt"]);
            this.dataType =
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'channelType', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyMapKey"])(x, SERVER_DATA_TYPES));
            this.voxelSize = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'pixelSize', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseXYZ"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyFinitePositiveFloat"]));
            this.upperVoxelBound = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'volumeSize', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseXYZ"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyPositiveInt"]));
            this.boundingBoxes = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'boundingBox', a => a === undefined ? [] : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseArray"])(a, parseBoundingBox));
        }
        catch (parseError) {
            throw new Error(`Failed to parse BrainMaps volume geometry: ${parseError.message}`);
        }
    }
}
function parseMeshInfo(obj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(obj);
    return {
        name: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'name', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyString"]),
        type: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyString"])
    };
}
function parseMeshesResponse(meshesResponse) {
    try {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(meshesResponse);
        return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(meshesResponse, 'meshes', y => {
            if (y === undefined) {
                return [];
            }
            return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseArray"])(y, parseMeshInfo);
        });
    }
    catch (parseError) {
        throw new Error(`Failed to parse BrainMaps meshes specification: ${parseError.message}`);
    }
}
const floatPattern = '([0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)';
const intPattern = '([0-9]+)';
const lodPattern = new RegExp(`^(.*)_${intPattern}x${intPattern}x${intPattern}_lod([0-9]+)_${floatPattern}$`);
function getMultiscaleMeshes(volumeInfo, meshes) {
    const multiscaleMeshes = new Map();
    const baseVolume = volumeInfo.scales[0];
    const invalidLodMeshes = new Set();
    for (const mesh of meshes) {
        // Only triangular meshes supported currently.
        if (mesh.type !== 'TRIANGLES')
            continue;
        const m = mesh.name.match(lodPattern);
        if (m === null)
            continue;
        const key = m[1];
        let info = multiscaleMeshes.get(key);
        if (info === undefined) {
            info = {
                key,
                chunkShape: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(),
                lods: []
            };
            multiscaleMeshes.set(key, info);
        }
        const lod = parseInt(m[5]);
        if (info.lods[lod] !== undefined) {
            invalidLodMeshes.add(key);
            continue;
        }
        const chunkShapeInVoxels = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].fromValues(parseInt(m[2], 10), parseInt(m[3], 10), parseInt(m[4], 10));
        const gridShape = new Uint32Array(3);
        for (let i = 0; i < 3; ++i) {
            gridShape[i] = Math.ceil(baseVolume.upperVoxelBound[i] / chunkShapeInVoxels[i]);
        }
        info.lods[lod] = {
            info: mesh,
            scale: parseFloat(m[6]),
            // Temporarily use the relativeBlockShape field to store the absolute shape in voxels.
            relativeBlockShape: chunkShapeInVoxels,
            gridShape,
        };
    }
    const output = [];
    meshLoop: for (const mesh of multiscaleMeshes.values()) {
        if (invalidLodMeshes.has(mesh.key))
            continue meshLoop;
        const baseLod = mesh.lods[0];
        if (baseLod === undefined)
            continue meshLoop;
        const baseBlockShapeInVoxels = baseLod.relativeBlockShape;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].multiply(mesh.chunkShape, baseBlockShapeInVoxels, baseVolume.voxelSize);
        for (let lodIndex = 1; lodIndex < mesh.lods.length; ++lodIndex) {
            const lod = mesh.lods[lodIndex];
            if (lod === undefined)
                continue meshLoop;
            const { relativeBlockShape } = lod;
            for (let i = 0; i < 3; ++i) {
                const curSize = relativeBlockShape[i];
                const baseSize = baseBlockShapeInVoxels[i];
                if (curSize < baseSize || (curSize % baseSize) !== 0)
                    continue meshLoop;
                relativeBlockShape[i] = curSize / baseSize;
            }
        }
        baseBlockShapeInVoxels.fill(1);
        output.push(mesh);
    }
    return output;
}
class MultiscaleVolumeInfo {
    constructor(volumeInfoResponse) {
        try {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(volumeInfoResponse);
            let scales = this.scales = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(volumeInfoResponse, 'geometry', y => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseArray"])(y, x => new VolumeInfo(x)));
            if (scales.length === 0) {
                throw new Error('Expected at least one scale.');
            }
            let baseScale = scales[0];
            let numChannels = this.numChannels = baseScale.numChannels;
            let dataType = this.dataType = baseScale.dataType;
            for (let scaleIndex = 1, numScales = scales.length; scaleIndex < numScales; ++scaleIndex) {
                let scale = scales[scaleIndex];
                if (scale.dataType !== dataType) {
                    throw new Error(`Scale ${scaleIndex} has data type ${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["DataType"][scale.dataType]} ` +
                        `but scale 0 has data type ${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["DataType"][dataType]}.`);
                }
                if (scale.numChannels !== numChannels) {
                    throw new Error(`Scale ${scaleIndex} has ${scale.numChannels} channel(s) ` +
                        `but scale 0 has ${numChannels} channels.`);
                }
            }
        }
        catch (parseError) {
            throw new Error(`Failed to parse BrainMaps multiscale volume specification: ${parseError.message}`);
        }
    }
}
class MultiscaleVolumeChunkSource {
    constructor(chunkManager, instance, credentialsProvider, volumeId, changeSpec, multiscaleVolumeInfo, meshesResponse, options) {
        this.chunkManager = chunkManager;
        this.instance = instance;
        this.credentialsProvider = credentialsProvider;
        this.volumeId = volumeId;
        this.changeSpec = changeSpec;
        this.multiscaleVolumeInfo = multiscaleVolumeInfo;
        this.encoding = options.encoding;
        this.chunkLayoutPreference = options.chunkLayoutPreference;
        // Infer the VolumeType from the data type and number of channels.
        let volumeType;
        if (this.numChannels === 1) {
            switch (this.dataType) {
                case neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["DataType"].UINT64:
                    volumeType = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["VolumeType"].SEGMENTATION;
                    break;
            }
        }
        if (volumeType === undefined) {
            if (options.volumeType !== undefined) {
                volumeType = options.volumeType;
            }
            else {
                volumeType = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["VolumeType"].IMAGE;
            }
        }
        this.volumeType = volumeType;
        this.meshes = parseMeshesResponse(meshesResponse);
    }
    get scales() {
        return this.multiscaleVolumeInfo.scales;
    }
    get dataType() {
        return this.multiscaleVolumeInfo.dataType;
    }
    get numChannels() {
        return this.multiscaleVolumeInfo.numChannels;
    }
    getSources(volumeSourceOptions) {
        let encoding = neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["VolumeChunkEncoding"].RAW;
        if (this.dataType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["DataType"].UINT64 && this.volumeType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["VolumeType"].SEGMENTATION) {
            encoding = neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATION;
        }
        else if (this.volumeType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["VolumeType"].IMAGE && this.dataType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["DataType"].UINT8 &&
            this.numChannels === 1 && this.encoding !== neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["VolumeChunkEncoding"].RAW) {
            encoding = neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["VolumeChunkEncoding"].JPEG;
        }
        const baseScale = this.scales[0];
        const upperClipBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(), baseScale.upperVoxelBound, baseScale.voxelSize);
        return this.scales.map((volumeInfo, scaleIndex) => neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_12__["VolumeChunkSpecification"]
            .getDefaults({
            voxelSize: volumeInfo.voxelSize,
            dataType: volumeInfo.dataType,
            numChannels: volumeInfo.numChannels,
            upperVoxelBound: volumeInfo.upperVoxelBound,
            upperClipBound,
            volumeType: this.volumeType,
            volumeSourceOptions,
            chunkLayoutPreference: this.chunkLayoutPreference,
            maxCompressedSegmentationBlockSize: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].fromValues(64, 64, 64),
        })
            .map(spec => {
            return this.chunkManager.getChunkSource(BrainmapsVolumeChunkSource, {
                credentialsProvider: this.credentialsProvider,
                spec,
                parameters: {
                    'volumeId': this.volumeId,
                    'changeSpec': this.changeSpec,
                    'scaleIndex': scaleIndex,
                    'encoding': encoding,
                    'instance': this.instance,
                }
            });
        }));
    }
    getMeshSource() {
        const multiscaleMeshes = getMultiscaleMeshes(this.multiscaleVolumeInfo, this.meshes);
        for (const mesh of multiscaleMeshes) {
            return this.chunkManager.getChunkSource(BrainmapsMultiscaleMeshSource, {
                credentialsProvider: this.credentialsProvider,
                format: {
                    fragmentRelativeVertices: false,
                    transform: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["mat4"].create(),
                    vertexPositionFormat: neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_8__["VertexPositionFormat"].float32,
                },
                parameters: {
                    'instance': this.instance,
                    'volumeId': this.volumeId,
                    'info': mesh,
                    'changeSpec': this.changeSpec,
                }
            });
        }
        for (const mesh of this.meshes) {
            if (mesh.type === 'TRIANGLES') {
                return this.chunkManager.getChunkSource(BrainmapsMeshSource, {
                    credentialsProvider: this.credentialsProvider,
                    parameters: {
                        'instance': this.instance,
                        'volumeId': this.volumeId,
                        'meshName': mesh.name,
                        'changeSpec': this.changeSpec,
                    }
                });
            }
            else if (mesh.type === 'LINE_SEGMENTS') {
                return this.chunkManager.getChunkSource(BrainmapsSkeletonSource, {
                    credentialsProvider: this.credentialsProvider,
                    parameters: {
                        'instance': this.instance,
                        'volumeId': this.volumeId,
                        'meshName': mesh.name,
                        'changeSpec': this.changeSpec,
                    }
                });
            }
        }
        return null;
    }
    getStaticAnnotations() {
        const baseScale = this.scales[0];
        const annotationSet = new neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationSource"](neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["mat4"].fromScaling(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["mat4"].create(), baseScale.voxelSize));
        annotationSet.readonly = true;
        annotationSet.add(Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["makeDataBoundsBoundingBox"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(), baseScale.upperVoxelBound));
        baseScale.boundingBoxes.forEach((boundingBox, i) => {
            annotationSet.add({
                type: neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationType"].AXIS_ALIGNED_BOUNDING_BOX,
                description: boundingBox.metadata,
                pointA: boundingBox.corner,
                pointB: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].add(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(), boundingBox.corner, boundingBox.size),
                id: `boundingBox${i}`,
            });
        });
        return annotationSet;
    }
}
function parseVolumeKey(key) {
    const match = key.match(/^([^:?]+:[^:?]+:[^:?]+)(?::([^:?]+))?(?:\?(.*))?$/);
    if (match === null) {
        throw new Error(`Invalid Brain Maps volume key: ${JSON.stringify(key)}.`);
    }
    let changeSpec;
    if (match[2] !== undefined) {
        changeSpec = { changeStackId: match[2] };
    }
    const parameters = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseQueryStringParameters"])(match[3] || '');
    return { volumeId: match[1], changeSpec, parameters };
}
const meshSourcePattern = /^([^\/]+)\/(.*)$/;
function parseProject(obj) {
    try {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(obj);
        return {
            id: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'id', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyString"]),
            label: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'label', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyString"]),
            description: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'description', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyOptionalString"]),
        };
    }
    catch (parseError) {
        throw new Error(`Failed to parse project: ${parseError.message}`);
    }
}
function parseProjectList(obj) {
    try {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(obj);
        return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, 'project', x => x === undefined ? [] : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseArray"])(x, parseProject));
    }
    catch (parseError) {
        throw new Error(`Error parsing project list: ${parseError.message}`);
    }
}
function parseAPIResponseList(obj, propertyName) {
    try {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(obj);
        return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(obj, propertyName, x => x === undefined ? [] : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseArray"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyString"]));
    }
    catch (parseError) {
        throw new Error(`Error parsing dataset list: ${parseError.message}`);
    }
}
class VolumeList {
    constructor(projectsResponse, volumesResponse) {
        this.projects = new Map();
        this.hierarchicalVolumeIds = new Map();
        const { projects } = this;
        for (let project of parseProjectList(projectsResponse)) {
            projects.set(project.id, project);
        }
        try {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(volumesResponse);
            let volumeIds = this.volumeIds = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(volumesResponse, 'volumeId', x => x === undefined ? [] : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseArray"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyString"]));
            volumeIds.sort();
            let hierarchicalSets = new Map();
            for (let volumeId of volumeIds) {
                let componentStart = 0;
                while (true) {
                    let nextColon = volumeId.indexOf(':', componentStart);
                    if (nextColon === -1) {
                        nextColon = undefined;
                    }
                    else {
                        ++nextColon;
                    }
                    let groupString = volumeId.substring(0, componentStart);
                    let group = hierarchicalSets.get(groupString);
                    if (group === undefined) {
                        group = new Set();
                        hierarchicalSets.set(groupString, group);
                    }
                    group.add(volumeId.substring(componentStart, nextColon));
                    if (nextColon === undefined) {
                        break;
                    }
                    componentStart = nextColon;
                }
            }
            let { hierarchicalVolumeIds } = this;
            for (let [group, valueSet] of hierarchicalSets) {
                hierarchicalVolumeIds.set(group, Array.from(valueSet));
            }
        }
        catch (parseError) {
            throw new Error(`Failed to parse Brain Maps volume list reply: ${parseError.message}`);
        }
    }
}
function parseChangeStackList(x) {
    return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(x, 'changeStackId', y => y === undefined ? undefined : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["parseArray"])(y, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyString"]));
}
function makeAnnotationGeometrySourceSpecifications(multiscaleInfo) {
    const baseScale = multiscaleInfo.scales[0];
    const spec = new neuroglancer_annotation_base__WEBPACK_IMPORTED_MODULE_1__["AnnotationGeometryChunkSpecification"]({
        voxelSize: baseScale.voxelSize,
        chunkSize: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].create(), baseScale.upperVoxelBound, baseScale.voxelSize),
        upperChunkBound: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["vec3"].fromValues(1, 1, 1),
    });
    return [[{ parameters: undefined, spec }]];
}
const MultiscaleAnnotationSourceBase = (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_3__["WithParameters"])(Object(neuroglancer_credentials_provider_chunk_source_frontend__WEBPACK_IMPORTED_MODULE_4__["WithCredentialsProvider"])()(neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_2__["MultiscaleAnnotationSource"]), neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["AnnotationSourceParameters"]));
class BrainmapsAnnotationSource extends MultiscaleAnnotationSourceBase {
    constructor(chunkManager, options) {
        super(chunkManager, Object.assign({ sourceSpecifications: makeAnnotationGeometrySourceSpecifications(options.multiscaleVolumeInfo) }, options));
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_16__["mat4"].fromScaling(this.objectToLocal, options.multiscaleVolumeInfo.scales[0].voxelSize);
    }
}
class BrainmapsDataSource extends neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_5__["DataSource"] {
    constructor(instance, credentialsProvider) {
        super();
        this.instance = instance;
        this.credentialsProvider = credentialsProvider;
    }
    get description() {
        return this.instance.description;
    }
    getMeshSource(chunkManager, url) {
        return chunkManager.getChunkSource(BrainmapsMeshSource, {
            credentialsProvider: this.credentialsProvider,
            parameters: this.getMeshSourceParameters(url)
        });
    }
    getMeshSourceParameters(url) {
        let match = url.match(meshSourcePattern);
        if (match === null) {
            throw new Error(`Invalid Brainmaps mesh URL: ${url}`);
        }
        let { volumeId, changeSpec } = parseVolumeKey(match[1]);
        return { instance: this.instance, volumeId, changeSpec, meshName: match[2] };
    }
    getSkeletonSource(chunkManager, url) {
        return chunkManager.getChunkSource(BrainmapsSkeletonSource, {
            credentialsProvider: this.credentialsProvider,
            parameters: this.getMeshSourceParameters(url)
        });
    }
    getMultiscaleInfo(chunkManager, volumeId) {
        return chunkManager.memoize.getUncounted({
            type: 'brainmaps:getMultiscaleInfo',
            volumeId,
            instance: this.instance,
            credentialsProvider: Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_18__["getObjectId"])(this.credentialsProvider)
        }, () => Object(neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_6__["makeRequest"])(this.instance, this.credentialsProvider, {
            method: 'GET',
            path: `/v1beta2/volumes/${volumeId}`,
            responseType: 'json'
        }).then(response => new MultiscaleVolumeInfo(response)));
    }
    getVolume(chunkManager, key, options) {
        const { volumeId, changeSpec, parameters } = parseVolumeKey(key);
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObject"])(parameters);
        const encoding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(parameters, 'encoding', x => x === undefined ? undefined : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyEnumString"])(x, neuroglancer_datasource_brainmaps_base__WEBPACK_IMPORTED_MODULE_7__["VolumeChunkEncoding"]));
        const chunkLayoutPreference = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyObjectProperty"])(parameters, 'chunkLayout', x => x === undefined ? undefined : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_17__["verifyEnumString"])(x, neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_11__["ChunkLayoutPreference"]));
        const brainmapsOptions = Object.assign({}, options, { encoding, chunkLayoutPreference });
        return chunkManager.memoize.getUncounted({
            type: 'brainmaps:getVolume',
            instance: this.instance,
            volumeId,
            changeSpec,
            brainmapsOptions
        }, () => Promise
            .all([
            this.getMultiscaleInfo(chunkManager, volumeId),
            Object(neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_6__["makeRequest"])(this.instance, this.credentialsProvider, {
                method: 'GET',
                path: `/v1beta2/objects/${volumeId}/meshes`,
                responseType: 'json'
            }),
        ])
            .then(([multiscaleVolumeInfo, meshesResponse]) => new MultiscaleVolumeChunkSource(chunkManager, this.instance, this.credentialsProvider, volumeId, changeSpec, multiscaleVolumeInfo, meshesResponse, brainmapsOptions)));
    }
    getAnnotationSource(chunkManager, key) {
        const { volumeId, changeSpec } = parseVolumeKey(key);
        if (changeSpec === undefined) {
            throw new Error(`A changestack must be specified.`);
        }
        const parameters = {
            volumeId,
            changestack: changeSpec.changeStackId,
            instance: this.instance,
        };
        return chunkManager.memoize.getUncounted({
            type: 'brainmaps:getAnnotationSource',
            instance: this.instance,
            credentialsProvider: Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_18__["getObjectId"])(this.credentialsProvider),
            parameters
        }, () => this.getMultiscaleInfo(chunkManager, volumeId)
            .then(multiscaleVolumeInfo => chunkManager.getChunkSource(BrainmapsAnnotationSource, {
            parameters,
            credentialsProvider: this.credentialsProvider,
            multiscaleVolumeInfo
        })));
    }
    getProjectList(chunkManager) {
        return chunkManager.memoize.getUncounted({ instance: this.instance, type: 'brainmaps:getProjectList' }, () => {
            let promise = Object(neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_6__["makeRequest"])(this.instance, this.credentialsProvider, {
                method: 'GET',
                path: '/v1beta2/projects',
                responseType: 'json'
            }).then((projectsResponse) => {
                return parseProjectList(projectsResponse);
            });
            const description = `${this.instance.description} project list`;
            neuroglancer_status__WEBPACK_IMPORTED_MODULE_14__["StatusMessage"].forPromise(promise, {
                delay: true,
                initialMessage: `Retrieving ${description}.`,
                errorPrefix: `Error retrieving ${description}: `,
            });
            return promise;
        });
    }
    getDatasetList(chunkManager, project) {
        return chunkManager.memoize.getUncounted({ instance: this.instance, type: `brainmaps:${project}:getDatasetList` }, () => {
            let promise = Object(neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_6__["makeRequest"])(this.instance, this.credentialsProvider, {
                method: 'GET',
                path: `/v1beta2/datasets?project_id=${project}`,
                responseType: 'json'
            }).then((datasetsResponse) => {
                return parseAPIResponseList(datasetsResponse, 'datasetIds');
            });
            const description = `${this.instance.description} dataset list`;
            neuroglancer_status__WEBPACK_IMPORTED_MODULE_14__["StatusMessage"].forPromise(promise, {
                delay: true,
                initialMessage: `Retrieving ${description}`,
                errorPrefix: `Error retrieving ${description}`
            });
            return promise;
        });
    }
    getVolumeList(chunkManager, project, dataset) {
        return chunkManager.memoize.getUncounted({ instance: this.instance, type: `brainmaps:${project}:${dataset}:getVolumeList` }, () => {
            let promise = Object(neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_6__["makeRequest"])(this.instance, this.credentialsProvider, {
                method: 'GET',
                path: `/v1beta2/volumes?project_id=${project}&dataset_id=${dataset}`,
                responseType: 'json'
            }).then((volumesResponse) => {
                const fullyQualifyiedVolumeList = parseAPIResponseList(volumesResponse, 'volumeId');
                const splitPoint = project.length + dataset.length + 2;
                const volumeList = [];
                for (const volume of fullyQualifyiedVolumeList) {
                    volumeList.push(volume.substring(splitPoint));
                }
                return volumeList;
            });
            const description = `${this.instance.description} volume list`;
            neuroglancer_status__WEBPACK_IMPORTED_MODULE_14__["StatusMessage"].forPromise(promise, {
                delay: true,
                initialMessage: `Retrieving ${description}`,
                errorPrefix: `Error retrieving ${description}`
            });
            return promise;
        });
    }
    getChangeStackList(chunkManager, volumeId) {
        return chunkManager.memoize.getUncounted({ instance: this.instance, type: 'brainmaps:getChangeStackList', volumeId }, () => {
            let promise = Object(neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_6__["makeRequest"])(this.instance, this.credentialsProvider, {
                method: 'GET',
                path: `/v1beta2/changes/${volumeId}/change_stacks`,
                responseType: 'json'
            }).then(response => parseChangeStackList(response));
            const description = `change stacks for ${volumeId}`;
            neuroglancer_status__WEBPACK_IMPORTED_MODULE_14__["StatusMessage"].forPromise(promise, {
                delay: true,
                initialMessage: `Retrieving ${description}.`,
                errorPrefix: `Error retrieving ${description}: `,
            });
            return promise;
        });
    }
    volumeCompleter(url, chunkManager) {
        let colonCount = 0;
        const colonIndices = [];
        for (let lastColon = url.indexOf(':'); lastColon >= 0; lastColon = url.indexOf(':', lastColon + 1)) {
            colonIndices.push(lastColon);
            ++colonCount;
        }
        switch (colonCount) {
            case 0: { // Fetch project names
                return this.getProjectList(chunkManager).then((projectMetadata) => {
                    let projectList = [];
                    let descriptionMap = new Map();
                    for (const projectDatum of projectMetadata) {
                        const projectColon = projectDatum.id + ':';
                        projectList.push(projectColon);
                        descriptionMap.set(projectColon, projectDatum.label);
                    }
                    return {
                        offset: 0,
                        completions: Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_15__["getPrefixMatchesWithDescriptions"])(url, projectList, x => x, x => descriptionMap.get(x))
                    };
                });
            }
            case 1: { // Fetch dataset names, under the current project
                const colonLocation = colonIndices[0];
                const projectId = url.substring(0, colonLocation);
                return this.getDatasetList(chunkManager, projectId).then((datasetList) => {
                    const splitPoint = colonLocation + 1;
                    const matchString = url.substring(splitPoint);
                    const possibleMatches = [];
                    for (const datasetName of datasetList) {
                        possibleMatches.push(datasetName + ':');
                    }
                    possibleMatches.sort();
                    return { offset: splitPoint, completions: Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_15__["getPrefixMatches"])(matchString, possibleMatches) };
                });
            }
            case 2: { // Fetch volume names, under the current project and dataset
                const projectId = url.substring(0, colonIndices[0]);
                const datasetId = url.substring(colonIndices[0] + 1, colonIndices[1]);
                const splitPoint = colonIndices[1] + 1;
                return this.getVolumeList(chunkManager, projectId, datasetId).then((volumeList) => {
                    const matchString = url.substring(splitPoint);
                    return { offset: splitPoint, completions: Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_15__["getPrefixMatches"])(matchString, volumeList) };
                });
            }
            default: { // Fetch changestack names, under the current volume
                const volumeId = url.substring(0, colonIndices[2]);
                const splitPoint = colonIndices[2] + 1;
                const matchString = url.substring(splitPoint);
                return this.getChangeStackList(chunkManager, volumeId).then(changeStacks => {
                    if (changeStacks === undefined) {
                        throw null;
                    }
                    return { offset: splitPoint, completions: Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_15__["getPrefixMatches"])(matchString, changeStacks) };
                });
            }
        }
    }
}
const productionInstance = {
    description: 'Google Brain Maps',
    serverUrl: 'https://brainmaps.googleapis.com',
};


/***/ }),

/***/ "./src/neuroglancer/datasource/brainmaps/register_credentials_provider.ts":
/*!********************************************************************************!*\
  !*** ./src/neuroglancer/datasource/brainmaps/register_credentials_provider.ts ***!
  \********************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_credentials_provider_default_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider/default_manager */ "./src/neuroglancer/credentials_provider/default_manager.ts");
/* harmony import */ var neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/brainmaps/api */ "./src/neuroglancer/datasource/brainmaps/api.ts");
/* harmony import */ var neuroglancer_datasource_brainmaps_credentials_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource/brainmaps/credentials_provider */ "./src/neuroglancer/datasource/brainmaps/credentials_provider.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



neuroglancer_credentials_provider_default_manager__WEBPACK_IMPORTED_MODULE_0__["defaultCredentialsManager"].register(neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_1__["credentialsKey"], () => new neuroglancer_datasource_brainmaps_credentials_provider__WEBPACK_IMPORTED_MODULE_2__["BrainmapsCredentialsProvider"]("639403125587-4k5hgdfumtrvur8v48e3pr7oo91d765k.apps.googleusercontent.com"));


/***/ }),

/***/ "./src/neuroglancer/datasource/brainmaps/register_default.ts":
/*!*******************************************************************!*\
  !*** ./src/neuroglancer/datasource/brainmaps/register_default.ts ***!
  \*******************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_brainmaps_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/brainmaps/frontend */ "./src/neuroglancer/datasource/brainmaps/frontend.ts");
/* harmony import */ var neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/brainmaps/api */ "./src/neuroglancer/datasource/brainmaps/api.ts");
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_2__["registerProvider"])('brainmaps', options => new neuroglancer_datasource_brainmaps_frontend__WEBPACK_IMPORTED_MODULE_0__["BrainmapsDataSource"](neuroglancer_datasource_brainmaps_frontend__WEBPACK_IMPORTED_MODULE_0__["productionInstance"], options.credentialsManager.getCredentialsProvider(neuroglancer_datasource_brainmaps_api__WEBPACK_IMPORTED_MODULE_1__["credentialsKey"])));


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/base.ts":
/*!******************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/base.ts ***!
  \******************************************************/
/*! exports provided: ComputedVolumeChunkSourceParameters, ComputationParameters, getArrayView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputedVolumeChunkSourceParameters", function() { return ComputedVolumeChunkSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputationParameters", function() { return ComputationParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayView", function() { return getArrayView; });
/* harmony import */ var neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/data_type */ "./src/neuroglancer/util/data_type.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ComputedVolumeChunkSourceParameters {
}
ComputedVolumeChunkSourceParameters.RPC_ID = 'computed/ComputedVolumeChunkSourceParameters';
// Parameters that specify data type, volume type, and size for the input and
// output buffers relative to a computation. This information will ultimately
// pass to the VolumeComputationBackend that executes the computation. Extend
// this interface to add parameters - any additional parameters should be
// optional to allow direct assignment to work between types.
class ComputationParameters {
}
function getArrayView(buffer, type) {
    switch (type) {
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].UINT8:
            return new Uint8Array(buffer);
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].UINT16:
            return new Uint16Array(buffer);
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].UINT32:
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].UINT64:
            return new Uint32Array(buffer);
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].FLOAT32:
            return new Float32Array(buffer);
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/example/base.ts":
/*!**************************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/example/base.ts ***!
  \**************************************************************/
/*! exports provided: EXAMPLE_COMPUTATION_RPC_ID, ExampleComputationParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXAMPLE_COMPUTATION_RPC_ID", function() { return EXAMPLE_COMPUTATION_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExampleComputationParameters", function() { return ExampleComputationParameters; });
/* harmony import */ var neuroglancer_datasource_computed_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/computed/base */ "./src/neuroglancer/datasource/computed/base.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const EXAMPLE_COMPUTATION_RPC_ID = 'Computation.ExampleComputation';
class ExampleComputationParameters extends neuroglancer_datasource_computed_base__WEBPACK_IMPORTED_MODULE_0__["ComputationParameters"] {
}


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/example/frontend.ts":
/*!******************************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/example/frontend.ts ***!
  \******************************************************************/
/*! exports provided: ExampleComputation, ExampleComputationProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExampleComputation", function() { return ExampleComputation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExampleComputationProvider", function() { return ExampleComputationProvider; });
/* harmony import */ var neuroglancer_datasource_computed_example_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/computed/example/base */ "./src/neuroglancer/datasource/computed/example/base.ts");
/* harmony import */ var neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/computed/frontend */ "./src/neuroglancer/datasource/computed/frontend.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let ExampleComputation = class ExampleComputation extends neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_1__["VolumeComputationFrontend"] {
};
ExampleComputation = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_3__["registerSharedObjectOwner"])(neuroglancer_datasource_computed_example_base__WEBPACK_IMPORTED_MODULE_0__["EXAMPLE_COMPUTATION_RPC_ID"])
], ExampleComputation);

class ExampleComputationProvider {
    getComputation(config, {}, params) {
        const computeParams = params.computationParameters;
        if (config['inputSize'] !== undefined) {
            const inputSize = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dVec"])(config['inputSize']);
            computeParams.inputSpec.size.set(inputSize);
        }
        if (config['outputSize'] !== undefined) {
            const outputSize = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verify3dVec"])(config['outputSize']);
            computeParams.outputSpec.size.set(outputSize);
        }
        return Promise.resolve(new ExampleComputation(computeParams));
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/example/register_default.ts":
/*!**************************************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/example/register_default.ts ***!
  \**************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_computed_example_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/computed/example/frontend */ "./src/neuroglancer/datasource/computed/example/frontend.ts");
/* harmony import */ var neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/computed/frontend */ "./src/neuroglancer/datasource/computed/frontend.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_1__["ComputedDataSource"].registerComputation('example', new neuroglancer_datasource_computed_example_frontend__WEBPACK_IMPORTED_MODULE_0__["ExampleComputationProvider"]());


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/frontend.ts":
/*!**********************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/frontend.ts ***!
  \**********************************************************/
/*! exports provided: VolumeComputationFrontend, ComputedMultiscaleVolumeChunkSource, ComputedDataSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeComputationFrontend", function() { return VolumeComputationFrontend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputedMultiscaleVolumeChunkSource", function() { return ComputedMultiscaleVolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputedDataSource", function() { return ComputedDataSource; });
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/* harmony import */ var neuroglancer_datasource_computed_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource/computed/base */ "./src/neuroglancer/datasource/computed/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








class ComputedVolumeChunkSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_4__["VolumeChunkSource"], neuroglancer_datasource_computed_base__WEBPACK_IMPORTED_MODULE_2__["ComputedVolumeChunkSourceParameters"])) {
}
class VolumeComputationFrontend extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_7__["SharedObject"] {
    constructor(params) {
        super();
        this.params = params;
    }
}
class ComputedMultiscaleVolumeChunkSource {
    constructor(params, sources, computation, chunkManager) {
        this.params = params;
        this.sources = sources;
        this.computation = computation;
        this.chunkManager = chunkManager;
        this.numChannels = params.computationParameters.outputSpec.numChannels;
        this.dataType = params.computationParameters.outputSpec.dataType;
        this.volumeType = params.computationParameters.outputSpec.volumeType;
    }
    getSources(volumeSourceOptions) {
        const spec = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["VolumeChunkSpecification"].getDefaults({
            voxelSize: this.params.outputVoxelSize,
            dataType: this.dataType,
            numChannels: this.numChannels,
            chunkDataSizes: [this.params.computationParameters.outputSpec.size],
            transform: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].fromTranslation(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].create(), this.params.outputVoxelSize, this.params.outputVoxelOffset)),
            upperVoxelBound: this.params.outputVolumeSize,
            volumeType: this.volumeType,
            baseVoxelOffset: this.params.outputVoxelOffset,
            volumeSourceOptions,
        })[0];
        const originSource = this.sources[this.params.inputScaleIndex][this.params.inputSourceIndex];
        const inputResolution = originSource.spec.voxelSize;
        const parameters = {
            computationRef: this.computation.addCounterpartRef(),
            sourceRef: originSource.addCounterpartRef(),
            inputSize: this.params.computationParameters.inputSpec.size,
            scaleFactor: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].divide(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].create(), this.params.outputVoxelSize, inputResolution)
        };
        const computedSource = this.chunkManager.getChunkSource(ComputedVolumeChunkSource, { spec, parameters });
        return [[computedSource]];
    }
    getMeshSource() {
        return null;
    }
}
class ComputedDataSource extends neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_1__["DataSource"] {
    getOriginVolumes(dataSourceProvider, originUrl, chunkManager, cancellationToken) {
        return dataSourceProvider.getVolume(chunkManager, originUrl, {}, cancellationToken)
            .then((multiScaleVolumeChunkSource) => {
            const sources = multiScaleVolumeChunkSource.getSources({});
            const specs = sources.map((volumeChunkSources) => {
                return volumeChunkSources.map((volumeChunkSource) => {
                    return volumeChunkSource.spec;
                });
            });
            return {
                specs,
                sources,
                volumeType: multiScaleVolumeChunkSource.volumeType,
                dataType: multiScaleVolumeChunkSource.dataType,
                numChannels: multiScaleVolumeChunkSource.numChannels,
            };
        });
    }
    /**
     * Creates a ComputedVolumeDataSourceParameters object with default values
     * populated from the first volume spec at native resolution.
     * @param volumeSpecs ComputedVolumeSpecs
     * @param originUrl url for the origin data source
     * @param dataSourceProvider
     * @returns ComputedVolumeDataSourceParameters
     */
    defaultParams(volumeSpecs, originUrl, dataSourceProvider) {
        const spec = volumeSpecs.sources[0][0].spec;
        // Default DataType, VolumeType, channel count
        const { dataType, volumeType, numChannels } = volumeSpecs;
        // Default chunk size, used for input and output computation buffer sizes.
        const size = spec.chunkDataSize;
        return {
            originUrl,
            computationParameters: {
                inputSpec: { size: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].copy(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].create(), size), dataType, volumeType, numChannels },
                outputSpec: { size: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].copy(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].create(), size), dataType, volumeType, numChannels }
            },
            inputScaleIndex: 0,
            inputSourceIndex: 0,
            outputVoxelSize: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].copy(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].create(), spec.voxelSize),
            outputVolumeSize: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].copy(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].create(), spec.upperVoxelBound),
            outputVoxelOffset: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].copy(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].create(), spec.baseVoxelOffset),
            dataSourceProvider
        };
    }
    get description() {
        return 'Computed data source.';
    }
    getVolume(chunkManager, config, options, cancellationToken) {
        // Config is expected to be a json string, for example:
        //   {"origin":"brainmaps://p:d:v","computation":"example","inputSize":
        //     [36,36,32],"outputSize":[32,32,32]}
        console.log('Computed datasource config:', config);
        if (!options.dataSourceProvider) {
            return Promise.reject(new Error('Need a DataSourceProvider'));
        }
        const dataSourceProvider = options.dataSourceProvider;
        let configObj;
        try {
            configObj = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_6__["verifyObject"])(JSON.parse(config));
        }
        catch (error) {
            return Promise.reject(new Error(`Could not parse JSON configuration while initializing computational datasource: ${error}`));
        }
        if (!configObj) {
            return Promise.reject(new Error('Could not verify configuration JSON'));
        }
        if (configObj['origin'] === undefined) {
            return Promise.reject(new Error('Config is missing origin'));
        }
        if (configObj['computation'] === undefined) {
            return Promise.reject(new Error('Config is missing computation'));
        }
        const computationName = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_6__["verifyString"])(configObj['computation']);
        const computationProvider = ComputedDataSource.computationMap.get(computationName);
        const originUrl = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_6__["verifyString"])(configObj['origin']);
        if (!computationProvider) {
            return Promise.reject(new Error(`Unable to find computation ${computationName}`));
        }
        return this.getOriginVolumes(dataSourceProvider, originUrl, chunkManager, cancellationToken)
            .then((volumes) => {
            const dataSourceParams = this.defaultParams(volumes, originUrl, dataSourceProvider);
            return chunkManager.memoize.getUncounted({ type: 'computed:getVolume', config: configObj }, () => computationProvider.getComputation(configObj, volumes.sources, dataSourceParams)
                .then((computation) => {
                computation.initializeCounterpart(chunkManager.rpc, computation.params);
                return new ComputedMultiscaleVolumeChunkSource(dataSourceParams, volumes.sources, computation, chunkManager);
            }));
        });
    }
    static registerComputation(key, computationProvider) {
        this.computationMap.set(key, computationProvider);
    }
}
ComputedDataSource.computationMap = new Map();


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/register_default.ts":
/*!******************************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/register_default.ts ***!
  \******************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/computed/frontend */ "./src/neuroglancer/datasource/computed/frontend.ts");
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


if (true) {
    Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__["registerProvider"])('computed', () => new neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_0__["ComputedDataSource"]());
}


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/tensorflow/base.ts":
/*!*****************************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/tensorflow/base.ts ***!
  \*****************************************************************/
/*! exports provided: TENSORFLOW_COMPUTATION_RPC_ID, TENSORFLOW_INFERENCE_RPC_ID, TensorflowComputationParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TENSORFLOW_COMPUTATION_RPC_ID", function() { return TENSORFLOW_COMPUTATION_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TENSORFLOW_INFERENCE_RPC_ID", function() { return TENSORFLOW_INFERENCE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorflowComputationParameters", function() { return TensorflowComputationParameters; });
/* harmony import */ var neuroglancer_datasource_computed_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/computed/base */ "./src/neuroglancer/datasource/computed/base.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const TENSORFLOW_COMPUTATION_RPC_ID = 'Computation.Tensorflow';
const TENSORFLOW_INFERENCE_RPC_ID = 'Computation.Tensorflow.Inference';
class TensorflowComputationParameters extends neuroglancer_datasource_computed_base__WEBPACK_IMPORTED_MODULE_0__["ComputationParameters"] {
}


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/tensorflow/frontend.ts":
/*!*********************************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/tensorflow/frontend.ts ***!
  \*********************************************************************/
/*! exports provided: loadTFjs, TensorflowComputation, TensorflowComputationProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadTFjs", function() { return loadTFjs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorflowComputation", function() { return TensorflowComputation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorflowComputationProvider", function() { return TensorflowComputationProvider; });
/* harmony import */ var neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/computed/frontend */ "./src/neuroglancer/datasource/computed/frontend.ts");
/* harmony import */ var neuroglancer_datasource_computed_tensorflow_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/computed/tensorflow/base */ "./src/neuroglancer/datasource/computed/tensorflow/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






let tfjs = null;
function loadTFjs() {
    if (tfjs) {
        return Promise.resolve();
    }
    return __webpack_require__.e(/*! import() | tfjs-library */ "tfjs-library").then(__webpack_require__.bind(null, /*! @tensorflow/tfjs */ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js")).then((module) => {
        tfjs = module;
    });
}
let TensorflowComputation = class TensorflowComputation extends neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_0__["VolumeComputationFrontend"] {
    constructor(params, model_) {
        super(params);
        this.model_ = model_;
        // The queue of pending inference requests. Maintained in order of increasing
        // priority, so that pop() always returns the next appropriate request.
        this.inferenceQueue_ = [];
        // True iff the inference loop is in operation.
        this.running_ = false;
    }
    /**
     * Adds a TF.js-compatible typed array to the inference queue and starts the
     * inference loop, if it isn't already running. Returns a promise that
     * resolves with the prediction output.
     *
     * Creates a PendingInference object and inserts it into the correct position
     * in the inference queue, which is guaranteed to be less than the length of
     * the backend computation queue in length. As such, it is most likely
     * faster to simply iterate the queue to insert the request rather than using
     * a more sophisticated method like binary insertion or a tree-based queue.
     * @param array the input data to run inference over
     * @param priority
     * @param cancellationToken
     */
    predict(array, priority, cancellationToken) {
        return new Promise((resolve, reject) => {
            let i;
            const queue = this.inferenceQueue_;
            for (i = 0; i < queue.length && queue[i].priority < priority; ++i) {
            }
            queue.splice(i, 0, { array, cancellationToken, priority, resolve, reject });
            this.startInference();
        })
            .then((result) => {
            return { value: result, transfers: [result.outputBuffer.buffer] };
        });
    }
    /**
     * Start the inference loop, if it isn't already running.
     */
    startInference() {
        if (this.running_) {
            return;
        }
        this.running_ = true;
        setTimeout(() => this.runInference_(), 0);
    }
    /**
     * Run the inference loop recursively.
     */
    runInference_() {
        if (this.inferenceQueue_.length === 0) {
            this.running_ = false;
            return;
        }
        const pendingInference = this.inferenceQueue_.pop();
        if (pendingInference.cancellationToken.isCanceled) {
            pendingInference.reject(neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_3__["CANCELED"]);
            this.runInference_();
            return;
        }
        this.modelInference_(pendingInference).then(() => this.runInference_());
    }
    /**
     * Executes tf.js prediction, resolving or rejecting the pending request's
     * promise, as appropriate.
     * @param inferenceRequest  the request to infer.
     */
    modelInference_(inferenceRequest) {
        const inputLength = inferenceRequest.array.length;
        const expectedLength = this.params.inputTensorNumElements;
        if (inputLength !== expectedLength) {
            inferenceRequest.reject(new Error(`Input array has ${inputLength} elements. Expected ${expectedLength}`));
            return Promise.resolve();
        }
        const prediction = tfjs.tidy(() => {
            const modelInput = tfjs.tensor(inferenceRequest.array).reshape(this.params.inputTensorShape);
            const model = this.model_;
            return model.predict(modelInput, {});
        });
        return prediction.data()
            .then((outputBuffer) => {
            prediction.dispose();
            const result = { outputBuffer };
            inferenceRequest.resolve(result);
        })
            .then(() => {
            return new Promise((resolve) => {
                setTimeout(() => resolve(), 10);
            });
        });
    }
};
TensorflowComputation = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_5__["registerSharedObjectOwner"])(neuroglancer_datasource_computed_tensorflow_base__WEBPACK_IMPORTED_MODULE_1__["TENSORFLOW_COMPUTATION_RPC_ID"])
], TensorflowComputation);

class TensorflowComputationProvider {
    getComputation(config, {}, params) {
        let modelPath = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyString"])(config['modelPath']);
        if (!modelPath.endsWith('/')) {
            modelPath += '/';
        }
        let model;
        let stdDev = 1.0;
        let mean = 0.0;
        let outputType = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_2__["VolumeType"].SEGMENTATION;
        if (config['stdDev'] !== undefined) {
            stdDev = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyFloat"])(config['stdDev']);
        }
        if (config['mean'] !== undefined) {
            mean = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyFloat"])(config['mean']);
        }
        if (config['atype'] !== undefined) {
            const atype = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyString"])(config['atype']);
            switch (atype) {
                case 'classifier':
                    break;
                case 'regressor':
                    outputType = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_2__["VolumeType"].IMAGE;
                    break;
                default:
                    throw new Error(`Unknown algorithm type ${atype}. Must be "classifier" or "regressor"`);
            }
        }
        // Load the model, then do a dummy inference run. This allows us to
        // explicitly discover the output dimensions, and to compile the
        // model on the gpu.
        return loadTFjs()
            .then(() => {
            return tfjs.loadFrozenModel(modelPath + 'tensorflowjs_model.pb', modelPath + 'weights_manifest.json');
        })
            .then((tfModel) => {
            model = tfModel;
            if (model.inputs.length !== 1) {
                throw new Error('Only models with exactly one input are supported');
            }
            if (model.outputs.length !== 1) {
                // Todo: support for multiple-output models.
                throw new Error('Only models with exactly one output are supported');
            }
            // Create a blank tensor, run prediction, check output size
            const dummyOutput = tfjs.tidy(() => {
                const dummyInput = tfjs.ones(model.inputs[0].shape);
                return model.predict(dummyInput, {});
            });
            return dummyOutput.data().then(() => {
                return dummyOutput;
            });
        })
            .then((outputTensor) => {
            const inputShape = [1, 1, 1];
            const outputShape = [1, 1, 1];
            const inputTensor = model.inputs[0];
            const inputDType = inputTensor.dtype;
            let idx = 0;
            for (let dim of inputTensor.shape) {
                if (dim > 1) {
                    inputShape[idx] = dim;
                    ++idx;
                }
                if (idx >= 3) {
                    throw new Error(`Cannot support tensorflow model with input ndim > 3: ${inputTensor.shape}`);
                }
            }
            idx = 0;
            for (let dim of outputTensor.shape) {
                if (dim > 1) {
                    outputShape[idx] = dim;
                    ++idx;
                }
                if (idx >= 3) {
                    throw new Error(`Cannot support tensorflow model with output ndim > 3: ${outputTensor.shape}`);
                }
            }
            outputTensor.dispose();
            let numElements = 1.0;
            for (const dim of inputTensor.shape) {
                numElements *= dim;
            }
            const tfParams = params.computationParameters;
            tfParams.inputSpec.size.set(inputShape);
            tfParams.outputSpec.size.set(outputShape);
            tfParams.outputSpec.dataType = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_2__["DataType"].UINT32;
            tfParams.outputSpec.volumeType = outputType;
            tfParams.inputDType = inputDType;
            tfParams.mean = mean;
            tfParams.stdDev = stdDev;
            tfParams.inputTensorShape = inputTensor.shape;
            tfParams.inputTensorNumElements = numElements;
            return new TensorflowComputation(tfParams, model);
        });
    }
}
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_5__["registerPromiseRPC"])(neuroglancer_datasource_computed_tensorflow_base__WEBPACK_IMPORTED_MODULE_1__["TENSORFLOW_INFERENCE_RPC_ID"], function (x, cancellationToken) {
    const request = x.inferenceRequest;
    const computation = this.get(request.computationRef);
    return computation.predict(request.inputBuffer, request.priority, cancellationToken);
});


/***/ }),

/***/ "./src/neuroglancer/datasource/computed/tensorflow/register_default.ts":
/*!*****************************************************************************!*\
  !*** ./src/neuroglancer/datasource/computed/tensorflow/register_default.ts ***!
  \*****************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/computed/frontend */ "./src/neuroglancer/datasource/computed/frontend.ts");
/* harmony import */ var neuroglancer_datasource_computed_tensorflow_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/computed/tensorflow/frontend */ "./src/neuroglancer/datasource/computed/tensorflow/frontend.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


neuroglancer_datasource_computed_frontend__WEBPACK_IMPORTED_MODULE_0__["ComputedDataSource"].registerComputation('tensorflow', new neuroglancer_datasource_computed_tensorflow_frontend__WEBPACK_IMPORTED_MODULE_1__["TensorflowComputationProvider"]());


/***/ }),

/***/ "./src/neuroglancer/datasource/csv/frontend.ts":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/datasource/csv/frontend.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./src/neuroglancer/datasource/default_provider.ts":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/datasource/default_provider.ts ***!
  \*********************************************************/
/*! exports provided: registerProvider, getDefaultDataSourceProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerProvider", function() { return registerProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultDataSourceProvider", function() { return getDefaultDataSourceProvider; });
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const providerFactories = new Map();
function registerProvider(name, factory) {
    providerFactories.set(name, factory);
}
function getDefaultDataSourceProvider(options) {
    const provider = new neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_0__["DataSourceProvider"]();
    for (const [name, factory] of providerFactories) {
        provider.register(name, factory(options));
    }
    return provider;
}


/***/ }),

/***/ "./src/neuroglancer/datasource/dvid/base.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/datasource/dvid/base.ts ***!
  \**************************************************/
/*! exports provided: VolumeChunkEncoding, DVIDSourceParameters, VolumeChunkSourceParameters, SkeletonSourceParameters, MeshSourceParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkEncoding", function() { return VolumeChunkEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DVIDSourceParameters", function() { return DVIDSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkSourceParameters", function() { return VolumeChunkSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonSourceParameters", function() { return SkeletonSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshSourceParameters", function() { return MeshSourceParameters; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VolumeChunkEncoding;
(function (VolumeChunkEncoding) {
    VolumeChunkEncoding[VolumeChunkEncoding["JPEG"] = 0] = "JPEG";
    VolumeChunkEncoding[VolumeChunkEncoding["RAW"] = 1] = "RAW";
    VolumeChunkEncoding[VolumeChunkEncoding["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
    VolumeChunkEncoding[VolumeChunkEncoding["COMPRESSED_SEGMENTATIONARRAY"] = 3] = "COMPRESSED_SEGMENTATIONARRAY";
})(VolumeChunkEncoding || (VolumeChunkEncoding = {}));
class DVIDSourceParameters {
}
class VolumeChunkSourceParameters extends DVIDSourceParameters {
}
VolumeChunkSourceParameters.RPC_ID = 'dvid/VolumeChunkSource';
class SkeletonSourceParameters extends DVIDSourceParameters {
}
SkeletonSourceParameters.RPC_ID = 'dvid/SkeletonSource';
class MeshSourceParameters extends DVIDSourceParameters {
}
MeshSourceParameters.RPC_ID = 'dvid/MeshSource';


/***/ }),

/***/ "./src/neuroglancer/datasource/dvid/frontend.ts":
/*!******************************************************!*\
  !*** ./src/neuroglancer/datasource/dvid/frontend.ts ***!
  \******************************************************/
/*! exports provided: DataInstanceBaseInfo, DataInstanceInfo, VolumeDataInstanceInfo, parseDataInstance, RepositoryInfo, parseRepositoriesInfo, ServerInfo, getServerInfo, getDataInstanceDetails, MultiscaleVolumeChunkSource, getVolume, completeInstanceName, completeNodeAndInstance, volumeCompleter, DVIDDataSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataInstanceBaseInfo", function() { return DataInstanceBaseInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataInstanceInfo", function() { return DataInstanceInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeDataInstanceInfo", function() { return VolumeDataInstanceInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDataInstance", function() { return parseDataInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepositoryInfo", function() { return RepositoryInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseRepositoriesInfo", function() { return parseRepositoriesInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ServerInfo", function() { return ServerInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getServerInfo", function() { return getServerInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDataInstanceDetails", function() { return getDataInstanceDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVolumeChunkSource", function() { return MultiscaleVolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVolume", function() { return getVolume; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "completeInstanceName", function() { return completeInstanceName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "completeNodeAndInstance", function() { return completeNodeAndInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "volumeCompleter", function() { return volumeCompleter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DVIDDataSource", function() { return DVIDDataSource; });
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/* harmony import */ var neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource/dvid/base */ "./src/neuroglancer/datasource/dvid/base.ts");
/* harmony import */ var neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/mesh/frontend */ "./src/neuroglancer/mesh/frontend.ts");
/* harmony import */ var neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/skeleton/frontend */ "./src/neuroglancer/skeleton/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/completion */ "./src/neuroglancer/util/completion.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/http_request */ "./src/neuroglancer/util/http_request.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Support for DVID (https://github.com/janelia-flyem/dvid) servers.
 */












let serverDataTypes = new Map();
serverDataTypes.set('uint8', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["DataType"].UINT8);
serverDataTypes.set('uint32', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["DataType"].UINT32);
serverDataTypes.set('uint64', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["DataType"].UINT64);
class DataInstanceBaseInfo {
    constructor(obj) {
        this.obj = obj;
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(obj);
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'TypeName', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
    }
    get typeName() {
        return this.obj['TypeName'];
    }
    get compressionName() {
        return this.obj['Compression'];
    }
}
class DataInstanceInfo {
    constructor(obj, name, base) {
        this.obj = obj;
        this.name = name;
        this.base = base;
    }
}
class DVIDVolumeChunkSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_6__["VolumeChunkSource"], neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkSourceParameters"])) {
}
class DVIDSkeletonSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_4__["SkeletonSource"], neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["SkeletonSourceParameters"])) {
}
class DVIDMeshSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_3__["MeshSource"], neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["MeshSourceParameters"])) {
}
class VolumeDataInstanceInfo extends DataInstanceInfo {
    constructor(obj, name, base, encoding, instanceNames) {
        super(obj, name, base);
        this.encoding = encoding;
        let extended = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'Extended', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"]);
        let extendedValues = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(extended, 'Values', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseArray"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"]));
        if (extendedValues.length < 1) {
            throw new Error('Expected Extended.Values property to have length >= 1, but received: ${JSON.stringify(extendedValues)}.');
        }
        this.numLevels = 1;
        let instSet = new Set(instanceNames);
        if (encoding === neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATIONARRAY) {
            // retrieve maximum downres level
            let maxdownreslevel = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(extended, 'MaxDownresLevel', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyPositiveInt"]);
            this.numLevels = maxdownreslevel + 1;
        }
        else {
            // labelblk does not have explicit datatype support for multiscale but
            // by convention different levels are specified with unique
            // instances where levels are distinguished by the suffix '_LEVELNUM'
            while (instSet.has(name + '_' + this.numLevels.toString())) {
                this.numLevels += 1;
            }
        }
        // only allow mesh or skeletons as sources but not both
        this.meshSrc = '';
        if (instSet.has(name + '_meshes')) {
            this.meshSrc = name + '_meshes';
        }
        this.skeletonSrc = '';
        if (this.meshSrc !== '') {
            if (instSet.has(name + '_skeletons')) {
                this.skeletonSrc = name + '_skeletons';
            }
        }
        this.dataType =
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(extendedValues[0], 'DataType', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyMapKey"])(x, serverDataTypes));
        this.voxelSize = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(extended, 'VoxelSize', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyFinitePositiveFloat"]));
        this.numChannels = 1;
    }
    get volumeType() {
        return ((this.encoding === neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATION ||
            this.encoding === neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATIONARRAY) ?
            neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["VolumeType"].SEGMENTATION :
            neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["VolumeType"].IMAGE);
    }
    getSources(chunkManager, parameters, volumeSourceOptions) {
        let { encoding } = this;
        let sources = [];
        // must be 64 block size to work with neuroglancer properly
        let blocksize = 64;
        for (let level = 0; level < this.numLevels; ++level) {
            let voxelSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].scale(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), this.voxelSize, Math.pow(2, level));
            let lowerVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create();
            let upperVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create();
            for (let i = 0; i < 3; ++i) {
                let lowerVoxelNotAligned = Math.floor(this.lowerVoxelBound[i] * (this.voxelSize[i] / voxelSize[i]));
                // adjust min to be a multiple of blocksize
                lowerVoxelBound[i] = lowerVoxelNotAligned - (lowerVoxelNotAligned % blocksize);
                let upperVoxelNotAligned = Math.ceil((this.upperVoxelBound[i] + 1) * (this.voxelSize[i] / voxelSize[i]));
                upperVoxelBound[i] = upperVoxelNotAligned;
                // adjust max to be a multiple of blocksize
                if ((upperVoxelNotAligned % blocksize) !== 0) {
                    upperVoxelBound[i] += (blocksize - (upperVoxelNotAligned % blocksize));
                }
            }
            let dataInstanceKey = parameters.dataInstanceKey;
            if (encoding !== neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATIONARRAY) {
                if (level > 0) {
                    dataInstanceKey += '_' + level.toString();
                }
            }
            let volParameters = {
                'baseUrl': parameters.baseUrl,
                'nodeKey': parameters.nodeKey,
                'dataInstanceKey': dataInstanceKey,
                'dataScale': level.toString(),
                'encoding': encoding,
            };
            let alternatives = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["VolumeChunkSpecification"]
                .getDefaults({
                voxelSize: voxelSize,
                dataType: this.dataType,
                numChannels: this.numChannels,
                transform: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].fromTranslation(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), lowerVoxelBound, voxelSize)),
                baseVoxelOffset: lowerVoxelBound,
                upperVoxelBound: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].subtract(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), upperVoxelBound, lowerVoxelBound),
                volumeType: this.volumeType,
                volumeSourceOptions,
                compressedSegmentationBlockSize: ((encoding === neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATION ||
                    encoding === neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATIONARRAY) ?
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].fromValues(8, 8, 8) :
                    undefined)
            })
                .map(spec => {
                return chunkManager.getChunkSource(DVIDVolumeChunkSource, { spec, parameters: volParameters });
            });
            sources.push(alternatives);
        }
        return sources;
    }
    getMeshSource(chunkManager, parameters) {
        if (this.meshSrc !== '') {
            return chunkManager.getChunkSource(DVIDMeshSource, {
                parameters: {
                    'baseUrl': parameters.baseUrl,
                    'nodeKey': parameters.nodeKey,
                    'dataInstanceKey': this.meshSrc,
                }
            });
        }
        else {
            return null;
        }
    }
    getSkeletonSource(chunkManager, parameters) {
        if (this.skeletonSrc !== '') {
            return chunkManager.getChunkSource(DVIDSkeletonSource, {
                parameters: {
                    'baseUrl': parameters.baseUrl,
                    'nodeKey': parameters.nodeKey,
                    'dataInstanceKey': this.skeletonSrc,
                }
            });
        }
        else {
            return null;
        }
    }
}
function parseDataInstance(obj, name, instanceNames) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(obj);
    let baseInfo = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'Base', x => new DataInstanceBaseInfo(x));
    switch (baseInfo.typeName) {
        case 'uint8blk':
        case 'grayscale8':
            let isjpegcompress = baseInfo.compressionName.indexOf('jpeg') !== -1;
            return new VolumeDataInstanceInfo(obj, name, baseInfo, (isjpegcompress ? neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].JPEG : neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].RAW), instanceNames);
        case 'labels64':
        case 'labelblk':
            return new VolumeDataInstanceInfo(obj, name, baseInfo, neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATION, instanceNames);
        case 'labelarray':
        case 'labelmap':
            return new VolumeDataInstanceInfo(obj, name, baseInfo, neuroglancer_datasource_dvid_base__WEBPACK_IMPORTED_MODULE_2__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATIONARRAY, instanceNames);
        default:
            throw new Error(`DVID data type ${JSON.stringify(baseInfo.typeName)} is not supported.`);
    }
}
class RepositoryInfo {
    constructor(obj) {
        this.errors = [];
        this.dataInstances = new Map();
        this.vnodes = new Set();
        if (obj instanceof RepositoryInfo) {
            this.alias = obj.alias;
            this.description = obj.description;
            // just copy references
            this.errors = obj.errors;
            this.dataInstances = obj.dataInstances;
            return;
        }
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(obj);
        this.alias = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'Alias', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
        this.description = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'Description', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
        let dataInstanceObjs = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'DataInstances', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"]);
        let instanceKeys = Object.keys(dataInstanceObjs);
        for (let key of instanceKeys) {
            try {
                this.dataInstances.set(key, parseDataInstance(dataInstanceObjs[key], key, instanceKeys));
            }
            catch (parseError) {
                let message = `Failed to parse data instance ${JSON.stringify(key)}: ${parseError.message}`;
                console.log(message);
                this.errors.push(message);
            }
        }
        let dagObj = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'DAG', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"]);
        let nodeObjs = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(dagObj, 'Nodes', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"]);
        for (let key of Object.keys(nodeObjs)) {
            this.vnodes.add(key);
        }
    }
}
function parseRepositoriesInfo(obj) {
    try {
        let result = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectAsMap"])(obj, x => new RepositoryInfo(x));
        // make all versions available for viewing
        let allVersions = new Map();
        for (let [key, info] of result) {
            allVersions.set(key, info);
            for (let key2 of info.vnodes) {
                if (key2 !== key) {
                    // create new repo
                    let rep = new RepositoryInfo(info);
                    allVersions.set(key2, rep);
                }
            }
        }
        for (let [key, info] of allVersions) {
            info.uuid = key;
        }
        return allVersions;
    }
    catch (parseError) {
        throw new Error(`Failed to parse DVID repositories info: ${parseError.message}`);
    }
}
class ServerInfo {
    constructor(obj) {
        this.repositories = parseRepositoriesInfo(obj);
    }
    getNode(nodeKey) {
        // FIXME: Support non-root nodes.
        let matches = [];
        for (let key of this.repositories.keys()) {
            if (key.startsWith(nodeKey)) {
                matches.push(key);
            }
        }
        if (matches.length !== 1) {
            throw new Error(`Node key ${JSON.stringify(nodeKey)} matches ${JSON.stringify(matches)} nodes.`);
        }
        return this.repositories.get(matches[0]);
    }
}
function getServerInfo(chunkManager, baseUrl) {
    return chunkManager.memoize.getUncounted({ type: 'dvid:getServerInfo', baseUrl }, () => {
        const result = Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["fetchOk"])(`${baseUrl}/api/repos/info`)
            .then(response => response.json())
            .then(response => new ServerInfo(response));
        const description = `repository info for DVID server ${baseUrl}`;
        neuroglancer_status__WEBPACK_IMPORTED_MODULE_7__["StatusMessage"].forPromise(result, {
            initialMessage: `Retrieving ${description}.`,
            delay: true,
            errorPrefix: `Error retrieving ${description}: `,
        });
        return result;
    });
}
/**
 * Get extra dataInstance info that isn't available on the server level.
 * this requires an extra api call
 */
function getDataInstanceDetails(chunkManager, baseUrl, nodeKey, info) {
    return chunkManager.memoize.getUncounted({ type: 'dvid:getInstanceDetails', baseUrl, nodeKey, name: info.name }, () => {
        let result = Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["fetchOk"])(`${baseUrl}/api/node/${nodeKey}/${info.name}/info`)
            .then(response => response.json());
        const description = `datainstance info for node ${nodeKey} and instance ${info.name} ` +
            `on DVID server ${baseUrl}`;
        neuroglancer_status__WEBPACK_IMPORTED_MODULE_7__["StatusMessage"].forPromise(result, {
            initialMessage: `Retrieving ${description}.`,
            delay: true,
            errorPrefix: `Error retrieving ${description}: `,
        });
        return result.then(instanceDetails => {
            let extended = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(instanceDetails, 'Extended', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"]);
            info.lowerVoxelBound =
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(extended, 'MinPoint', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseIntVec"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), x));
            info.upperVoxelBound =
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(extended, 'MaxPoint', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseIntVec"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), x));
            return info;
        });
    });
}
class MultiscaleVolumeChunkSource {
    constructor(chunkManager, baseUrl, nodeKey, dataInstanceKey, info) {
        this.chunkManager = chunkManager;
        this.baseUrl = baseUrl;
        this.nodeKey = nodeKey;
        this.dataInstanceKey = dataInstanceKey;
        this.info = info;
    }
    get dataType() {
        return this.info.dataType;
    }
    get numChannels() {
        return this.info.numChannels;
    }
    get volumeType() {
        return this.info.volumeType;
    }
    getSources(volumeSourceOptions) {
        return this.info.getSources(this.chunkManager, {
            'baseUrl': this.baseUrl,
            'nodeKey': this.nodeKey,
            'dataInstanceKey': this.dataInstanceKey,
        }, volumeSourceOptions);
    }
    getMeshSource() {
        let meshSource = this.info.getMeshSource(this.chunkManager, {
            'baseUrl': this.baseUrl,
            'nodeKey': this.nodeKey,
            'dataInstanceKey': this.dataInstanceKey,
        });
        if (meshSource === null) {
            return this.info.getSkeletonSource(this.chunkManager, {
                'baseUrl': this.baseUrl,
                'nodeKey': this.nodeKey,
                'dataInstanceKey': this.dataInstanceKey,
            });
        }
        return meshSource;
    }
}
const urlPattern = /^((?:http|https):\/\/[^\/]+)\/([^\/]+)\/([^\/]+)$/;
function getVolume(chunkManager, url) {
    let match = url.match(urlPattern);
    if (match === null) {
        throw new Error(`Invalid DVID URL: ${JSON.stringify(url)}.`);
    }
    const baseUrl = match[1];
    const nodeKey = match[2];
    const dataInstanceKey = match[3];
    return getServerInfo(chunkManager, baseUrl)
        .then(serverInfo => {
        let repositoryInfo = serverInfo.getNode(nodeKey);
        if (repositoryInfo === undefined) {
            throw new Error(`Invalid node: ${JSON.stringify(nodeKey)}.`);
        }
        const dataInstanceInfo = repositoryInfo.dataInstances.get(dataInstanceKey);
        if (!(dataInstanceInfo instanceof VolumeDataInstanceInfo)) {
            throw new Error(`Invalid data instance ${dataInstanceKey}.`);
        }
        return getDataInstanceDetails(chunkManager, baseUrl, nodeKey, dataInstanceInfo);
    })
        .then((info) => {
        return chunkManager.memoize.getUncounted({
            type: 'dvid:MultiscaleVolumeChunkSource',
            baseUrl,
            nodeKey: nodeKey,
            dataInstanceKey,
        }, () => new MultiscaleVolumeChunkSource(chunkManager, baseUrl, nodeKey, dataInstanceKey, info));
    });
}
function completeInstanceName(repositoryInfo, prefix) {
    return {
        offset: 0,
        completions: Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__["getPrefixMatchesWithDescriptions"])(prefix, repositoryInfo.dataInstances.values(), instance => instance.name, instance => {
            return `${instance.base.typeName}`;
        })
    };
}
function completeNodeAndInstance(serverInfo, prefix) {
    let match = prefix.match(/^(?:([^\/]+)(?:\/([^\/]*))?)?$/);
    if (match === null) {
        throw new Error(`Invalid DVID URL syntax.`);
    }
    if (match[2] === undefined) {
        // Try to complete the node name.
        return {
            offset: 0,
            completions: Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__["getPrefixMatchesWithDescriptions"])(prefix, serverInfo.repositories.values(), repository => repository.uuid + '/', repository => `${repository.alias}: ${repository.description}`)
        };
    }
    let nodeKey = match[1];
    let repositoryInfo = serverInfo.getNode(nodeKey);
    return Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__["applyCompletionOffset"])(nodeKey.length + 1, completeInstanceName(repositoryInfo, match[2]));
}
function volumeCompleter(url, chunkManager) {
    const curUrlPattern = /^((?:http|https):\/\/[^\/]+)\/(.*)$/;
    let match = url.match(curUrlPattern);
    if (match === null) {
        // We don't yet have a full hostname.
        return Promise.reject(null);
    }
    let baseUrl = match[1];
    let path = match[2];
    return getServerInfo(chunkManager, baseUrl)
        .then(serverInfo => Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_8__["applyCompletionOffset"])(baseUrl.length + 1, completeNodeAndInstance(serverInfo, path)));
}
class DVIDDataSource extends neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_1__["DataSource"] {
    get description() {
        return 'DVID';
    }
    getVolume(chunkManager, url) {
        return getVolume(chunkManager, url);
    }
    volumeCompleter(url, chunkManager) {
        return volumeCompleter(url, chunkManager);
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/dvid/register_default.ts":
/*!**************************************************************!*\
  !*** ./src/neuroglancer/datasource/dvid/register_default.ts ***!
  \**************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_dvid_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/dvid/frontend */ "./src/neuroglancer/datasource/dvid/frontend.ts");
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__["registerProvider"])('dvid', () => new neuroglancer_datasource_dvid_frontend__WEBPACK_IMPORTED_MODULE_0__["DVIDDataSource"]());


/***/ }),

/***/ "./src/neuroglancer/datasource/index.ts":
/*!**********************************************!*\
  !*** ./src/neuroglancer/datasource/index.ts ***!
  \**********************************************/
/*! exports provided: RedirectError, findSourceGroupBasedOnSeparator, suggestLayerNameBasedOnSeparator, DataSource, DataSourceProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedirectError", function() { return RedirectError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findSourceGroupBasedOnSeparator", function() { return findSourceGroupBasedOnSeparator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "suggestLayerNameBasedOnSeparator", function() { return suggestLayerNameBasedOnSeparator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataSource", function() { return DataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataSourceProvider", function() { return DataSourceProvider; });
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/completion */ "./src/neuroglancer/util/completion.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class RedirectError extends Error {
    constructor(redirect_target) {
        super(`Redirected to: ${redirect_target}`);
        this.redirect_target = redirect_target;
    }
}
/**
 * Returns the length of the prefix of path that corresponds to the "group", according to the
 * specified separator.
 *
 * If the separator is not specified, gueses whether it is '/' or ':'.
 */
function findSourceGroupBasedOnSeparator(path, separator) {
    if (separator === undefined) {
        // Try to guess whether '/' or ':' is the separator.
        if (path.indexOf('/') === -1) {
            separator = ':';
        }
        else {
            separator = '/';
        }
    }
    let index = path.lastIndexOf(separator);
    if (index === -1) {
        return 0;
    }
    return index + 1;
}
/**
 * Returns the last "component" of path, according to the specified separator.
 * If the separator is not specified, gueses whether it is '/' or ':'.
 */
function suggestLayerNameBasedOnSeparator(path, separator) {
    let groupIndex = findSourceGroupBasedOnSeparator(path, separator);
    return path.substring(groupIndex);
}
class DataSource extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__["RefCounted"] {
}
const protocolPattern = /^(?:([a-zA-Z][a-zA-Z0-9-+_]*):\/\/)?(.*)$/;
class DataSourceProvider extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__["RefCounted"] {
    constructor() {
        super(...arguments);
        this.dataSources = new Map();
    }
    register(name, dataSource) {
        this.dataSources.set(name, this.registerDisposer(dataSource));
    }
    getDataSource(url) {
        let m = url.match(protocolPattern);
        if (m === null || m[1] === undefined) {
            throw new Error(`Data source URL must have the form "<protocol>://<path>".`);
        }
        let dataSource = m[1];
        let factory = this.dataSources.get(dataSource);
        if (factory === undefined) {
            throw new Error(`Unsupported data source: ${JSON.stringify(dataSource)}.`);
        }
        return [factory, m[2], dataSource];
    }
    getVolume(chunkManager, url, options = {}, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"], redirect_log = new Set()) {
        let [dataSource, path] = this.getDataSource(url);
        if (options === undefined) {
            options = {};
        }
        options.dataSourceProvider = this;
        redirect_log.add(url);
        return new Promise(resolve => {
            resolve(dataSource.getVolume(chunkManager, path, options, cancellationToken));
        })
            .catch((err) => {
            if (err instanceof RedirectError) {
                const redirect = err.redirect_target;
                if (redirect_log.has(redirect)) {
                    throw Error('Layer source redirection contains loop.');
                }
                if (redirect_log.size >= 10) {
                    throw Error('Too many layer source redirections.');
                }
                return this.getVolume(chunkManager, redirect, options, cancellationToken, redirect_log);
            }
            else {
                throw err;
            }
        });
    }
    getAnnotationSource(chunkManager, url, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"]) {
        let [dataSource, path] = this.getDataSource(url);
        return new Promise(resolve => {
            resolve(dataSource.getAnnotationSource(chunkManager, path, cancellationToken));
        });
    }
    getVectorGraphicsSource(chunkManager, url, options = {}, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"]) {
        let [dataSource, path] = this.getDataSource(url);
        return new Promise(resolve => {
            resolve(dataSource.getVectorGraphicsSource(chunkManager, path, options, cancellationToken));
        });
    }
    getMeshSource(chunkManager, url, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"]) {
        let [dataSource, path] = this.getDataSource(url);
        return new Promise(resolve => {
            resolve(dataSource.getMeshSource(chunkManager, path, cancellationToken));
        });
    }
    getSkeletonSource(chunkManager, url, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"]) {
        let [dataSource, path] = this.getDataSource(url);
        return new Promise(resolve => {
            resolve(dataSource.getSkeletonSource(chunkManager, path, cancellationToken));
        });
    }
    volumeCompleter(url, chunkManager, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"]) {
        // Check if url matches a protocol.  Note that protocolPattern always matches.
        let protocolMatch = url.match(protocolPattern);
        let protocol = protocolMatch[1];
        if (protocol === undefined) {
            // Return protocol completions.
            let completions = [];
            for (let [name, factory] of this.dataSources) {
                name = name + '://';
                if (name.startsWith(url)) {
                    completions.push({ value: name, description: factory.description });
                }
            }
            return Promise.resolve({ offset: 0, completions });
        }
        else {
            const factory = this.dataSources.get(protocol);
            if (factory !== undefined) {
                if (factory.volumeCompleter !== undefined) {
                    return factory.volumeCompleter(protocolMatch[2], chunkManager, cancellationToken)
                        .then(completions => Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_1__["applyCompletionOffset"])(protocol.length + 3, completions));
                }
            }
            return Promise.reject(null);
        }
    }
    suggestLayerName(url) {
        let [dataSource, path] = this.getDataSource(url);
        let suggestor = dataSource.suggestLayerName;
        if (suggestor !== undefined) {
            return suggestor(path);
        }
        return suggestLayerNameBasedOnSeparator(path);
    }
    findSourceGroup(url) {
        let [dataSource, path, dataSourceName] = this.getDataSource(url);
        let helper = dataSource.findSourceGroup || findSourceGroupBasedOnSeparator;
        return helper(path) + dataSourceName.length + 3;
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/n5/base.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/datasource/n5/base.ts ***!
  \************************************************/
/*! exports provided: VolumeChunkEncoding, VolumeChunkSourceParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkEncoding", function() { return VolumeChunkEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkSourceParameters", function() { return VolumeChunkSourceParameters; });
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VolumeChunkEncoding;
(function (VolumeChunkEncoding) {
    VolumeChunkEncoding[VolumeChunkEncoding["RAW"] = 0] = "RAW";
    VolumeChunkEncoding[VolumeChunkEncoding["GZIP"] = 1] = "GZIP";
})(VolumeChunkEncoding || (VolumeChunkEncoding = {}));
class VolumeChunkSourceParameters {
}
VolumeChunkSourceParameters.RPC_ID = 'n5/VolumeChunkSource';


/***/ }),

/***/ "./src/neuroglancer/datasource/n5/frontend.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/datasource/n5/frontend.ts ***!
  \****************************************************/
/*! exports provided: MultiscaleVolumeChunkSource, N5DataSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVolumeChunkSource", function() { return MultiscaleVolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "N5DataSource", function() { return N5DataSource; });
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/* harmony import */ var neuroglancer_datasource_n5_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/datasource/n5/base */ "./src/neuroglancer/datasource/n5/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/http_request */ "./src/neuroglancer/util/http_request.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









class N5VolumeChunkSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["WithParameters"])(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_5__["VolumeChunkSource"], neuroglancer_datasource_n5_base__WEBPACK_IMPORTED_MODULE_3__["VolumeChunkSourceParameters"])) {
}
class MultiscaleVolumeChunkSource {
    constructor(chunkManager, url, topLevelMetadata, scales) {
        this.chunkManager = chunkManager;
        this.url = url;
        this.topLevelMetadata = topLevelMetadata;
        this.scales = scales;
        let dataType;
        let baseScaleIndex;
        scales.forEach((scale, i) => {
            if (scale === undefined)
                return;
            if (baseScaleIndex === undefined) {
                baseScaleIndex = i;
            }
            if (dataType !== undefined && scale.dataType !== dataType) {
                throw new Error(`Scale s${i} has data type ${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_4__["DataType"][scale.dataType]} but expected ${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_4__["DataType"][dataType]}.`);
            }
            dataType = scale.dataType;
        });
        if (dataType === undefined) {
            throw new Error(`At least one scale must be specified.`);
        }
        this.dataType = dataType;
        this.volumeType = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_4__["VolumeType"].IMAGE;
        this.baseScaleIndex = baseScaleIndex;
    }
    get numChannels() {
        return 1;
    }
    getMeshSource() {
        return null;
    }
    getSources(volumeSourceOptions) {
        const { topLevelMetadata } = this;
        const sources = [];
        this.scales.forEach((scale, i) => {
            if (scale === undefined)
                return;
            sources.push(neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_4__["VolumeChunkSpecification"]
                .getDefaults({
                voxelSize: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create(), topLevelMetadata.pixelResolution, topLevelMetadata.scales[i]),
                dataType: scale.dataType,
                numChannels: 1,
                upperVoxelBound: scale.size,
                volumeType: this.volumeType,
                chunkDataSizes: [scale.chunkSize],
                volumeSourceOptions,
            })
                .map(spec => this.chunkManager.getChunkSource(N5VolumeChunkSource, {
                spec,
                parameters: { 'url': `${this.url}/s${i}`, 'encoding': scale.encoding }
            })));
        });
        return sources;
    }
    getStaticAnnotations() {
        const { topLevelMetadata, baseScaleIndex } = this;
        const annotationSet = new neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationSource"](neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].fromScaling(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create(), topLevelMetadata.pixelResolution, topLevelMetadata.scales[baseScaleIndex])));
        annotationSet.readonly = true;
        annotationSet.add(Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["makeDataBoundsBoundingBox"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create(), this.scales[baseScaleIndex].size));
        return annotationSet;
    }
}
const pixelResolutionUnits = new Map([
    ['mm', 1e6],
    ['m', 1e9],
    ['um', 1000],
    ['nm', 1],
]);
class TopLevelMetadata {
    constructor(obj) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObject"])(obj);
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(obj, 'pixelResolution', resObj => {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObject"])(resObj);
            const unitScale = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(resObj, 'unit', x => {
                const s = pixelResolutionUnits.get(x);
                if (s === undefined) {
                    throw new Error(`Unsupported unit: ${JSON.stringify(x)}.`);
                }
                return s;
            });
            const dimensions = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(resObj, 'dimensions', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyFinitePositiveFloat"]));
            this.pixelResolution = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].scale(dimensions, dimensions, unitScale);
        });
        this.scales = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(obj, 'scales', scalesObj => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["parseArray"])(scalesObj, scaleObj => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create(), scaleObj, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyFinitePositiveFloat"])));
    }
}
class ScaleMetadata {
    constructor(obj) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObject"])(obj);
        this.dataType = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(obj, 'dataType', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyEnumString"])(x, neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_4__["DataType"]));
        this.size = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(obj, 'dimensions', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyPositiveInt"]));
        this.chunkSize = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(obj, 'blockSize', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyPositiveInt"]));
        let encoding;
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(obj, 'compression', compression => {
            encoding =
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(compression, 'type', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyEnumString"])(x, neuroglancer_datasource_n5_base__WEBPACK_IMPORTED_MODULE_3__["VolumeChunkEncoding"]));
        });
        if (encoding === undefined) {
            encoding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(obj, 'compressionType', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyEnumString"])(x, neuroglancer_datasource_n5_base__WEBPACK_IMPORTED_MODULE_3__["VolumeChunkEncoding"]));
        }
        this.encoding = encoding;
    }
}
function getTopLevelMetadata(chunkManager, url) {
    return chunkManager.memoize.getUncounted({ 'type': 'n5:topLevelMetadata', url }, () => Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_7__["fetchOk"])(url)
        .then(response => response.json())
        .then(response => new TopLevelMetadata(response)));
}
function getScaleMetadata(chunkManager, url) {
    return chunkManager.memoize.getUncounted({ 'type': 'n5:scaleMetadata', url }, () => Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_7__["fetchOk"])(url)
        .then(response => response.json())
        .then(response => new ScaleMetadata(response)));
}
function getAllScales(chunkManager, url, topLevelMetadata) {
    return Promise.all(topLevelMetadata.scales.map((_scale, i) => {
        return getScaleMetadata(chunkManager, `${url}/s${i}/attributes.json`).catch(e => {
            if (e instanceof neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_7__["HttpError"] && e.status === 404) {
                return undefined;
            }
            throw e;
        });
    }));
}
class N5DataSource extends neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_2__["DataSource"] {
    get description() {
        return 'N5 data source';
    }
    getVolume(chunkManager, url) {
        url = Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_7__["parseSpecialUrl"])(url);
        const m = url.match(/^(.*)\/(c[0-9]+)$/);
        let topLevelMetadataUrl;
        if (m !== null) {
            topLevelMetadataUrl = `${m[1]}/attributes.json`;
        }
        else {
            topLevelMetadataUrl = `${url}/attributes.json`;
        }
        return chunkManager.memoize.getUncounted({ 'type': 'n5:MultiscaleVolumeChunkSource', url }, () => getTopLevelMetadata(chunkManager, topLevelMetadataUrl)
            .then(topLevelMetadata => getAllScales(chunkManager, url, topLevelMetadata)
            .then(scales => new MultiscaleVolumeChunkSource(chunkManager, url, topLevelMetadata, scales))));
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/n5/register_default.ts":
/*!************************************************************!*\
  !*** ./src/neuroglancer/datasource/n5/register_default.ts ***!
  \************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/* harmony import */ var neuroglancer_datasource_n5_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/n5/frontend */ "./src/neuroglancer/datasource/n5/frontend.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_0__["registerProvider"])('n5', () => new neuroglancer_datasource_n5_frontend__WEBPACK_IMPORTED_MODULE_1__["N5DataSource"]());


/***/ }),

/***/ "./src/neuroglancer/datasource/nifti/base.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/datasource/nifti/base.ts ***!
  \***************************************************/
/*! exports provided: GET_NIFTI_VOLUME_INFO_RPC_ID, NiftiDataType, VolumeSourceParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GET_NIFTI_VOLUME_INFO_RPC_ID", function() { return GET_NIFTI_VOLUME_INFO_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NiftiDataType", function() { return NiftiDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeSourceParameters", function() { return VolumeSourceParameters; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const GET_NIFTI_VOLUME_INFO_RPC_ID = 'nifti/getNiftiVolumeInfo';
var NiftiDataType;
(function (NiftiDataType) {
    NiftiDataType[NiftiDataType["NONE"] = 0] = "NONE";
    NiftiDataType[NiftiDataType["BINARY"] = 1] = "BINARY";
    NiftiDataType[NiftiDataType["UINT8"] = 2] = "UINT8";
    NiftiDataType[NiftiDataType["INT16"] = 4] = "INT16";
    NiftiDataType[NiftiDataType["INT32"] = 8] = "INT32";
    NiftiDataType[NiftiDataType["FLOAT32"] = 16] = "FLOAT32";
    NiftiDataType[NiftiDataType["COMPLEX64"] = 32] = "COMPLEX64";
    NiftiDataType[NiftiDataType["FLOAT64"] = 64] = "FLOAT64";
    NiftiDataType[NiftiDataType["RGB24"] = 128] = "RGB24";
    NiftiDataType[NiftiDataType["INT8"] = 256] = "INT8";
    NiftiDataType[NiftiDataType["UINT16"] = 512] = "UINT16";
    NiftiDataType[NiftiDataType["UINT32"] = 768] = "UINT32";
    NiftiDataType[NiftiDataType["INT64"] = 1024] = "INT64";
    NiftiDataType[NiftiDataType["UINT64"] = 1280] = "UINT64";
    NiftiDataType[NiftiDataType["FLOAT128"] = 1536] = "FLOAT128";
    NiftiDataType[NiftiDataType["COMPLEX128"] = 1792] = "COMPLEX128";
    NiftiDataType[NiftiDataType["COMPLEX256"] = 2048] = "COMPLEX256";
})(NiftiDataType || (NiftiDataType = {}));
class VolumeSourceParameters {
}
VolumeSourceParameters.RPC_ID = 'nifti/VolumeChunkSource';


/***/ }),

/***/ "./src/neuroglancer/datasource/nifti/frontend.ts":
/*!*******************************************************!*\
  !*** ./src/neuroglancer/datasource/nifti/frontend.ts ***!
  \*******************************************************/
/*! exports provided: MultiscaleVolumeChunkSource, getVolume, NiftiDataSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVolumeChunkSource", function() { return MultiscaleVolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVolume", function() { return getVolume; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NiftiDataSource", function() { return NiftiDataSource; });
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/* harmony import */ var neuroglancer_datasource_nifti_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource/nifti/base */ "./src/neuroglancer/datasource/nifti/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Support for displaying single NIfTI (https://www.nitrc.org/projects/nifti) files as
 * volumes.
 */







class NiftiVolumeChunkSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_4__["VolumeChunkSource"], neuroglancer_datasource_nifti_base__WEBPACK_IMPORTED_MODULE_2__["VolumeSourceParameters"])) {
}
class MultiscaleVolumeChunkSource {
    constructor(chunkManager, url, info) {
        this.chunkManager = chunkManager;
        this.url = url;
        this.info = info;
    }
    get numChannels() {
        return this.info.numChannels;
    }
    get dataType() {
        return this.info.dataType;
    }
    get volumeType() {
        return this.info.volumeType;
    }
    getSources(volumeSourceOptions) {
        let { info } = this;
        const spec = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["VolumeChunkSpecification"].withDefaultCompression({
            volumeType: info.volumeType,
            chunkDataSize: info.volumeSize,
            dataType: info.dataType,
            voxelSize: info.voxelSize,
            numChannels: info.numChannels,
            upperVoxelBound: info.volumeSize,
            transform: Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["translationRotationScaleZReflectionToMat4"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].create(), info.qoffset, info.quatern, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["kOneVec"], info.qfac),
            volumeSourceOptions,
        });
        return [[this.chunkManager.getChunkSource(NiftiVolumeChunkSource, { spec, parameters: { url: this.url } })]];
    }
    getMeshSource() {
        return null;
    }
}
function getNiftiVolumeInfo(chunkManager, url, cancellationToken) {
    return chunkManager.rpc.promiseInvoke(neuroglancer_datasource_nifti_base__WEBPACK_IMPORTED_MODULE_2__["GET_NIFTI_VOLUME_INFO_RPC_ID"], { 'chunkManager': chunkManager.addCounterpartRef(), 'url': url }, cancellationToken);
}
function getVolume(chunkManager, url) {
    return chunkManager.memoize.getUncounted({ type: 'nifti/getVolume', url }, () => getNiftiVolumeInfo(chunkManager, url, neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_5__["uncancelableToken"])
        .then(info => new MultiscaleVolumeChunkSource(chunkManager, url, info)));
}
class NiftiDataSource extends neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_1__["DataSource"] {
    get description() { return 'Single NIfTI file'; }
    getVolume(chunkManager, url) {
        return getVolume(chunkManager, url);
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/nifti/register_default.ts":
/*!***************************************************************!*\
  !*** ./src/neuroglancer/datasource/nifti/register_default.ts ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_nifti_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/nifti/frontend */ "./src/neuroglancer/datasource/nifti/frontend.ts");
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__["registerProvider"])('nifti', () => new neuroglancer_datasource_nifti_frontend__WEBPACK_IMPORTED_MODULE_0__["NiftiDataSource"]());


/***/ }),

/***/ "./src/neuroglancer/datasource/precomputed/base.ts":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/datasource/precomputed/base.ts ***!
  \*********************************************************/
/*! exports provided: VolumeChunkEncoding, VolumeChunkSourceParameters, MeshSourceParameters, DataEncoding, ShardingHashFunction, MultiscaleMeshMetadata, MultiscaleMeshSourceParameters, SkeletonSourceParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkEncoding", function() { return VolumeChunkEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkSourceParameters", function() { return VolumeChunkSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshSourceParameters", function() { return MeshSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataEncoding", function() { return DataEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShardingHashFunction", function() { return ShardingHashFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleMeshMetadata", function() { return MultiscaleMeshMetadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleMeshSourceParameters", function() { return MultiscaleMeshSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonSourceParameters", function() { return SkeletonSourceParameters; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VolumeChunkEncoding;
(function (VolumeChunkEncoding) {
    VolumeChunkEncoding[VolumeChunkEncoding["RAW"] = 0] = "RAW";
    VolumeChunkEncoding[VolumeChunkEncoding["JPEG"] = 1] = "JPEG";
    VolumeChunkEncoding[VolumeChunkEncoding["COMPRESSED_SEGMENTATION"] = 2] = "COMPRESSED_SEGMENTATION";
})(VolumeChunkEncoding || (VolumeChunkEncoding = {}));
class VolumeChunkSourceParameters {
}
VolumeChunkSourceParameters.RPC_ID = 'precomputed/VolumeChunkSource';
class MeshSourceParameters {
}
MeshSourceParameters.RPC_ID = 'precomputed/MeshSource';
var DataEncoding;
(function (DataEncoding) {
    DataEncoding[DataEncoding["RAW"] = 0] = "RAW";
    DataEncoding[DataEncoding["GZIP"] = 1] = "GZIP";
})(DataEncoding || (DataEncoding = {}));
var ShardingHashFunction;
(function (ShardingHashFunction) {
    ShardingHashFunction[ShardingHashFunction["IDENTITY"] = 0] = "IDENTITY";
    ShardingHashFunction[ShardingHashFunction["MURMURHASH3_X86_128"] = 1] = "MURMURHASH3_X86_128";
})(ShardingHashFunction || (ShardingHashFunction = {}));
class MultiscaleMeshMetadata {
}
class MultiscaleMeshSourceParameters {
}
MultiscaleMeshSourceParameters.RPC_ID = 'precomputed/MultiscaleMeshSource';
class SkeletonSourceParameters {
}
SkeletonSourceParameters.RPC_ID = 'precomputed/SkeletonSource';


/***/ }),

/***/ "./src/neuroglancer/datasource/precomputed/frontend.ts":
/*!*************************************************************!*\
  !*** ./src/neuroglancer/datasource/precomputed/frontend.ts ***!
  \*************************************************************/
/*! exports provided: PrecomputedSkeletonSource, MultiscaleVolumeChunkSource, getShardedMeshSource, getSkeletonSource, getVolume, PrecomputedDataSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrecomputedSkeletonSource", function() { return PrecomputedSkeletonSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVolumeChunkSource", function() { return MultiscaleVolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getShardedMeshSource", function() { return getShardedMeshSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSkeletonSource", function() { return getSkeletonSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVolume", function() { return getVolume; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrecomputedDataSource", function() { return PrecomputedDataSource; });
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/* harmony import */ var neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/datasource/precomputed/base */ "./src/neuroglancer/datasource/precomputed/base.ts");
/* harmony import */ var neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/mesh/base */ "./src/neuroglancer/mesh/base.ts");
/* harmony import */ var neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/mesh/frontend */ "./src/neuroglancer/mesh/frontend.ts");
/* harmony import */ var neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/skeleton/frontend */ "./src/neuroglancer/skeleton/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/http_request */ "./src/neuroglancer/util/http_request.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












class PrecomputedVolumeChunkSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["WithParameters"])(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_8__["VolumeChunkSource"], neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["VolumeChunkSourceParameters"])) {
}
class PrecomputedMeshSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["WithParameters"])(neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_5__["MeshSource"], neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["MeshSourceParameters"])) {
}
class PrecomputedMultiscaleMeshSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["WithParameters"])(neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_5__["MultiscaleMeshSource"], neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["MultiscaleMeshSourceParameters"])) {
}
class PrecomputedSkeletonSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["WithParameters"])(neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_6__["SkeletonSource"], neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["SkeletonSourceParameters"])) {
    get skeletonVertexCoordinatesInVoxels() {
        return false;
    }
    get vertexAttributes() {
        return this.parameters.metadata.vertexAttributes;
    }
}
function resolvePath(a, b) {
    const outputParts = a.split('/');
    for (const part of b.split('/')) {
        if (part === '..') {
            if (outputParts.length !== 0) {
                outputParts.length = outputParts.length - 1;
                continue;
            }
        }
        outputParts.push(part);
    }
    return outputParts.join('/');
}
class ScaleInfo {
    constructor(obj) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(obj);
        this.resolution = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'resolution', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyFinitePositiveFloat"]));
        this.voxelOffset = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'voxel_offset', x => x === undefined ? neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create() : Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseIntVec"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), x));
        this.size = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'size', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyPositiveInt"]));
        this.chunkSizes = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'chunk_sizes', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseArray"])(x, y => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), y, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyPositiveInt"])));
        if (this.chunkSizes.length === 0) {
            throw new Error('No chunk sizes specified.');
        }
        this.sharding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'sharding', parseShardingParameters);
        if (this.sharding !== undefined && this.chunkSizes.length !== 1) {
            throw new Error('Sharding requires a single chunk size per scale');
        }
        let encoding = this.encoding =
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'encoding', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyEnumString"])(x, neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["VolumeChunkEncoding"]));
        if (encoding === neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["VolumeChunkEncoding"].COMPRESSED_SEGMENTATION) {
            this.compressedSegmentationBlockSize = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'compressed_segmentation_block_size', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseFixedLengthArray"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyPositiveInt"]));
        }
        this.key = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'key', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
    }
}
class MultiscaleVolumeChunkSource {
    constructor(chunkManager, url, obj) {
        this.chunkManager = chunkManager;
        this.url = url;
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(obj);
        const redirect = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'redirect', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyOptionalString"]);
        if (redirect !== undefined) {
            throw new neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_2__["RedirectError"](redirect);
        }
        const t = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, '@type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyOptionalString"]);
        if (t !== undefined && t !== 'neuroglancer_multiscale_volume') {
            throw new Error(`Invalid type: ${JSON.stringify(t)}`);
        }
        this.dataType = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'data_type', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyEnumString"])(x, neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_7__["DataType"]));
        this.numChannels = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'num_channels', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyPositiveInt"]);
        this.volumeType = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'type', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyEnumString"])(x, neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_7__["VolumeType"]));
        this.mesh = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'mesh', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyOptionalString"]);
        this.skeletons = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'skeletons', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyOptionalString"]);
        this.scales = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(obj, 'scales', x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseArray"])(x, y => new ScaleInfo(y)));
    }
    getMeshSource() {
        const { mesh } = this;
        if (mesh !== undefined) {
            return getMeshSource(this.chunkManager, resolvePath(this.url, mesh));
        }
        const { skeletons } = this;
        if (skeletons !== undefined) {
            return getSkeletonSource(this.chunkManager, resolvePath(this.url, skeletons));
        }
        return null;
    }
    getSources(volumeSourceOptions) {
        return this.scales.map(scaleInfo => {
            return neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_7__["VolumeChunkSpecification"]
                .getDefaults({
                voxelSize: scaleInfo.resolution,
                dataType: this.dataType,
                numChannels: this.numChannels,
                transform: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].fromTranslation(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), scaleInfo.resolution, scaleInfo.voxelOffset)),
                upperVoxelBound: scaleInfo.size,
                volumeType: this.volumeType,
                chunkDataSizes: scaleInfo.chunkSizes,
                baseVoxelOffset: scaleInfo.voxelOffset,
                compressedSegmentationBlockSize: scaleInfo.compressedSegmentationBlockSize,
                volumeSourceOptions,
            })
                .map(spec => this.chunkManager.getChunkSource(PrecomputedVolumeChunkSource, {
                spec,
                parameters: {
                    url: resolvePath(this.url, scaleInfo.key),
                    encoding: scaleInfo.encoding,
                    sharding: scaleInfo.sharding,
                }
            }));
        });
    }
    getStaticAnnotations() {
        const baseScale = this.scales[0];
        const annotationSet = new neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["AnnotationSource"](neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].fromScaling(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create(), baseScale.resolution));
        annotationSet.readonly = true;
        annotationSet.add(Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_0__["makeDataBoundsBoundingBox"])(baseScale.voxelOffset, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].add(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create(), baseScale.voxelOffset, baseScale.size)));
        return annotationSet;
    }
}
function getShardedMeshSource(chunkManager, parameters) {
    return chunkManager.getChunkSource(PrecomputedMeshSource, { parameters });
}
function parseTransform(data) {
    return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(data, 'transform', value => {
        const transform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create();
        if (value !== undefined) {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseFixedLengthArray"])(transform.subarray(0, 12), value, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyFiniteFloat"]);
        }
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].transpose(transform, transform);
        return transform;
    });
}
function parseMeshMetadata(data) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(data);
    const t = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(data, '@type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
    if (t === 'neuroglancer_legacy_mesh') {
        return undefined;
    }
    else if (t !== 'neuroglancer_multilod_draco') {
        throw new Error(`Unsupported mesh type: ${JSON.stringify(t)}`);
    }
    const lodScaleMultiplier = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(data, 'lod_scale_multiplier', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyFinitePositiveFloat"]);
    const vertexQuantizationBits = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(data, 'vertex_quantization_bits', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyPositiveInt"]);
    const transform = parseTransform(data);
    const sharding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(data, 'sharding', parseShardingParameters);
    return { lodScaleMultiplier, transform, sharding, vertexQuantizationBits };
}
function getMeshMetadata(chunkManager, url) {
    return chunkManager.memoize.getUncounted({ 'type': 'precomputed:MeshSource', url }, () => Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["fetchOk"])(`${url}/info`)
        .then(response => {
        return response.json().then(value => parseMeshMetadata(value));
    }, 
    // If we fail to fetch the info file, assume it is the legacy
    // single-resolution mesh format.
    () => undefined));
}
function parseShardingEncoding(y) {
    if (y === undefined)
        return neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["DataEncoding"].RAW;
    return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyEnumString"])(y, neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["DataEncoding"]);
}
function parseShardingParameters(shardingData) {
    if (shardingData === undefined)
        return undefined;
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(shardingData);
    const t = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(shardingData, '@type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
    if (t !== 'neuroglancer_uint64_sharded_v1') {
        throw new Error(`Unsupported sharding format: ${JSON.stringify(t)}`);
    }
    const hash = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(shardingData, 'hash', y => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyEnumString"])(y, neuroglancer_datasource_precomputed_base__WEBPACK_IMPORTED_MODULE_3__["ShardingHashFunction"]));
    const preshiftBits = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(shardingData, 'preshift_bits', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    const shardBits = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(shardingData, 'shard_bits', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    const minishardBits = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(shardingData, 'minishard_bits', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyInt"]);
    const minishardIndexEncoding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(shardingData, 'minishard_index_encoding', parseShardingEncoding);
    const dataEncoding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(shardingData, 'data_encoding', parseShardingEncoding);
    return { hash, preshiftBits, shardBits, minishardBits, minishardIndexEncoding, dataEncoding };
}
function parseSkeletonMetadata(data) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(data);
    const t = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(data, '@type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
    if (t !== 'neuroglancer_skeletons') {
        throw new Error(`Unsupported skeleton type: ${JSON.stringify(t)}`);
    }
    const transform = parseTransform(data);
    const vertexAttributes = new Map();
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(data, 'vertex_attributes', attributes => {
        if (attributes === undefined)
            return;
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["parseArray"])(attributes, attributeData => {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObject"])(attributeData);
            const id = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(attributeData, 'id', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
            if (id === '')
                throw new Error('vertex attribute id must not be empty');
            if (vertexAttributes.has(id)) {
                throw new Error(`duplicate vertex attribute id ${JSON.stringify(id)}`);
            }
            const dataType = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(attributeData, 'data_type', y => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyEnumString"])(y, neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_7__["DataType"]));
            const numComponents = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(attributeData, 'num_components', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyPositiveInt"]);
            vertexAttributes.set(id, { dataType, numComponents });
        });
    });
    const sharding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyObjectProperty"])(data, 'sharding', parseShardingParameters);
    return { transform, vertexAttributes, sharding };
}
function getSkeletonMetadata(chunkManager, url) {
    return chunkManager.memoize.getUncounted({ 'type': 'precomputed:SkeletonSource', url }, async () => {
        const response = await Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["fetchOk"])(`${url}/info`);
        const value = await response.json();
        return parseSkeletonMetadata(value);
    });
}
async function getMeshSource(chunkManager, url) {
    const metadata = await getMeshMetadata(chunkManager, url);
    if (metadata === undefined) {
        return getShardedMeshSource(chunkManager, { url, lod: 0 });
    }
    let vertexPositionFormat;
    const { vertexQuantizationBits } = metadata;
    if (vertexQuantizationBits === 10) {
        vertexPositionFormat = neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_4__["VertexPositionFormat"].uint10;
    }
    else if (vertexQuantizationBits === 16) {
        vertexPositionFormat = neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_4__["VertexPositionFormat"].uint16;
    }
    else {
        throw new Error(`Invalid vertex quantization bits: ${vertexQuantizationBits}`);
    }
    return chunkManager.getChunkSource(PrecomputedMultiscaleMeshSource, {
        parameters: { url, metadata },
        format: {
            fragmentRelativeVertices: true,
            vertexPositionFormat,
            transform: metadata.transform,
        }
    });
}
async function getSkeletonSource(chunkManager, url) {
    const metadata = await getSkeletonMetadata(chunkManager, url);
    return chunkManager.getChunkSource(PrecomputedSkeletonSource, {
        parameters: {
            url,
            metadata,
        },
        transform: metadata.transform,
    });
}
function getVolume(chunkManager, url) {
    url = Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["parseSpecialUrl"])(url);
    return chunkManager.memoize.getUncounted({ 'type': 'precomputed:MultiscaleVolumeChunkSource', url }, () => Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["fetchOk"])(`${url}/info`)
        .then(response => response.json())
        .then(response => new MultiscaleVolumeChunkSource(chunkManager, url, response)));
}
class PrecomputedDataSource extends neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_2__["DataSource"] {
    get description() {
        return 'Precomputed file-backed data source';
    }
    getVolume(chunkManager, url) {
        return getVolume(chunkManager, url);
    }
    getMeshSource(chunkManager, url) {
        return getMeshSource(chunkManager, Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["parseSpecialUrl"])(url));
    }
    getSkeletonSource(chunkManager, url) {
        return getSkeletonSource(chunkManager, Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_10__["parseSpecialUrl"])(url));
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/precomputed/register_default.ts":
/*!*********************************************************************!*\
  !*** ./src/neuroglancer/datasource/precomputed/register_default.ts ***!
  \*********************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_precomputed_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/precomputed/frontend */ "./src/neuroglancer/datasource/precomputed/frontend.ts");
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_1__["registerProvider"])('precomputed', () => new neuroglancer_datasource_precomputed_frontend__WEBPACK_IMPORTED_MODULE_0__["PrecomputedDataSource"]());


/***/ }),

/***/ "./src/neuroglancer/datasource/render/base.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/datasource/render/base.ts ***!
  \****************************************************/
/*! exports provided: RenderBaseSourceParameters, RenderSourceParameters, TileChunkSourceParameters, PointMatchChunkSourceParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderBaseSourceParameters", function() { return RenderBaseSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderSourceParameters", function() { return RenderSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileChunkSourceParameters", function() { return TileChunkSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointMatchChunkSourceParameters", function() { return PointMatchChunkSourceParameters; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RenderBaseSourceParameters {
}
class RenderSourceParameters extends RenderBaseSourceParameters {
}
class TileChunkSourceParameters extends RenderSourceParameters {
}
TileChunkSourceParameters.RPC_ID = 'render/TileChunkSource';
class PointMatchChunkSourceParameters extends RenderSourceParameters {
}
PointMatchChunkSourceParameters.RPC_ID = 'render/PointMatchSource';


/***/ }),

/***/ "./src/neuroglancer/datasource/render/frontend.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/datasource/render/frontend.ts ***!
  \********************************************************/
/*! exports provided: MultiscaleVolumeChunkSource, computeStackHierarchy, getOwnerInfo, getVolume, stackAndProjectCompleter, volumeCompleter, MultiscaleVectorGraphicsChunkSource, getPointMatches, RenderDataSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVolumeChunkSource", function() { return MultiscaleVolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeStackHierarchy", function() { return computeStackHierarchy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOwnerInfo", function() { return getOwnerInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVolume", function() { return getVolume; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stackAndProjectCompleter", function() { return stackAndProjectCompleter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "volumeCompleter", function() { return volumeCompleter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleVectorGraphicsChunkSource", function() { return MultiscaleVectorGraphicsChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointMatches", function() { return getPointMatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderDataSource", function() { return RenderDataSource; });
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource */ "./src/neuroglancer/datasource/index.ts");
/* harmony import */ var neuroglancer_datasource_render_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/datasource/render/base */ "./src/neuroglancer/datasource/render/base.ts");
/* harmony import */ var neuroglancer_sliceview_vector_graphics_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/sliceview/vector_graphics/base */ "./src/neuroglancer/sliceview/vector_graphics/base.ts");
/* harmony import */ var neuroglancer_sliceview_vector_graphics_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/vector_graphics/frontend */ "./src/neuroglancer/sliceview/vector_graphics/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/completion */ "./src/neuroglancer/util/completion.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/http_request */ "./src/neuroglancer/util/http_request.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Support for Render (https://github.com/saalfeldlab/render) servers.
 */











const VALID_ENCODINGS = new Set(['jpg', 'raw16']);
const TileChunkSourceBase = Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_6__["VolumeChunkSource"], neuroglancer_datasource_render_base__WEBPACK_IMPORTED_MODULE_2__["TileChunkSourceParameters"]);
class TileChunkSource extends TileChunkSourceBase {
}
const PointMatchSourceBase = Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_0__["WithParameters"])(neuroglancer_sliceview_vector_graphics_frontend__WEBPACK_IMPORTED_MODULE_4__["VectorGraphicsChunkSource"], neuroglancer_datasource_render_base__WEBPACK_IMPORTED_MODULE_2__["PointMatchChunkSourceParameters"]);
class PointMatchSource extends PointMatchSourceBase {
}
const VALID_STACK_STATES = new Set(['COMPLETE', 'READ_ONLY']);
const PARTIAL_STACK_STATES = new Set(['LOADING']);
function parseOwnerInfo(obj) {
    let stackObjs = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["parseArray"])(obj, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"]);
    if (stackObjs.length < 1) {
        throw new Error(`No stacks found for owner object.`);
    }
    let projects = new Map();
    // Get the owner from the first stack
    let owner = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackObjs[0], 'stackId', parseStackOwner);
    for (let stackObj of stackObjs) {
        let stackName = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackObj, 'stackId', parseStackName);
        let stackInfo = parseStackInfo(stackObj);
        if (stackInfo !== undefined) {
            let projectName = stackInfo.project;
            let projectInfo = projects.get(projectName);
            if (projectInfo === undefined) {
                let stacks = new Map();
                projects.set(projectName, { stacks });
                projectInfo = projects.get(projectName);
            }
            projectInfo.stacks.set(stackName, stackInfo);
        }
    }
    return { owner, projects };
}
function parseStackName(stackIdObj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"])(stackIdObj);
    return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackIdObj, 'stack', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyString"]);
}
function parseStackOwner(stackIdObj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"])(stackIdObj);
    return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackIdObj, 'owner', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyString"]);
}
function parseStackInfo(obj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"])(obj);
    let state = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(obj, 'state', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyString"]);
    let channels = [];
    let lowerVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
    let upperVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
    if (VALID_STACK_STATES.has(state)) {
        let stackStatsObj = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(obj, 'stats', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"]);
        lowerVoxelBound = parseLowerVoxelBounds(stackStatsObj);
        upperVoxelBound = parseUpperVoxelBounds(stackStatsObj);
        if (stackStatsObj.hasOwnProperty('channelNames')) {
            channels = parseChannelNames(stackStatsObj);
        }
    }
    else if (PARTIAL_STACK_STATES.has(state)) {
        // Stacks in LOADING state will not have a 'stats' object.
        // Values will be populated from command arguments in MultiscaleVolumeChunkSource()
    }
    else {
        return undefined;
    }
    let voxelResolution = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(obj, 'currentVersion', parseStackVersionInfo);
    let project = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(obj, 'stackId', parseStackProject);
    return { lowerVoxelBound, upperVoxelBound, voxelResolution, project, channels };
}
function parseUpperVoxelBounds(stackStatsObj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"])(stackStatsObj);
    let stackBounds = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackStatsObj, 'stackBounds', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"]);
    let upperVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
    upperVoxelBound[0] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackBounds, 'maxX', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]) + 1;
    upperVoxelBound[1] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackBounds, 'maxY', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]) + 1;
    upperVoxelBound[2] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackBounds, 'maxZ', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]) + 1;
    return upperVoxelBound;
}
function parseLowerVoxelBounds(stackStatsObj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"])(stackStatsObj);
    let stackBounds = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackStatsObj, 'stackBounds', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"]);
    let lowerVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
    lowerVoxelBound[0] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackBounds, 'minX', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]);
    lowerVoxelBound[1] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackBounds, 'minY', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]);
    lowerVoxelBound[2] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackBounds, 'minZ', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]);
    return lowerVoxelBound;
}
function parseChannelNames(stackStatsObj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"])(stackStatsObj);
    return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackStatsObj, 'channelNames', channelNamesObj => {
        return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["parseArray"])(channelNamesObj, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyString"]);
    });
}
function parseStackVersionInfo(stackVersionObj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"])(stackVersionObj);
    let voxelResolution = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
    try {
        voxelResolution[0] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackVersionObj, 'stackResolutionX', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]);
        voxelResolution[1] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackVersionObj, 'stackResolutionY', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]);
        voxelResolution[2] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackVersionObj, 'stackResolutionZ', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyFloat"]);
    }
    catch (ignoredError) {
        // default is 1, 1, 1
        voxelResolution[0] = 1;
        voxelResolution[1] = 1;
        voxelResolution[2] = 1;
    }
    return voxelResolution;
}
function parseStackProject(stackIdObj) {
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObject"])(stackIdObj);
    return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyObjectProperty"])(stackIdObj, 'project', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyString"]);
}
class MultiscaleVolumeChunkSource {
    constructor(chunkManager, baseUrl, ownerInfo, stack, project, channel, parameters) {
        this.chunkManager = chunkManager;
        this.baseUrl = baseUrl;
        this.ownerInfo = ownerInfo;
        this.project = project;
        this.parameters = parameters;
        let projectInfo = ownerInfo.projects.get(project);
        if (projectInfo === undefined) {
            throw new Error(`Specified project ${JSON.stringify(project)} does not exist for ` +
                `specified owner ${JSON.stringify(ownerInfo.owner)}`);
        }
        if (stack === undefined) {
            const stackNames = Array.from(projectInfo.stacks.keys());
            if (stackNames.length !== 1) {
                throw new Error(`Dataset contains multiple stacks: ${JSON.stringify(stackNames)}`);
            }
            stack = stackNames[0];
        }
        const stackInfo = projectInfo.stacks.get(stack);
        if (stackInfo === undefined) {
            throw new Error(`Specified stack ${JSON.stringify(stack)} is not one of the supported stacks: ` +
                JSON.stringify(Array.from(projectInfo.stacks.keys())));
        }
        this.stack = stack;
        this.stackInfo = stackInfo;
        if (channel !== undefined && channel.length > 0) {
            this.channel = channel;
        }
        this.minIntensity = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['minIntensity']);
        this.maxIntensity = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['maxIntensity']);
        this.maxTileSpecsToRender = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['maxTileSpecsToRender']);
        this.filter = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalBoolean"])(parameters['filter']);
        this.minX = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['minX']);
        this.minY = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['minY']);
        this.minZ = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['minZ']);
        this.maxX = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['maxX']);
        this.maxY = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['maxY']);
        this.maxZ = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['maxZ']);
        if (this.minX !== undefined) {
            stackInfo.lowerVoxelBound[0] = this.minX;
        }
        if (this.minY !== undefined) {
            stackInfo.lowerVoxelBound[1] = this.minY;
        }
        if (this.minZ !== undefined) {
            stackInfo.lowerVoxelBound[2] = this.minZ;
        }
        if (this.maxX !== undefined) {
            stackInfo.upperVoxelBound[0] = this.maxX;
        }
        if (this.maxY !== undefined) {
            stackInfo.upperVoxelBound[1] = this.maxY;
        }
        if (this.maxZ !== undefined) {
            stackInfo.upperVoxelBound[2] = this.maxZ;
        }
        let encoding = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalString"])(parameters['encoding']);
        if (encoding === undefined) {
            encoding = 'jpg';
        }
        else {
            if (!VALID_ENCODINGS.has(encoding)) {
                throw new Error(`Invalid encoding: ${JSON.stringify(encoding)}.`);
            }
        }
        this.encoding = encoding;
        this.numLevels = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['numlevels']);
        this.dims = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
        let tileSize = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['tilesize']);
        if (tileSize === undefined) {
            tileSize = 1024; // Default tile size is 1024 x 1024
        }
        this.dims[0] = tileSize;
        this.dims[1] = tileSize;
        this.dims[2] = 1;
    }
    get dataType() {
        if (this.parameters.encoding === 'raw16') {
            return neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["DataType"].UINT16;
        }
        else {
            // JPEG
            return neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["DataType"].UINT8;
        }
    }
    get numChannels() {
        if (this.parameters.encoding === 'raw16') {
            return 1;
        }
        else {
            // JPEG
            return 3;
        }
    }
    get volumeType() {
        return neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["VolumeType"].IMAGE;
    }
    getSources(volumeSourceOptions) {
        let sources = [];
        let numLevels = this.numLevels;
        if (numLevels === undefined) {
            numLevels = computeStackHierarchy(this.stackInfo, this.dims[0]);
        }
        let lowerClipBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create(), upperClipBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
        // Generate and set the clip bounds based on the highest resolution (lowest scale) data in
        // render. Otherwise, rounding errors can cause inconsistencies in clip bounds between scaling
        // levels.
        for (let i = 0; i < 3; i++) {
            lowerClipBound[i] = this.stackInfo.lowerVoxelBound[i] * this.stackInfo.voxelResolution[i];
            upperClipBound[i] = this.stackInfo.upperVoxelBound[i] * this.stackInfo.voxelResolution[i];
        }
        for (let level = 0; level < numLevels; level++) {
            let voxelSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].clone(this.stackInfo.voxelResolution);
            let chunkDataSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].fromValues(1, 1, 1);
            // tiles are NxMx1
            for (let i = 0; i < 2; ++i) {
                voxelSize[i] = voxelSize[i] * Math.pow(2, level);
                chunkDataSize[i] = this.dims[i];
            }
            let lowerVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create(), upperVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
            for (let i = 0; i < 3; i++) {
                lowerVoxelBound[i] = Math.floor(this.stackInfo.lowerVoxelBound[i] * (this.stackInfo.voxelResolution[i] / voxelSize[i]));
                upperVoxelBound[i] = Math.ceil(this.stackInfo.upperVoxelBound[i] * (this.stackInfo.voxelResolution[i] / voxelSize[i]));
            }
            let spec = neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_5__["VolumeChunkSpecification"].make({
                voxelSize,
                chunkDataSize,
                numChannels: this.numChannels,
                dataType: this.dataType,
                lowerClipBound,
                upperClipBound,
                lowerVoxelBound,
                upperVoxelBound,
                volumeSourceOptions,
            });
            let source = this.chunkManager.getChunkSource(TileChunkSource, {
                spec,
                parameters: {
                    'baseUrl': this.baseUrl,
                    'owner': this.ownerInfo.owner,
                    'project': this.stackInfo.project,
                    'stack': this.stack,
                    'channel': this.channel,
                    'minIntensity': this.minIntensity,
                    'maxIntensity': this.maxIntensity,
                    'maxTileSpecsToRender': this.maxTileSpecsToRender,
                    'filter': this.filter,
                    'dims': `${this.dims[0]}_${this.dims[1]}`,
                    'level': level,
                    'encoding': this.encoding,
                }
            });
            sources.push([source]);
        }
        return sources;
    }
    /**
     * Meshes are not supported.
     */
    getMeshSource() {
        return null;
    }
}
function computeStackHierarchy(stackInfo, tileSize) {
    let maxBound = 0;
    for (let i = 0; i < 2; i++) {
        maxBound < stackInfo.upperVoxelBound[i] ? maxBound = stackInfo.upperVoxelBound[i] :
            maxBound = maxBound;
    }
    if (tileSize >= maxBound) {
        return 1;
    }
    let counter = 0;
    while (maxBound > tileSize) {
        maxBound = maxBound / 2;
        counter++;
    }
    return counter;
}
function getOwnerInfo(chunkManager, hostname, owner) {
    return chunkManager.memoize.getUncounted({ 'type': 'render:getOwnerInfo', hostname, owner }, () => Object(neuroglancer_util_http_request__WEBPACK_IMPORTED_MODULE_9__["fetchOk"])(`${hostname}/render-ws/v1/owner/${owner}/stacks`)
        .then(response => response.json())
        .then(parseOwnerInfo));
}
const pathPattern = /^([^\/?]+)(?:\/([^\/?]+))?(?:\/([^\/?]+))(?:\/([^\/?]*))?(?:\?(.*))?$/;
const urlPattern = /^((?:(?:(?:http|https):\/\/[^,\/]+)[^\/?]))\/(.*)$/;
function getVolume(chunkManager, datasourcePath) {
    let hostname, path;
    {
        let match = datasourcePath.match(urlPattern);
        if (match === null) {
            throw new Error(`Invalid render volume path: ${JSON.stringify(datasourcePath)}`);
        }
        hostname = match[1];
        path = match[2];
    }
    const match = path.match(pathPattern);
    if (match === null) {
        throw new Error(`Invalid volume path ${JSON.stringify(path)}`);
    }
    const owner = match[1];
    const project = match[2];
    const stack = match[3];
    const channel = match[4];
    const parameters = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["parseQueryStringParameters"])(match[5] || '');
    return chunkManager.memoize.getUncounted({ type: 'render:MultiscaleVolumeChunkSource', hostname, path }, () => getOwnerInfo(chunkManager, hostname, owner)
        .then(ownerInfo => new MultiscaleVolumeChunkSource(chunkManager, hostname, ownerInfo, stack, project, channel, parameters)));
}
function stackAndProjectCompleter(chunkManager, hostname, path) {
    const stackMatch = path.match(/^(?:([^\/]+)(?:\/([^\/]*))?(?:\/([^\/]*))?(\/.*?)?)?$/);
    if (stackMatch === null) {
        // URL has incorrect format, don't return any results.
        return Promise.reject(null);
    }
    if (stackMatch[2] === undefined) {
        // Don't autocomplete the owner
        return Promise.reject(null);
    }
    if (stackMatch[3] === undefined) {
        let projectPrefix = stackMatch[2] || '';
        return getOwnerInfo(chunkManager, hostname, stackMatch[1]).then(ownerInfo => {
            let completions = Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_7__["getPrefixMatchesWithDescriptions"])(projectPrefix, ownerInfo.projects, x => x[0] + '/', () => undefined);
            return { offset: stackMatch[1].length + 1, completions };
        });
    }
    if (stackMatch[4] === undefined) {
        let stackPrefix = stackMatch[3] || '';
        return getOwnerInfo(chunkManager, hostname, stackMatch[1]).then(ownerInfo => {
            let projectInfo = ownerInfo.projects.get(stackMatch[2]);
            if (projectInfo === undefined) {
                return Promise.reject(null);
            }
            let completions = Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_7__["getPrefixMatchesWithDescriptions"])(stackPrefix, projectInfo.stacks, x => x[0] + '/', x => {
                return `(${x[1].project})`;
            });
            return { offset: stackMatch[1].length + stackMatch[2].length + 2, completions };
        });
    }
    let channelPrefix = stackMatch[4].substr(1) || '';
    return getOwnerInfo(chunkManager, hostname, stackMatch[1]).then(ownerInfo => {
        let projectInfo = ownerInfo.projects.get(stackMatch[2]);
        if (projectInfo === undefined) {
            return Promise.reject(null);
        }
        let stackInfo = projectInfo.stacks.get(stackMatch[3]);
        if (stackInfo === undefined) {
            return Promise.reject(null);
        }
        let channels = stackInfo.channels;
        if (channels.length === 0) {
            return Promise.reject(null);
        }
        else {
            // Try and complete the channel
            let completions = Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_7__["getPrefixMatchesWithDescriptions"])(channelPrefix, channels, x => x, () => undefined);
            return {
                offset: stackMatch[1].length + stackMatch[2].length + stackMatch[3].length + 3,
                completions
            };
        }
    });
}
function volumeCompleter(url, chunkManager) {
    let match = url.match(urlPattern);
    if (match === null) {
        // We don't yet have a full hostname.
        return Promise.reject(null);
    }
    let hostname = match[1];
    let path = match[2];
    return stackAndProjectCompleter(chunkManager, hostname, path)
        .then(completions => Object(neuroglancer_util_completion__WEBPACK_IMPORTED_MODULE_7__["applyCompletionOffset"])(match[1].length + 1, completions));
}
class MultiscaleVectorGraphicsChunkSource {
    constructor(chunkManager, baseUrl, ownerInfo, stack, project, parameters) {
        this.chunkManager = chunkManager;
        this.baseUrl = baseUrl;
        this.ownerInfo = ownerInfo;
        this.project = project;
        this.parameters = parameters;
        let projectInfo = ownerInfo.projects.get(project);
        if (projectInfo === undefined) {
            throw new Error(`Specified project ${JSON.stringify(project)} does not exist for ` +
                `specified owner ${JSON.stringify(ownerInfo.owner)}`);
        }
        if (stack === undefined) {
            const stackNames = Array.from(projectInfo.stacks.keys());
            if (stackNames.length !== 1) {
                throw new Error(`Dataset contains multiple stacks: ${JSON.stringify(stackNames)}`);
            }
            stack = stackNames[0];
        }
        const stackInfo = projectInfo.stacks.get(stack);
        if (stackInfo === undefined) {
            throw new Error(`Specified stack ${JSON.stringify(stack)} is not one of the supported stacks: ` +
                JSON.stringify(Array.from(projectInfo.stacks.keys())));
        }
        this.stack = stack;
        this.stackInfo = stackInfo;
        let matchCollection = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalString"])(parameters['matchCollection']);
        if (matchCollection === undefined) {
            matchCollection = stack;
        }
        this.matchCollection = matchCollection;
        let zoffset = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['zoffset']);
        if (zoffset === undefined) {
            zoffset = 1;
        }
        this.zoffset = zoffset;
        this.dims = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
        let tileSize = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["verifyOptionalInt"])(parameters['tilesize']);
        if (tileSize === undefined) {
            tileSize = 1024; // Default tile size is 1024 x 1024
        }
        this.dims[0] = tileSize;
        this.dims[1] = tileSize;
        this.dims[2] = 1;
    }
    getSources(vectorGraphicsSourceOptions) {
        const voxelSize = this.stackInfo.voxelResolution;
        const chunkSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].subtract(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create(), this.stackInfo.upperVoxelBound, this.stackInfo.lowerVoxelBound);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].multiply(chunkSize, chunkSize, voxelSize);
        chunkSize[2] = voxelSize[2];
        const spec = neuroglancer_sliceview_vector_graphics_base__WEBPACK_IMPORTED_MODULE_3__["VectorGraphicsChunkSpecification"].make({
            voxelSize,
            chunkSize,
            lowerChunkBound: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].fromValues(0, 0, this.stackInfo.lowerVoxelBound[2]),
            upperChunkBound: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].fromValues(1, 1, this.stackInfo.upperVoxelBound[2]),
            vectorGraphicsSourceOptions
        });
        const source = this.chunkManager.getChunkSource(PointMatchSource, {
            spec,
            parameters: {
                'baseUrl': this.baseUrl,
                'owner': this.ownerInfo.owner,
                'project': this.stackInfo.project,
                'stack': this.stack,
                'encoding': 'points',
                'matchCollection': this.matchCollection,
                'zoffset': this.zoffset
            }
        });
        return [[source]];
    }
}
function getPointMatches(chunkManager, datasourcePath) {
    let hostname, path;
    {
        let match = datasourcePath.match(urlPattern);
        if (match === null) {
            throw new Error(`Invalid render point path: ${JSON.stringify(datasourcePath)}`);
        }
        hostname = match[1];
        path = match[2];
    }
    const match = path.match(pathPattern);
    if (match === null) {
        throw new Error(`Invalid point path ${JSON.stringify(path)}`);
    }
    const owner = match[1];
    const project = match[2];
    const stack = match[3];
    const parameters = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_10__["parseQueryStringParameters"])(match[4] || '');
    return chunkManager.memoize.getUncounted({ type: 'render:MultiscaleVectorGraphicsChunkSource', hostname, path }, () => getOwnerInfo(chunkManager, hostname, owner)
        .then(ownerInfo => new MultiscaleVectorGraphicsChunkSource(chunkManager, hostname, ownerInfo, stack, project, parameters)));
}
class RenderDataSource extends neuroglancer_datasource__WEBPACK_IMPORTED_MODULE_1__["DataSource"] {
    get description() {
        return 'Render';
    }
    getVolume(chunkManager, url) {
        return getVolume(chunkManager, url);
    }
    volumeCompleter(url, chunkManager) {
        return volumeCompleter(url, chunkManager);
    }
    getVectorGraphicsSource(chunkManager, url) {
        return getPointMatches(chunkManager, url);
    }
}


/***/ }),

/***/ "./src/neuroglancer/datasource/render/register_default.ts":
/*!****************************************************************!*\
  !*** ./src/neuroglancer/datasource/render/register_default.ts ***!
  \****************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/* harmony import */ var neuroglancer_datasource_render_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/datasource/render/frontend */ "./src/neuroglancer/datasource/render/frontend.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_0__["registerProvider"])('render', () => new neuroglancer_datasource_render_frontend__WEBPACK_IMPORTED_MODULE_1__["RenderDataSource"]());


/***/ }),

/***/ "./src/neuroglancer/datasource/vtk/frontend.ts":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/datasource/vtk/frontend.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./src/neuroglancer/display_context.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/display_context.ts ***!
  \*********************************************/
/*! exports provided: RenderedPanel, DisplayContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderedPanel", function() { return RenderedPanel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayContext", function() { return DisplayContext; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_webgl_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/context */ "./src/neuroglancer/webgl/context.ts");
/* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! resize-observer-polyfill */ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class RenderedPanel extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(context, element, visibility) {
        super();
        this.context = context;
        this.element = element;
        this.visibility = visibility;
        this.gl = context.gl;
        context.addPanel(this);
    }
    scheduleRedraw() {
        if (this.visible) {
            this.context.scheduleRedraw();
        }
    }
    setGLViewport() {
        let element = this.element;
        const clientRect = element.getBoundingClientRect();
        const canvasRect = this.context.canvasRect;
        const scaleX = canvasRect.width / this.context.canvas.width;
        const scaleY = canvasRect.height / this.context.canvas.height;
        let left = (element.clientLeft + clientRect.left - canvasRect.left) * scaleX;
        let width = element.clientWidth;
        let top = (clientRect.top - canvasRect.top + element.clientTop) * scaleY;
        let height = element.clientHeight;
        let bottom = top + height;
        let gl = this.gl;
        gl.enable(gl.SCISSOR_TEST);
        let glBottom = this.context.canvas.height - bottom;
        gl.viewport(left, glBottom, width, height);
        gl.scissor(left, glBottom, width, height);
    }
    disposed() {
        this.context.removePanel(this);
        super.disposed();
    }
    get visible() {
        return this.visibility.visible;
    }
}
class DisplayContext extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(container) {
        super();
        this.container = container;
        this.canvas = document.createElement('canvas');
        this.updateStarted = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__["NullarySignal"]();
        this.updateFinished = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__["NullarySignal"]();
        this.changed = this.updateFinished;
        this.panels = new Set();
        this.updatePending = null;
        /**
         * Unique number of the next frame.  Incremented once each time a frame is drawn.
         */
        this.frameNumber = 0;
        this.resizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_3__["default"](() => this.scheduleRedraw());
        const { canvas, resizeObserver } = this;
        container.style.position = 'relative';
        canvas.style.position = 'absolute';
        canvas.style.top = '0px';
        canvas.style.left = '0px';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.zIndex = '0';
        resizeObserver.observe(canvas);
        container.appendChild(canvas);
        this.gl = Object(neuroglancer_webgl_context__WEBPACK_IMPORTED_MODULE_2__["initializeWebGL"])(canvas);
    }
    isReady() {
        for (const panel of this.panels) {
            if (!panel.visible) {
                continue;
            }
            if (!panel.isReady()) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a child element that overlays the canvas.
     */
    makeCanvasOverlayElement() {
        const element = document.createElement('div');
        element.style.position = 'absolute';
        element.style.top = '0px';
        element.style.left = '0px';
        element.style.width = '100%';
        element.style.height = '100%';
        element.style.zIndex = '2';
        this.container.appendChild(element);
        return element;
    }
    disposed() {
        this.resizeObserver.disconnect();
        if (this.updatePending != null) {
            cancelAnimationFrame(this.updatePending);
            this.updatePending = null;
        }
    }
    addPanel(panel) {
        this.panels.add(panel);
        this.resizeObserver.observe(panel.element);
        this.scheduleRedraw();
    }
    removePanel(panel) {
        this.resizeObserver.unobserve(panel.element);
        this.panels.delete(panel);
        panel.dispose();
        this.scheduleRedraw();
    }
    scheduleRedraw() {
        if (this.updatePending === null) {
            this.updatePending = requestAnimationFrame(this.update.bind(this));
        }
    }
    draw() {
        ++this.frameNumber;
        this.updateStarted.dispatch();
        let gl = this.gl;
        let canvas = this.canvas;
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        this.canvasRect = canvas.getBoundingClientRect();
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        for (let panel of this.panels) {
            let { element } = panel;
            if (!panel.visible || element.clientWidth === 0 || element.clientHeight === 0 ||
                element.offsetWidth === 0 || element.offsetHeight === 0) {
                // Skip drawing if the panel has zero client area.
                continue;
            }
            panel.setGLViewport();
            panel.draw();
        }
        // Ensure the alpha buffer is set to 1.
        gl.disable(gl.SCISSOR_TEST);
        this.gl.clearColor(1.0, 1.0, 1.0, 1.0);
        this.gl.colorMask(false, false, false, true);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.gl.colorMask(true, true, true, true);
        this.updateFinished.dispatch();
    }
    update() {
        this.updatePending = null;
        this.draw();
    }
}


/***/ }),

/***/ "./src/neuroglancer/gpu_hash/hash_function.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/gpu_hash/hash_function.ts ***!
  \****************************************************/
/*! exports provided: hashCombine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hashCombine", function() { return hashCombine; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const k1 = 0xcc9e2d51;
const k2 = 0x1b873593;
// MurmurHash excluding the final mixing steps.
function hashCombine(state, value) {
    value >>>= 0;
    state >>>= 0;
    value = Math.imul(value, k1) >>> 0;
    value = ((value << 15) | (value >>> 17)) >>> 0;
    value = Math.imul(value, k2) >>> 0;
    state = (state ^ value) >>> 0;
    state = ((state << 13) | (state >>> 19)) >>> 0;
    state = ((state * 5) + 0xe6546b64) >>> 0;
    return state;
}


/***/ }),

/***/ "./src/neuroglancer/gpu_hash/hash_table.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/gpu_hash/hash_table.ts ***!
  \*************************************************/
/*! exports provided: NUM_ALTERNATIVES, HashTableBase, HashSetUint64, HashMapUint64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUM_ALTERNATIVES", function() { return NUM_ALTERNATIVES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashTableBase", function() { return HashTableBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashSetUint64", function() { return HashSetUint64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashMapUint64", function() { return HashMapUint64; });
/* harmony import */ var neuroglancer_gpu_hash_hash_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/gpu_hash/hash_function */ "./src/neuroglancer/gpu_hash/hash_function.ts");
/* harmony import */ var neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/random */ "./src/neuroglancer/util/random.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const NUM_ALTERNATIVES = 3;
const DEFAULT_LOAD_FACTOR = 0.9;
const DEBUG = false;
// Key that needs to be inserted.  Temporary variables used during insert.  These can safely be
// global because control never leaves functions defined in this module while these are in use.
let pendingLow = 0, pendingHigh = 0, backupPendingLow = 0, backupPendingHigh = 0;
class HashTableBase {
    constructor(hashSeeds = HashTableBase.generateHashSeeds(NUM_ALTERNATIVES)) {
        this.hashSeeds = hashSeeds;
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        this.size = 0;
        this.emptyLow = 4294967295;
        this.emptyHigh = 4294967295;
        this.maxRehashAttempts = 5;
        this.maxAttempts = 5;
        this.generation = 0;
        this.mungedEmptyKey = -1;
        // Minimum size must be greater than 2 * hashSeeds.length.  Otherwise, tableWithMungedEmptyKey
        // may loop infinitely.
        let initialSize = 8;
        while (initialSize < 2 * hashSeeds.length) {
            initialSize *= 2;
        }
        this.allocate(initialSize);
    }
    updateHashFunctions(numHashes) {
        this.hashSeeds = HashTableBase.generateHashSeeds(numHashes);
        this.mungedEmptyKey = -1;
    }
    /**
     * Invokes callback with a modified version of the hash table data array.
     *
     * Replaces all slots that appear to be valid entries for (emptyLow, emptyHigh), i.e. slots that
     * contain (emptyLow, emptyHigh) and to which (emptyLow, emptyHigh) hashes, with (mungedEmptyKey,
     * mungedEmptyKey).
     *
     * mungedEmptyKey is chosen to be a 32-bit value with the property that the 64-bit value
     * (mungedEmptyKey, mungedEmptyKey) does not hash to any of the same slots as (emptyLow,
     * emptyHigh).
     *
     * This allows the modified data array to be used for lookups without special casing the empty
     * key.
     */
    tableWithMungedEmptyKey(callback) {
        const numHashes = this.hashSeeds.length;
        const emptySlots = new Array(numHashes);
        for (let i = 0; i < numHashes; ++i) {
            emptySlots[i] = this.getHash(i, this.emptyLow, this.emptyHigh);
        }
        let { mungedEmptyKey } = this;
        if (mungedEmptyKey === -1) {
            chooseMungedEmptyKey: while (true) {
                mungedEmptyKey = (Math.random() * 0x1000000) >>> 0;
                for (let i = 0; i < numHashes; ++i) {
                    let h = this.getHash(i, mungedEmptyKey, mungedEmptyKey);
                    for (let j = 0; j < numHashes; ++j) {
                        if (emptySlots[j] === h) {
                            continue chooseMungedEmptyKey;
                        }
                    }
                }
                this.mungedEmptyKey = mungedEmptyKey;
                break;
            }
        }
        let { table, emptyLow, emptyHigh } = this;
        for (let i = 0; i < numHashes; ++i) {
            let h = emptySlots[i];
            if (table[h] === emptyLow && table[h + 1] === emptyHigh) {
                table[h] = mungedEmptyKey;
                table[h + 1] = mungedEmptyKey;
            }
        }
        try {
            callback(table);
        }
        finally {
            for (let i = 0; i < numHashes; ++i) {
                let h = emptySlots[i];
                if (table[h] === mungedEmptyKey && table[h + 1] === mungedEmptyKey) {
                    table[h] = emptyLow;
                    table[h + 1] = emptyHigh;
                }
            }
        }
    }
    static generateHashSeeds(numAlternatives = NUM_ALTERNATIVES) {
        return Object(neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_1__["getRandomValues"])(new Uint32Array(numAlternatives));
    }
    getHash(hashIndex, low, high) {
        let hash = this.hashSeeds[hashIndex];
        hash = Object(neuroglancer_gpu_hash_hash_function__WEBPACK_IMPORTED_MODULE_0__["hashCombine"])(hash, low);
        hash = Object(neuroglancer_gpu_hash_hash_function__WEBPACK_IMPORTED_MODULE_0__["hashCombine"])(hash, high);
        return this.entryStride * (hash & (this.tableSize - 1));
    }
    /**
     * Iterates over the Uint64 keys contained in the hash set.
     *
     * The same temp value will be modified and yielded at every iteration.
     */
    *keys(temp = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_2__["Uint64"]()) {
        let { emptyLow, emptyHigh, entryStride } = this;
        let { table } = this;
        for (let i = 0, length = table.length; i < length; i += entryStride) {
            let low = table[i], high = table[i + 1];
            if (low !== emptyLow || high !== emptyHigh) {
                temp.low = low;
                temp.high = high;
                yield temp;
            }
        }
    }
    indexOfPair(low, high) {
        let { table, emptyLow, emptyHigh } = this;
        if (low === emptyLow && high === emptyHigh) {
            return -1;
        }
        for (let i = 0, numHashes = this.hashSeeds.length; i < numHashes; ++i) {
            let h = this.getHash(i, low, high);
            if (table[h] === low && table[h + 1] === high) {
                return h;
            }
        }
        return -1;
    }
    /**
     * Returns the offset into the hash table of the specified element, or -1 if the element is not
     * present.
     */
    indexOf(x) {
        return this.indexOfPair(x.low, x.high);
    }
    /**
     * Changes the empty key to a value that is not equal to the current empty key and is not present
     * in the table.
     *
     * This is called when an attempt is made to insert the empty key.
     */
    chooseAnotherEmptyKey() {
        let { emptyLow, emptyHigh, table, entryStride } = this;
        let newLow, newHigh;
        while (true) {
            newLow = (Math.random() * 0x100000000) >>> 0;
            newHigh = (Math.random() * 0x100000000) >>> 0;
            if (newLow === emptyLow && newHigh === emptyHigh) {
                continue;
            }
            if (this.hasPair(newLow, newHigh)) {
                continue;
            }
            break;
        }
        this.emptyLow = newLow;
        this.emptyHigh = newHigh;
        // Replace empty keys in the table.
        for (let h = 0, length = table.length; h < length; h += entryStride) {
            if (table[h] === emptyLow && table[h + 1] === emptyHigh) {
                table[h] = newLow;
                table[h + 1] = newHigh;
            }
        }
    }
    /**
     * Returns true iff the specified element is present.
     */
    has(x) {
        return this.indexOf(x) !== -1;
    }
    /**
     * Returns true iff the specified element is present.
     */
    hasPair(low, high) {
        return this.indexOfPair(low, high) !== -1;
    }
    delete(x) {
        let index = this.indexOf(x);
        if (index !== -1) {
            let { table } = this;
            table[index] = this.emptyLow;
            table[index + 1] = this.emptyHigh;
            ++this.generation;
            this.size--;
            return true;
        }
        return false;
    }
    clearTable() {
        let { table, entryStride, emptyLow, emptyHigh } = this;
        let length = table.length;
        for (let h = 0; h < length; h += entryStride) {
            table[h] = emptyLow;
            table[h + 1] = emptyHigh;
        }
    }
    clear() {
        if (this.size === 0) {
            return false;
        }
        this.size = 0;
        ++this.generation;
        this.clearTable();
        return true;
    }
    swapPending(table, offset) {
        let tempLow = pendingLow, tempHigh = pendingHigh;
        this.storePending(table, offset);
        table[offset] = tempLow;
        table[offset + 1] = tempHigh;
    }
    storePending(table, offset) {
        pendingLow = table[offset];
        pendingHigh = table[offset + 1];
    }
    backupPending() {
        backupPendingLow = pendingLow;
        backupPendingHigh = pendingHigh;
    }
    restorePending() {
        pendingLow = backupPendingLow;
        pendingHigh = backupPendingHigh;
    }
    tryToInsert() {
        if (DEBUG) {
            console.log(`tryToInsert: ${pendingLow}, ${pendingHigh}`);
        }
        let attempt = 0;
        let { emptyLow, emptyHigh, maxAttempts, table } = this;
        let numHashes = this.hashSeeds.length;
        let tableIndex = Math.floor(Math.random() * numHashes);
        while (true) {
            let h = this.getHash(tableIndex, pendingLow, pendingHigh);
            this.swapPending(table, h);
            if (pendingLow === emptyLow && pendingHigh === emptyHigh) {
                return true;
            }
            if (++attempt === maxAttempts) {
                break;
            }
            tableIndex = (tableIndex + Math.floor(Math.random() * (numHashes - 1)) + 1) % numHashes;
        }
        return false;
    }
    allocate(tableSize) {
        this.tableSize = tableSize;
        let { entryStride } = this;
        this.table = new Uint32Array(tableSize * entryStride);
        this.maxAttempts = tableSize;
        this.clearTable();
        this.capacity = tableSize * this.loadFactor;
        this.mungedEmptyKey = -1;
    }
    rehash(oldTable, tableSize) {
        if (DEBUG) {
            console.log('rehash begin');
        }
        this.allocate(tableSize);
        this.updateHashFunctions(this.hashSeeds.length);
        let { emptyLow, emptyHigh, entryStride } = this;
        for (let h = 0, length = oldTable.length; h < length; h += entryStride) {
            let low = oldTable[h], high = oldTable[h + 1];
            if (low !== emptyLow || high !== emptyHigh) {
                this.storePending(oldTable, h);
                if (!this.tryToInsert()) {
                    if (DEBUG) {
                        console.log('rehash failed');
                    }
                    return false;
                }
            }
        }
        if (DEBUG) {
            console.log('rehash end');
        }
        return true;
    }
    grow(desiredTableSize) {
        if (DEBUG) {
            console.log(`grow: ${desiredTableSize}`);
        }
        let oldTable = this.table;
        let { tableSize } = this;
        while (tableSize < desiredTableSize) {
            tableSize *= 2;
        }
        while (true) {
            for (let rehashAttempt = 0; rehashAttempt < this.maxRehashAttempts; ++rehashAttempt) {
                if (this.rehash(oldTable, tableSize)) {
                    if (DEBUG) {
                        console.log(`grow end`);
                    }
                    return;
                }
            }
            tableSize *= 2;
        }
    }
    insertInternal() {
        ++this.generation;
        if (pendingLow === this.emptyLow && pendingHigh === this.emptyHigh) {
            this.chooseAnotherEmptyKey();
        }
        if (++this.size > this.capacity) {
            this.backupPending();
            this.grow(this.tableSize * 2);
            this.restorePending();
        }
        while (!this.tryToInsert()) {
            this.backupPending();
            this.grow(this.tableSize);
            this.restorePending();
        }
    }
}
class HashSetUint64 extends HashTableBase {
    add(x) {
        let { low, high } = x;
        if (this.hasPair(low, high)) {
            return false;
        }
        if (DEBUG) {
            console.log(`add: ${low},${high}`);
        }
        pendingLow = low;
        pendingHigh = high;
        this.insertInternal();
        return true;
    }
    /**
     * Iterates over the keys.  The same temporary value will be modified and yielded at every
     * iteration.
     */
    [Symbol.iterator]() {
        return this.keys();
    }
}
HashSetUint64.prototype.entryStride = 2;
// Value that needs to be inserted.  Temporary variables used during insert.  These can safely be
// global because control never leaves functions defined in this module while these are in use.
let pendingValueLow = 0, pendingValueHigh = 0, backupPendingValueLow = 0, backupPendingValueHigh = 0;
class HashMapUint64 extends HashTableBase {
    set(key, value) {
        let { low, high } = key;
        if (this.hasPair(low, high)) {
            return false;
        }
        if (DEBUG) {
            console.log(`add: ${low},${high} -> ${value.low},${value.high}`);
        }
        pendingLow = low;
        pendingHigh = high;
        pendingValueLow = value.low;
        pendingValueHigh = value.high;
        this.insertInternal();
        return true;
    }
    get(key, value) {
        let h = this.indexOf(key);
        if (h === -1) {
            return false;
        }
        let { table } = this;
        value.low = table[h + 2];
        value.high = table[h + 3];
        return true;
    }
    swapPending(table, offset) {
        let tempLow = pendingValueLow, tempHigh = pendingValueHigh;
        super.swapPending(table, offset);
        table[offset + 2] = tempLow;
        table[offset + 3] = tempHigh;
    }
    storePending(table, offset) {
        super.storePending(table, offset);
        pendingValueLow = table[offset + 2];
        pendingValueHigh = table[offset + 3];
    }
    backupPending() {
        super.backupPending();
        backupPendingValueLow = pendingValueLow;
        backupPendingValueHigh = pendingValueHigh;
    }
    restorePending() {
        super.restorePending();
        pendingValueLow = backupPendingValueLow;
        pendingValueHigh = backupPendingValueHigh;
    }
    /**
     * Iterates over entries.  The same temporary value will be modified and yielded at every
     * iteration.
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Iterates over entries.  The same temporary value will be modified and yielded at every
     * iteration.
     */
    *entries(temp = [new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_2__["Uint64"](), new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_2__["Uint64"]()]) {
        let { emptyLow, emptyHigh, entryStride } = this;
        let { table } = this;
        let [key, value] = temp;
        for (let i = 0, length = table.length; i < length; i += entryStride) {
            let low = table[i], high = table[i + 1];
            if (low !== emptyLow || high !== emptyHigh) {
                key.low = low;
                key.high = high;
                value.low = table[i + 2];
                value.high = table[i + 3];
                yield temp;
            }
        }
    }
}
HashMapUint64.prototype.entryStride = 4;


/***/ }),

/***/ "./src/neuroglancer/gpu_hash/shader.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/gpu_hash/shader.ts ***!
  \*********************************************/
/*! exports provided: glsl_hashCombine, GPUHashTable, HashSetShaderManager, HashMapShaderManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_hashCombine", function() { return glsl_hashCombine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GPUHashTable", function() { return GPUHashTable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashSetShaderManager", function() { return HashSetShaderManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashMapShaderManager", function() { return HashMapShaderManager; });
/* harmony import */ var neuroglancer_gpu_hash_hash_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/gpu_hash/hash_table */ "./src/neuroglancer/gpu_hash/hash_table.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/shader_lib */ "./src/neuroglancer/webgl/shader_lib.ts");
/* harmony import */ var neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/webgl/texture_access */ "./src/neuroglancer/webgl/texture_access.ts");
/* harmony import */ var _util_data_type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/data_type */ "./src/neuroglancer/util/data_type.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





// MumurHash, excluding the final mixing steps.
const glsl_hashCombine = [
    neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_uint64"], `
highp uint hashCombine(highp uint state, highp uint value) {
  value *= 0xcc9e2d51u;
  value = (value << 15u) | (value >> 17u);
  value *= 0x1b873593u;
  state ^= value;
  state = (state << 13u) | (state >> 19u);
  state = (state * 5u) + 0xe6546b64u;
  return state;
}
highp uint hashCombine(highp uint state, uint64_t x) {
  state = hashCombine(state, x.value[0]);
  return hashCombine(state, x.value[1]);
}
`
];
const textureFormat = Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_3__["computeTextureFormat"])(new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_3__["TextureFormat"](), _util_data_type__WEBPACK_IMPORTED_MODULE_4__["DataType"].UINT64, 1);
class GPUHashTable extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(gl, hashTable) {
        super();
        this.gl = gl;
        this.hashTable = hashTable;
        this.generation = -1;
        this.texture = null;
        // createTexture should never actually return null.
        this.texture = gl.createTexture();
    }
    copyToGPU() {
        let { hashTable } = this;
        let { generation } = hashTable;
        if (this.generation === generation) {
            return;
        }
        const { gl, texture } = this;
        Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_3__["compute1dTextureLayout"])(this, gl, textureFormat.texelsPerElement, hashTable.tableSize * hashTable.entryStride / 2);
        this.generation = generation;
        gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + gl.tempTextureUnit);
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
        hashTable.tableWithMungedEmptyKey(table => {
            Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_3__["setOneDimensionalTextureData"])(this.gl, this, textureFormat, table);
        });
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
    disposed() {
        let { gl } = this;
        gl.deleteTexture(this.texture);
        this.texture = null;
        this.gl = undefined;
        this.hashTable = undefined;
        super.disposed();
    }
    static get(gl, hashTable) {
        return gl.memoize.get(hashTable, () => new this(gl, hashTable));
    }
}
class HashSetShaderManager {
    constructor(prefix, numAlternatives = neuroglancer_gpu_hash_hash_table__WEBPACK_IMPORTED_MODULE_0__["NUM_ALTERNATIVES"]) {
        this.prefix = prefix;
        this.numAlternatives = numAlternatives;
        this.textureUnitSymbol = Symbol.for(`gpuhashtable:${this.prefix}`);
        this.accessHelper = new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_3__["OneDimensionalTextureAccessHelper"](`gpuhashtable_${this.prefix}`);
        this.samplerName = this.prefix + '_sampler';
        this.hashSeedsName = this.prefix + '_seeds';
        this.hashKeyMask = this.prefix + '_keyMask';
        this.readTable = this.prefix + '_readTable';
    }
    defineShader(builder) {
        let { hashSeedsName, samplerName, numAlternatives, hashKeyMask } = this;
        builder.addUniform('highp uint', hashSeedsName, numAlternatives);
        builder.addUniform('highp uint', hashKeyMask);
        builder.addTextureSampler('usampler2D', samplerName, this.textureUnitSymbol);
        builder.addFragmentCode(glsl_hashCombine);
        builder.addFragmentCode(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_uint64"]);
        builder.addFragmentCode(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_equalUint64"]);
        this.accessHelper.defineShader(builder);
        builder.addFragmentCode(this.accessHelper.getAccessor(this.readTable, this.samplerName, _util_data_type__WEBPACK_IMPORTED_MODULE_4__["DataType"].UINT64, 1));
        let s = '';
        s += `
bool ${this.hasFunctionName}(uint64_t x) {
`;
        for (let alt = 0; alt < numAlternatives; ++alt) {
            s += `
  {
    uint h = hashCombine(${hashSeedsName}[${alt}], x) & ${hashKeyMask};
    uint64_t key = ${this.readTable}(h);
    if (equals(key, x)) {
      return true;
    }
  }
`;
        }
        s += `
  return false;
}
`;
        builder.addFragmentCode(s);
    }
    get hasFunctionName() {
        return `${this.prefix}_has`;
    }
    enable(gl, shader, hashTable) {
        hashTable.copyToGPU();
        const textureUnit = shader.textureUnit(this.textureUnitSymbol);
        gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, hashTable.texture);
        this.accessHelper.setupTextureLayout(gl, shader, hashTable);
        gl.uniform1ui(shader.uniform(this.hashKeyMask), hashTable.hashTable.tableSize - 1);
        gl.uniform1uiv(shader.uniform(this.hashSeedsName), hashTable.hashTable.hashSeeds);
    }
    disable(gl, shader) {
        const textureUnit = shader.textureUnit(this.textureUnitSymbol);
        gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
}
class HashMapShaderManager extends HashSetShaderManager {
    defineShader(builder) {
        super.defineShader(builder);
        let { numAlternatives, hashSeedsName, hashKeyMask } = this;
        let s = `
bool ${this.getFunctionName}(uint64_t x, out uint64_t value) {
`;
        for (let alt = 0; alt < numAlternatives; ++alt) {
            s += `
  {
    uint h = hashCombine(${hashSeedsName}[${alt}], x) & ${hashKeyMask};
    uint64_t key = ${this.readTable}(h * 2u);
    if (equals(key, x)) {
      value = ${this.readTable}(h * 2u + 1u);
      return true;
    }
  }
`;
        }
        s += `
  return false;
}
`;
        builder.addFragmentCode(s);
    }
    get getFunctionName() {
        return `${this.prefix}_get`;
    }
}


/***/ }),

/***/ "./src/neuroglancer/help/input_event_bindings.css":
/*!********************************************************!*\
  !*** ./src/neuroglancer/help/input_event_bindings.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/help/input_event_bindings.ts":
/*!*******************************************************!*\
  !*** ./src/neuroglancer/help/input_event_bindings.ts ***!
  \*******************************************************/
/*! exports provided: formatKeyName, formatKeyStroke, InputEventBindingHelpDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatKeyName", function() { return formatKeyName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatKeyStroke", function() { return formatKeyStroke; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputEventBindingHelpDialog", function() { return InputEventBindingHelpDialog; });
/* harmony import */ var neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/overlay */ "./src/neuroglancer/overlay.ts");
/* harmony import */ var _input_event_bindings_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./input_event_bindings.css */ "./src/neuroglancer/help/input_event_bindings.css");
/* harmony import */ var _input_event_bindings_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_input_event_bindings_css__WEBPACK_IMPORTED_MODULE_1__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function formatKeyName(name) {
    if (name.startsWith('key')) {
        return name.substring(3);
    }
    if (name.startsWith('digit')) {
        return name.substring(5);
    }
    if (name.startsWith('arrow')) {
        return name.substring(5);
    }
    return name;
}
function formatKeyStroke(stroke) {
    let parts = stroke.split('+');
    return parts.map(formatKeyName).join('+');
}
class InputEventBindingHelpDialog extends neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_0__["Overlay"] {
    /**
     * @param keyMap Key map to list.
     */
    constructor(bindings) {
        super();
        let { content } = this;
        content.classList.add('describe-key-bindings');
        let scroll = document.createElement('div');
        scroll.classList.add('describe-key-bindings-container');
        const uniqueMaps = new Map();
        function addEntries(eventMap, entries) {
            for (const parent of eventMap.parents) {
                if (parent.label !== undefined) {
                    addMap(parent.label, parent);
                }
                else {
                    addEntries(parent, entries);
                }
            }
            for (const [event, eventAction] of eventMap.bindings.entries()) {
                const firstColon = event.indexOf(':');
                const suffix = event.substring(firstColon + 1);
                entries.set(suffix, eventAction.action);
            }
        }
        function addMap(label, map) {
            if (uniqueMaps.has(map)) {
                return;
            }
            const list = {
                label,
                entries: new Map(),
            };
            addEntries(map, list.entries);
            uniqueMaps.set(map, list);
        }
        for (const [label, eventMap] of bindings) {
            addMap(label, eventMap);
        }
        for (const list of uniqueMaps.values()) {
            let header = document.createElement('h2');
            header.textContent = list.label;
            scroll.appendChild(header);
            for (const [event, action] of list.entries) {
                let dt = document.createElement('div');
                dt.className = 'dt';
                dt.textContent = formatKeyStroke(event);
                let dd = document.createElement('div');
                dd.className = 'dd';
                dd.textContent = action;
                scroll.appendChild(dt);
                scroll.appendChild(dd);
            }
        }
        content.appendChild(scroll);
    }
}


/***/ }),

/***/ "./src/neuroglancer/image_user_layer.css":
/*!***********************************************!*\
  !*** ./src/neuroglancer/image_user_layer.css ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/image_user_layer.ts":
/*!**********************************************!*\
  !*** ./src/neuroglancer/image_user_layer.ts ***!
  \**********************************************/
/*! exports provided: ImageUserLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUserLayer", function() { return ImageUserLayer; });
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/overlay */ "./src/neuroglancer/overlay.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_image_renderlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/volume/image_renderlayer */ "./src/neuroglancer/sliceview/volume/image_renderlayer.ts");
/* harmony import */ var neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/trackable_alpha */ "./src/neuroglancer/trackable_alpha.ts");
/* harmony import */ var neuroglancer_trackable_blend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/trackable_blend */ "./src/neuroglancer/trackable_blend.ts");
/* harmony import */ var neuroglancer_user_layer_with_volume_source__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/user_layer_with_volume_source */ "./src/neuroglancer/user_layer_with_volume_source.ts");
/* harmony import */ var neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/webgl/dynamic_shader */ "./src/neuroglancer/webgl/dynamic_shader.ts");
/* harmony import */ var neuroglancer_webgl_shader_ui_controls__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/webgl/shader_ui_controls */ "./src/neuroglancer/webgl/shader_ui_controls.ts");
/* harmony import */ var neuroglancer_widget_enum_widget__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/widget/enum_widget */ "./src/neuroglancer/widget/enum_widget.ts");
/* harmony import */ var neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/widget/range */ "./src/neuroglancer/widget/range.ts");
/* harmony import */ var neuroglancer_widget_render_scale_widget__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/widget/render_scale_widget */ "./src/neuroglancer/widget/render_scale_widget.ts");
/* harmony import */ var neuroglancer_widget_shader_code_widget__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/widget/shader_code_widget */ "./src/neuroglancer/widget/shader_code_widget.ts");
/* harmony import */ var neuroglancer_widget_shader_controls__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/widget/shader_controls */ "./src/neuroglancer/widget/shader_controls.ts");
/* harmony import */ var neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/widget/tab_view */ "./src/neuroglancer/widget/tab_view.ts");
/* harmony import */ var _image_user_layer_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./image_user_layer.css */ "./src/neuroglancer/image_user_layer.css");
/* harmony import */ var _image_user_layer_css__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_image_user_layer_css__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var neuroglancer_maximize_button_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! neuroglancer/maximize_button.css */ "./src/neuroglancer/maximize_button.css");
/* harmony import */ var neuroglancer_maximize_button_css__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_maximize_button_css__WEBPACK_IMPORTED_MODULE_17__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















const OPACITY_JSON_KEY = 'opacity';
const BLEND_JSON_KEY = 'blend';
const SHADER_JSON_KEY = 'shader';
const SHADER_CONTROLS_JSON_KEY = 'shaderControls';
const Base = Object(neuroglancer_user_layer_with_volume_source__WEBPACK_IMPORTED_MODULE_7__["UserLayerWithVolumeSourceMixin"])(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__["UserLayer"]);
class ImageUserLayer extends Base {
    constructor(manager, x) {
        super(manager, x);
        this.opacity = Object(neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_5__["trackableAlphaValue"])(0.5);
        this.blendMode = Object(neuroglancer_trackable_blend__WEBPACK_IMPORTED_MODULE_6__["trackableBlendModeValue"])();
        this.fragmentMain = Object(neuroglancer_sliceview_volume_image_renderlayer__WEBPACK_IMPORTED_MODULE_4__["getTrackableFragmentMain"])();
        this.shaderError = Object(neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_8__["makeWatchableShaderError"])();
        this.shaderControlState = new neuroglancer_webgl_shader_ui_controls__WEBPACK_IMPORTED_MODULE_9__["ShaderControlState"](this.fragmentMain);
        this.registerDisposer(this.blendMode.changed.add(this.specificationChanged.dispatch));
        this.registerDisposer(this.fragmentMain.changed.add(this.specificationChanged.dispatch));
        this.registerDisposer(this.shaderControlState.changed.add(this.specificationChanged.dispatch));
        this.tabs.add('rendering', { label: 'Rendering', order: -100, getter: () => new RenderingOptionsTab(this) });
        this.tabs.default = 'rendering';
    }
    restoreState(specification) {
        super.restoreState(specification);
        this.opacity.restoreState(specification[OPACITY_JSON_KEY]);
        const blendValue = specification[BLEND_JSON_KEY];
        if (blendValue !== undefined) {
            this.blendMode.restoreState(blendValue);
        }
        this.fragmentMain.restoreState(specification[SHADER_JSON_KEY]);
        this.shaderControlState.restoreState(specification[SHADER_CONTROLS_JSON_KEY]);
        const { multiscaleSource } = this;
        if (multiscaleSource === undefined) {
            throw new Error(`source property must be specified`);
        }
        multiscaleSource.then(volume => {
            if (!this.wasDisposed) {
                let renderLayer = this.renderLayer = new neuroglancer_sliceview_volume_image_renderlayer__WEBPACK_IMPORTED_MODULE_4__["ImageRenderLayer"](volume, {
                    opacity: this.opacity,
                    blendMode: this.blendMode,
                    shaderControlState: this.shaderControlState,
                    shaderError: this.shaderError,
                    transform: this.transform,
                    renderScaleTarget: this.sliceViewRenderScaleTarget,
                    renderScaleHistogram: this.sliceViewRenderScaleHistogram,
                });
                this.addRenderLayer(renderLayer);
                this.shaderError.changed.dispatch();
                this.isReady = true;
            }
        });
    }
    toJSON() {
        const x = super.toJSON();
        x['type'] = 'image';
        x[OPACITY_JSON_KEY] = this.opacity.toJSON();
        x[BLEND_JSON_KEY] = this.blendMode.toJSON();
        x[SHADER_JSON_KEY] = this.fragmentMain.toJSON();
        x[SHADER_CONTROLS_JSON_KEY] = this.shaderControlState.toJSON();
        return x;
    }
}
function makeShaderCodeWidget(layer) {
    return new neuroglancer_widget_shader_code_widget__WEBPACK_IMPORTED_MODULE_13__["ShaderCodeWidget"]({
        shaderError: layer.shaderError,
        fragmentMain: layer.fragmentMain,
        fragmentMainStartLine: neuroglancer_sliceview_volume_image_renderlayer__WEBPACK_IMPORTED_MODULE_4__["FRAGMENT_MAIN_START"],
        shaderControlState: layer.shaderControlState,
    });
}
class RenderingOptionsTab extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_15__["Tab"] {
    constructor(layer) {
        super();
        this.layer = layer;
        this.opacityWidget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_11__["RangeWidget"](this.layer.opacity));
        this.codeWidget = this.registerDisposer(makeShaderCodeWidget(this.layer));
        const { element } = this;
        element.classList.add('image-dropdown');
        let { opacityWidget } = this;
        let topRow = document.createElement('div');
        topRow.className = 'image-dropdown-top-row';
        opacityWidget.promptElement.textContent = 'Opacity';
        {
            const renderScaleWidget = this.registerDisposer(new neuroglancer_widget_render_scale_widget__WEBPACK_IMPORTED_MODULE_12__["RenderScaleWidget"](this.layer.sliceViewRenderScaleHistogram, this.layer.sliceViewRenderScaleTarget));
            renderScaleWidget.label.textContent = 'Resolution (slice)';
            element.appendChild(renderScaleWidget.element);
        }
        {
            const label = document.createElement('label');
            label.textContent = 'Blending';
            label.appendChild(this.registerDisposer(new neuroglancer_widget_enum_widget__WEBPACK_IMPORTED_MODULE_10__["EnumSelectWidget"](layer.blendMode)).element);
            element.appendChild(label);
        }
        let spacer = document.createElement('div');
        spacer.style.flex = '1';
        let helpLink = document.createElement('a');
        let helpButton = document.createElement('button');
        helpButton.type = 'button';
        helpButton.textContent = '?';
        helpButton.className = 'help-link';
        helpLink.appendChild(helpButton);
        helpLink.title = 'Documentation on image layer rendering';
        helpLink.target = '_blank';
        helpLink.href =
            'https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md';
        let maximizeButton = document.createElement('button');
        maximizeButton.innerHTML = '&square;';
        maximizeButton.className = 'maximize-button';
        maximizeButton.title = 'Show larger editor view';
        this.registerEventListener(maximizeButton, 'click', () => {
            new ShaderCodeOverlay(this.layer);
        });
        topRow.appendChild(this.opacityWidget.element);
        topRow.appendChild(spacer);
        topRow.appendChild(maximizeButton);
        topRow.appendChild(helpLink);
        element.appendChild(topRow);
        element.appendChild(this.codeWidget.element);
        element.appendChild(this.registerDisposer(new neuroglancer_widget_shader_controls__WEBPACK_IMPORTED_MODULE_14__["ShaderControls"](layer.shaderControlState)).element);
        this.codeWidget.textEditor.refresh();
        this.visibility.changed.add(() => {
            if (this.visible) {
                this.codeWidget.textEditor.refresh();
            }
        });
    }
}
class ShaderCodeOverlay extends neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_2__["Overlay"] {
    constructor(layer) {
        super();
        this.layer = layer;
        this.codeWidget = this.registerDisposer(makeShaderCodeWidget(this.layer));
        this.content.classList.add('image-layer-shader-overlay');
        this.content.appendChild(this.codeWidget.element);
        this.codeWidget.textEditor.refresh();
    }
}
Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_1__["registerLayerType"])('image', ImageUserLayer);
Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_1__["registerVolumeLayerType"])(neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["VolumeType"].IMAGE, ImageUserLayer);


/***/ }),

/***/ "./src/neuroglancer/layer.ts":
/*!***********************************!*\
  !*** ./src/neuroglancer/layer.ts ***!
  \***********************************/
/*! exports provided: RenderLayerRole, allRenderLayerRoles, RenderLayer, VisibilityTrackedRenderLayer, UserLayer, ManagedUserLayer, LayerManager, MouseSelectionState, LayerSelectedValues, VisibleRenderLayerTracker, makeRenderedPanelVisibleLayerTracker, SelectedLayerState, LayerReference */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderLayerRole", function() { return RenderLayerRole; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allRenderLayerRoles", function() { return allRenderLayerRoles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderLayer", function() { return RenderLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VisibilityTrackedRenderLayer", function() { return VisibilityTrackedRenderLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserLayer", function() { return UserLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ManagedUserLayer", function() { return ManagedUserLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerManager", function() { return LayerManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MouseSelectionState", function() { return MouseSelectionState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerSelectedValues", function() { return LayerSelectedValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VisibleRenderLayerTracker", function() { return VisibleRenderLayerTracker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRenderedPanelVisibleLayerTracker", function() { return makeRenderedPanelVisibleLayerTracker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectedLayerState", function() { return SelectedLayerState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerReference", function() { return LayerReference; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_ui_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/ui/tool */ "./src/neuroglancer/ui/tool.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_signal_binding_updater__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/signal_binding_updater */ "./src/neuroglancer/util/signal_binding_updater.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/widget/tab_view */ "./src/neuroglancer/widget/tab_view.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











var RenderLayerRole;
(function (RenderLayerRole) {
    RenderLayerRole[RenderLayerRole["DATA"] = 0] = "DATA";
    RenderLayerRole[RenderLayerRole["ANNOTATION"] = 1] = "ANNOTATION";
    RenderLayerRole[RenderLayerRole["DEFAULT_ANNOTATION"] = 2] = "DEFAULT_ANNOTATION";
})(RenderLayerRole || (RenderLayerRole = {}));
function allRenderLayerRoles() {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_1__["WatchableSet"]([RenderLayerRole.DATA, RenderLayerRole.ANNOTATION, RenderLayerRole.DEFAULT_ANNOTATION]);
}
class RenderLayer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor() {
        super(...arguments);
        this.ready = false;
        this.role = RenderLayerRole.DATA;
        this.layerChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.redrawNeeded = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.readyStateChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        /**
         * Base voxel size for this layer, in nanometers per voxel.
         */
        this.voxelSize = null;
        /**
         * Bounding box for this layer, in nanometers.
         */
        this.boundingBox = null;
    }
    setReady(value) {
        this.ready = value;
        this.readyStateChanged.dispatch();
        this.layerChanged.dispatch();
    }
    handleAction(_action) {
        // Do nothing by default.
    }
    getValueAt(_x) {
        return undefined;
    }
    /**
     * Transform the stored pickedValue and offset associated with the retrieved pick ID into the
     * actual value.
     */
    transformPickedValue(pickedValue, _pickedOffset) {
        return pickedValue;
    }
    /**
     * Optionally updates the mouse state based on the retrived pick information.  This might snap the
     * 3-d position to the center of the picked point.
     */
    updateMouseState(_mouseState, _pickedValue, _pickedOffset, _data) { }
}
/**
 * Extends RenderLayer with functionality for tracking the number of panels in which the layer is
 * visible.
 */
class VisibilityTrackedRenderLayer extends RenderLayer {
    constructor() {
        super(...arguments);
        this.visibility = new neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_9__["VisibilityPriorityAggregator"]();
    }
}
const TAB_JSON_KEY = 'tab';
const TOOL_JSON_KEY = 'tool';
class UserLayer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(manager, specification) {
        super();
        this.manager = manager;
        this.layersChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.readyStateChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.specificationChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.renderLayers = new Array();
        this.isReady = false;
        this.tabs = this.registerDisposer(new neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_10__["TabSpecification"]());
        this.tool = this.registerDisposer(new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_1__["TrackableRefCounted"](value => Object(neuroglancer_ui_tool__WEBPACK_IMPORTED_MODULE_2__["restoreTool"])(this, value), value => value.toJSON()));
        specification;
        this.tabs.changed.add(this.specificationChanged.dispatch);
        this.tool.changed.add(this.specificationChanged.dispatch);
    }
    restoreState(specification) {
        this.tool.restoreState(specification[TOOL_JSON_KEY]);
        this.tabs.restoreState(specification[TAB_JSON_KEY]);
    }
    addRenderLayer(layer) {
        this.renderLayers.push(layer);
        const { layersChanged, readyStateChanged } = this;
        layer.layerChanged.add(layersChanged.dispatch);
        layer.readyStateChanged.add(readyStateChanged.dispatch);
        readyStateChanged.dispatch();
        layersChanged.dispatch();
    }
    removeRenderLayer(layer) {
        const { renderLayers, layersChanged, readyStateChanged } = this;
        const index = renderLayers.indexOf(layer);
        if (index === -1) {
            throw new Error('Attempted to remove invalid RenderLayer');
        }
        renderLayers.splice(index, 1);
        layer.layerChanged.remove(layersChanged.dispatch);
        layer.readyStateChanged.remove(readyStateChanged.dispatch);
        layer.dispose();
        readyStateChanged.dispatch();
        layersChanged.dispatch();
    }
    disposed() {
        const { layersChanged, readyStateChanged } = this;
        for (const layer of this.renderLayers) {
            layer.layerChanged.remove(layersChanged.dispatch);
            layer.readyStateChanged.remove(readyStateChanged.dispatch);
            layer.dispose();
        }
        super.disposed();
    }
    getValueAt(position, pickState) {
        let result;
        let { renderLayers } = this;
        let { pickedRenderLayer } = pickState;
        if (pickedRenderLayer !== null && renderLayers.indexOf(pickedRenderLayer) !== -1) {
            result =
                pickedRenderLayer.transformPickedValue(pickState.pickedValue, pickState.pickedOffset);
            return this.transformPickedValue(result);
        }
        for (let layer of renderLayers) {
            if (!layer.ready) {
                continue;
            }
            result = layer.getValueAt(position);
            if (result !== undefined) {
                break;
            }
        }
        return this.transformPickedValue(result);
    }
    transformPickedValue(value) {
        return value;
    }
    toJSON() {
        return {
            [TAB_JSON_KEY]: this.tabs.toJSON(),
            [TOOL_JSON_KEY]: this.tool.toJSON(),
        };
    }
    handleAction(_action) { }
}
class ManagedUserLayer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    /**
     * If layer is not null, tranfers ownership of a reference.
     */
    constructor(name, layer = null, visible = true) {
        super();
        this.visible = visible;
        this.readyStateChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.layerChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.specificationChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.wasDisposed = false;
        this.layer_ = null;
        this.name_ = name;
        this.layer = layer;
    }
    get layer() {
        return this.layer_;
    }
    /**
     * If layer is not null, tranfers ownership of a reference.
     */
    set layer(layer) {
        let oldLayer = this.layer_;
        if (oldLayer != null) {
            this.unregisterUserLayer();
            oldLayer.dispose();
        }
        this.layer_ = layer;
        if (layer != null) {
            const removers = [
                layer.layersChanged.add(() => this.handleLayerChanged()),
                layer.readyStateChanged.add(this.readyStateChanged.dispatch),
                layer.specificationChanged.add(this.specificationChanged.dispatch)
            ];
            this.unregisterUserLayer = () => {
                removers.forEach(x => x());
            };
            this.readyStateChanged.dispatch();
            this.handleLayerChanged();
        }
    }
    isReady() {
        const { layer } = this;
        return layer !== null && layer.isReady;
    }
    get name() {
        return this.name_;
    }
    set name(value) {
        if (value !== this.name_) {
            this.name_ = value;
            this.layerChanged.dispatch();
        }
    }
    handleLayerChanged() {
        if (this.visible) {
            this.layerChanged.dispatch();
        }
    }
    setVisible(value) {
        if (value !== this.visible) {
            this.visible = value;
            this.layerChanged.dispatch();
        }
    }
    disposed() {
        this.wasDisposed = true;
        this.layer = null;
        super.disposed();
    }
}
class LayerManager extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor() {
        super();
        this.managedLayers = new Array();
        this.layerSet = new Set();
        this.layersChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.readyStateChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.specificationChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.boundPositions = new WeakSet();
        this.numDirectUsers = 0;
        this.renderLayerToManagedLayerMapGeneration = -1;
        this.renderLayerToManagedLayerMap_ = new Map();
        this.scheduleRemoveLayersWithSingleRef = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => this.removeLayersWithSingleRef(), 0));
        this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef);
    }
    get renderLayerToManagedLayerMap() {
        const generation = this.layersChanged.count;
        const map = this.renderLayerToManagedLayerMap_;
        if (this.renderLayerToManagedLayerMapGeneration !== generation) {
            this.renderLayerToManagedLayerMapGeneration = generation;
            map.clear();
            for (const managedLayer of this.managedLayers) {
                const userLayer = managedLayer.layer;
                if (userLayer !== null) {
                    for (const renderLayer of userLayer.renderLayers) {
                        map.set(renderLayer, managedLayer);
                    }
                }
            }
        }
        return map;
    }
    filter(predicate) {
        let changed = false;
        this.managedLayers = this.managedLayers.filter(layer => {
            if (!predicate(layer)) {
                this.unbindManagedLayer(layer);
                this.layerSet.delete(layer);
                changed = true;
                return false;
            }
            return true;
        });
        if (changed) {
            this.layersChanged.dispatch();
        }
    }
    removeLayersWithSingleRef() {
        if (this.numDirectUsers > 0) {
            return;
        }
        this.filter(layer => layer.refCount !== 1);
    }
    updateSignalBindings(layer, callback) {
        callback(layer.layerChanged, this.layersChanged.dispatch);
        callback(layer.readyStateChanged, this.readyStateChanged.dispatch);
        callback(layer.specificationChanged, this.specificationChanged.dispatch);
    }
    useDirectly() {
        if (++this.numDirectUsers === 1) {
            this.layersChanged.remove(this.scheduleRemoveLayersWithSingleRef);
        }
        return () => {
            if (--this.numDirectUsers === 0) {
                this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef);
                this.scheduleRemoveLayersWithSingleRef();
            }
        };
    }
    /**
     * Assumes ownership of an existing reference to managedLayer.
     */
    addManagedLayer(managedLayer, index) {
        this.updateSignalBindings(managedLayer, neuroglancer_util_signal_binding_updater__WEBPACK_IMPORTED_MODULE_7__["addSignalBinding"]);
        this.layerSet.add(managedLayer);
        if (index === undefined) {
            index = this.managedLayers.length;
        }
        this.managedLayers.splice(index, 0, managedLayer);
        this.layersChanged.dispatch();
        this.readyStateChanged.dispatch();
        return managedLayer;
    }
    /**
     * Assumes ownership of an existing reference to userLayer.
     */
    addUserLayer(name, userLayer, visible) {
        let managedLayer = new ManagedUserLayer(name, userLayer, visible);
        return this.addManagedLayer(managedLayer);
    }
    *readyRenderLayers() {
        for (let managedUserLayer of this.managedLayers) {
            if (!managedUserLayer.visible || !managedUserLayer.layer) {
                continue;
            }
            for (let renderLayer of managedUserLayer.layer.renderLayers) {
                if (!renderLayer.ready) {
                    continue;
                }
                yield renderLayer;
            }
        }
    }
    unbindManagedLayer(managedLayer) {
        this.updateSignalBindings(managedLayer, neuroglancer_util_signal_binding_updater__WEBPACK_IMPORTED_MODULE_7__["removeSignalBinding"]);
        managedLayer.dispose();
    }
    clear() {
        for (let managedLayer of this.managedLayers) {
            this.unbindManagedLayer(managedLayer);
        }
        this.managedLayers.length = 0;
        this.layerSet.clear();
        this.layersChanged.dispatch();
    }
    remove(index) {
        const layer = this.managedLayers[index];
        this.unbindManagedLayer(layer);
        this.managedLayers.splice(index, 1);
        this.layerSet.delete(layer);
        this.layersChanged.dispatch();
    }
    removeManagedLayer(managedLayer) {
        let index = this.managedLayers.indexOf(managedLayer);
        if (index === -1) {
            throw new Error(`Internal error: invalid managed layer.`);
        }
        this.remove(index);
    }
    reorderManagedLayer(oldIndex, newIndex) {
        const numLayers = this.managedLayers.length;
        if (oldIndex === newIndex || oldIndex < 0 || oldIndex >= numLayers || newIndex < 0 ||
            newIndex >= numLayers) {
            // Don't do anything.
            return;
        }
        let [oldLayer] = this.managedLayers.splice(oldIndex, 1);
        this.managedLayers.splice(newIndex, 0, oldLayer);
        this.layersChanged.dispatch();
    }
    disposed() {
        this.clear();
        super.disposed();
    }
    getLayerByName(name) {
        return this.managedLayers.find(x => x.name === name);
    }
    getUniqueLayerName(name) {
        let suggestedName = name;
        let suffix = 0;
        while (this.getLayerByName(suggestedName) !== undefined) {
            suggestedName = name + (++suffix);
        }
        return suggestedName;
    }
    has(layer) {
        return this.layerSet.has(layer);
    }
    /**
     * Asynchronously initialize the voxelSize and position based on the managed layers.
     *
     * The first ready layer with an associated bounding box will set the position to the center of
     * the bounding box.
     *
     * If the position later becomes invalid, it will be initialized again.
     */
    initializePosition(position) {
        let { boundPositions } = this;
        if (boundPositions.has(position)) {
            return;
        }
        boundPositions.add(position);
        // Deboucne to ensure that if the position is reset and the layers are reset immediately after,
        // the position will not be reinitialized based on the soon to be reset layers.
        const handler = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
            this.updatePositionFromLayers(position);
        });
        this.readyStateChanged.add(handler);
        position.changed.add(handler);
        this.updatePositionFromLayers(position);
    }
    updatePositionFromLayers(position) {
        if (position.valid) {
            return;
        }
        for (let managedLayer of this.managedLayers) {
            let userLayer = managedLayer.layer;
            if (userLayer == null) {
                continue;
            }
            for (let renderLayer of userLayer.renderLayers) {
                if (!renderLayer.ready) {
                    continue;
                }
                if (!position.voxelSize.valid && renderLayer.voxelSize != null) {
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].copy(position.voxelSize.size, renderLayer.voxelSize);
                    position.voxelSize.setValid();
                }
                if (!position.spatialCoordinatesValid && !position.voxelCoordinatesValid &&
                    renderLayer.boundingBox != null) {
                    let boundingBox = renderLayer.boundingBox;
                    let centerPosition = position.spatialCoordinates;
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].add(centerPosition, boundingBox.lower, boundingBox.upper);
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].scale(centerPosition, centerPosition, 0.5);
                    position.spatialCoordinatesValid = true;
                    position.changed.dispatch();
                }
            }
        }
    }
    get renderLayers() {
        let layerManager = this;
        return {
            *[Symbol.iterator]() {
                for (let managedLayer of layerManager.managedLayers) {
                    if (managedLayer.layer === null) {
                        continue;
                    }
                    for (let renderLayer of managedLayer.layer.renderLayers) {
                        yield renderLayer;
                    }
                }
            }
        };
    }
    get visibleRenderLayers() {
        let layerManager = this;
        return {
            *[Symbol.iterator]() {
                for (let managedLayer of layerManager.managedLayers) {
                    if (managedLayer.layer === null || !managedLayer.visible) {
                        continue;
                    }
                    for (let renderLayer of managedLayer.layer.renderLayers) {
                        yield renderLayer;
                    }
                }
            }
        };
    }
    invokeAction(action) {
        for (let managedLayer of this.managedLayers) {
            if (managedLayer.layer === null || !managedLayer.visible) {
                continue;
            }
            let userLayer = managedLayer.layer;
            userLayer.handleAction(action);
            for (let renderLayer of userLayer.renderLayers) {
                if (!renderLayer.ready) {
                    continue;
                }
                renderLayer.handleAction(action);
            }
        }
    }
}
class MouseSelectionState {
    constructor() {
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.position = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        this.active = false;
        this.pickedRenderLayer = null;
        this.pickedValue = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_8__["Uint64"](0, 0);
        this.pickedOffset = 0;
        this.pickedAnnotationLayer = undefined;
        this.pickedAnnotationId = undefined;
        this.pickedAnnotationBuffer = undefined;
        this.pickedAnnotationBufferOffset = undefined;
        this.forcerFunction = undefined;
    }
    removeForcer(forcer) {
        if (forcer === this.forcerFunction) {
            this.forcerFunction = undefined;
            this.setActive(false);
        }
    }
    setForcer(forcer) {
        this.forcerFunction = forcer;
        if (forcer === undefined) {
            this.setActive(false);
        }
    }
    updateUnconditionally() {
        const { forcerFunction } = this;
        if (forcerFunction === undefined) {
            return false;
        }
        forcerFunction();
        return this.active;
    }
    setActive(value) {
        if (this.active !== value || value === true) {
            this.active = value;
            this.changed.dispatch();
        }
    }
}
class LayerSelectedValues extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(layerManager, mouseState) {
        super();
        this.layerManager = layerManager;
        this.mouseState = mouseState;
        this.values = new Map();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.needsUpdate = true;
        this.registerDisposer(mouseState.changed.add(() => {
            this.handleChange();
        }));
        this.registerDisposer(layerManager.layersChanged.add(() => {
            this.handleLayerChange();
        }));
    }
    /**
     * This should be called when the layer data may have changed, due to the set of managed layers
     * changing or new data having been received.
     */
    handleLayerChange() {
        if (this.mouseState.active) {
            this.handleChange();
        }
    }
    handleChange() {
        this.needsUpdate = true;
        this.changed.dispatch();
    }
    update() {
        if (!this.needsUpdate) {
            return;
        }
        this.needsUpdate = false;
        let values = this.values;
        let mouseState = this.mouseState;
        values.clear();
        if (mouseState.active) {
            let position = mouseState.position;
            for (let layer of this.layerManager.managedLayers) {
                let userLayer = layer.layer;
                if (layer.visible && userLayer) {
                    values.set(userLayer, userLayer.getValueAt(position, mouseState));
                }
            }
        }
    }
    get(userLayer) {
        this.update();
        return this.values.get(userLayer);
    }
    toJSON() {
        this.update();
        const result = {};
        const { values } = this;
        for (const layer of this.layerManager.managedLayers) {
            const userLayer = layer.layer;
            if (userLayer) {
                let v = values.get(userLayer);
                if (v !== undefined) {
                    if (v instanceof neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_8__["Uint64"]) {
                        v = { 't': 'u64', 'v': v };
                    }
                    result[layer.name] = v;
                }
            }
        }
        return result;
    }
}
class VisibleRenderLayerTracker extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(layerManager, renderLayerType, roles, layerAdded, visibility) {
        super();
        this.layerManager = layerManager;
        this.renderLayerType = renderLayerType;
        this.roles = roles;
        this.layerAdded = layerAdded;
        this.visibility = visibility;
        /**
         * Maps a layer to the disposer to call when it is no longer visible.
         */
        this.visibleLayers = new Map();
        this.newVisibleLayers = new Set();
        this.debouncedUpdateVisibleLayers = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => this.updateVisibleLayers(), 0));
        this.registerDisposer(layerManager.layersChanged.add(this.debouncedUpdateVisibleLayers));
        this.registerDisposer(roles.changed.add(this.debouncedUpdateVisibleLayers));
        this.updateVisibleLayers();
    }
    disposed() {
        this.visibleLayers.forEach(disposer => disposer());
        this.visibleLayers.clear();
        super.disposed();
    }
    updateVisibleLayers() {
        let { visibleLayers, newVisibleLayers, renderLayerType, layerAdded, roles } = this;
        for (let renderLayer of this.layerManager.readyRenderLayers()) {
            if (renderLayer instanceof renderLayerType && roles.has(renderLayer.role)) {
                let typedLayer = renderLayer;
                newVisibleLayers.add(typedLayer);
                if (!visibleLayers.has(typedLayer)) {
                    const visibilityDisposer = typedLayer.visibility.add(this.visibility);
                    const disposer = layerAdded(typedLayer);
                    visibleLayers.set(typedLayer.addRef(), () => {
                        disposer();
                        visibilityDisposer();
                        typedLayer.dispose();
                    });
                }
            }
        }
        for (let [renderLayer, disposer] of visibleLayers) {
            if (!newVisibleLayers.has(renderLayer)) {
                visibleLayers.delete(renderLayer);
                disposer();
            }
        }
        newVisibleLayers.clear();
    }
    getVisibleLayers() {
        this.debouncedUpdateVisibleLayers.flush();
        return [...this.visibleLayers.keys()];
    }
}
function makeRenderedPanelVisibleLayerTracker(layerManager, renderLayerType, roles, panel, layerAdded) {
    return panel.registerDisposer(new VisibleRenderLayerTracker(layerManager, renderLayerType, roles, layer => {
        const disposer = layer.redrawNeeded.add(() => panel.scheduleRedraw());
        const disposer2 = layerAdded && layerAdded(layer);
        panel.scheduleRedraw();
        return () => {
            if (disposer2 !== undefined) {
                disposer2();
            }
            disposer();
            panel.scheduleRedraw();
        };
    }, panel.visibility));
}
class SelectedLayerState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(layerManager) {
        super();
        this.layerManager = layerManager;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.visible_ = false;
        this.size = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_1__["TrackableValue"](300, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__["verifyPositiveInt"]);
        this.registerDisposer(layerManager);
        this.size.changed.add(this.changed.dispatch);
    }
    get layer() {
        return this.layer_;
    }
    get visible() {
        return this.visible_;
    }
    set visible(value) {
        if (this.layer_ === undefined) {
            value = false;
        }
        if (this.visible_ !== value) {
            this.visible_ = value;
            this.changed.dispatch();
        }
    }
    set layer(layer) {
        if (layer === this.layer_) {
            return;
        }
        if (this.layer_ !== undefined) {
            this.existingLayerDisposer();
            this.existingLayerDisposer = undefined;
        }
        this.layer_ = layer;
        if (layer !== undefined) {
            const layerDisposed = () => {
                this.layer_ = undefined;
                this.visible = false;
                this.existingLayerDisposer = undefined;
                this.changed.dispatch();
            };
            layer.registerDisposer(layerDisposed);
            const layerChangedDisposer = layer.specificationChanged.add(() => {
                this.changed.dispatch();
            });
            this.existingLayerDisposer = () => {
                const userLayer = layer.layer;
                if (userLayer !== null) {
                    const tool = userLayer.tool.value;
                    if (tool !== undefined) {
                        tool.deactivate();
                    }
                }
                layer.unregisterDisposer(layerDisposed);
                layerChangedDisposer();
            };
        }
        else {
            this.visible_ = false;
        }
        this.changed.dispatch();
    }
    toJSON() {
        if (this.layer === undefined) {
            return undefined;
        }
        return {
            'layer': this.layer.name,
            'visible': this.visible === true ? true : undefined,
            'size': this.size.toJSON(),
        };
    }
    restoreState(obj) {
        if (obj === undefined) {
            this.reset();
            return;
        }
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__["verifyObject"])(obj);
        const layerName = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__["verifyObjectProperty"])(obj, 'layer', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__["verifyOptionalString"]);
        const layer = layerName !== undefined ? this.layerManager.getLayerByName(layerName) : undefined;
        this.layer = layer;
        this.visible = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__["verifyObjectProperty"])(obj, 'visible', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__["verifyOptionalBoolean"]) ? true : false;
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__["verifyObjectProperty"])(obj, 'size', x => this.size.restoreState(x));
    }
    reset() {
        this.layer = undefined;
    }
}
class LayerReference extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(layerManager, filter) {
        super();
        this.layerManager = layerManager;
        this.filter = filter;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["NullarySignal"]();
        this.validate = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
            const { layerName_ } = this;
            if (layerName_ !== undefined) {
                const layer = this.layerManager.getLayerByName(layerName_);
                if (layer !== undefined && this.filter(layer)) {
                    this.layer_ = layer;
                    this.changed.dispatch();
                }
                else {
                    this.layer_ = undefined;
                    this.layerName_ = undefined;
                    this.changed.dispatch();
                }
            }
        }, 0);
        this.registerDisposer(layerManager);
        this.registerDisposer(layerManager.specificationChanged.add(() => {
            const { layer_ } = this;
            if (layer_ !== undefined) {
                if (!this.layerManager.layerSet.has(layer_) || !this.filter(layer_)) {
                    this.layer_ = undefined;
                    this.layerName_ = undefined;
                    this.changed.dispatch();
                }
                else {
                    const { name } = layer_;
                    if (name !== this.layerName_) {
                        this.layerName_ = name;
                        this.changed.dispatch();
                    }
                }
            }
        }));
    }
    get layer() {
        return this.layer_;
    }
    get layerName() {
        return this.layerName_;
    }
    set layer(value) {
        if (this.layer_ === value) {
            return;
        }
        if (value !== undefined && this.layerManager.layerSet.has(value) && this.filter(value)) {
            this.layer_ = value;
            this.layerName_ = value.name;
        }
        else {
            this.layer_ = undefined;
            this.layerName_ = undefined;
        }
        this.changed.dispatch();
    }
    set layerName(value) {
        if (value === this.layerName_) {
            return;
        }
        this.layer_ = undefined;
        this.layerName_ = value;
        this.changed.dispatch();
        this.validate();
    }
    restoreState(obj) {
        const layerName = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_5__["verifyOptionalString"])(obj);
        this.layerName = layerName;
    }
    toJSON() {
        const { layer_ } = this;
        if (layer_ !== undefined) {
            return layer_.name;
        }
        return this.layerName_;
    }
    reset() {
        this.layerName_ = undefined;
        this.layer_ = undefined;
        this.changed.dispatch();
    }
}


/***/ }),

/***/ "./src/neuroglancer/layer_dialog.css":
/*!*******************************************!*\
  !*** ./src/neuroglancer/layer_dialog.css ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/layer_dialog.ts":
/*!******************************************!*\
  !*** ./src/neuroglancer/layer_dialog.ts ***!
  \******************************************/
/*! exports provided: LayerDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerDialog", function() { return LayerDialog; });
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/overlay */ "./src/neuroglancer/overlay.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_widget_associate_label__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/widget/associate_label */ "./src/neuroglancer/widget/associate_label.ts");
/* harmony import */ var neuroglancer_widget_autocomplete__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/widget/autocomplete */ "./src/neuroglancer/widget/autocomplete.ts");
/* harmony import */ var neuroglancer_widget_hidden_submit_button__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/widget/hidden_submit_button */ "./src/neuroglancer/widget/hidden_submit_button.ts");
/* harmony import */ var _layer_dialog_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./layer_dialog.css */ "./src/neuroglancer/layer_dialog.css");
/* harmony import */ var _layer_dialog_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_layer_dialog_css__WEBPACK_IMPORTED_MODULE_7__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








class LayerDialog extends neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_1__["Overlay"] {
    constructor(manager, existingLayer) {
        super();
        this.manager = manager;
        this.existingLayer = existingLayer;
        /**
         * Used for displaying status information.
         */
        this.statusElement = document.createElement('div');
        this.submitElement = document.createElement('button');
        this.namePromptElement = document.createElement('label');
        this.nameInputElement = document.createElement('input');
        this.volumeCancellationSource = undefined;
        this.sourceValid = false;
        this.nameValid = true;
        let dialogElement = this.content;
        dialogElement.classList.add('add-layer-overlay');
        let sourceCompleter = (value, cancellationToken) => this.manager.dataSourceProvider
            .volumeCompleter(value, this.manager.chunkManager, cancellationToken)
            .then(originalResult => ({
            completions: originalResult.completions,
            makeElement: neuroglancer_widget_autocomplete__WEBPACK_IMPORTED_MODULE_5__["makeCompletionElementWithDescription"],
            offset: originalResult.offset,
            showSingleResult: true,
        }));
        let sourceForm = document.createElement('form');
        sourceForm.className = 'source-form';
        this.registerEventListener(sourceForm, 'submit', (event) => {
            event.preventDefault();
            this.validateSource(/*focusName=*/ true);
        });
        let sourcePrompt = document.createElement('label');
        sourcePrompt.textContent = 'Source:';
        let sourceInput = this.sourceInput =
            this.registerDisposer(new neuroglancer_widget_autocomplete__WEBPACK_IMPORTED_MODULE_5__["AutocompleteTextInput"]({ completer: sourceCompleter, delay: 0 }));
        sourceInput.element.classList.add('add-layer-source');
        sourceInput.inputElement.addEventListener('blur', () => {
            this.validateSource(/*focusName=*/ false);
        });
        this.submitElement.disabled = true;
        sourceInput.inputChanged.add(() => {
            const { volumeCancellationSource } = this;
            if (volumeCancellationSource !== undefined) {
                volumeCancellationSource.cancel();
                this.volumeCancellationSource = undefined;
            }
            this.sourceValid = false;
            this.submitElement.disabled = true;
            this.statusElement.textContent = '';
        });
        sourceForm.appendChild(sourcePrompt);
        sourceForm.appendChild(sourceInput.element);
        Object(neuroglancer_widget_associate_label__WEBPACK_IMPORTED_MODULE_4__["associateLabelWithElement"])(sourcePrompt, sourceInput.inputElement);
        let hiddenSourceSubmit = Object(neuroglancer_widget_hidden_submit_button__WEBPACK_IMPORTED_MODULE_6__["makeHiddenSubmitButton"])();
        sourceForm.appendChild(hiddenSourceSubmit);
        dialogElement.appendChild(sourceForm);
        let { statusElement, namePromptElement, nameInputElement, submitElement } = this;
        statusElement.className = 'dialog-status';
        let nameForm = document.createElement('form');
        nameForm.className = 'name-form';
        namePromptElement.textContent = 'Name:';
        nameInputElement.className = 'add-layer-name';
        nameInputElement.autocomplete = 'off';
        nameInputElement.spellcheck = false;
        nameInputElement.type = 'text';
        this.registerEventListener(nameInputElement, 'input', () => {
            this.validateName();
        });
        submitElement.type = 'submit';
        Object(neuroglancer_widget_associate_label__WEBPACK_IMPORTED_MODULE_4__["associateLabelWithElement"])(namePromptElement, nameInputElement);
        nameForm.appendChild(namePromptElement);
        nameForm.appendChild(nameInputElement);
        nameForm.appendChild(submitElement);
        dialogElement.appendChild(nameForm);
        dialogElement.appendChild(statusElement);
        if (existingLayer !== undefined) {
            if (existingLayer.sourceUrl !== undefined) {
                sourceInput.value = existingLayer.sourceUrl;
                this.validateSource();
            }
            else {
                this.sourceValid = true;
            }
            sourceInput.disabled = true;
            nameInputElement.value = existingLayer.name;
            this.validateName();
            submitElement.textContent = 'Save';
            nameInputElement.focus();
        }
        else {
            let { managedLayers } = this.manager.layerManager;
            for (let hintLayerIndex = managedLayers.length - 1; hintLayerIndex >= 0; --hintLayerIndex) {
                const hintLayer = managedLayers[hintLayerIndex];
                if (!(hintLayer instanceof neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_0__["ManagedUserLayerWithSpecification"]))
                    continue;
                const { sourceUrl } = hintLayer;
                if (sourceUrl === undefined)
                    continue;
                try {
                    let groupIndex = this.manager.dataSourceProvider.findSourceGroup(sourceUrl);
                    sourceInput.value = sourceUrl.substring(0, groupIndex);
                    sourceInput.inputElement.setSelectionRange(0, groupIndex);
                    break;
                }
                catch (_a) {
                }
            }
            sourceInput.inputElement.focus();
            submitElement.textContent = 'Add Layer';
        }
        this.registerEventListener(nameForm, 'submit', (event) => {
            event.preventDefault();
            this.submit();
        });
    }
    isNameValid() {
        let name = this.nameInputElement.value;
        if (name === '') {
            return false;
        }
        let otherLayer = this.manager.layerManager.getLayerByName(name);
        return otherLayer === undefined || otherLayer === this.existingLayer;
    }
    submit() {
        if (this.sourceValid && this.isNameValid()) {
            if (this.existingLayer) {
                this.existingLayer.name = this.nameInputElement.value;
                this.manager.layerManager.layersChanged.dispatch();
            }
            else {
                this.manager.add(this.manager.getLayer(this.nameInputElement.value, this.sourceInput.value));
            }
            this.dispose();
        }
    }
    validateName() {
        let { nameInputElement } = this;
        let nameValid = this.nameValid = this.isNameValid();
        if (nameValid) {
            nameInputElement.classList.add('valid-input');
            nameInputElement.classList.remove('invalid-input');
        }
        else {
            nameInputElement.classList.remove('valid-input');
            nameInputElement.classList.add('invalid-input');
        }
        this.validityChanged();
    }
    validityChanged() {
        this.submitElement.disabled = !(this.nameValid && this.sourceValid);
    }
    validateSource(focusName = false) {
        let url = this.sourceInput.value;
        if (url === '') {
            return;
        }
        try {
            let baseSuggestedName = this.manager.dataSourceProvider.suggestLayerName(url);
            let { nameInputElement } = this;
            if (this.nameInputElement.value === '') {
                let suggestedName = this.manager.layerManager.getUniqueLayerName(baseSuggestedName);
                nameInputElement.value = suggestedName;
                nameInputElement.setSelectionRange(0, suggestedName.length);
                this.validateName();
            }
            if (focusName) {
                nameInputElement.focus();
            }
        }
        catch (error) {
            this.setError(error.message);
            return;
        }
        this.setInfo('Validating volume source...');
        const token = this.volumeCancellationSource = new neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_3__["CancellationTokenSource"]();
        this.manager.dataSourceProvider
            .getVolume(this.manager.chunkManager, url, /*options=*/ undefined, token)
            .then(source => {
            if (token.isCanceled) {
                return;
            }
            this.volumeCancellationSource = undefined;
            this.sourceValid = true;
            this.setInfo(`${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_2__["VolumeType"][source.volumeType].toLowerCase()}: ` +
                `${source.numChannels}-channel ${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_2__["DataType"][source.dataType].toLowerCase()}`);
            this.validityChanged();
        })
            .catch((reason) => {
            if (token.isCanceled) {
                return;
            }
            this.volumeCancellationSource = undefined;
            this.setError(reason.message);
        });
    }
    setInfo(message) {
        this.statusElement.className = 'dialog-status dialog-status-info';
        this.statusElement.textContent = message;
    }
    setError(message) {
        this.statusElement.className = 'dialog-status dialog-status-error';
        this.statusElement.textContent = message;
    }
}


/***/ }),

/***/ "./src/neuroglancer/layer_group_viewer.css":
/*!*************************************************!*\
  !*** ./src/neuroglancer/layer_group_viewer.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/layer_group_viewer.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/layer_group_viewer.ts ***!
  \************************************************/
/*! exports provided: viewerDragType, hasViewerDrag, getCompatibleViewerDragSource, getViewerDropEffect, LinkedViewerNavigationState, LayerGroupViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewerDragType", function() { return viewerDragType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasViewerDrag", function() { return hasViewerDrag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCompatibleViewerDragSource", function() { return getCompatibleViewerDragSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getViewerDropEffect", function() { return getViewerDropEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinkedViewerNavigationState", function() { return LinkedViewerNavigationState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerGroupViewer", function() { return LayerGroupViewer; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_data_panel_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/data_panel_layout */ "./src/neuroglancer/data_panel_layout.ts");
/* harmony import */ var neuroglancer_layer_panel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/layer_panel */ "./src/neuroglancer/layer_panel.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/navigation_state */ "./src/neuroglancer/navigation_state.ts");
/* harmony import */ var neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/trackable_boolean */ "./src/neuroglancer/trackable_boolean.ts");
/* harmony import */ var neuroglancer_ui_context_menu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/ui/context_menu */ "./src/neuroglancer/ui/context_menu.ts");
/* harmony import */ var neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/ui/layer_drag_and_drop */ "./src/neuroglancer/ui/layer_drag_and_drop.ts");
/* harmony import */ var neuroglancer_ui_position_drag_and_drop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/ui/position_drag_and_drop */ "./src/neuroglancer/ui/position_drag_and_drop.ts");
/* harmony import */ var neuroglancer_util_automatic_focus__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/automatic_focus */ "./src/neuroglancer/util/automatic_focus.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony import */ var neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/util/trackable */ "./src/neuroglancer/util/trackable.ts");
/* harmony import */ var neuroglancer_widget_enum_widget__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/widget/enum_widget */ "./src/neuroglancer/widget/enum_widget.ts");
/* harmony import */ var _layer_group_viewer_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./layer_group_viewer.css */ "./src/neuroglancer/layer_group_viewer.css");
/* harmony import */ var _layer_group_viewer_css__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_layer_group_viewer_css__WEBPACK_IMPORTED_MODULE_15__);
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Viewer for a group of layers.
 */
















const viewerDragType = 'neuroglancer-layer-group-viewer';
function hasViewerDrag(event) {
    return event.dataTransfer.types.indexOf(viewerDragType) !== -1;
}
let dragSource;
function getCompatibleViewerDragSource(manager) {
    if (dragSource && dragSource.viewer.layerSpecification.rootLayers === manager.rootLayers) {
        return dragSource.viewer;
    }
    else {
        return undefined;
    }
}
function getDefaultViewerDropEffect(manager) {
    if (getCompatibleViewerDragSource(manager) !== undefined) {
        return 'move';
    }
    else {
        return 'copy';
    }
}
function getViewerDropEffect(event, manager) {
    if (event.shiftKey) {
        return 'copy';
    }
    else if (event.ctrlKey) {
        return 'move';
    }
    else {
        return getDefaultViewerDropEffect(manager);
    }
}
class LinkedViewerNavigationState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(parent) {
        super();
        this.position = new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["LinkedSpatialPosition"](parent.navigationState.position.addRef());
        this.crossSectionOrientation =
            new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["LinkedOrientationState"](parent.navigationState.pose.orientation.addRef());
        this.crossSectionZoom = new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["LinkedZoomState"](parent.navigationState.zoomFactor.addRef());
        this.navigationState = this.registerDisposer(new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["NavigationState"](new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["Pose"](this.position.value, this.crossSectionOrientation.value), this.crossSectionZoom.value));
        this.perspectiveOrientation =
            new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["LinkedOrientationState"](parent.perspectiveNavigationState.pose.orientation.addRef());
        this.perspectiveZoom =
            new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["LinkedZoomState"](parent.perspectiveNavigationState.zoomFactor.addRef());
        this.perspectiveNavigationState = this.registerDisposer(new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["NavigationState"](new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_4__["Pose"](this.position.value.addRef(), this.perspectiveOrientation.value), this.perspectiveZoom.value));
    }
    copyToParent() {
        for (const x of [this.position, this.crossSectionOrientation, this.crossSectionZoom,
            this.perspectiveOrientation, this.perspectiveZoom]) {
            x.copyToPeer();
        }
    }
    register(state) {
        state.add('position', this.position);
        state.add('crossSectionOrientation', this.crossSectionOrientation);
        state.add('crossSectionZoom', this.crossSectionZoom);
        state.add('perspectiveOrientation', this.perspectiveOrientation);
        state.add('perspectiveZoom', this.perspectiveZoom);
    }
}
function makeViewerMenu(parent, viewer) {
    const contextMenu = new neuroglancer_ui_context_menu__WEBPACK_IMPORTED_MODULE_6__["ContextMenu"](parent);
    const menu = contextMenu.element;
    menu.classList.add('neuroglancer-layer-group-viewer-context-menu');
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Remove layer group';
    menu.appendChild(closeButton);
    contextMenu.registerEventListener(closeButton, 'click', () => {
        viewer.layerSpecification.layerManager.clear();
    });
    const { viewerNavigationState } = viewer;
    for (const [name, model] of [
        ['Position', viewerNavigationState.position.link],
        ['Cross-section orientation', viewerNavigationState.crossSectionOrientation.link],
        ['Cross-section zoom', viewerNavigationState.crossSectionZoom.link],
        ['Perspective orientation', viewerNavigationState.perspectiveOrientation.link],
        ['Perspective zoom', viewerNavigationState.perspectiveZoom.link],
    ]) {
        const widget = contextMenu.registerDisposer(new neuroglancer_widget_enum_widget__WEBPACK_IMPORTED_MODULE_14__["EnumSelectWidget"](model));
        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.flexDirection = 'row';
        label.style.whiteSpace = 'nowrap';
        label.textContent = name;
        label.appendChild(widget.element);
        menu.appendChild(label);
    }
    return contextMenu;
}
class LayerGroupViewer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(element, viewerState, options = {}) {
        super();
        this.element = element;
        this.viewerState = viewerState;
        this.state = new neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_13__["CompoundTrackable"]();
        this.options = Object.assign({ showLayerPanel: new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_5__["TrackableBoolean"](true), showViewerMenu: false }, options);
        this.layerSpecification = this.registerDisposer(viewerState.layerSpecification);
        this.viewerNavigationState =
            this.registerDisposer(new LinkedViewerNavigationState(viewerState));
        this.viewerNavigationState.register(this.state);
        if (!(this.layerSpecification instanceof neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_3__["LayerSubsetSpecification"])) {
            this.state.add('layers', {
                changed: this.layerSpecification.changed,
                toJSON: () => this.layerSpecification.layerManager.managedLayers.map(x => x.name),
                reset: () => {
                    throw new Error('not implemented');
                },
                restoreState: () => {
                    throw new Error('not implemented');
                }
            });
        }
        else {
            this.state.add('layers', this.layerSpecification);
        }
        element.classList.add('neuroglancer-layer-group-viewer');
        this.registerDisposer(new neuroglancer_util_automatic_focus__WEBPACK_IMPORTED_MODULE_9__["AutomaticallyFocusedElement"](element));
        this.layout = this.registerDisposer(new neuroglancer_data_panel_layout__WEBPACK_IMPORTED_MODULE_1__["DataPanelLayoutContainer"](this, 'xy'));
        this.state.add('layout', this.layout);
        this.registerActionBindings();
        this.registerDisposer(this.layerManager.useDirectly());
        this.registerDisposer(Object(neuroglancer_ui_position_drag_and_drop__WEBPACK_IMPORTED_MODULE_8__["setupPositionDropHandlers"])(element, this.navigationState.position));
        this.registerDisposer(this.options.showLayerPanel.changed.add(this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => this.updateUI(), 0))));
        this.makeUI();
    }
    get perspectiveNavigationState() {
        return this.viewerNavigationState.perspectiveNavigationState;
    }
    get navigationState() {
        return this.viewerNavigationState.navigationState;
    }
    // FIXME: don't make viewerState a property, just make these things properties directly
    get display() {
        return this.viewerState.display;
    }
    get selectedLayer() {
        return this.viewerState.selectedLayer;
    }
    get layerManager() {
        return this.layerSpecification.layerManager;
    }
    get chunkManager() {
        return this.layerSpecification.chunkManager;
    }
    get mouseState() {
        return this.viewerState.mouseState;
    }
    get showAxisLines() {
        return this.viewerState.showAxisLines;
    }
    get showScaleBar() {
        return this.viewerState.showScaleBar;
    }
    get showPerspectiveSliceViews() {
        return this.viewerState.showPerspectiveSliceViews;
    }
    get inputEventBindings() {
        return this.viewerState.inputEventBindings;
    }
    get visibility() {
        return this.viewerState.visibility;
    }
    get visibleLayerRoles() {
        return this.viewerState.visibleLayerRoles;
    }
    get crossSectionBackgroundColor() {
        return this.viewerState.crossSectionBackgroundColor;
    }
    get perspectiveViewBackgroundColor() {
        return this.viewerState.perspectiveViewBackgroundColor;
    }
    get scaleBarOptions() {
        return this.viewerState.scaleBarOptions;
    }
    get changed() {
        return this.state.changed;
    }
    bindAction(action, handler) {
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_12__["registerActionListener"])(this.element, action, handler));
    }
    registerActionBindings() {
        this.bindAction('add-layer', () => {
            if (this.layerPanel) {
                this.layerPanel.addLayerMenu();
            }
        });
    }
    toJSON() {
        return Object.assign({ 'type': 'viewer' }, this.state.toJSON());
    }
    reset() {
        this.state.reset();
    }
    restoreState(obj) {
        this.state.restoreState(obj);
    }
    makeUI() {
        this.element.style.flex = '1';
        this.element.style.display = 'flex';
        this.element.style.flexDirection = 'column';
        this.element.appendChild(this.layout.element);
        this.updateUI();
    }
    updateUI() {
        const { options } = this;
        const showLayerPanel = options.showLayerPanel.value;
        if (this.layerPanel !== undefined && !showLayerPanel) {
            this.layerPanel.dispose();
            this.layerPanel = undefined;
            return;
        }
        if (showLayerPanel && this.layerPanel === undefined) {
            const layerPanel = this.layerPanel = new neuroglancer_layer_panel__WEBPACK_IMPORTED_MODULE_2__["LayerPanel"](this.display, this.layerSpecification, this.viewerNavigationState, this.viewerState.selectedLayer, () => this.layout.toJSON());
            if (options.showViewerMenu) {
                layerPanel.registerDisposer(makeViewerMenu(layerPanel.element, this));
                layerPanel.element.title = 'Right click for options, drag to move/copy layer group.';
            }
            else {
                layerPanel.element.title = 'Drag to move/copy layer group.';
            }
            layerPanel.element.draggable = true;
            this.registerEventListener(layerPanel.element, 'dragstart', (event) => {
                Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_7__["startLayerDrag"])(event, {
                    manager: this.layerSpecification,
                    layers: this.layerManager.managedLayers,
                    layoutSpec: this.layout.toJSON(),
                });
                const disposer = () => {
                    if (dragSource && dragSource.viewer === this) {
                        dragSource = undefined;
                    }
                    this.unregisterDisposer(disposer);
                };
                dragSource = { viewer: this, disposer };
                this.registerDisposer(disposer);
                const dragData = this.toJSON();
                delete dragData['layers'];
                event.dataTransfer.setData(viewerDragType, JSON.stringify(dragData));
            });
            this.registerEventListener(layerPanel.element, 'dragend', (event) => {
                Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_7__["endLayerDrag"])(event);
                if (dragSource !== undefined && dragSource.viewer === this) {
                    dragSource.disposer();
                }
            });
            this.element.insertBefore(layerPanel.element, this.element.firstChild);
        }
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeChildren"])(this.element);
        const { layerPanel } = this;
        if (layerPanel !== undefined) {
            layerPanel.dispose();
            this.layerPanel = undefined;
        }
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/layer_groups_layout.css":
/*!**************************************************!*\
  !*** ./src/neuroglancer/layer_groups_layout.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/layer_groups_layout.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/layer_groups_layout.ts ***!
  \*************************************************/
/*! exports provided: LayoutComponentContainer, SingletonLayerGroupViewer, StackLayoutComponent, RootLayoutContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutComponentContainer", function() { return LayoutComponentContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingletonLayerGroupViewer", function() { return SingletonLayerGroupViewer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackLayoutComponent", function() { return StackLayoutComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RootLayoutContainer", function() { return RootLayoutContainer; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer_group_viewer */ "./src/neuroglancer/layer_group_viewer.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/ui/layer_drag_and_drop */ "./src/neuroglancer/ui/layer_drag_and_drop.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/drag_and_drop */ "./src/neuroglancer/util/drag_and_drop.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var _layer_groups_layout_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./layer_groups_layout.css */ "./src/neuroglancer/layer_groups_layout.css");
/* harmony import */ var _layer_groups_layout_css__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_layer_groups_layout_css__WEBPACK_IMPORTED_MODULE_9__);
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for laying out multiple LayerGroupViewer instances.
 */










const layoutComponentContainerSymbol = Symbol('layoutComponentContainer');
/**
 * Container for a LayoutComponent.  The contained LayoutComponent may change.
 */
class LayoutComponentContainer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["RefCounted"] {
    constructor(viewer, spec, parent) {
        super();
        this.viewer = viewer;
        this.parent = parent;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_8__["NullarySignal"]();
        this.element = document.createElement('div');
        const { element } = this;
        element.style.display = 'flex';
        element.style.flex = '1';
        element.style.position = 'relative';
        element.style.alignItems = 'stretch';
        element.foo = 'hello';
        element[layoutComponentContainerSymbol] = this;
        this.setSpecification(spec);
        const dropZones = [];
        const makeDropZone = (name) => {
            const dropZone = document.createElement('div');
            dropZone.className = 'neuroglancer-layout-split-drop-zone';
            let direction;
            dropZone.style[name] = '0';
            switch (name) {
                case 'left':
                case 'right':
                    direction = 'row';
                    dropZone.style.width = '10px';
                    dropZone.style.height = '100%';
                    break;
                case 'top':
                case 'bottom':
                    direction = 'column';
                    dropZone.style.height = '10px';
                    dropZone.style.width = '100%';
                    break;
            }
            dropZone.style.display = 'none';
            dropZones.push({ element: dropZone, direction: direction, orientation: name });
            element.appendChild(dropZone);
            this.registerDisposer(setupDropZone(dropZone, this.viewer.layerSpecification, () => (this.split(name).newContainer.component)));
        };
        makeDropZone('left');
        makeDropZone('right');
        makeDropZone('top');
        makeDropZone('bottom');
        let dropZonesVisible = false;
        this.registerEventListener(element, 'dragenter', (event) => {
            if (dropZonesVisible) {
                return;
            }
            if (Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["getLayerDragInfo"])(event) === undefined) {
                return;
            }
            dropZonesVisible = true;
            for (const { element: dropZone, direction, orientation } of dropZones) {
                if (parent !== undefined && direction === parent.direction) {
                    if (((orientation === 'left' || orientation === 'top') && parent.get(0) !== this) ||
                        ((orientation === 'bottom' || orientation === 'right') &&
                            parent.get(parent.length - 1) !== this)) {
                        continue;
                    }
                }
                const { component } = this;
                if (component instanceof StackLayoutComponent && component.direction === direction) {
                    continue;
                }
                dropZone.style.display = 'block';
            }
        }, true);
        this.registerEventListener(element, 'drop', (_event) => {
            if (!dropZonesVisible) {
                return;
            }
            dropZonesVisible = false;
            for (const { element: dropZone } of dropZones) {
                dropZone.style.display = 'none';
            }
        }, /*capture=*/ true);
        this.registerEventListener(element, 'dragleave', (event) => {
            const { relatedTarget } = event;
            if (!dropZonesVisible) {
                return;
            }
            if (relatedTarget instanceof HTMLElement && this.element.contains(relatedTarget)) {
                return;
            }
            dropZonesVisible = false;
            for (const { element: dropZone } of dropZones) {
                dropZone.style.display = 'none';
            }
        }, true);
    }
    unsetComponent() {
        const oldComponent = this.componentValue;
        if (oldComponent !== undefined) {
            oldComponent.changed.remove(this.changed.dispatch);
            this.element.removeChild(oldComponent.element);
            oldComponent.dispose();
        }
    }
    get component() {
        return this.componentValue;
    }
    setComponent(component) {
        this.unsetComponent();
        this.componentValue = component;
        component.changed.add(this.changed.dispatch);
        this.element.appendChild(component.element);
        if (component instanceof neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__["LayerGroupViewer"]) {
            const { layerManager } = component;
            const scheduleMaybeDelete = component.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
                if (layerManager.managedLayers.length === 0) {
                    this.dispose();
                }
            }, 0));
            component.registerDisposer(layerManager.layersChanged.add(() => {
                if (layerManager.managedLayers.length === 0) {
                    scheduleMaybeDelete();
                }
            }));
            scheduleMaybeDelete();
        }
        else if (component instanceof StackLayoutComponent) {
            const scheduleMaybeDelete = component.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
                const { length } = component;
                if (length === 0 && this.parent !== undefined) {
                    this.dispose();
                }
                else if (length === 1) {
                    const childComponent = component.get(0).component;
                    let spec;
                    if (this.parent === undefined && childComponent instanceof neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__["LayerGroupViewer"]) {
                        spec = childComponent.layout.specification.toJSON();
                        childComponent.viewerNavigationState.copyToParent();
                        const layersToKeep = new Set(childComponent.layerManager.managedLayers);
                        const { layerSpecification } = childComponent;
                        layerSpecification.rootLayers.filter(layer => layersToKeep.has(layer));
                        layerSpecification.rootLayers.managedLayers =
                            Array.from(childComponent.layerManager.managedLayers);
                        layerSpecification.rootLayers.layersChanged.dispatch();
                    }
                    else {
                        spec = childComponent.toJSON();
                    }
                    this.setSpecification(spec);
                }
            }, 0));
            component.registerDisposer(component.changed.add(() => {
                if (component.length < 2) {
                    scheduleMaybeDelete();
                }
            }));
            scheduleMaybeDelete();
        }
        this.changed.dispatch();
    }
    toJSON() {
        return this.component.toJSON();
    }
    setSpecification(spec) {
        this.setComponent(makeComponent(this, spec));
    }
    static getFromElement(element) {
        return element[layoutComponentContainerSymbol];
    }
    disposed() {
        this.unsetComponent();
        this.componentValue = undefined;
        super.disposed();
    }
    split(side) {
        const newComponentSpec = {
            type: 'viewer',
        };
        const { parent } = this;
        if (parent !== undefined) {
            if ((side === 'left' && parent.direction === 'row') ||
                (side === 'top' && parent.direction === 'column')) {
                return { newContainer: parent.insertChild(newComponentSpec, this), existingContainer: this };
            }
            else if ((side === 'right' && parent.direction === 'row') ||
                (side === 'bottom' && parent.direction === 'column')) {
                return { newContainer: parent.insertChild(newComponentSpec), existingContainer: this };
            }
        }
        let existingComponentSpec;
        const existingComponent = this.component;
        if (existingComponent instanceof SingletonLayerGroupViewer) {
            existingComponentSpec = existingComponent.layerGroupViewer.toJSON();
        }
        else {
            existingComponentSpec = existingComponent.toJSON();
        }
        let spec;
        let newIndex;
        const direction = side === 'left' || side === 'right' ? 'row' : 'column';
        switch (side) {
            case 'left':
            case 'top':
                spec = { type: direction, children: [newComponentSpec, existingComponentSpec] };
                newIndex = 0;
                break;
            case 'right':
            case 'bottom':
                spec = { type: direction, children: [existingComponentSpec, newComponentSpec] };
                newIndex = 1;
                break;
        }
        this.setSpecification(spec);
        const stackComponent = this.component;
        return {
            newContainer: stackComponent.get(newIndex),
            existingContainer: stackComponent.get(1 - newIndex)
        };
    }
}
function getCommonViewerState(viewer) {
    return {
        mouseState: viewer.mouseState,
        showAxisLines: viewer.showAxisLines,
        showScaleBar: viewer.showScaleBar,
        scaleBarOptions: viewer.scaleBarOptions,
        showPerspectiveSliceViews: viewer.showPerspectiveSliceViews,
        inputEventBindings: viewer.inputEventBindings,
        visibility: viewer.visibility,
        selectedLayer: viewer.selectedLayer,
        visibleLayerRoles: viewer.visibleLayerRoles,
        navigationState: viewer.navigationState.addRef(),
        perspectiveNavigationState: viewer.perspectiveNavigationState.addRef(),
        crossSectionBackgroundColor: viewer.crossSectionBackgroundColor,
        perspectiveViewBackgroundColor: viewer.perspectiveViewBackgroundColor,
    };
}
class SingletonLayerGroupViewer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["RefCounted"] {
    constructor(element, layout, viewer) {
        super();
        this.element = element;
        this.layerGroupViewer = this.registerDisposer(new neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__["LayerGroupViewer"](element, Object.assign({ display: viewer.display, layerSpecification: viewer.layerSpecification.addRef() }, getCommonViewerState(viewer)), { showLayerPanel: viewer.uiControlVisibility.showLayerPanel, showViewerMenu: false }));
        this.layerGroupViewer.layout.restoreState(layout);
    }
    toJSON() {
        return this.layerGroupViewer.layout.specification.toJSON();
    }
    get changed() {
        return this.layerGroupViewer.layout.changed;
    }
}
function setupDropZone(dropZone, manager, makeLayerGroupViewer) {
    const enterDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["registerEventListener"])(dropZone, 'dragenter', (event) => {
        if (Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["getLayerDragInfo"])(event) === undefined) {
            return;
        }
        dropZone.classList.add('neuroglancer-drag-over');
    });
    const leaveDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["registerEventListener"])(dropZone, 'dragleave', () => {
        dropZone.classList.remove('neuroglancer-drag-over');
    });
    const overDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["registerEventListener"])(dropZone, 'dragover', (event) => {
        if (Object(neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__["hasViewerDrag"])(event)) {
            Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_6__["setDropEffect"])(event, Object(neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__["getViewerDropEffect"])(event, manager));
            event.stopPropagation();
            event.preventDefault();
            return;
        }
        if (Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["getLayerDragInfo"])(event) !== undefined) {
            Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["updateLayerDropEffect"])(event, manager, /*newTarget=*/ true);
            event.stopPropagation();
            event.preventDefault();
            return;
        }
    });
    const dropDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["registerEventListener"])(dropZone, 'drop', (event) => {
        dropZone.classList.remove('neuroglancer-drag-over');
        if (Object(neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__["hasViewerDrag"])(event)) {
            event.stopPropagation();
            let dropState;
            try {
                dropState = JSON.parse(event.dataTransfer.getData(neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__["viewerDragType"]));
            }
            catch (e) {
                return;
            }
            const dropLayers = Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["getDropLayers"])(event, manager, /*forceCopy=*/ false, /*allowMove=*/ false, 
            /*newTarget=*/ true);
            if (dropLayers !== undefined && dropLayers.finalize(event)) {
                event.preventDefault();
                event.dataTransfer.dropEffect = Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_6__["getDropEffect"])();
                Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["endLayerDrag"])(event);
                const layerGroupViewer = makeLayerGroupViewer();
                for (const newLayer of dropLayers.layers.keys()) {
                    layerGroupViewer.layerSpecification.add(newLayer);
                }
                try {
                    layerGroupViewer.restoreState(dropState);
                }
                catch (_a) {
                }
            }
        }
        else {
            const dropLayers = Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["getDropLayers"])(event, manager, /*forceCopy=*/ Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_6__["getDropEffect"])() === 'copy', 
            /*allowMove=*/ false, 
            /*newTarget=*/ true);
            if (dropLayers !== undefined && dropLayers.finalize(event)) {
                event.preventDefault();
                event.dataTransfer.dropEffect = Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_6__["getDropEffect"])();
                Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["endLayerDrag"])(event);
                const layerGroupViewer = makeLayerGroupViewer();
                for (const newLayer of dropLayers.layers.keys()) {
                    layerGroupViewer.layerSpecification.add(newLayer);
                }
                try {
                    layerGroupViewer.layout.restoreState(dropLayers.layoutSpec);
                }
                catch (_b) {
                    layerGroupViewer.layout.reset();
                    // Ignore error restoring layout.
                }
                return;
            }
        }
    });
    return () => {
        dropDisposer();
        overDisposer();
        leaveDisposer();
        enterDisposer();
    };
}
class StackLayoutComponent extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["RefCounted"] {
    constructor(element, direction, children, container) {
        super();
        this.element = element;
        this.direction = direction;
        this.container = container;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_8__["NullarySignal"]();
        element.classList.add('neuroglancer-stack-layout');
        element.classList.add(`neuroglancer-stack-layout-${direction}`);
        element.style.display = 'flex';
        element.style.flexDirection = direction;
        element.appendChild(this.makeDropPlaceholder(this));
        for (const childSpec of children) {
            this.insertChild(childSpec);
        }
    }
    get length() {
        return (this.element.childElementCount - 1) / 2;
    }
    makeDropPlaceholder(refCounted) {
        const dropZone = document.createElement('div');
        dropZone.className = 'neuroglancer-stack-layout-drop-placeholder';
        refCounted.registerDisposer(setupDropZone(dropZone, this.viewer.layerSpecification, () => {
            const nextElement = dropZone.nextElementSibling;
            let nextChild;
            if (nextElement !== null) {
                nextChild = LayoutComponentContainer.getFromElement(nextElement);
            }
            const newChild = this.insertChild({ type: 'viewer', layers: [] }, nextChild);
            return newChild.component;
        }));
        refCounted.registerDisposer(() => {
            Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_5__["removeFromParent"])(dropZone);
        });
        return dropZone;
    }
    get viewer() {
        return this.container.viewer;
    }
    get(index) {
        return LayoutComponentContainer.getFromElement(this.element.children[index * 2 + 1]);
    }
    insertChild(spec, before) {
        const child = new LayoutComponentContainer(this.viewer, spec, this);
        const dropZone = this.makeDropPlaceholder(child);
        child.element.classList.add('neuroglancer-stack-layout-child');
        child.registerDisposer(child.changed.add(this.changed.dispatch));
        child.registerDisposer(() => {
            this.element.removeChild(child.element);
            this.changed.dispatch();
        });
        const beforeElement = before !== undefined ? before.element : null;
        this.element.insertBefore(child.element, beforeElement);
        this.element.insertBefore(dropZone, beforeElement);
        this.changed.dispatch();
        return child;
    }
    disposed() {
        this.clear();
        super.disposed();
    }
    clear() {
        while (this.length !== 0) {
            this.get(0).dispose();
        }
    }
    *[Symbol.iterator]() {
        const { length } = this;
        for (let i = 0; i < length; ++i) {
            yield this.get(i);
        }
    }
    toJSON() {
        return {
            type: this.direction,
            children: Array.from(this).map(x => x.toJSON()),
        };
    }
}
function makeComponent(container, spec) {
    const element = document.createElement('div');
    element.style.flex = '1';
    element.style.width = '0px';
    if (typeof spec === 'string') {
        if (container.parent !== undefined) {
            throw new Error(`Invalid layout component specification: ${JSON.stringify(spec)}`);
        }
        return new SingletonLayerGroupViewer(element, spec, container.viewer);
    }
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_7__["verifyObject"])(spec);
    const componentType = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_7__["verifyObjectProperty"])(spec, 'type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_7__["verifyString"]);
    switch (componentType) {
        case 'row':
        case 'column': {
            return new StackLayoutComponent(element, componentType, Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_7__["verifyObjectProperty"])(spec, 'children', x => {
                const children = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_7__["parseArray"])(x, y => y);
                if (container.parent === undefined && children.length === 0) {
                    throw new Error('Stack layout requires at least one child.');
                }
                return children;
            }), container);
        }
        case 'viewer': {
            const viewer = container.viewer;
            const layerSpecification = new neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_2__["LayerSubsetSpecification"](viewer.layerSpecification.addRef());
            const layerGroupViewer = new neuroglancer_layer_group_viewer__WEBPACK_IMPORTED_MODULE_1__["LayerGroupViewer"](element, Object.assign({ display: viewer.display, layerSpecification }, getCommonViewerState(viewer)), { showLayerPanel: viewer.uiControlVisibility.showLayerPanel, showViewerMenu: true });
            try {
                layerGroupViewer.restoreState(spec);
            }
            catch (e) {
                layerGroupViewer.dispose();
                throw e;
            }
            return layerGroupViewer;
        }
        default: {
            // Treat it as a singleton layer group.
            return new SingletonLayerGroupViewer(element, spec, container.viewer);
        }
    }
}
class RootLayoutContainer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_4__["RefCounted"] {
    constructor(viewer, defaultSpecification) {
        super();
        this.viewer = viewer;
        this.defaultSpecification = defaultSpecification;
        this.container = this.registerDisposer(new LayoutComponentContainer(this.viewer, this.defaultSpecification, undefined));
    }
    get changed() { return this.container.changed; }
    get element() {
        return this.container.element;
    }
    reset() {
        this.container.setSpecification(this.defaultSpecification);
    }
    restoreState(obj) {
        this.container.setSpecification(obj);
    }
    disposed() {
        super.disposed();
    }
    toJSON() {
        return this.container.toJSON();
    }
}


/***/ }),

/***/ "./src/neuroglancer/layer_panel.css":
/*!******************************************!*\
  !*** ./src/neuroglancer/layer_panel.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/layer_panel.ts":
/*!*****************************************!*\
  !*** ./src/neuroglancer/layer_panel.ts ***!
  \*****************************************/
/*! exports provided: LayerPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerPanel", function() { return LayerPanel; });
/* harmony import */ var neuroglancer_layer_dialog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/layer_dialog */ "./src/neuroglancer/layer_dialog.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/navigation_state */ "./src/neuroglancer/navigation_state.ts");
/* harmony import */ var neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/ui/layer_drag_and_drop */ "./src/neuroglancer/ui/layer_drag_and_drop.ts");
/* harmony import */ var neuroglancer_util_animation_frame_debounce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/animation_frame_debounce */ "./src/neuroglancer/util/animation_frame_debounce.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/drag_and_drop */ "./src/neuroglancer/util/drag_and_drop.ts");
/* harmony import */ var neuroglancer_util_float32_to_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/float32_to_string */ "./src/neuroglancer/util/float32_to_string.ts");
/* harmony import */ var neuroglancer_widget_close_button__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/widget/close_button */ "./src/neuroglancer/widget/close_button.ts");
/* harmony import */ var neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/widget/position_widget */ "./src/neuroglancer/widget/position_widget.ts");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/noselect.css */ "./src/neuroglancer/noselect.css");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _layer_panel_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./layer_panel.css */ "./src/neuroglancer/layer_panel.css");
/* harmony import */ var _layer_panel_css__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_layer_panel_css__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/ui/button.css */ "./src/neuroglancer/ui/button.css");
/* harmony import */ var neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_13__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














function destroyDropLayers(dropLayers, targetLayer) {
    if (dropLayers.method === 'move') {
        // Nothing to do.
        return false;
    }
    dropLayers.manager.layerManager.filter(layer => !dropLayers.layers.has(layer));
    return targetLayer !== undefined && dropLayers.layers.has(targetLayer);
}
function registerDropHandlers(panel, target, targetLayer) {
    function update(event, updateDropEffect) {
        let dropLayers = panel.dropLayers;
        const dropEffect = updateDropEffect ? Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["getLayerDropEffect"])(event, panel.manager) : Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_7__["getDropEffect"])();
        let existingDropLayers = true;
        if (dropLayers !== undefined) {
            if (updateDropEffect) {
                Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_7__["setDropEffect"])(event, dropEffect);
            }
            if (!dropLayers.compatibleWithMethod(dropEffect)) {
                panel.dropLayers = undefined;
                if (destroyDropLayers(dropLayers, targetLayer)) {
                    // We destroyed the layer for which we received the dragenter event.  Wait until we get
                    // another dragenter or drop event to do something.
                    return undefined;
                }
            }
        }
        if (dropLayers === undefined) {
            dropLayers = panel.dropLayers = Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["getDropLayers"])(event, panel.manager, /*forceCopy=*/ dropEffect === 'copy', /*allowMove=*/ true, 
            /*newTarget=*/ false);
            if (dropLayers === undefined) {
                return undefined;
            }
            existingDropLayers = dropLayers.method === 'move';
        }
        // Dragged onto itself, nothing to do.
        if (targetLayer !== undefined && dropLayers.layers.has(targetLayer)) {
            return dropLayers;
        }
        if (!existingDropLayers) {
            let newIndex;
            if (targetLayer !== undefined) {
                newIndex = panel.manager.layerManager.managedLayers.indexOf(targetLayer);
            }
            for (const newLayer of dropLayers.layers.keys()) {
                panel.manager.add(newLayer, newIndex);
            }
        }
        else {
            // Rearrange layers.
            const { layerManager } = panel.manager;
            const existingLayers = new Set();
            let firstRemovalIndex = Number.POSITIVE_INFINITY;
            const managedLayers = layerManager.managedLayers =
                layerManager.managedLayers.filter((x, index) => {
                    if (dropLayers.layers.has(x)) {
                        if (firstRemovalIndex === Number.POSITIVE_INFINITY) {
                            firstRemovalIndex = index;
                        }
                        existingLayers.add(x);
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            let newIndex;
            if (targetLayer !== undefined) {
                newIndex = managedLayers.indexOf(targetLayer);
                if (firstRemovalIndex <= newIndex) {
                    ++newIndex;
                }
            }
            else {
                newIndex = managedLayers.length;
            }
            // Filter out layers that have been concurrently removed.
            for (const layer of dropLayers.layers.keys()) {
                if (!existingLayers.has(layer)) {
                    dropLayers.layers.delete(layer);
                }
            }
            managedLayers.splice(newIndex, 0, ...dropLayers.layers.keys());
            layerManager.layersChanged.dispatch();
        }
        return dropLayers;
    }
    const enterDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["registerEventListener"])(target, 'dragenter', (event) => {
        if (update(event, /*updateDropEffect=*/ true) !== undefined) {
            event.preventDefault();
        }
    });
    const dropDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["registerEventListener"])(target, 'drop', (event) => {
        event.preventDefault();
        const dropLayers = update(event, /*updateDropEffect=*/ false);
        if (dropLayers !== undefined) {
            if (!dropLayers.finalize(event)) {
                destroyDropLayers(dropLayers);
            }
            else {
                event.dataTransfer.dropEffect = Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_7__["getDropEffect"])();
                Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["endLayerDrag"])(dropLayers.method === 'move' ? undefined : event);
            }
        }
        panel.dropLayers = undefined;
    });
    const overDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["registerEventListener"])(target, 'dragover', (event) => {
        const dropLayers = update(event, /*updateDropEffect=*/ true);
        if (dropLayers === undefined) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
    });
    return () => {
        overDisposer();
        dropDisposer();
        enterDisposer();
    };
}
class LayerWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["RefCounted"] {
    constructor(layer, panel) {
        super();
        this.layer = layer;
        this.panel = panel;
        let element = this.element = document.createElement('div');
        element.title = 'Control+click for layer options, drag to move/copy.';
        element.className = 'neuroglancer-layer-item neuroglancer-noselect';
        let labelElement = this.labelElement = document.createElement('span');
        labelElement.className = 'neuroglancer-layer-item-label';
        let layerNumberElement = this.layerNumberElement = document.createElement('span');
        layerNumberElement.className = 'neuroglancer-layer-item-number';
        let valueElement = this.valueElement = document.createElement('span');
        valueElement.className = 'neuroglancer-layer-item-value';
        const closeElement = Object(neuroglancer_widget_close_button__WEBPACK_IMPORTED_MODULE_9__["makeCloseButton"])();
        closeElement.title = 'Delete layer';
        this.registerEventListener(closeElement, 'click', (event) => {
            this.panel.layerManager.removeManagedLayer(this.layer);
            event.stopPropagation();
        });
        element.appendChild(layerNumberElement);
        element.appendChild(labelElement);
        element.appendChild(valueElement);
        element.appendChild(closeElement);
        this.registerEventListener(element, 'click', (event) => {
            if (event.ctrlKey) {
                panel.selectedLayer.layer = layer;
                panel.selectedLayer.visible = true;
            }
            else {
                layer.setVisible(!layer.visible);
            }
        });
        this.registerEventListener(element, 'contextmenu', (event) => {
            panel.selectedLayer.layer = layer;
            panel.selectedLayer.visible = true;
            event.stopPropagation();
            event.preventDefault();
        });
        element.draggable = true;
        this.registerEventListener(element, 'dragstart', (event) => {
            Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["startLayerDrag"])(event, { manager: panel.manager, layers: [this.layer], layoutSpec: panel.getLayoutSpecForDrag() });
            event.stopPropagation();
        });
        this.registerEventListener(element, 'dragend', (event) => {
            Object(neuroglancer_ui_layer_drag_and_drop__WEBPACK_IMPORTED_MODULE_3__["endLayerDrag"])(event);
        });
        this.registerDisposer(registerDropHandlers(this.panel, element, this.layer));
        this.registerEventListener(element, 'dblclick', (_event) => {
            if (layer instanceof neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_1__["ManagedUserLayerWithSpecification"]) {
                new neuroglancer_layer_dialog__WEBPACK_IMPORTED_MODULE_0__["LayerDialog"](this.panel.manager, layer);
            }
        });
    }
    update() {
        let { layer } = this;
        this.labelElement.textContent = layer.name;
        this.element.setAttribute('layer-visible', layer.visible.toString());
        this.element.setAttribute('layer-selected', (layer === this.panel.selectedLayer.layer).toString());
    }
    disposed() {
        this.element.parentElement.removeChild(this.element);
        super.disposed();
    }
}
class LayerPanel extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["RefCounted"] {
    constructor(display, manager, viewerNavigationState, selectedLayer, getLayoutSpecForDrag) {
        super();
        this.display = display;
        this.manager = manager;
        this.viewerNavigationState = viewerNavigationState;
        this.selectedLayer = selectedLayer;
        this.getLayoutSpecForDrag = getLayoutSpecForDrag;
        this.layerWidgets = new Map();
        this.element = document.createElement('div');
        this.layerUpdateNeeded = true;
        this.valueUpdateNeeded = false;
        this.layerWidgetInsertionPoint = document.createElement('div');
        this.positionWidget = this.registerDisposer(new neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_10__["PositionWidget"](this.viewerNavigationState.position.value));
        this.scheduleUpdate = this.registerCancellable(Object(neuroglancer_util_animation_frame_debounce__WEBPACK_IMPORTED_MODULE_4__["animationFrameDebounce"])(() => this.update()));
        this.registerDisposer(selectedLayer);
        const { element } = this;
        element.className = 'neuroglancer-layer-panel';
        this.registerDisposer(manager.layerSelectedValues.changed.add(() => {
            this.handleLayerValuesChanged();
        }));
        this.registerDisposer(manager.layerManager.layersChanged.add(() => {
            this.handleLayersChanged();
        }));
        this.registerDisposer(selectedLayer.changed.add(() => {
            this.handleLayersChanged();
        }));
        this.layerWidgetInsertionPoint.style.display = 'none';
        this.element.appendChild(this.layerWidgetInsertionPoint);
        let addButton = document.createElement('div');
        addButton.className = 'neuroglancer-layer-add-button neuroglancer-button';
        addButton.title =
            'Click to add layer, control+click/right click/+click to add local annotation layer.';
        addButton.textContent = '+';
        let dropZone = this.dropZone = document.createElement('div');
        dropZone.className = 'neuroglancer-layer-panel-drop-zone';
        const addLayer = (event) => {
            if (event.ctrlKey || event.metaKey || event.type === 'contextmenu') {
                const layer = new neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_1__["ManagedUserLayerWithSpecification"]('annotation', {}, this.manager);
                this.manager.initializeLayerFromSpec(layer, { type: 'annotation' });
                this.manager.add(layer);
            }
            else {
                this.addLayerMenu();
            }
        };
        this.registerEventListener(addButton, 'click', addLayer);
        this.registerEventListener(addButton, 'contextmenu', addLayer);
        element.appendChild(addButton);
        element.appendChild(dropZone);
        this.registerDisposer(Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_7__["preventDrag"])(addButton));
        element.appendChild(this.positionWidget.element);
        const updatePositionWidgetVisibility = () => {
            const linkValue = this.viewerNavigationState.position.link.value;
            this.positionWidget.element.style.display =
                linkValue === neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_2__["NavigationLinkType"].LINKED ? 'none' : null;
        };
        this.registerDisposer(this.viewerNavigationState.position.link.changed.add(updatePositionWidgetVisibility));
        updatePositionWidgetVisibility();
        this.update();
        this.registerEventListener(element, 'dragleave', (event) => {
            if (event.relatedTarget && element.contains(event.relatedTarget)) {
                return;
            }
            const { dropLayers } = this;
            if (dropLayers !== undefined) {
                destroyDropLayers(dropLayers);
                this.dropLayers = undefined;
            }
        });
        this.registerDisposer(registerDropHandlers(this, addButton, undefined));
        this.registerDisposer(registerDropHandlers(this, dropZone, undefined));
        // Ensure layer widgets are updated before WebGL drawing starts; we don't want the layout to
        // change after WebGL drawing or we will get flicker.
        this.registerDisposer(display.updateStarted.add(() => this.updateLayers()));
    }
    get layerManager() {
        return this.manager.layerManager;
    }
    disposed() {
        this.layerWidgets.forEach(x => x.dispose());
        this.layerWidgets = undefined;
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_6__["removeFromParent"])(this.element);
        super.disposed();
    }
    handleLayersChanged() {
        this.layerUpdateNeeded = true;
        this.handleLayerValuesChanged();
    }
    handleLayerValuesChanged() {
        if (!this.valueUpdateNeeded) {
            this.valueUpdateNeeded = true;
            this.scheduleUpdate();
        }
    }
    update() {
        this.valueUpdateNeeded = false;
        this.updateLayers();
        let values = this.manager.layerSelectedValues;
        for (let [layer, widget] of this.layerWidgets) {
            let userLayer = layer.layer;
            let text = '';
            if (userLayer !== null) {
                let value = values.get(userLayer);
                if (value !== undefined) {
                    value = Array().concat(value);
                    value = value.map((x) => {
                        if (x === null) {
                            return 'null';
                        }
                        else if (Math.fround(x) === x) {
                            // FIXME: Verify actual layer data type
                            return Object(neuroglancer_util_float32_to_string__WEBPACK_IMPORTED_MODULE_8__["float32ToString"])(x);
                        }
                        else {
                            return x;
                        }
                    });
                    text += value.join(', ');
                }
            }
            widget.valueElement.textContent = text;
        }
    }
    updateLayers() {
        if (!this.layerUpdateNeeded) {
            return;
        }
        this.layerUpdateNeeded = false;
        let container = this.element;
        let layers = new Set();
        let nextChild = this.layerWidgetInsertionPoint.nextElementSibling;
        this.manager.layerManager.managedLayers.forEach((layer) => {
            layers.add(layer);
            let widget = this.layerWidgets.get(layer);
            const layerIndex = this.manager.rootLayers.managedLayers.indexOf(layer);
            if (widget === undefined) {
                widget = new LayerWidget(layer, this);
                this.layerWidgets.set(layer, widget);
            }
            widget.layerNumberElement.textContent = '' + (1 + layerIndex);
            widget.update();
            let { element } = widget;
            if (element !== nextChild) {
                container.insertBefore(widget.element, nextChild);
            }
            nextChild = element.nextElementSibling;
        });
        for (let [layer, widget] of this.layerWidgets) {
            if (!layers.has(layer)) {
                this.layerWidgets.delete(layer);
                widget.dispose();
            }
        }
    }
    addLayerMenu() {
        // Automatically destroys itself when it exits.
        new neuroglancer_layer_dialog__WEBPACK_IMPORTED_MODULE_0__["LayerDialog"](this.manager);
    }
}


/***/ }),

/***/ "./src/neuroglancer/layer_specification.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/layer_specification.ts ***!
  \*************************************************/
/*! exports provided: getVolumeWithStatusMessage, ManagedUserLayerWithSpecification, TopLevelLayerListSpecification, LayerSubsetSpecification, registerLayerType, registerVolumeLayerType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVolumeWithStatusMessage", function() { return getVolumeWithStatusMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ManagedUserLayerWithSpecification", function() { return ManagedUserLayerWithSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TopLevelLayerListSpecification", function() { return TopLevelLayerListSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerSubsetSpecification", function() { return LayerSubsetSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerLayerType", function() { return registerLayerType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerVolumeLayerType", function() { return registerVolumeLayerType; });
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






function getVolumeWithStatusMessage(dataSourceProvider, chunkManager, x, options = {}) {
    return neuroglancer_status__WEBPACK_IMPORTED_MODULE_2__["StatusMessage"].forPromise(new Promise(function (resolve) {
        resolve(dataSourceProvider.getVolume(chunkManager, x, options));
    }), {
        initialMessage: `Retrieving metadata for volume ${x}.`,
        delay: true,
        errorPrefix: `Error retrieving metadata for volume ${x}: `,
    });
}
class ManagedUserLayerWithSpecification extends neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__["ManagedUserLayer"] {
    constructor(name, initialSpecification, manager) {
        super(name);
        this.initialSpecification = initialSpecification;
        this.manager = manager;
    }
    toJSON() {
        let userLayer = this.layer;
        if (!userLayer) {
            return this.initialSpecification;
        }
        let layerSpec = userLayer.toJSON();
        layerSpec.name = this.name;
        if (!this.visible) {
            layerSpec['visible'] = false;
        }
        return layerSpec;
    }
}
class TopLevelLayerListSpecification extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(dataSourceProvider, layerManager, chunkManager, layerSelectedValues, voxelSize) {
        super();
        this.dataSourceProvider = dataSourceProvider;
        this.layerManager = layerManager;
        this.chunkManager = chunkManager;
        this.layerSelectedValues = layerSelectedValues;
        this.voxelSize = voxelSize;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_5__["NullarySignal"]();
        this.voxelCoordinatesSet = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_5__["Signal"]();
        this.spatialCoordinatesSet = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_5__["Signal"]();
        this.registerDisposer(layerManager.layersChanged.add(this.changed.dispatch));
        this.registerDisposer(layerManager.specificationChanged.add(this.changed.dispatch));
    }
    /**
     * @deprecated
     */
    get worker() {
        return this.chunkManager.rpc;
    }
    get rpc() {
        return this.chunkManager.rpc;
    }
    reset() {
        this.layerManager.clear();
    }
    restoreState(x) {
        this.layerManager.clear();
        if (Array.isArray(x)) {
            // If array, layers have an order
            for (const layerObj of x) {
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyObject"])(layerObj);
                const name = this.layerManager.getUniqueLayerName(Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyObjectProperty"])(layerObj, 'name', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyString"]));
                this.layerManager.addManagedLayer(this.getLayer(name, layerObj));
            }
        }
        else {
            // Keep for backwards compatibility
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyObject"])(x);
            for (let key of Object.keys(x)) {
                this.layerManager.addManagedLayer(this.getLayer(key, x[key]));
            }
        }
    }
    initializeLayerFromSpec(managedLayer, spec) {
        managedLayer.initialSpecification = spec;
        if (typeof spec === 'string') {
            spec = { 'source': spec };
        }
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyObject"])(spec);
        let layerType = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyObjectProperty"])(spec, 'type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyOptionalString"]);
        managedLayer.visible = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyObjectProperty"])(spec, 'visible', x => {
            if (x === undefined || x === true) {
                return true;
            }
            if (x === false) {
                return false;
            }
            throw new Error(`Expected boolean, but received: ${JSON.stringify(x)}.`);
        });
        const makeUserLayer = (layerConstructor, spec) => {
            const userLayer = new layerConstructor(this, spec);
            userLayer.restoreState(spec);
            managedLayer.layer = userLayer;
        };
        let sourceUrl = managedLayer.sourceUrl =
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyObjectProperty"])(spec, 'source', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyOptionalString"]);
        if (layerType === undefined) {
            if (sourceUrl === undefined) {
                throw new Error(`Either layer 'type' or 'source' URL must be specified.`);
            }
            let volumeSourcePromise = getVolumeWithStatusMessage(this.dataSourceProvider, this.chunkManager, sourceUrl);
            volumeSourcePromise.then(source => {
                if (this.layerManager.managedLayers.indexOf(managedLayer) === -1) {
                    // Layer was removed before promise became ready.
                    return;
                }
                let layerConstructor = volumeLayerTypes.get(source.volumeType);
                if (layerConstructor !== undefined) {
                    makeUserLayer(layerConstructor, spec);
                }
                else {
                    throw new Error(`Unsupported volume type: ${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_1__["VolumeType"][source.volumeType]}.`);
                }
            });
        }
        else {
            let layerConstructor = layerTypes.get(layerType);
            if (layerConstructor !== undefined) {
                makeUserLayer(layerConstructor, spec);
            }
            else {
                throw new Error(`Unsupported layer type: ${JSON.stringify(layerType)}.`);
            }
        }
    }
    getLayer(name, spec) {
        let managedLayer = new ManagedUserLayerWithSpecification(name, spec, this);
        this.initializeLayerFromSpec(managedLayer, spec);
        return managedLayer;
    }
    add(layer, index) {
        if (this.layerManager.managedLayers.indexOf(layer) === -1) {
            layer.name = this.layerManager.getUniqueLayerName(layer.name);
        }
        this.layerManager.addManagedLayer(layer, index);
    }
    toJSON() {
        const result = [];
        let numResults = 0;
        for (let managedLayer of this.layerManager.managedLayers) {
            const layerJson = managedLayer.toJSON();
            // A `null` layer specification is used to indicate a transient drag target, and should not be
            // serialized.
            if (layerJson != null) {
                result.push(layerJson);
                ++numResults;
            }
        }
        if (numResults === 0) {
            return undefined;
        }
        return result;
    }
    /**
     * Called by user layers to indicate that a voxel position has been selected interactively.
     */
    setVoxelCoordinates(voxelCoordinates) {
        this.voxelCoordinatesSet.dispatch(voxelCoordinates);
    }
    setSpatialCoordinates(spatialCoordinates) {
        this.spatialCoordinatesSet.dispatch(spatialCoordinates);
    }
    get rootLayers() {
        return this.layerManager;
    }
}
/**
 * Class for specifying a subset of a TopLevelLayerListsSpecification.
 */
class LayerSubsetSpecification extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(master) {
        super();
        this.master = master;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_5__["NullarySignal"]();
        this.layerManager = new neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__["LayerManager"]();
        this.registerDisposer(master);
        const { layerManager } = this;
        this.registerDisposer(layerManager.layersChanged.add(this.changed.dispatch));
        this.registerDisposer(layerManager.specificationChanged.add(this.changed.dispatch));
    }
    get voxelCoordinatesSet() { return this.master.voxelCoordinatesSet; }
    get spatialCoordinatesSet() { return this.master.spatialCoordinatesSet; }
    get worker() { return this.master.rpc; }
    get rpc() { return this.master.rpc; }
    get dataSourceProvider() { return this.master.dataSourceProvider; }
    get chunkManager() { return this.master.chunkManager; }
    get voxelSize() { return this.master.voxelSize; }
    get layerSelectedValues() { return this.master.layerSelectedValues; }
    reset() {
        this.layerManager.clear();
    }
    restoreState(x) {
        const masterLayerManager = this.master.layerManager;
        const layers = [];
        for (const name of new Set(Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["parseArray"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyString"]))) {
            const layer = masterLayerManager.getLayerByName(name);
            if (layer === undefined) {
                throw new Error(`Undefined layer referenced in subset specification: ${JSON.stringify(name)}`);
            }
            layers.push(layer);
        }
        this.layerManager.clear();
        for (const layer of layers) {
            this.layerManager.addManagedLayer(layer.addRef());
        }
    }
    toJSON() {
        return this.layerManager.managedLayers.map(x => x.name);
    }
    initializeLayerFromSpec(managedLayer, spec) {
        this.master.initializeLayerFromSpec(managedLayer, spec);
    }
    getLayer(name, spec) {
        return this.master.getLayer(name, spec);
    }
    add(layer, index) {
        if (this.master.layerManager.managedLayers.indexOf(layer) === -1) {
            layer.name = this.master.layerManager.getUniqueLayerName(layer.name);
            this.master.layerManager.addManagedLayer(layer.addRef());
        }
        this.layerManager.addManagedLayer(layer, index);
    }
    setVoxelCoordinates(voxelCoordinates) {
        this.master.setVoxelCoordinates(voxelCoordinates);
    }
    setSpatialCoordinates(spatialCoordinates) {
        this.master.setSpatialCoordinates(spatialCoordinates);
    }
    get rootLayers() { return this.master.rootLayers; }
}
const layerTypes = new Map();
const volumeLayerTypes = new Map();
function registerLayerType(name, layerConstructor) {
    layerTypes.set(name, layerConstructor);
}
function registerVolumeLayerType(volumeType, layerConstructor) {
    volumeLayerTypes.set(volumeType, layerConstructor);
}


/***/ }),

/***/ "./src/neuroglancer/layout.ts":
/*!************************************!*\
  !*** ./src/neuroglancer/layout.ts ***!
  \************************************/
/*! exports provided: withFlex, withStyle, withAttributes, box */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withFlex", function() { return withFlex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withStyle", function() { return withStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withAttributes", function() { return withAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "box", function() { return box; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function withFlex(value, handler) {
    return (element) => {
        element.style.flex = value;
        handler(element);
    };
}
function withStyle(style, handler) {
    return (element) => {
        Object.assign(element.style, style);
        handler(element);
    };
}
function withAttributes(attributes, handler) {
    return (element) => {
        Object.assign(element, attributes);
        handler(element);
    };
}
function box(flexDirection, spec) {
    return (container) => {
        container.style.display = 'flex';
        container.style.flexDirection = flexDirection;
        for (let handler of spec) {
            let element = container.ownerDocument.createElement('div');
            container.appendChild(element);
            handler(element);
        }
    };
}


/***/ }),

/***/ "./src/neuroglancer/maximize_button.css":
/*!**********************************************!*\
  !*** ./src/neuroglancer/maximize_button.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/mesh/base.ts":
/*!***************************************!*\
  !*** ./src/neuroglancer/mesh/base.ts ***!
  \***************************************/
/*! exports provided: MESH_LAYER_RPC_ID, MULTISCALE_MESH_LAYER_RPC_ID, FRAGMENT_SOURCE_RPC_ID, MULTISCALE_FRAGMENT_SOURCE_RPC_ID, VertexPositionFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MESH_LAYER_RPC_ID", function() { return MESH_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MULTISCALE_MESH_LAYER_RPC_ID", function() { return MULTISCALE_MESH_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_SOURCE_RPC_ID", function() { return FRAGMENT_SOURCE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MULTISCALE_FRAGMENT_SOURCE_RPC_ID", function() { return MULTISCALE_FRAGMENT_SOURCE_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexPositionFormat", function() { return VertexPositionFormat; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MESH_LAYER_RPC_ID = 'mesh/MeshLayer';
const MULTISCALE_MESH_LAYER_RPC_ID = 'mesh/MultiscaleMeshLayer';
const FRAGMENT_SOURCE_RPC_ID = 'mesh/FragmentSource';
const MULTISCALE_FRAGMENT_SOURCE_RPC_ID = 'mesh/MultiscaleFragmentSource';
var VertexPositionFormat;
(function (VertexPositionFormat) {
    VertexPositionFormat[VertexPositionFormat["float32"] = 0] = "float32";
    VertexPositionFormat[VertexPositionFormat["uint10"] = 1] = "uint10";
    VertexPositionFormat[VertexPositionFormat["uint16"] = 2] = "uint16";
})(VertexPositionFormat || (VertexPositionFormat = {}));


/***/ }),

/***/ "./src/neuroglancer/mesh/frontend.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/mesh/frontend.ts ***!
  \*******************************************/
/*! exports provided: MeshShaderManager, MeshLayer, ManifestChunk, FragmentChunk, MeshSource, FragmentSource, MultiscaleMeshLayer, MultiscaleManifestChunk, MultiscaleFragmentChunk, MultiscaleMeshSource, MultiscaleFragmentSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshShaderManager", function() { return MeshShaderManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLayer", function() { return MeshLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ManifestChunk", function() { return ManifestChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FragmentChunk", function() { return FragmentChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshSource", function() { return MeshSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FragmentSource", function() { return FragmentSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleMeshLayer", function() { return MultiscaleMeshLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleManifestChunk", function() { return MultiscaleManifestChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleFragmentChunk", function() { return MultiscaleFragmentChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleMeshSource", function() { return MultiscaleMeshSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiscaleFragmentSource", function() { return MultiscaleFragmentSource; });
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/mesh/base */ "./src/neuroglancer/mesh/base.ts");
/* harmony import */ var neuroglancer_mesh_multiscale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/mesh/multiscale */ "./src/neuroglancer/mesh/multiscale.ts");
/* harmony import */ var neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/perspective_view/render_layer */ "./src/neuroglancer/perspective_view/render_layer.ts");
/* harmony import */ var neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/segmentation_display_state/base */ "./src/neuroglancer/segmentation_display_state/base.ts");
/* harmony import */ var neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/segmentation_display_state/frontend */ "./src/neuroglancer/segmentation_display_state/frontend.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};












const tempMat4 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat4"].create();
const tempModelMatrix = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat4"].create();
const tempMat3 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat3"].create();
const DEBUG_MULTISCALE_FRAGMENTS = false;
function copyMeshDataToGpu(gl, chunk) {
    chunk.vertexBuffer =
        neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_9__["Buffer"].fromData(gl, chunk.meshData.vertexPositions, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
    chunk.indexBuffer =
        neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_9__["Buffer"].fromData(gl, chunk.meshData.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);
    chunk.normalBuffer =
        neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_9__["Buffer"].fromData(gl, chunk.meshData.vertexNormals, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
}
function freeGpuMeshData(chunk) {
    chunk.vertexBuffer.dispose();
    chunk.indexBuffer.dispose();
    chunk.normalBuffer.dispose();
}
/**
 * Decodes normal vectors in 2xSnorm8 octahedron encoding into normalized 3x32f vector.
 *
 * Zina H. Cigolle, Sam Donow, Daniel Evangelakos, Michael Mara, Morgan McGuire, and Quirin Meyer,
 * Survey of Efficient Representations for Independent Unit Vectors, Journal of Computer Graphics
 * Techniques (JCGT), vol. 3, no. 2, 1-30, 2014
 *
 * Available online http://jcgt.org/published/0003/02/01/
 */
const glsl_decodeNormalOctahedronSnorm8 = `
highp vec3 decodeNormalOctahedronSnorm8(highp vec2 e) {
  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  if (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * vec2(v.x > 0.0 ? 1.0 : -1.0, v.y > 0.0 ? 1.0 : -1.0);
  return normalize(v);
}
`;
function getFloatPositionHandler(glAttributeType) {
    return {
        defineShader: (builder) => {
            builder.addAttribute('highp vec3', 'aVertexPosition');
            builder.addVertexCode(`highp vec3 getVertexPosition() { return aVertexPosition; }`);
        },
        bind(_gl, shader, fragmentChunk) {
            fragmentChunk.vertexBuffer.bindToVertexAttrib(shader.attribute('aVertexPosition'), 
            /*components=*/ 3, glAttributeType, /* normalized=*/ true);
        },
        endLayer: (gl, shader) => {
            gl.disableVertexAttribArray(shader.attribute('aVertexPosition'));
        }
    };
}
const vertexPositionHandlers = {
    [neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__["VertexPositionFormat"].float32]: getFloatPositionHandler(WebGL2RenderingContext.FLOAT),
    [neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__["VertexPositionFormat"].uint16]: getFloatPositionHandler(WebGL2RenderingContext.UNSIGNED_SHORT),
    [neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__["VertexPositionFormat"].uint10]: {
        defineShader: (builder) => {
            builder.addAttribute('highp uint', 'aVertexPosition');
            builder.addVertexCode(`
highp vec3 getVertexPosition() {
  return vec3(float(aVertexPosition & 1023u),
              float((aVertexPosition >> 10) & 1023u),
              float((aVertexPosition >> 20) & 1023u)) / 1023.0;
}
`);
        },
        bind(_gl, shader, fragmentChunk) {
            fragmentChunk.vertexBuffer.bindToVertexAttribI(shader.attribute('aVertexPosition'), 
            /*components=*/ 1, WebGL2RenderingContext.UNSIGNED_INT);
        },
        endLayer: (gl, shader) => {
            gl.disableVertexAttribArray(shader.attribute('aVertexPosition'));
        }
    },
};
class MeshShaderManager {
    constructor(fragmentRelativeVertices, vertexPositionFormat) {
        this.fragmentRelativeVertices = fragmentRelativeVertices;
        this.vertexPositionFormat = vertexPositionFormat;
        this.tempLightVec = new Float32Array(4);
        this.vertexPositionHandler = vertexPositionHandlers[this.vertexPositionFormat];
    }
    defineShader(builder) {
        this.vertexPositionHandler.defineShader(builder);
        builder.addAttribute('highp vec2', 'aVertexNormal');
        builder.addVarying('highp vec4', 'vColor');
        builder.addUniform('highp vec4', 'uLightDirection');
        builder.addUniform('highp vec4', 'uColor');
        builder.addUniform('highp mat3', 'uNormalMatrix');
        builder.addUniform('highp mat4', 'uModelViewProjection');
        builder.addUniform('highp uint', 'uPickID');
        if (this.fragmentRelativeVertices) {
            builder.addUniform('highp vec3', 'uFragmentOrigin');
            builder.addUniform('highp vec3', 'uFragmentShape');
        }
        builder.addVertexCode(glsl_decodeNormalOctahedronSnorm8);
        let vertexMain = ``;
        if (this.fragmentRelativeVertices) {
            vertexMain += `
highp vec3 vertexPosition = uFragmentOrigin + uFragmentShape * getVertexPosition();
highp vec3 normalMultiplier = 1.0 / uFragmentShape;
`;
        }
        else {
            vertexMain += `
highp vec3 vertexPosition = getVertexPosition();
highp vec3 normalMultiplier = vec3(1.0, 1.0, 1.0);
`;
        }
        vertexMain += `
gl_Position = uModelViewProjection * vec4(vertexPosition, 1.0);
vec3 normal = normalize(uNormalMatrix * normalMultiplier * decodeNormalOctahedronSnorm8(aVertexNormal));
float lightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;
vColor = vec4(lightingFactor * uColor.rgb, uColor.a);
`;
        builder.setVertexMain(vertexMain);
        builder.setFragmentMain(`emit(vColor, uPickID);`);
    }
    beginLayer(gl, shader, renderContext) {
        let { lightDirection, ambientLighting, directionalLighting } = renderContext;
        let lightVec = this.tempLightVec;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["vec3"].scale(lightVec, lightDirection, directionalLighting);
        lightVec[3] = ambientLighting;
        gl.uniform4fv(shader.uniform('uLightDirection'), lightVec);
    }
    setColor(gl, shader, color) {
        gl.uniform4fv(shader.uniform('uColor'), color);
    }
    setPickID(gl, shader, pickID) {
        gl.uniform1ui(shader.uniform('uPickID'), pickID);
    }
    beginModel(gl, shader, renderContext, modelMat) {
        gl.uniformMatrix4fv(shader.uniform('uModelViewProjection'), false, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat4"].multiply(tempMat4, renderContext.dataToDevice, modelMat));
        Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat3FromMat4"])(tempMat3, modelMat);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat3"].invert(tempMat3, tempMat3);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat3"].transpose(tempMat3, tempMat3);
        gl.uniformMatrix3fv(shader.uniform('uNormalMatrix'), false, tempMat3);
    }
    getShader(gl, emitter) {
        return gl.memoize.get(`mesh/MeshShaderManager:${Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_8__["getObjectId"])(emitter)}/` +
            `${this.fragmentRelativeVertices}/${this.vertexPositionFormat}`, () => {
            let builder = new neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_10__["ShaderBuilder"](gl);
            builder.require(emitter);
            this.defineShader(builder);
            return builder.build();
        });
    }
    drawFragmentHelper(gl, shader, fragmentChunk, indexBegin, indexEnd) {
        this.vertexPositionHandler.bind(gl, shader, fragmentChunk);
        const { meshData } = fragmentChunk;
        fragmentChunk.normalBuffer.bindToVertexAttrib(shader.attribute('aVertexNormal'), 
        /*components=*/ 2, WebGL2RenderingContext.BYTE, /*normalized=*/ true);
        fragmentChunk.indexBuffer.bind();
        const { indices } = meshData;
        gl.drawElements(meshData.strips ? WebGL2RenderingContext.TRIANGLE_STRIP : WebGL2RenderingContext.TRIANGLES, indexEnd - indexBegin, indices.BYTES_PER_ELEMENT === 2 ? WebGL2RenderingContext.UNSIGNED_SHORT :
            WebGL2RenderingContext.UNSIGNED_INT, indexBegin * indices.BYTES_PER_ELEMENT);
    }
    drawFragment(gl, shader, fragmentChunk) {
        const { meshData } = fragmentChunk;
        const { indices } = meshData;
        this.drawFragmentHelper(gl, shader, fragmentChunk, 0, indices.length);
    }
    drawMultiscaleFragment(gl, shader, fragmentChunk, subChunkBegin, subChunkEnd) {
        const indexBegin = fragmentChunk.meshData.subChunkOffsets[subChunkBegin];
        const indexEnd = fragmentChunk.meshData.subChunkOffsets[subChunkEnd];
        this.drawFragmentHelper(gl, shader, fragmentChunk, indexBegin, indexEnd);
    }
    endLayer(gl, shader) {
        this.vertexPositionHandler.endLayer(gl, shader);
        gl.disableVertexAttribArray(shader.attribute('aVertexNormal'));
    }
}
class MeshLayer extends neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_4__["PerspectiveViewRenderLayer"] {
    constructor(chunkManager, source, displayState) {
        super();
        this.chunkManager = chunkManager;
        this.source = source;
        this.displayState = displayState;
        this.meshShaderManager = new MeshShaderManager(/*fragmentRelativeVertices=*/ false, neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__["VertexPositionFormat"].float32);
        this.shaders = new Map();
        Object(neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_6__["registerRedrawWhenSegmentationDisplayState3DChanged"])(displayState, this);
        let sharedObject = this.backend =
            this.registerDisposer(new neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_6__["SegmentationLayerSharedObject"](chunkManager, displayState));
        sharedObject.RPC_TYPE_ID = neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__["MESH_LAYER_RPC_ID"];
        sharedObject.initializeCounterpartWithChunkManager({
            'source': source.addCounterpartRef(),
        });
        this.setReady(true);
        sharedObject.visibility.add(this.visibility);
        this.registerDisposer(displayState.renderScaleHistogram.visibility.add(this.visibility));
    }
    getShader(emitter) {
        let { shaders } = this;
        let shader = shaders.get(emitter);
        if (shader === undefined) {
            shader = this.registerDisposer(this.meshShaderManager.getShader(this.gl, emitter));
            shaders.set(emitter, shader);
        }
        return shader;
    }
    get isTransparent() {
        return this.displayState.objectAlpha.value < 1.0;
    }
    get gl() {
        return this.chunkManager.chunkQueueManager.gl;
    }
    draw(renderContext) {
        if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
            // No need for a separate pick ID pass.
            return;
        }
        let { gl, displayState, meshShaderManager } = this;
        let alpha = Math.min(1.0, displayState.objectAlpha.value);
        if (alpha <= 0.0) {
            // Skip drawing.
            return;
        }
        let shader = this.getShader(renderContext.emitter);
        shader.bind();
        const objectToDataMatrix = this.displayState.objectToDataTransform.transform;
        meshShaderManager.beginLayer(gl, shader, renderContext);
        meshShaderManager.beginModel(gl, shader, renderContext, objectToDataMatrix);
        let { pickIDs } = renderContext;
        const manifestChunks = this.source.chunks;
        let totalChunks = 0, presentChunks = 0;
        const { renderScaleHistogram } = this.displayState;
        const fragmentChunks = this.source.fragmentSource.chunks;
        Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__["forEachVisibleSegment"])(displayState, (objectId, rootObjectId) => {
            const key = Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__["getObjectKey"])(objectId);
            const manifestChunk = manifestChunks.get(key);
            if (manifestChunk === undefined)
                return;
            if (renderContext.emitColor) {
                meshShaderManager.setColor(gl, shader, Object(neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_6__["getObjectColor"])(displayState, rootObjectId, alpha));
            }
            if (renderContext.emitPickID) {
                meshShaderManager.setPickID(gl, shader, pickIDs.registerUint64(this, objectId));
            }
            totalChunks += manifestChunk.fragmentIds.length;
            for (const fragmentId of manifestChunk.fragmentIds) {
                const fragment = fragmentChunks.get(`${key}/${fragmentId}`);
                if (fragment !== undefined && fragment.state === neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY) {
                    meshShaderManager.drawFragment(gl, shader, fragment);
                    ++presentChunks;
                }
            }
        });
        if (renderContext.emitColor) {
            renderScaleHistogram.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
            renderScaleHistogram.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, presentChunks, totalChunks - presentChunks);
        }
        meshShaderManager.endLayer(gl, shader);
    }
    isReady() {
        const { displayState, source } = this;
        let ready = true;
        const fragmentChunks = source.fragmentSource.chunks;
        Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__["forEachVisibleSegment"])(displayState, objectId => {
            const key = Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__["getObjectKey"])(objectId);
            const manifestChunk = source.chunks.get(key);
            if (manifestChunk === undefined) {
                ready = false;
                return;
            }
            for (const fragmentId of manifestChunk.fragmentIds) {
                const fragmentChunk = fragmentChunks.get(`${key}/${fragmentId}`);
                if (fragmentChunk === undefined || fragmentChunk.state !== neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY) {
                    ready = false;
                    return;
                }
            }
        });
        return ready;
    }
}
class ManifestChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["Chunk"] {
    constructor(source, x) {
        super(source);
        this.fragmentIds = x.fragmentIds;
    }
}
class FragmentChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["Chunk"] {
    constructor(source, x) {
        super(source);
        this.meshData = x;
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        copyMeshDataToGpu(gl, this);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        freeGpuMeshData(this);
    }
}
class MeshSource extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["ChunkSource"] {
    constructor() {
        super(...arguments);
        this.fragmentSource = this.registerDisposer(new FragmentSource(this.chunkManager, this));
    }
    initializeCounterpart(rpc, options) {
        this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {});
        options['fragmentSource'] = this.fragmentSource.addCounterpartRef();
        super.initializeCounterpart(rpc, options);
    }
    getChunk(x) {
        return new ManifestChunk(this, x);
    }
}
let FragmentSource = class FragmentSource extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["ChunkSource"] {
    constructor(chunkManager, meshSource) {
        super(chunkManager);
        this.meshSource = meshSource;
    }
    get key() {
        return this.meshSource.key;
    }
    getChunk(x) {
        return new FragmentChunk(this, x);
    }
};
FragmentSource = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__["registerSharedObjectOwner"])(neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__["FRAGMENT_SOURCE_RPC_ID"])
], FragmentSource);

function hasFragmentChunk(fragmentChunks, objectKey, lod, chunkIndex) {
    const fragmentChunk = fragmentChunks.get(Object(neuroglancer_mesh_multiscale__WEBPACK_IMPORTED_MODULE_3__["getMultiscaleFragmentKey"])(objectKey, lod, chunkIndex));
    return fragmentChunk !== undefined && fragmentChunk.state === neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY;
}
class MultiscaleMeshLayer extends neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_4__["PerspectiveViewRenderLayer"] {
    constructor(chunkManager, source, displayState) {
        super();
        this.chunkManager = chunkManager;
        this.source = source;
        this.displayState = displayState;
        this.meshShaderManager = new MeshShaderManager(
        /*fragmentRelativeVertices=*/ this.source.format.fragmentRelativeVertices, this.source.format.vertexPositionFormat);
        this.shaders = new Map();
        Object(neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_6__["registerRedrawWhenSegmentationDisplayState3DChanged"])(displayState, this);
        let sharedObject = this.backend =
            this.registerDisposer(new neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_6__["SegmentationLayerSharedObject"](chunkManager, displayState));
        sharedObject.RPC_TYPE_ID = neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__["MULTISCALE_MESH_LAYER_RPC_ID"];
        sharedObject.initializeCounterpartWithChunkManager({
            'source': source.addCounterpartRef(),
        });
        this.setReady(true);
        sharedObject.visibility.add(this.visibility);
        this.registerDisposer(displayState.renderScaleHistogram.visibility.add(this.visibility));
    }
    getShader(emitter) {
        let { shaders } = this;
        let shader = shaders.get(emitter);
        if (shader === undefined) {
            shader = this.registerDisposer(this.meshShaderManager.getShader(this.gl, emitter));
            shaders.set(emitter, shader);
        }
        return shader;
    }
    get isTransparent() {
        return this.displayState.objectAlpha.value < 1.0;
    }
    get gl() {
        return this.chunkManager.chunkQueueManager.gl;
    }
    draw(renderContext) {
        if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
            // No need for a separate pick ID pass.
            return;
        }
        let { gl, displayState, meshShaderManager } = this;
        let alpha = Math.min(1.0, displayState.objectAlpha.value);
        if (alpha <= 0.0) {
            // Skip drawing.
            return;
        }
        let shader = this.getShader(renderContext.emitter);
        shader.bind();
        meshShaderManager.beginLayer(gl, shader, renderContext);
        const { renderScaleHistogram } = this.displayState;
        if (renderContext.emitColor) {
            renderScaleHistogram.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
        }
        let { pickIDs } = renderContext;
        const objectToDataMatrix = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat4"].multiply(tempModelMatrix, this.displayState.objectToDataTransform.transform, this.source.format.transform);
        Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat3FromMat4"])(tempMat3, objectToDataMatrix);
        const scaleMultiplier = Math.pow(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat3"].determinant(tempMat3), 1 / 3);
        const { chunks } = this.source;
        const fragmentChunks = this.source.fragmentSource.chunks;
        const modelViewProjection = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat4"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat4"].create(), renderContext.dataToDevice, objectToDataMatrix);
        const clippingPlanes = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["getFrustrumPlanes"])(new Float32Array(24), modelViewProjection);
        const detailCutoff = this.displayState.renderScaleTarget.value;
        const { fragmentRelativeVertices } = this.source.format;
        meshShaderManager.beginModel(gl, shader, renderContext, objectToDataMatrix);
        Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__["forEachVisibleSegment"])(displayState, (objectId, rootObjectId) => {
            const key = Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__["getObjectKey"])(objectId);
            const manifestChunk = chunks.get(key);
            if (manifestChunk === undefined)
                return;
            const { manifest } = manifestChunk;
            const { octree, chunkShape, chunkGridSpatialOrigin, vertexOffsets } = manifest;
            if (renderContext.emitColor) {
                meshShaderManager.setColor(gl, shader, Object(neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_6__["getObjectColor"])(displayState, rootObjectId, alpha));
            }
            if (renderContext.emitPickID) {
                meshShaderManager.setPickID(gl, shader, pickIDs.registerUint64(this, objectId));
            }
            if (DEBUG_MULTISCALE_FRAGMENTS) {
                console.log('drawing object, numChunks=', manifest.octree.length / 5, manifest.octree);
            }
            Object(neuroglancer_mesh_multiscale__WEBPACK_IMPORTED_MODULE_3__["getMultiscaleChunksToDraw"])(manifest, modelViewProjection, clippingPlanes, detailCutoff, renderContext.viewportWidth, renderContext.viewportHeight, (lod, chunkIndex, renderScale) => {
                const has = hasFragmentChunk(fragmentChunks, key, lod, chunkIndex);
                if (renderContext.emitColor) {
                    renderScaleHistogram.add(manifest.lodScales[lod] * scaleMultiplier, renderScale, has ? 1 : 0, has ? 0 : 1);
                }
                return has;
            }, (lod, chunkIndex, subChunkBegin, subChunkEnd) => {
                const fragmentKey = Object(neuroglancer_mesh_multiscale__WEBPACK_IMPORTED_MODULE_3__["getMultiscaleFragmentKey"])(key, lod, chunkIndex);
                const fragmentChunk = fragmentChunks.get(fragmentKey);
                const x = octree[5 * chunkIndex], y = octree[5 * chunkIndex + 1], z = octree[5 * chunkIndex + 2];
                const scale = 1 << lod;
                if (fragmentRelativeVertices) {
                    gl.uniform3f(shader.uniform('uFragmentOrigin'), chunkGridSpatialOrigin[0] + (x * chunkShape[0]) * scale +
                        vertexOffsets[lod * 3 + 0], chunkGridSpatialOrigin[1] + (y * chunkShape[1]) * scale +
                        vertexOffsets[lod * 3 + 1], chunkGridSpatialOrigin[2] + (z * chunkShape[2]) * scale +
                        vertexOffsets[lod * 3 + 2]);
                    gl.uniform3f(shader.uniform('uFragmentShape'), chunkShape[0] * scale, chunkShape[1] * scale, chunkShape[2] * scale);
                }
                meshShaderManager.drawMultiscaleFragment(gl, shader, fragmentChunk, subChunkBegin, subChunkEnd);
            });
        });
        meshShaderManager.endLayer(gl, shader);
    }
    isReady(renderContext) {
        let { displayState } = this;
        let alpha = Math.min(1.0, displayState.objectAlpha.value);
        if (alpha <= 0.0) {
            // Skip drawing.
            return true;
        }
        const objectToDataMatrix = this.displayState.objectToDataTransform.transform;
        const { chunks } = this.source;
        const fragmentChunks = this.source.fragmentSource.chunks;
        const modelViewProjection = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat4"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["mat4"].create(), renderContext.dataToDevice, objectToDataMatrix);
        const clippingPlanes = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["getFrustrumPlanes"])(new Float32Array(24), modelViewProjection);
        const detailCutoff = this.displayState.renderScaleTarget.value;
        let hasAllChunks = true;
        Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__["forEachVisibleSegment"])(displayState, (objectId) => {
            if (!hasAllChunks)
                return;
            const key = Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_5__["getObjectKey"])(objectId);
            const manifestChunk = chunks.get(key);
            if (manifestChunk === undefined) {
                hasAllChunks = false;
                return;
            }
            const { manifest } = manifestChunk;
            Object(neuroglancer_mesh_multiscale__WEBPACK_IMPORTED_MODULE_3__["getMultiscaleChunksToDraw"])(manifest, modelViewProjection, clippingPlanes, detailCutoff, renderContext.viewportWidth, renderContext.viewportHeight, (lod, chunkIndex) => {
                hasAllChunks = hasAllChunks && hasFragmentChunk(fragmentChunks, key, lod, chunkIndex);
                return hasAllChunks;
            }, () => { });
        });
        return hasAllChunks;
    }
}
class MultiscaleManifestChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["Chunk"] {
    constructor(source, x) {
        super(source);
        this.manifest = x['manifest'];
    }
}
class MultiscaleFragmentChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["Chunk"] {
    constructor(source, x) {
        super(source);
        this.meshData = x;
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        copyMeshDataToGpu(gl, this);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        freeGpuMeshData(this);
    }
}
class MultiscaleMeshSource extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["ChunkSource"] {
    constructor(chunkManager, options) {
        super(chunkManager, options);
        this.fragmentSource = this.registerDisposer(new MultiscaleFragmentSource(this.chunkManager, this));
        this.format = options.format;
    }
    initializeCounterpart(rpc, options) {
        this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {});
        options['fragmentSource'] = this.fragmentSource.addCounterpartRef();
        options['format'] = this.format;
        super.initializeCounterpart(rpc, options);
    }
    getChunk(x) {
        return new MultiscaleManifestChunk(this, x);
    }
}
let MultiscaleFragmentSource = class MultiscaleFragmentSource extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["ChunkSource"] {
    constructor(chunkManager, meshSource) {
        super(chunkManager);
        this.meshSource = meshSource;
    }
    get key() {
        return this.meshSource.key;
    }
    getChunk(x) {
        return new MultiscaleFragmentChunk(this, x);
    }
};
MultiscaleFragmentSource = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_11__["registerSharedObjectOwner"])(neuroglancer_mesh_base__WEBPACK_IMPORTED_MODULE_2__["MULTISCALE_FRAGMENT_SOURCE_RPC_ID"])
], MultiscaleFragmentSource);



/***/ }),

/***/ "./src/neuroglancer/mesh/multiscale.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/mesh/multiscale.ts ***!
  \*********************************************/
/*! exports provided: getDesiredMultiscaleMeshChunks, getMultiscaleChunksToDraw, validateOctree, getMultiscaleFragmentKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDesiredMultiscaleMeshChunks", function() { return getDesiredMultiscaleMeshChunks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMultiscaleChunksToDraw", function() { return getMultiscaleChunksToDraw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateOctree", function() { return validateOctree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMultiscaleFragmentKey", function() { return getMultiscaleFragmentKey; });
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_zorder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/zorder */ "./src/neuroglancer/util/zorder.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param detailCutoff Factor by which the spatial resolution of the mesh may be worse than the
 *     spatial resolution of a single viewport pixel.  For example, a value of 10 means that if a
 *     given portion of the object will be rendered such that a pixel corresponds to 50 nm, then a
 *     mesh level of detail down to 500 nm will be requested for that portion of the object.
 */
function getDesiredMultiscaleMeshChunks(manifest, modelViewProjection, clippingPlanes, detailCutoff, viewportWidth, viewportHeight, callback) {
    const { octree, lodScales, chunkGridSpatialOrigin, chunkShape } = manifest;
    const maxLod = lodScales.length - 1;
    const m00 = modelViewProjection[0], m01 = modelViewProjection[4], m02 = modelViewProjection[8], m10 = modelViewProjection[1], m11 = modelViewProjection[5], m12 = modelViewProjection[9], m30 = modelViewProjection[3], m31 = modelViewProjection[7], m32 = modelViewProjection[11], m33 = modelViewProjection[15];
    const minWXcoeff = m30 > 0 ? 0 : 1;
    const minWYcoeff = m31 > 0 ? 0 : 1;
    const minWZcoeff = m32 > 0 ? 0 : 1;
    const nearA = clippingPlanes[4 * 4], nearB = clippingPlanes[4 * 4 + 1], nearC = clippingPlanes[4 * 4 + 2], nearD = clippingPlanes[4 * 4 + 3];
    function getPointW(x, y, z) {
        return m30 * x + m31 * y + m32 * z + m33;
    }
    function getBoxW(xLower, yLower, zLower, xUpper, yUpper, zUpper) {
        return getPointW(xLower + minWXcoeff * (xUpper - xLower), yLower + minWYcoeff * (yUpper - yLower), zLower + minWZcoeff * (zUpper - zLower));
    }
    /**
     * Minimum value of w within clipping frustrum (under the assumption that the minimum value is
     * occurs occurs on the near clipping plane).
     */
    const minWClip = getPointW(-nearD * nearA, -nearD * nearB, -nearD * nearC);
    const objectXLower = manifest.clipLowerBound[0], objectYLower = manifest.clipLowerBound[1], objectZLower = manifest.clipLowerBound[2];
    const objectXUpper = manifest.clipUpperBound[0], objectYUpper = manifest.clipUpperBound[1], objectZUpper = manifest.clipUpperBound[2];
    const xScale = Math.sqrt((m00 * viewportWidth) ** 2 + (m10 * viewportHeight) ** 2);
    const yScale = Math.sqrt((m01 * viewportWidth) ** 2 + (m11 * viewportHeight) ** 2);
    const zScale = Math.sqrt((m02 * viewportWidth) ** 2 + (m12 * viewportHeight) ** 2);
    const scaleFactor = Math.max(xScale, yScale, zScale);
    function handleChunk(lod, row, priorLodScale) {
        const size = 1 << lod;
        const rowOffset = row * 5;
        const gridX = octree[rowOffset], gridY = octree[rowOffset + 1], gridZ = octree[rowOffset + 2], childBegin = octree[rowOffset + 3], childEndAndEmpty = octree[rowOffset + 4];
        let xLower = gridX * size * chunkShape[0] + chunkGridSpatialOrigin[0], yLower = gridY * size * chunkShape[1] + chunkGridSpatialOrigin[1], zLower = gridZ * size * chunkShape[2] + chunkGridSpatialOrigin[2];
        let xUpper = xLower + size * chunkShape[0], yUpper = yLower + size * chunkShape[1], zUpper = zLower + size * chunkShape[2];
        xLower = Math.max(xLower, objectXLower);
        yLower = Math.max(yLower, objectYLower);
        zLower = Math.max(zLower, objectZLower);
        xUpper = Math.min(xUpper, objectXUpper);
        yUpper = Math.min(yUpper, objectYUpper);
        zUpper = Math.min(zUpper, objectZUpper);
        if (Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["isAABBVisible"])(xLower, yLower, zLower, xUpper, yUpper, zUpper, clippingPlanes)) {
            const minW = Math.max(minWClip, getBoxW(xLower, yLower, zLower, xUpper, yUpper, zUpper));
            const pixelSize = minW / scaleFactor;
            if (priorLodScale === 0 || pixelSize * detailCutoff < priorLodScale) {
                const lodScale = lodScales[lod];
                if (lodScale !== 0) {
                    callback(lod, row, lodScale / pixelSize, (childEndAndEmpty >>> 31));
                }
                if (lod > 0 && (lodScale === 0 || pixelSize * detailCutoff < lodScale)) {
                    const nextPriorLodScale = lodScale === 0 ? priorLodScale : lodScale;
                    const childEnd = (childEndAndEmpty & 0x7FFFFFFF) >>> 0;
                    for (let childRow = childBegin; childRow < childEnd; ++childRow) {
                        handleChunk(lod - 1, childRow, nextPriorLodScale);
                    }
                }
            }
        }
    }
    handleChunk(maxLod, octree.length / 5 - 1, 0);
}
function getMultiscaleChunksToDraw(manifest, modelViewProjection, clippingPlanes, detailCutoff, viewportWidth, viewportHeight, hasChunk, callback) {
    const { lodScales } = manifest;
    let maxLod = 0;
    while (maxLod + 1 < lodScales.length && lodScales[maxLod + 1] !== 0) {
        ++maxLod;
    }
    const stackEntryStride = 3;
    // [row, parentSubChunkIndex, renderScale]
    const stack = [];
    let stackDepth = 0;
    let priorSubChunkIndex = 0;
    function emitChunksUpTo(targetStackIndex, subChunkIndex) {
        while (true) {
            if (stackDepth === 0)
                return;
            // Finish last chunk of last (finest) lod.
            const stackIndex = stackDepth - 1;
            const entryLod = maxLod - stackIndex;
            const entryRow = stack[stackIndex * stackEntryStride];
            const numSubChunks = entryLod === 0 ? 1 : 8;
            const entrySubChunkIndex = stack[stackIndex * stackEntryStride + 1];
            const entryRenderScale = stack[stackIndex * stackEntryStride + 2];
            if (targetStackIndex === stackDepth) {
                const endSubChunk = subChunkIndex & (numSubChunks - 1);
                if (priorSubChunkIndex !== endSubChunk && entryRow !== -1) {
                    callback(entryLod, entryRow, priorSubChunkIndex, endSubChunk, entryRenderScale);
                }
                priorSubChunkIndex = endSubChunk + 1;
                return;
            }
            if (priorSubChunkIndex !== numSubChunks && entryRow !== -1) {
                callback(entryLod, entryRow, priorSubChunkIndex, numSubChunks, entryRenderScale);
            }
            priorSubChunkIndex = entrySubChunkIndex + 1;
            --stackDepth;
        }
    }
    let priorMissingLod = 0;
    const { octree } = manifest;
    getDesiredMultiscaleMeshChunks(manifest, modelViewProjection, clippingPlanes, detailCutoff, viewportWidth, viewportHeight, (lod, row, renderScale, empty) => {
        if (!empty && !hasChunk(lod, row, renderScale)) {
            priorMissingLod = Math.max(lod, priorMissingLod);
            return;
        }
        if (lod < priorMissingLod)
            return;
        priorMissingLod = 0;
        const rowOffset = row * 5;
        const x = octree[rowOffset], y = octree[rowOffset + 1], z = octree[rowOffset + 2];
        const subChunkIndex = Object(neuroglancer_util_zorder__WEBPACK_IMPORTED_MODULE_1__["getOctreeChildIndex"])(x, y, z);
        const stackIndex = maxLod - lod;
        emitChunksUpTo(stackIndex, subChunkIndex);
        const stackOffset = stackIndex * stackEntryStride;
        stack[stackOffset] = empty ? -1 : row;
        stack[stackOffset + 1] = subChunkIndex;
        stack[stackOffset + 2] = renderScale;
        priorSubChunkIndex = 0;
        stackDepth = stackIndex + 1;
    });
    emitChunksUpTo(0, 0);
}
function validateOctree(octree) {
    if (octree.length % 5 !== 0) {
        throw new Error('Invalid length');
    }
    const numNodes = octree.length / 5;
    const seenNodes = new Set();
    function exploreNode(node) {
        if (seenNodes.has(node)) {
            throw new Error('Previously seen node');
        }
        seenNodes.add(node);
        if (node < 0 || node >= numNodes) {
            throw new Error('Invalid node reference');
        }
        const x = octree[node * 5], y = octree[node * 5 + 1], z = octree[node * 5 + 2], beginChild = octree[node * 5 + 3], endChild = octree[node * 5 + 4];
        if (beginChild < 0 || endChild < 0 || endChild < beginChild || endChild > numNodes ||
            beginChild + 8 < endChild) {
            throw new Error('Invalid child references');
        }
        for (let child = beginChild; child < endChild; ++child) {
            const childX = octree[child * 5], childY = octree[child * 5 + 1], childZ = octree[child * 5 + 2];
            if ((childX >>> 1) !== x || (childY >>> 1) !== y || (childZ >>> 1) != z) {
                throw new Error('invalid child');
            }
            exploreNode(child);
        }
    }
    if (numNodes === 0)
        return;
    exploreNode(numNodes - 1);
}
function getMultiscaleFragmentKey(objectKey, lod, chunkIndex) {
    return `${objectKey}/${lod}:${chunkIndex}`;
}


/***/ }),

/***/ "./src/neuroglancer/navigation_state.ts":
/*!**********************************************!*\
  !*** ./src/neuroglancer/navigation_state.ts ***!
  \**********************************************/
/*! exports provided: NavigationLinkType, TrackableNavigationLink, VoxelSize, SpatialPosition, LinkedSpatialPosition, OrientationState, LinkedOrientationState, Pose, TrackableZoomState, LinkedZoomState, NavigationState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationLinkType", function() { return NavigationLinkType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableNavigationLink", function() { return TrackableNavigationLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoxelSize", function() { return VoxelSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpatialPosition", function() { return SpatialPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinkedSpatialPosition", function() { return LinkedSpatialPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrientationState", function() { return OrientationState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinkedOrientationState", function() { return LinkedOrientationState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pose", function() { return Pose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableZoomState", function() { return TrackableZoomState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinkedZoomState", function() { return LinkedZoomState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationState", function() { return NavigationState; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_trackable_enum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/trackable_enum */ "./src/neuroglancer/util/trackable_enum.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var NavigationLinkType;
(function (NavigationLinkType) {
    NavigationLinkType[NavigationLinkType["LINKED"] = 0] = "LINKED";
    NavigationLinkType[NavigationLinkType["RELATIVE"] = 1] = "RELATIVE";
    NavigationLinkType[NavigationLinkType["UNLINKED"] = 2] = "UNLINKED";
})(NavigationLinkType || (NavigationLinkType = {}));
class TrackableNavigationLink extends neuroglancer_util_trackable_enum__WEBPACK_IMPORTED_MODULE_4__["TrackableEnum"] {
    constructor(value = NavigationLinkType.LINKED) {
        super(NavigationLinkType, value);
    }
}
class VoxelSize extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(voxelSize) {
        super();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
        let valid = true;
        if (voxelSize == null) {
            voxelSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
            valid = false;
        }
        this.size = voxelSize;
        this.valid = valid;
    }
    reset() {
        this.valid = false;
        this.changed.dispatch();
    }
    /**
     * This should be called after setting the voxel size initially.  The voxel
     * size should not be changed once it is valid.
     */
    setValid() {
        if (!this.valid) {
            this.valid = true;
            this.changed.dispatch();
        }
    }
    toJSON() {
        if (!this.valid) {
            return undefined;
        }
        return Array.prototype.slice.call(this.size);
    }
    restoreState(obj) {
        try {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["parseFiniteVec"])(this.size, obj);
            this.valid = true;
            this.changed.dispatch();
        }
        catch (e) {
            this.valid = false;
            this.changed.dispatch();
        }
    }
    toString() {
        if (!this.valid) {
            return null;
        }
        return this.size.toString();
    }
    voxelFromSpatial(voxel, spatial) {
        return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].divide(voxel, spatial, this.size);
    }
    spatialFromVoxel(spatial, voxel) {
        return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].multiply(spatial, voxel, this.size);
    }
}
const tempVec3 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
const tempQuat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].create();
function makeLinked(self, peer, link, operations) {
    let updatingSelf = false;
    let updatingPeer = false;
    let selfMinusPeer;
    self.registerDisposer(peer);
    const handlePeerUpdate = () => {
        if (updatingPeer) {
            return;
        }
        updatingSelf = true;
        switch (link.value) {
            case NavigationLinkType.UNLINKED:
                if (operations.isValid(self)) {
                    break;
                }
                else {
                    // Fallthrough to LINKED case.
                }
            case NavigationLinkType.LINKED:
                operations.assign(self, peer);
                break;
            case NavigationLinkType.RELATIVE:
                operations.add(self, peer, selfMinusPeer);
                break;
        }
        updatingSelf = false;
    };
    const handleSelfUpdate = () => {
        if (updatingSelf) {
            return;
        }
        switch (link.value) {
            case NavigationLinkType.UNLINKED:
                break;
            case NavigationLinkType.LINKED:
                operations.assign(peer, self);
                break;
            case NavigationLinkType.RELATIVE:
                operations.subtract(peer, self, selfMinusPeer);
                break;
        }
    };
    let previousLinkValue = NavigationLinkType.UNLINKED;
    const handleLinkUpdate = () => {
        const linkValue = link.value;
        if (linkValue !== previousLinkValue) {
            switch (linkValue) {
                case NavigationLinkType.UNLINKED:
                    selfMinusPeer = undefined;
                    break;
                case NavigationLinkType.LINKED:
                    selfMinusPeer = undefined;
                    operations.assign(self, peer);
                    break;
                case NavigationLinkType.RELATIVE:
                    selfMinusPeer = operations.difference(self, peer);
                    break;
            }
        }
        previousLinkValue = linkValue;
        self.changed.dispatch();
    };
    self.registerDisposer(self.changed.add(handleSelfUpdate));
    self.registerDisposer(peer.changed.add(handlePeerUpdate));
    self.registerDisposer(link.changed.add(handleLinkUpdate));
    handleLinkUpdate();
    return self;
}
class SpatialPosition extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(voxelSize, spatialCoordinates) {
        super();
        this.voxelCoordinates = null;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
        if (voxelSize == null) {
            voxelSize = new VoxelSize();
        }
        this.voxelSize = voxelSize;
        let spatialCoordinatesValid = true;
        if (spatialCoordinates == null) {
            spatialCoordinates = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
            spatialCoordinatesValid = false;
        }
        this.spatialCoordinates = spatialCoordinates;
        this.spatialCoordinatesValid = spatialCoordinatesValid;
        this.registerDisposer(voxelSize);
        this.registerDisposer(voxelSize.changed.add(() => {
            this.handleVoxelSizeChanged();
        }));
    }
    get valid() {
        return this.spatialCoordinatesValid && this.voxelSize.valid;
    }
    get voxelCoordinatesValid() {
        return this.valid || this.voxelCoordinates != null;
    }
    reset() {
        this.spatialCoordinatesValid = false;
        this.voxelCoordinates = null;
        this.voxelSize.reset();
        this.changed.dispatch();
    }
    getVoxelCoordinates(out) {
        let { voxelCoordinates } = this;
        if (voxelCoordinates) {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].copy(out, voxelCoordinates);
        }
        else if (this.valid) {
            this.voxelSize.voxelFromSpatial(out, this.spatialCoordinates);
        }
        else {
            return false;
        }
        return true;
    }
    /**
     * Sets this position to the spatial coordinats corresponding to the specified
     * voxelPosition.  If this.voxelSize.valid == false, then this position won't
     * be set until it is.
     */
    setVoxelCoordinates(voxelCoordinates) {
        let voxelSize = this.voxelSize;
        if (voxelSize.valid) {
            voxelSize.spatialFromVoxel(this.spatialCoordinates, voxelCoordinates);
            this.markSpatialCoordinatesChanged();
        }
        else {
            let voxelCoordinates_ = this.voxelCoordinates;
            if (!voxelCoordinates_) {
                this.voxelCoordinates = voxelCoordinates_ = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].clone(voxelCoordinates);
            }
            else {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].copy(voxelCoordinates_, voxelCoordinates);
            }
        }
        this.changed.dispatch();
    }
    markSpatialCoordinatesChanged() {
        this.spatialCoordinatesValid = true;
        this.voxelCoordinates = null;
        this.changed.dispatch();
    }
    handleVoxelSizeChanged() {
        if (this.voxelCoordinates != null && !this.spatialCoordinatesValid) {
            this.voxelSize.spatialFromVoxel(this.spatialCoordinates, this.voxelCoordinates);
            this.spatialCoordinatesValid = true;
        }
        this.voxelCoordinates = null;
        this.changed.dispatch();
    }
    toJSON() {
        let empty = true;
        let voxelSizeJson = this.voxelSize.toJSON();
        let obj = {};
        if (voxelSizeJson !== undefined) {
            empty = false;
            obj['voxelSize'] = voxelSizeJson;
        }
        if (this.voxelCoordinatesValid) {
            let voxelCoordinates = tempVec3;
            this.getVoxelCoordinates(voxelCoordinates);
            obj['voxelCoordinates'] = Array.prototype.slice.call(voxelCoordinates);
            empty = false;
        }
        else if (this.spatialCoordinatesValid) {
            obj['spatialCoordinates'] = Array.prototype.slice.call(this.spatialCoordinates);
            empty = false;
        }
        if (empty) {
            return undefined;
        }
        return obj;
    }
    restoreState(obj) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObject"])(obj);
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'voxelSize', x => {
            if (x !== undefined) {
                this.voxelSize.restoreState(x);
            }
        });
        this.spatialCoordinatesValid = false;
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'voxelCoordinates', x => {
            if (x !== undefined) {
                this.setVoxelCoordinates(Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["parseFiniteVec"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create(), x));
            }
        });
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'spatialCoordinates', x => {
            if (x !== undefined) {
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["parseFiniteVec"])(this.spatialCoordinates, x);
                this.markSpatialCoordinatesChanged();
            }
        });
    }
    snapToVoxel() {
        if (!this.valid) {
            let { voxelCoordinates } = this;
            if (voxelCoordinates != null) {
                for (let i = 0; i < 3; ++i) {
                    voxelCoordinates[i] = Math.round(voxelCoordinates[i]);
                }
                this.changed.dispatch();
            }
        }
        else {
            let spatialCoordinates = this.spatialCoordinates;
            let voxelSize = this.voxelSize.size;
            for (let i = 0; i < 3; ++i) {
                let voxelSizeValue = voxelSize[i];
                spatialCoordinates[i] = Math.round(spatialCoordinates[i] / voxelSizeValue) * voxelSizeValue;
            }
            this.changed.dispatch();
        }
    }
    assign(other) {
        this.spatialCoordinatesValid = other.spatialCoordinatesValid;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].copy(this.spatialCoordinates, other.spatialCoordinates);
        const { voxelCoordinates } = other;
        this.voxelCoordinates = voxelCoordinates && neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].clone(voxelCoordinates);
        this.changed.dispatch();
    }
    /**
     * Get the offset of `a` relative to `b`.
     */
    static getOffset(a, b) {
        if (a.spatialCoordinatesValid && b.spatialCoordinatesValid) {
            return {
                spatialOffset: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].subtract(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create(), a.spatialCoordinates, b.spatialCoordinates)
            };
        }
        if (a.voxelCoordinates && b.voxelCoordinates) {
            if (a.voxelSize !== b.voxelSize) {
                throw new Error('Voxel offsets are only meaningful with identical voxelSize.');
            }
            return { voxelOffset: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].subtract(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create(), a.voxelCoordinates, b.voxelCoordinates) };
        }
        return {};
    }
    static addOffset(target, source, offset, scale = 1) {
        const { spatialOffset, voxelOffset } = offset;
        if (spatialOffset !== undefined && source.spatialCoordinatesValid) {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].scaleAndAdd(target.spatialCoordinates, source.spatialCoordinates, spatialOffset, scale);
            target.markSpatialCoordinatesChanged();
        }
        else if (voxelOffset !== undefined && source.getVoxelCoordinates(tempVec3)) {
            target.setVoxelCoordinates(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].scaleAndAdd(tempVec3, tempVec3, voxelOffset, scale));
        }
    }
}
class LinkedBase {
    constructor(peer, link = new TrackableNavigationLink()) {
        this.peer = peer;
        this.link = link;
    }
    get changed() {
        return this.value.changed;
    }
    toJSON() {
        const { link } = this;
        if (link.value === NavigationLinkType.LINKED) {
            return undefined;
        }
        return { link: link.toJSON(), value: this.getValueJson() };
    }
    getValueJson() {
        return this.value.toJSON();
    }
    reset() {
        this.link.value = NavigationLinkType.LINKED;
    }
    restoreState(obj) {
        if (obj === undefined || Object.keys(obj).length === 0) {
            this.link.value = NavigationLinkType.LINKED;
            return;
        }
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObject"])(obj);
        this.link.value = NavigationLinkType.UNLINKED;
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'value', x => {
            if (x !== undefined) {
                this.value.restoreState(x);
            }
        });
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'link', x => this.link.restoreState(x));
    }
    copyToPeer() {
        if (this.link.value !== NavigationLinkType.LINKED) {
            this.link.value = NavigationLinkType.UNLINKED;
            this.peer.assign(this.value);
            this.link.value = NavigationLinkType.LINKED;
        }
    }
}
class LinkedSpatialPosition extends LinkedBase {
    constructor() {
        super(...arguments);
        this.value = makeLinked(new SpatialPosition(this.peer.voxelSize.addRef()), this.peer, this.link, {
            assign: (a, b) => a.assign(b),
            isValid: (a) => {
                return a.spatialCoordinatesValid || a.voxelCoordinatesValid;
            },
            difference: SpatialPosition.getOffset,
            add: SpatialPosition.addOffset,
            subtract: (target, source, amount) => {
                SpatialPosition.addOffset(target, source, amount, -1);
            },
        });
    }
    getValueJson() {
        const value = this.value.toJSON() || {};
        delete value['voxelSize'];
        return value;
    }
}
function quaternionIsIdentity(q) {
    return q[0] === 0 && q[1] === 0 && q[2] === 0 && q[3] === 1;
}
class OrientationState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(orientation) {
        super();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
        if (orientation == null) {
            orientation = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].create();
        }
        this.orientation = orientation;
    }
    toJSON() {
        let { orientation } = this;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].normalize(this.orientation, this.orientation);
        if (quaternionIsIdentity(orientation)) {
            return undefined;
        }
        return Array.prototype.slice.call(this.orientation);
    }
    restoreState(obj) {
        try {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["parseFiniteVec"])(this.orientation, obj);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].normalize(this.orientation, this.orientation);
        }
        catch (ignoredError) {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].identity(this.orientation);
        }
        this.changed.dispatch();
    }
    reset() {
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].identity(this.orientation);
        this.changed.dispatch();
    }
    snap() {
        let mat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["mat3"].create();
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["mat3"].fromQuat(mat, this.orientation);
        let usedAxes = [false, false, false];
        for (let i = 0; i < 3; ++i) {
            let maxComponent = 0;
            let argmaxComponent = 0;
            for (let j = 0; j < 3; ++j) {
                let value = mat[i * 3 + j];
                mat[i * 3 + j] = 0;
                if (usedAxes[j]) {
                    continue;
                }
                if (Math.abs(value) > Math.abs(maxComponent)) {
                    maxComponent = value;
                    argmaxComponent = j;
                }
            }
            mat[i * 3 + argmaxComponent] = Math.sign(maxComponent);
            usedAxes[argmaxComponent] = true;
        }
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].fromMat3(this.orientation, mat);
        this.changed.dispatch();
    }
    /**
     * Returns a new OrientationState with orientation fixed to peerToSelf * peer.orientation.  Any
     * changes to the returned OrientationState will cause a corresponding change in peer, and vice
     * versa.
     */
    static makeRelative(peer, peerToSelf) {
        let self = new OrientationState(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].create(), peer.orientation, peerToSelf));
        let updatingPeer = false;
        self.registerDisposer(peer.changed.add(() => {
            if (!updatingPeer) {
                updatingSelf = true;
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(self.orientation, peer.orientation, peerToSelf);
                self.changed.dispatch();
                updatingSelf = false;
            }
        }));
        let updatingSelf = false;
        const selfToPeer = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].invert(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].create(), peerToSelf);
        self.registerDisposer(self.changed.add(() => {
            if (!updatingSelf) {
                updatingPeer = true;
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(peer.orientation, self.orientation, selfToPeer);
                peer.changed.dispatch();
                updatingPeer = false;
            }
        }));
        return self;
    }
    assign(other) {
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].copy(this.orientation, other.orientation);
        this.changed.dispatch();
    }
}
class LinkedOrientationState extends LinkedBase {
    constructor() {
        super(...arguments);
        this.value = makeLinked(new OrientationState(), this.peer, this.link, {
            assign: (a, b) => a.assign(b),
            isValid: () => true,
            difference: (a, b) => {
                const temp = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].create();
                return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(temp, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].invert(temp, b.orientation), a.orientation);
            },
            add: (target, source, amount) => {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(target.orientation, source.orientation, amount);
                target.changed.dispatch();
            },
            subtract: (target, source, amount) => {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(target.orientation, source.orientation, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].invert(tempQuat, amount));
                target.changed.dispatch();
            }
        });
    }
}
class Pose extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(position, orientation) {
        super();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
        if (position == null) {
            position = new SpatialPosition();
        }
        this.position = position;
        if (orientation == null) {
            orientation = new OrientationState();
        }
        this.orientation = orientation;
        this.registerDisposer(this.position);
        this.registerDisposer(this.orientation);
        this.registerDisposer(this.position.changed.add(this.changed.dispatch));
        this.registerDisposer(this.orientation.changed.add(this.changed.dispatch));
    }
    get valid() {
        return this.position.valid;
    }
    /**
     * Resets everything.
     */
    reset() {
        this.position.reset();
        this.orientation.reset();
    }
    toMat4(mat) {
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["mat4"].fromRotationTranslation(mat, this.orientation.orientation, this.position.spatialCoordinates);
    }
    toJSON() {
        let positionJson = this.position.toJSON();
        let orientationJson = this.orientation.toJSON();
        if (positionJson === undefined && orientationJson === undefined) {
            return undefined;
        }
        return { 'position': positionJson, 'orientation': orientationJson };
    }
    restoreState(obj) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObject"])(obj);
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'position', x => {
            if (x !== undefined) {
                this.position.restoreState(x);
            }
        });
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'orientation', x => {
            if (x !== undefined) {
                this.orientation.restoreState(x);
            }
        });
    }
    /**
     * Snaps the orientation to the nearest axis-aligned orientation, and
     * snaps the position to the nearest voxel.
     */
    snap() {
        this.orientation.snap();
        this.position.snapToVoxel();
        this.changed.dispatch();
    }
    translateAbsolute(translation) {
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].add(this.position.spatialCoordinates, this.position.spatialCoordinates, translation);
        this.position.changed.dispatch();
    }
    translateRelative(translation) {
        if (!this.valid) {
            return;
        }
        const temp = tempVec3;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformQuat(temp, translation, this.orientation.orientation);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].add(this.position.spatialCoordinates, this.position.spatialCoordinates, temp);
        this.position.changed.dispatch();
    }
    translateVoxelsRelative(translation) {
        if (!this.valid) {
            return;
        }
        var temp = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformQuat(temp, translation, this.orientation.orientation);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].multiply(temp, temp, this.position.voxelSize.size);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].add(this.position.spatialCoordinates, this.position.spatialCoordinates, temp);
        this.position.changed.dispatch();
    }
    rotateRelative(axis, angle) {
        var temp = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].create();
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].setAxisAngle(temp, axis, angle);
        var orientation = this.orientation.orientation;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(orientation, orientation, temp);
        this.orientation.changed.dispatch();
    }
    rotateAbsolute(axis, angle, fixedPoint) {
        var temp = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].create();
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].setAxisAngle(temp, axis, angle);
        var orientation = this.orientation.orientation;
        if (fixedPoint !== undefined) {
            // We want the coordinates in the transformed coordinate frame of the fixed point to remain
            // the same after the rotation.
            // We have the invariants:
            // oldOrienation * fixedPointLocal + oldPosition == fixedPoint.
            // newOrientation * fixedPointLocal + newPosition == fixedPoint.
            // Therefore, we compute fixedPointLocal by:
            // fixedPointLocal == inverse(oldOrientation) * (fixedPoint - oldPosition).
            let { spatialCoordinates } = this.position;
            let fixedPointLocal = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].subtract(tempVec3, fixedPoint, spatialCoordinates);
            let invOrientation = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].invert(tempQuat, orientation);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformQuat(fixedPointLocal, fixedPointLocal, invOrientation);
            // We then compute the newPosition by:
            // newPosition := fixedPoint - newOrientation * fixedPointLocal.
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(orientation, temp, orientation);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformQuat(spatialCoordinates, fixedPointLocal, orientation);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].subtract(spatialCoordinates, fixedPoint, spatialCoordinates);
            this.position.changed.dispatch();
        }
        else {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["quat"].multiply(orientation, temp, orientation);
        }
        this.orientation.changed.dispatch();
    }
}
class TrackableZoomState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(value_ = Number.NaN, defaultValue = value_) {
        super();
        this.value_ = value_;
        this.defaultValue = defaultValue;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
    }
    get value() {
        return this.value_;
    }
    set value(newValue) {
        if (newValue !== this.value_) {
            this.value_ = newValue;
            this.changed.dispatch();
        }
    }
    toJSON() {
        let { value_, defaultValue } = this;
        if (Number.isNaN(value_) && Number.isNaN(defaultValue) || value_ === defaultValue) {
            return undefined;
        }
        return value_;
    }
    restoreState(obj) {
        if (typeof obj === 'number' && Number.isFinite(obj) && obj > 0) {
            this.value = obj;
        }
        else {
            this.value = this.defaultValue;
        }
    }
    reset() {
        this.value = this.defaultValue;
    }
    zoomBy(factor) {
        let { value_ } = this;
        if (Number.isNaN(value_)) {
            return;
        }
        this.value = value_ * factor;
    }
    assign(other) {
        this.value = other.value;
    }
    get valid() {
        return !Number.isNaN(this.value);
    }
}
class LinkedZoomState extends LinkedBase {
    constructor() {
        super(...arguments);
        this.value = (() => {
            const self = new TrackableZoomState();
            const assign = (target, source) => target.assign(source);
            const difference = (a, b) => {
                return a.value / b.value;
            };
            const add = (target, source, amount) => {
                target.value = source.value * amount;
            };
            const subtract = (target, source, amount) => {
                target.value = source.value / amount;
            };
            const isValid = (x) => x.valid;
            return makeLinked(self, this.peer, this.link, { assign, isValid, difference, add, subtract });
        })();
    }
}
class NavigationState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(pose = new Pose(), zoomFactor = Number.NaN) {
        super();
        this.pose = pose;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
        if (typeof zoomFactor === 'number') {
            this.zoomFactor = new TrackableZoomState(zoomFactor);
        }
        else {
            this.zoomFactor = zoomFactor;
        }
        this.registerDisposer(this.zoomFactor);
        this.registerDisposer(pose);
        this.registerDisposer(this.pose.changed.add(() => {
            this.changed.dispatch();
        }));
        this.registerDisposer(this.zoomFactor.changed.add(() => {
            this.changed.dispatch();
        }));
        this.registerDisposer(this.voxelSize.changed.add(() => {
            this.handleVoxelSizeChanged();
        }));
        this.handleVoxelSizeChanged();
    }
    get voxelSize() {
        return this.pose.position.voxelSize;
    }
    /**
     * Resets everything.
     */
    reset() {
        this.pose.reset();
        this.zoomFactor.reset();
    }
    setZoomFactorFromVoxelSize() {
        let { voxelSize } = this;
        if (voxelSize.valid) {
            this.zoomFactor.value = Math.min.apply(null, this.voxelSize.size);
        }
    }
    /**
     * Sets the zoomFactor to the minimum voxelSize if it is not already set.
     */
    handleVoxelSizeChanged() {
        if (!this.zoomFactor.valid) {
            this.setZoomFactorFromVoxelSize();
        }
    }
    get position() {
        return this.pose.position;
    }
    toMat4(mat) {
        this.pose.toMat4(mat);
        let zoom = this.zoomFactor.value;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["mat4"].scale(mat, mat, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(zoom, zoom, zoom));
    }
    get valid() {
        return this.pose.valid;
    }
    toJSON() {
        let poseJson = this.pose.toJSON();
        let zoomFactorJson = this.zoomFactor.toJSON();
        if (poseJson === undefined && zoomFactorJson === undefined) {
            return undefined;
        }
        return { 'pose': poseJson, 'zoomFactor': zoomFactorJson };
    }
    restoreState(obj) {
        try {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObject"])(obj);
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'pose', x => {
                if (x !== undefined) {
                    this.pose.restoreState(x);
                }
            });
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'zoomFactor', x => {
                if (x !== undefined) {
                    this.zoomFactor.restoreState(x);
                }
            });
            this.handleVoxelSizeChanged();
            this.changed.dispatch();
        }
        catch (parseError) {
            this.reset();
        }
    }
    zoomBy(factor) {
        this.zoomFactor.zoomBy(factor);
    }
}


/***/ }),

/***/ "./src/neuroglancer/noselect.css":
/*!***************************************!*\
  !*** ./src/neuroglancer/noselect.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/object_picking.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/object_picking.ts ***!
  \********************************************/
/*! exports provided: PickIDManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PickIDManager", function() { return PickIDManager; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEBUG_PICKING = false;
class PickIDManager {
    constructor() {
        /**
         * This specifies the render layer corresponding to each registered entry.
         */
        this.renderLayers = [null];
        this.pickData = [null];
        /**
         * This contains 3 consecutive values, specifying (startPickID, low, high), for each registered
         * entry.  startPickID specifies the first uint32 pick ID corresponding to the entry.  low and
         * high specify two additional numbers associated with the entry.
         */
        this.values = [0, 0, 0];
        this.nextPickID = 1;
    }
    clear() {
        this.renderLayers.length = 1;
        this.pickData.length = 1;
        this.values.length = 3;
        this.nextPickID = 1;
    }
    registerUint64(renderLayer, x, count = 1) {
        return this.register(renderLayer, count, x.low, x.high);
    }
    register(renderLayer, count = 1, low = 0, high = 0, data = null) {
        let { renderLayers, values } = this;
        let pickID = this.nextPickID;
        this.nextPickID += count;
        let index = renderLayers.length;
        renderLayers[index] = renderLayer;
        let valuesOffset = index * 3;
        values[valuesOffset] = pickID;
        values[valuesOffset + 1] = low;
        values[valuesOffset + 2] = high;
        this.pickData[index] = data;
        return pickID;
    }
    /**
     * Set the object state according to the specified pick ID.
     */
    setMouseState(mouseState, pickID) {
        // Binary search to find largest registered index with a pick ID <= pickID.
        const { renderLayers, values } = this;
        let lower = 0, upper = renderLayers.length - 1;
        while (lower < upper) {
            const mid = Math.ceil(lower + (upper - lower) / 2);
            if (values[mid * 3] > pickID) {
                upper = mid - 1;
            }
            else {
                lower = mid;
            }
        }
        const pickedRenderLayer = mouseState.pickedRenderLayer = renderLayers[lower];
        const valuesOffset = lower * 3;
        const pickedOffset = mouseState.pickedOffset = pickID - values[valuesOffset];
        if (DEBUG_PICKING) {
            console.log(`Looking up pick ID ${pickID}: renderLayer`, pickedRenderLayer, `offset=${pickedOffset}`);
        }
        let { pickedValue } = mouseState;
        pickedValue.low = values[valuesOffset + 1];
        pickedValue.high = values[valuesOffset + 2];
        mouseState.pickedAnnotationId = undefined;
        mouseState.pickedAnnotationLayer = undefined;
        if (pickedRenderLayer !== null) {
            pickedRenderLayer.updateMouseState(mouseState, pickedValue, pickedOffset, this.pickData[lower]);
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/overlay.css":
/*!**************************************!*\
  !*** ./src/neuroglancer/overlay.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/overlay.ts":
/*!*************************************!*\
  !*** ./src/neuroglancer/overlay.ts ***!
  \*************************************/
/*! exports provided: overlayKeyboardHandlerPriority, overlaysOpen, defaultEventMap, Overlay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "overlayKeyboardHandlerPriority", function() { return overlayKeyboardHandlerPriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "overlaysOpen", function() { return overlaysOpen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultEventMap", function() { return defaultEventMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Overlay", function() { return Overlay; });
/* harmony import */ var neuroglancer_util_automatic_focus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/automatic_focus */ "./src/neuroglancer/util/automatic_focus.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/keyboard_bindings */ "./src/neuroglancer/util/keyboard_bindings.ts");
/* harmony import */ var _overlay_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overlay.css */ "./src/neuroglancer/overlay.css");
/* harmony import */ var _overlay_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_overlay_css__WEBPACK_IMPORTED_MODULE_3__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const overlayKeyboardHandlerPriority = 100;

let overlaysOpen = 0;
const defaultEventMap = neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_2__["EventActionMap"].fromObject({
    'escape': { action: 'close' },
});
class Overlay extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor() {
        super();
        this.keyMap = new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_2__["EventActionMap"]();
        this.keyMap.addParent(defaultEventMap, Number.NEGATIVE_INFINITY);
        ++overlaysOpen;
        let container = this.container = document.createElement('div');
        container.className = 'overlay';
        let content = this.content = document.createElement('div');
        this.registerDisposer(new neuroglancer_util_automatic_focus__WEBPACK_IMPORTED_MODULE_0__["AutomaticallyFocusedElement"](content));
        content.className = 'overlay-content';
        container.appendChild(content);
        document.body.appendChild(container);
        this.registerDisposer(new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_2__["KeyboardEventBinder"](this.container, this.keyMap));
        this.registerEventListener(container, 'action:close', () => {
            this.dispose();
        });
        content.focus();
    }
    disposed() {
        --overlaysOpen;
        document.body.removeChild(this.container);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/perspective_view/base.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/perspective_view/base.ts ***!
  \***************************************************/
/*! exports provided: PERSPECTIVE_VIEW_RPC_ID, PERSPECTIVE_VIEW_ADD_LAYER_RPC_ID, PERSPECTIVE_VIEW_REMOVE_LAYER_RPC_ID, PERSPECTIVE_VIEW_UPDATE_VIEWPORT_RPC_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PERSPECTIVE_VIEW_RPC_ID", function() { return PERSPECTIVE_VIEW_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PERSPECTIVE_VIEW_ADD_LAYER_RPC_ID", function() { return PERSPECTIVE_VIEW_ADD_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PERSPECTIVE_VIEW_REMOVE_LAYER_RPC_ID", function() { return PERSPECTIVE_VIEW_REMOVE_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PERSPECTIVE_VIEW_UPDATE_VIEWPORT_RPC_ID", function() { return PERSPECTIVE_VIEW_UPDATE_VIEWPORT_RPC_ID; });
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PERSPECTIVE_VIEW_RPC_ID = 'perspective_view/PerspectiveView';
const PERSPECTIVE_VIEW_ADD_LAYER_RPC_ID = 'perspective_view/addLayer';
const PERSPECTIVE_VIEW_REMOVE_LAYER_RPC_ID = 'perspective_view/removeLayer';
const PERSPECTIVE_VIEW_UPDATE_VIEWPORT_RPC_ID = 'perspective_view/updateViewport';


/***/ }),

/***/ "./src/neuroglancer/perspective_view/panel.css":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/perspective_view/panel.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/perspective_view/panel.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/perspective_view/panel.ts ***!
  \****************************************************/
/*! exports provided: OffscreenTextures, glsl_perspectivePanelEmit, glsl_computeOITWeight, glsl_perspectivePanelEmitOIT, perspectivePanelEmit, perspectivePanelEmitOIT, PerspectivePanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffscreenTextures", function() { return OffscreenTextures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_perspectivePanelEmit", function() { return glsl_perspectivePanelEmit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_computeOITWeight", function() { return glsl_computeOITWeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_perspectivePanelEmitOIT", function() { return glsl_perspectivePanelEmitOIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectivePanelEmit", function() { return perspectivePanelEmit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectivePanelEmitOIT", function() { return perspectivePanelEmitOIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectivePanel", function() { return PerspectivePanel; });
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/throttle */ "./node_modules/lodash/throttle.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_axes_lines__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/axes_lines */ "./src/neuroglancer/axes_lines.ts");
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_perspective_view_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/perspective_view/base */ "./src/neuroglancer/perspective_view/base.ts");
/* harmony import */ var neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/perspective_view/render_layer */ "./src/neuroglancer/perspective_view/render_layer.ts");
/* harmony import */ var neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/rendered_data_panel */ "./src/neuroglancer/rendered_data_panel.ts");
/* harmony import */ var neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/sliceview/frontend */ "./src/neuroglancer/sliceview/frontend.ts");
/* harmony import */ var neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/trackable_boolean */ "./src/neuroglancer/trackable_boolean.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/mouse_drag */ "./src/neuroglancer/util/mouse_drag.ts");
/* harmony import */ var neuroglancer_util_watchable_map__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/watchable_map */ "./src/neuroglancer/util/watchable_map.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/webgl/offscreen */ "./src/neuroglancer/webgl/offscreen.ts");
/* harmony import */ var neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/widget/scale_bar */ "./src/neuroglancer/widget/scale_bar.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/noselect.css */ "./src/neuroglancer/noselect.css");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _panel_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./panel.css */ "./src/neuroglancer/perspective_view/panel.css");
/* harmony import */ var _panel_css__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_panel_css__WEBPACK_IMPORTED_MODULE_17__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















var OffscreenTextures;
(function (OffscreenTextures) {
    OffscreenTextures[OffscreenTextures["COLOR"] = 0] = "COLOR";
    OffscreenTextures[OffscreenTextures["Z"] = 1] = "Z";
    OffscreenTextures[OffscreenTextures["PICK"] = 2] = "PICK";
    OffscreenTextures[OffscreenTextures["NUM_TEXTURES"] = 3] = "NUM_TEXTURES";
})(OffscreenTextures || (OffscreenTextures = {}));
const glsl_perspectivePanelEmit = `
void emit(vec4 color, highp uint pickId) {
  out_color = color;
  out_z = 1.0 - gl_FragCoord.z;
  out_pickId = float(pickId);
}
`;
/**
 * http://jcgt.org/published/0002/02/09/paper.pdf
 * http://casual-effects.blogspot.com/2015/03/implemented-weighted-blended-order.html
 */
const glsl_computeOITWeight = `
float computeOITWeight(float alpha) {
  float a = min(1.0, alpha) * 8.0 + 0.01;
  float b = -gl_FragCoord.z * 0.95 + 1.0;
  return a * a * a * b * b * b;
}
`;
// Color must be premultiplied by alpha.
const glsl_perspectivePanelEmitOIT = [
    glsl_computeOITWeight, `
void emit(vec4 color, highp uint pickId) {
  float weight = computeOITWeight(color.a);
  vec4 accum = color * weight;
  v4f_fragData0 = vec4(accum.rgb, color.a);
  v4f_fragData1 = vec4(accum.a, 0.0, 0.0, 0.0);
}
`
];
function perspectivePanelEmit(builder) {
    builder.addOutputBuffer('vec4', `out_color`, OffscreenTextures.COLOR);
    builder.addOutputBuffer('highp float', `out_z`, OffscreenTextures.Z);
    builder.addOutputBuffer('highp float', `out_pickId`, OffscreenTextures.PICK);
    builder.addFragmentCode(glsl_perspectivePanelEmit);
}
function perspectivePanelEmitOIT(builder) {
    builder.addOutputBuffer('vec4', 'v4f_fragData0', 0);
    builder.addOutputBuffer('vec4', 'v4f_fragData1', 1);
    builder.addFragmentCode(glsl_perspectivePanelEmitOIT);
}
const tempVec3 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create();
const tempVec3b = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create();
const tempVec4 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec4"].create();
const tempMat4 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create();
function defineTransparencyCopyShader(builder) {
    builder.addOutputBuffer('vec4', 'v4f_fragColor', null);
    builder.setFragmentMain(`
vec4 v0 = getValue0();
vec4 v1 = getValue1();
vec4 accum = vec4(v0.rgb, v1.r);
float revealage = v0.a;

v4f_fragColor = vec4(accum.rgb / accum.a, revealage);
`);
}
const PerspectiveViewStateBase = Object(neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_12__["withSharedVisibility"])(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_15__["SharedObject"]);
class PerspectiveViewState extends PerspectiveViewStateBase {
}
class PerspectivePanel extends neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["RenderedDataPanel"] {
    constructor(context, element, viewer) {
        super(context, element, viewer);
        /**
         * If boolean value is true, sliceView is shown unconditionally, regardless of the value of
         * this.viewer.showSliceViews.value.
         */
        this.sliceViews = (() => {
            const sliceViewDisposers = new Map();
            return this.registerDisposer(new neuroglancer_util_watchable_map__WEBPACK_IMPORTED_MODULE_11__["WatchableMap"]((_unconditional, sliceView) => {
                const disposer = sliceView.visibility.add(this.visibility);
                sliceViewDisposers.set(sliceView, disposer);
                this.scheduleRedraw();
            }, (_unconditional, sliceView) => {
                const disposer = sliceViewDisposers.get(sliceView);
                sliceViewDisposers.delete(sliceView);
                disposer();
                sliceView.dispose();
                this.scheduleRedraw();
            }));
        })();
        /**
         * Transform from camera space to OpenGL clip space.
         */
        this.projectionMat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create();
        /**
         * Transform from world space to camera space.
         */
        this.viewMat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create();
        /**
         * Inverse of `viewMat`.
         */
        this.viewMatInverse = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create();
        /**
         * Transform from world space to OpenGL clip space.  Equal to `projectionMat * viewMat`.
         */
        this.viewProjectionMat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create();
        /**
         * Inverse of `viewProjectionMat`.
         */
        this.viewProjectionMatInverse = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].create();
        /**
         * Width of panel viewport in pixels.
         */
        this.width = 0;
        /**
         * Height of panel viewport in pixels.
         */
        this.height = 0;
        this.axesLineHelper = this.registerDisposer(neuroglancer_axes_lines__WEBPACK_IMPORTED_MODULE_1__["AxesLineHelper"].get(this.gl));
        this.sliceViewRenderHelper = this.registerDisposer(neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_6__["SliceViewRenderHelper"].get(this.gl, perspectivePanelEmit));
        this.offscreenFramebuffer = this.registerDisposer(new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["FramebufferConfiguration"](this.gl, {
            colorBuffers: [
                new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["TextureBuffer"](this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE),
                new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["TextureBuffer"](this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT),
                new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["TextureBuffer"](this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT),
            ],
            depthBuffer: new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["DepthBuffer"](this.gl)
        }));
        this.offscreenCopyHelper = this.registerDisposer(neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["OffscreenCopyHelper"].get(this.gl));
        this.transparencyCopyHelper = this.registerDisposer(neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["OffscreenCopyHelper"].get(this.gl, defineTransparencyCopyShader, 2));
        this.scaleBarCopyHelper = this.registerDisposer(neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["OffscreenCopyHelper"].get(this.gl));
        this.scaleBarTexture = this.registerDisposer(new neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_14__["ScaleBarTexture"](this.gl));
        this.nanometersPerPixel = 1;
        this.throttledSendViewportUpdate = this.registerCancellable(lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default()(() => {
            const { sharedObject } = this;
            const { valid } = this.navigationState;
            if (valid) {
                this.updateProjectionMatrix();
            }
            sharedObject.rpc.invoke(neuroglancer_perspective_view_base__WEBPACK_IMPORTED_MODULE_3__["PERSPECTIVE_VIEW_UPDATE_VIEWPORT_RPC_ID"], {
                view: sharedObject.rpcId,
                viewport: {
                    width: valid ? this.width : 0,
                    height: valid ? this.height : 0,
                    viewMat: this.viewMat,
                    projectionMat: this.projectionMat,
                    viewProjectionMat: this.viewProjectionMat,
                },
            });
        }, 10));
        this.registerDisposer(this.navigationState.changed.add(() => {
            this.throttledSendViewportUpdate();
            this.context.scheduleRedraw();
        }));
        const sharedObject = this.sharedObject = this.registerDisposer(new PerspectiveViewState());
        sharedObject.RPC_TYPE_ID = neuroglancer_perspective_view_base__WEBPACK_IMPORTED_MODULE_3__["PERSPECTIVE_VIEW_RPC_ID"];
        sharedObject.initializeCounterpart(viewer.rpc, {});
        sharedObject.visibility.add(this.visibility);
        this.visibleLayerTracker = Object(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_2__["makeRenderedPanelVisibleLayerTracker"])(this.viewer.layerManager, neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_4__["PerspectiveViewRenderLayer"], this.viewer.visibleLayerRoles, this, layer => {
            const { backend } = layer;
            if (backend) {
                backend.rpc.invoke(neuroglancer_perspective_view_base__WEBPACK_IMPORTED_MODULE_3__["PERSPECTIVE_VIEW_ADD_LAYER_RPC_ID"], { layer: backend.rpcId, view: this.sharedObject.rpcId });
                return () => {
                    backend.rpc.invoke(neuroglancer_perspective_view_base__WEBPACK_IMPORTED_MODULE_3__["PERSPECTIVE_VIEW_REMOVE_LAYER_RPC_ID"], { layer: backend.rpcId, view: this.sharedObject.rpcId });
                };
            }
            return undefined;
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__["registerActionListener"])(element, 'rotate-via-mouse-drag', (e) => {
            Object(neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_10__["startRelativeMouseDrag"])(e.detail, (_event, deltaX, deltaY) => {
                this.navigationState.pose.rotateRelative(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["kAxes"][1], deltaX / 4.0 * Math.PI / 180.0);
                this.navigationState.pose.rotateRelative(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["kAxes"][0], -deltaY / 4.0 * Math.PI / 180.0);
            });
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__["registerActionListener"])(element, 'rotate-in-plane-via-touchrotate', (e) => {
            const { detail } = e;
            this.navigationState.pose.rotateRelative(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["kAxes"][2], detail.angle - detail.prevAngle);
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__["registerActionListener"])(element, 'rotate-out-of-plane-via-touchtranslate', (e) => {
            const { detail } = e;
            this.navigationState.pose.rotateRelative(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["kAxes"][1], detail.deltaX / 4.0 * Math.PI / 180.0);
            this.navigationState.pose.rotateRelative(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["kAxes"][0], -detail.deltaY / 4.0 * Math.PI / 180.0);
        });
        if (viewer.showSliceViewsCheckbox) {
            let showSliceViewsCheckbox = this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_7__["TrackableBooleanCheckbox"](viewer.showSliceViews));
            showSliceViewsCheckbox.element.className =
                'perspective-panel-show-slice-views neuroglancer-noselect';
            let showSliceViewsLabel = document.createElement('label');
            showSliceViewsLabel.className = 'perspective-panel-show-slice-views neuroglancer-noselect';
            showSliceViewsLabel.appendChild(document.createTextNode('Slices'));
            showSliceViewsLabel.appendChild(showSliceViewsCheckbox.element);
            this.element.appendChild(showSliceViewsLabel);
        }
        this.registerDisposer(viewer.orthographicProjection.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.showScaleBar.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.scaleBarOptions.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.showSliceViews.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.showAxisLines.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(viewer.perspectiveViewBackgroundColor.changed.add(() => this.scheduleRedraw()));
    }
    translateByViewportPixels(deltaX, deltaY) {
        const temp = tempVec3;
        const { viewProjectionMat } = this;
        const { width, height } = this;
        const { position } = this.viewer.navigationState;
        const pos = position.spatialCoordinates;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].transformMat4(temp, pos, viewProjectionMat);
        temp[0] = -2 * deltaX / width;
        temp[1] = 2 * deltaY / height;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].transformMat4(pos, temp, this.viewProjectionMatInverse);
        position.changed.dispatch();
    }
    get navigationState() {
        return this.viewer.navigationState;
    }
    isReady() {
        if (!this.visible) {
            return true;
        }
        for (const [sliceView, unconditional] of this.sliceViews) {
            if (unconditional || this.viewer.showSliceViews.value) {
                if (!sliceView.isReady()) {
                    return false;
                }
            }
        }
        this.checkForResize();
        const { width, height } = this;
        if (width === 0 || height === 0) {
            return true;
        }
        const { viewProjectionMat } = this;
        this.updateProjectionMatrix();
        const renderContext = {
            viewportWidth: width,
            viewportHeight: height,
            dataToDevice: viewProjectionMat,
        };
        let visibleLayers = this.visibleLayerTracker.getVisibleLayers();
        for (let renderLayer of visibleLayers) {
            if (!renderLayer.isReady(renderContext)) {
                return false;
            }
        }
        return true;
    }
    updateProjectionMatrix() {
        const { projectionMat, viewProjectionMat } = this;
        const zOffsetAmount = 100;
        const widthOverHeight = this.width / this.height;
        const fovy = Math.PI / 4.0;
        const nearBound = 10, farBound = 5000;
        if (this.viewer.orthographicProjection.value) {
            // Pick orthographic projection to match perspective projection at plane parallel to image
            // plane containing the center position.
            const f = 1.0 / Math.tan(fovy / 2);
            // We need -2 / (left - right) == f / widthOverHeight.
            // left - right = - 2 * widthOverHeight * orthoScalar
            // -2 / (left - right) = 1 / (widthOverHeight * orthoScalar).
            // 1 / orthoScalar == f.
            // orthoScalar = 1 / f
            const orthoScalar = zOffsetAmount / f;
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].ortho(projectionMat, -widthOverHeight * orthoScalar, widthOverHeight * orthoScalar, -orthoScalar, orthoScalar, nearBound, farBound);
            this.nanometersPerPixel = 1 / (2 * projectionMat[0]) * this.navigationState.zoomFactor.value;
            this.nanometersPerPixel =
                2 * widthOverHeight * orthoScalar / this.width * this.navigationState.zoomFactor.value;
        }
        else {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].perspective(projectionMat, fovy, widthOverHeight, nearBound, farBound);
        }
        const { viewMatInverse, viewMat } = this;
        this.navigationState.toMat4(viewMatInverse);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].set(tempVec3, 1, -1, -1);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].scale(viewMatInverse, viewMatInverse, tempVec3);
        let viewOffset = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].set(tempVec3, 0, 0, zOffsetAmount);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].translate(viewMatInverse, viewMatInverse, viewOffset);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].invert(viewMat, viewMatInverse);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].multiply(viewProjectionMat, projectionMat, viewMat);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].invert(this.viewProjectionMatInverse, viewProjectionMat);
    }
    panelSizeChanged() {
        this.throttledSendViewportUpdate();
    }
    disposed() {
        for (let sliceView of this.sliceViews.keys()) {
            sliceView.dispose();
        }
        this.sliceViews.clear();
        super.disposed();
    }
    issuePickRequest(glWindowX, glWindowY) {
        const { offscreenFramebuffer } = this;
        offscreenFramebuffer.readPixelFloat32IntoBuffer(OffscreenTextures.Z, glWindowX - neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickRadius"], glWindowY - neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickRadius"], 0, neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"], neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"]);
        offscreenFramebuffer.readPixelFloat32IntoBuffer(OffscreenTextures.PICK, glWindowX - neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickRadius"], glWindowY - neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickRadius"], 4 * 4 * neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"] * neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"], neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"], neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"]);
    }
    completePickRequest(glWindowX, glWindowY, data, pickingData) {
        const { mouseState } = this.viewer;
        mouseState.pickedRenderLayer = null;
        Object(neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["clearOutOfBoundsPickData"])(data, 0, 4, glWindowX, glWindowY, pickingData.viewportWidth, pickingData.viewportHeight);
        const numOffsets = neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickOffsetSequence"].length;
        for (let i = 0; i < numOffsets; ++i) {
            const offset = neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickOffsetSequence"][i];
            let zValue = data[4 * offset];
            if (zValue === 0)
                continue;
            const relativeX = offset % neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"];
            const relativeY = (offset - relativeX) / neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"];
            let glWindowZ = 1.0 - zValue;
            const out = mouseState.position;
            out[0] = 2.0 * (glWindowX + relativeX - neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickRadius"]) / pickingData.viewportWidth - 1.0;
            out[1] = 2.0 * (glWindowY + relativeY - neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickRadius"]) / pickingData.viewportHeight - 1.0;
            out[2] = 2.0 * glWindowZ - 1.0;
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].transformMat4(out, out, pickingData.invTransform);
            const pickValue = data[4 * neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"] * neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_5__["pickDiameter"] + 4 * offset];
            pickingData.pickIDs.setMouseState(mouseState, pickValue);
            mouseState.setActive(true);
            return;
        }
        mouseState.setActive(false);
    }
    translateDataPointByViewportPixels(out, orig, deltaX, deltaY) {
        const temp = tempVec3;
        const { viewProjectionMat } = this;
        const { width, height } = this;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].transformMat4(temp, orig, viewProjectionMat);
        temp[0] += 2 * deltaX / width;
        temp[1] += -2 * deltaY / height;
        return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].transformMat4(out, temp, this.viewProjectionMatInverse);
    }
    get transparentConfiguration() {
        let transparentConfiguration = this.transparentConfiguration_;
        if (transparentConfiguration === undefined) {
            transparentConfiguration = this.transparentConfiguration_ =
                this.registerDisposer(new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["FramebufferConfiguration"](this.gl, {
                    colorBuffers: Object(neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_13__["makeTextureBuffers"])(this.gl, 2, this.gl.RGBA32F, this.gl.RGBA, this.gl.FLOAT),
                    depthBuffer: this.offscreenFramebuffer.depthBuffer.addRef(),
                }));
        }
        return transparentConfiguration;
    }
    drawWithPicking(pickingData) {
        if (!this.navigationState.valid) {
            return false;
        }
        const { width, height } = this;
        const showSliceViews = this.viewer.showSliceViews.value;
        for (const [sliceView, unconditional] of this.sliceViews) {
            if (unconditional || showSliceViews) {
                sliceView.updateRendering();
            }
        }
        let gl = this.gl;
        this.offscreenFramebuffer.bind(width, height);
        gl.disable(gl.SCISSOR_TEST);
        const backgroundColor = this.viewer.perspectiveViewBackgroundColor.value;
        this.gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);
        let { viewProjectionMat } = this;
        this.updateProjectionMatrix();
        // FIXME; avoid temporaries
        let lightingDirection = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create();
        Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["transformVectorByMat4"])(lightingDirection, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["kAxes"][2], this.viewMatInverse);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].normalize(lightingDirection, lightingDirection);
        let ambient = 0.2;
        let directional = 1 - ambient;
        const renderContext = {
            dataToDevice: viewProjectionMat,
            lightDirection: lightingDirection,
            ambientLighting: ambient,
            directionalLighting: directional,
            pickIDs: pickingData.pickIDs,
            emitter: perspectivePanelEmit,
            emitColor: true,
            emitPickID: true,
            alreadyEmittedPickID: false,
            viewportWidth: width,
            viewportHeight: height,
        };
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].copy(pickingData.invTransform, this.viewProjectionMatInverse);
        let visibleLayers = this.visibleLayerTracker.getVisibleLayers();
        let hasTransparent = false;
        let hasAnnotation = false;
        // Draw fully-opaque layers first.
        for (let renderLayer of visibleLayers) {
            if (!renderLayer.isTransparent) {
                if (!renderLayer.isAnnotation) {
                    renderLayer.draw(renderContext);
                }
                else {
                    hasAnnotation = true;
                }
            }
            else {
                hasTransparent = true;
            }
        }
        this.drawSliceViews(renderContext);
        if (hasAnnotation) {
            gl.enable(WebGL2RenderingContext.BLEND);
            gl.depthFunc(WebGL2RenderingContext.LEQUAL);
            gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
            // Render only to the color buffer, but not the pick or z buffer.  With blending enabled, the
            // z and color values would be corrupted.
            gl.drawBuffers([
                gl.COLOR_ATTACHMENT0,
                gl.NONE,
                gl.NONE,
            ]);
            renderContext.emitPickID = false;
            for (let renderLayer of visibleLayers) {
                if (renderLayer.isAnnotation) {
                    renderLayer.draw(renderContext);
                }
            }
            gl.depthFunc(WebGL2RenderingContext.LESS);
            gl.disable(WebGL2RenderingContext.BLEND);
            gl.drawBuffers([
                gl.COLOR_ATTACHMENT0,
                gl.COLOR_ATTACHMENT1,
                gl.COLOR_ATTACHMENT2,
            ]);
            renderContext.emitPickID = true;
        }
        if (this.viewer.showAxisLines.value) {
            this.drawAxisLines();
        }
        if (hasTransparent) {
            // Draw transparent objects.
            gl.depthMask(false);
            gl.enable(WebGL2RenderingContext.BLEND);
            // Compute accumulate and revealage textures.
            const { transparentConfiguration } = this;
            transparentConfiguration.bind(width, height);
            this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
            renderContext.emitter = perspectivePanelEmitOIT;
            gl.blendFuncSeparate(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
            renderContext.emitPickID = false;
            for (let renderLayer of visibleLayers) {
                if (renderLayer.isTransparent) {
                    renderLayer.draw(renderContext);
                }
            }
            // Copy transparent rendering result back to primary buffer.
            gl.disable(WebGL2RenderingContext.DEPTH_TEST);
            this.offscreenFramebuffer.bindSingle(OffscreenTextures.COLOR);
            gl.blendFunc(WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA, WebGL2RenderingContext.SRC_ALPHA);
            this.transparencyCopyHelper.draw(transparentConfiguration.colorBuffers[0].texture, transparentConfiguration.colorBuffers[1].texture);
            gl.depthMask(true);
            gl.disable(WebGL2RenderingContext.BLEND);
            gl.enable(WebGL2RenderingContext.DEPTH_TEST);
            // Restore framebuffer attachments.
            this.offscreenFramebuffer.bind(width, height);
        }
        // Do picking only rendering pass.
        gl.drawBuffers([gl.NONE, gl.COLOR_ATTACHMENT1, gl.COLOR_ATTACHMENT2]);
        renderContext.emitter = perspectivePanelEmit;
        renderContext.emitPickID = true;
        renderContext.emitColor = false;
        // Offset z values forward so that we reliably write pick IDs and depth information even though
        // we've already done one drawing pass.
        gl.enable(WebGL2RenderingContext.POLYGON_OFFSET_FILL);
        gl.polygonOffset(-1, -1);
        for (let renderLayer of visibleLayers) {
            renderContext.alreadyEmittedPickID = !renderLayer.isTransparent && !renderLayer.isAnnotation;
            renderLayer.draw(renderContext);
        }
        gl.disable(WebGL2RenderingContext.POLYGON_OFFSET_FILL);
        if (this.viewer.showScaleBar.value && this.viewer.orthographicProjection.value) {
            // Only modify color buffer.
            gl.drawBuffers([
                gl.COLOR_ATTACHMENT0,
            ]);
            gl.disable(WebGL2RenderingContext.DEPTH_TEST);
            gl.enable(WebGL2RenderingContext.BLEND);
            gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
            const { scaleBarTexture } = this;
            const options = this.viewer.scaleBarOptions.value;
            const { dimensions } = scaleBarTexture;
            dimensions.targetLengthInPixels = Math.min(options.maxWidthFraction * width, options.maxWidthInPixels * options.scaleFactor);
            dimensions.nanometersPerPixel = this.nanometersPerPixel;
            scaleBarTexture.update(options);
            gl.viewport(options.leftPixelOffset * options.scaleFactor, options.bottomPixelOffset * options.scaleFactor, scaleBarTexture.width, scaleBarTexture.height);
            this.scaleBarCopyHelper.draw(scaleBarTexture.texture);
            gl.disable(WebGL2RenderingContext.BLEND);
        }
        this.offscreenFramebuffer.unbind();
        // Draw the texture over the whole viewport.
        this.setGLViewport();
        this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[OffscreenTextures.COLOR].texture);
        return true;
    }
    drawSliceViews(renderContext) {
        let { sliceViewRenderHelper } = this;
        let { lightDirection, ambientLighting, directionalLighting, dataToDevice } = renderContext;
        const showSliceViews = this.viewer.showSliceViews.value;
        for (const [sliceView, unconditional] of this.sliceViews) {
            if (!unconditional && !showSliceViews) {
                continue;
            }
            if (sliceView.width === 0 || sliceView.height === 0 || !sliceView.hasValidViewport) {
                continue;
            }
            let scalar = Math.abs(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].dot(lightDirection, sliceView.viewportAxes[2]));
            let factor = ambientLighting + scalar * directionalLighting;
            let mat = tempMat4;
            // Need a matrix that maps (+1, +1, 0) to projectionMat * (width, height, 0)
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].identity(mat);
            mat[0] = sliceView.width / 2.0;
            mat[5] = -sliceView.height / 2.0;
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].multiply(mat, sliceView.viewportToData, mat);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].multiply(mat, dataToDevice, mat);
            const backgroundColor = tempVec4;
            const crossSectionBackgroundColor = this.viewer.crossSectionBackgroundColor.value;
            backgroundColor[0] = crossSectionBackgroundColor[0];
            backgroundColor[1] = crossSectionBackgroundColor[1];
            backgroundColor[2] = crossSectionBackgroundColor[2];
            backgroundColor[3] = 1;
            sliceViewRenderHelper.draw(sliceView.offscreenFramebuffer.colorBuffers[0].texture, mat, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec4"].fromValues(factor, factor, factor, 1), tempVec4, 0, 0, 1, 1);
        }
    }
    drawAxisLines() {
        const temp = tempVec3;
        const temp2 = tempVec3b;
        const { viewProjectionMat } = this;
        const { position } = this.viewer.navigationState;
        const pos = position.spatialCoordinates;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].transformMat4(temp, pos, viewProjectionMat);
        temp[0] = 0.5;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].transformMat4(temp2, temp, this.viewProjectionMatInverse);
        const length0 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].distance(temp2, pos);
        temp[0] = 0;
        temp[1] = 0.5;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].transformMat4(temp2, temp, this.viewProjectionMatInverse);
        const length1 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].distance(temp2, pos);
        let { gl } = this;
        let mat = tempMat4;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].identity(mat);
        // Draw axes lines.
        let axisLength = Math.min(length0, length1);
        // Construct matrix that maps [-1, +1] x/y range to the full viewport data
        // coordinates.
        mat[0] = axisLength;
        mat[5] = axisLength;
        mat[10] = axisLength;
        let center = this.navigationState.position.spatialCoordinates;
        mat[12] = center[0];
        mat[13] = center[1];
        mat[14] = center[2];
        mat[15] = 1;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["mat4"].multiply(mat, this.viewProjectionMat, mat);
        gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
        this.axesLineHelper.draw(mat, false);
    }
    zoomByMouse(factor) {
        this.navigationState.zoomBy(factor);
    }
}


/***/ }),

/***/ "./src/neuroglancer/perspective_view/render_layer.ts":
/*!***********************************************************!*\
  !*** ./src/neuroglancer/perspective_view/render_layer.ts ***!
  \***********************************************************/
/*! exports provided: PerspectiveViewRenderLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveViewRenderLayer", function() { return PerspectiveViewRenderLayer; });
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class PerspectiveViewRenderLayer extends neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__["VisibilityTrackedRenderLayer"] {
    draw(_renderContext) {
        // Must be overridden by subclasses.
    }
    isReady(_renderContext) {
        return true;
    }
}


/***/ }),

/***/ "./src/neuroglancer/render_scale_statistics.ts":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/render_scale_statistics.ts ***!
  \*****************************************************/
/*! exports provided: numRenderScaleHistogramBins, renderScaleHistogramBinSize, renderScaleHistogramOrigin, getRenderScaleHistogramOffset, getRenderScaleFromHistogramOffset, trackableRenderScaleTarget, RenderScaleHistogram */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numRenderScaleHistogramBins", function() { return numRenderScaleHistogramBins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderScaleHistogramBinSize", function() { return renderScaleHistogramBinSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderScaleHistogramOrigin", function() { return renderScaleHistogramOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRenderScaleHistogramOffset", function() { return getRenderScaleHistogramOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRenderScaleFromHistogramOffset", function() { return getRenderScaleFromHistogramOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackableRenderScaleTarget", function() { return trackableRenderScaleTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderScaleHistogram", function() { return RenderScaleHistogram; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var _util_signal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const numRenderScaleHistogramBins = 40;
const renderScaleHistogramBinSize = 0.5;
const renderScaleHistogramOrigin = -4;
function getRenderScaleHistogramOffset(renderScale) {
    return (Math.log2(renderScale) - renderScaleHistogramOrigin) / renderScaleHistogramBinSize;
}
function getRenderScaleFromHistogramOffset(offset) {
    return 2 ** (offset * renderScaleHistogramBinSize + renderScaleHistogramOrigin);
}
function trackableRenderScaleTarget(initialValue) {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["TrackableValue"](initialValue, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verifyFinitePositiveFloat"]);
}
class RenderScaleHistogram {
    constructor() {
        this.visibility = new neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_2__["VisibilityPriorityAggregator"]();
        this.changed = new _util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
        /**
         * Frame number corresponding to the current histogram.
         */
        this.frameNumber = -1;
        /**
         * Maps from spatial scale (nanometers) to histogram row index in the range
         * `[0, spatialScales.size)`.
         */
        this.spatialScales = new Map();
        /**
         * Current number of rows allocated for the histogram.
         */
        this.numHistogramRows = 1;
        /**
         * Initially allocate one row.
         */
        this.value = new Uint32Array(numRenderScaleHistogramBins * this.numHistogramRows * 2);
    }
    begin(frameNumber) {
        if (frameNumber !== this.frameNumber) {
            this.value.fill(0);
            this.frameNumber = frameNumber;
            this.spatialScales.clear();
            this.changed.dispatch();
        }
    }
    /**
     * Adds a count to the histogram.
     *
     * @param spatialScale Spatial resolution of data in nanometers.
     * @param renderScale Rendered scale of data in screen pixels.
     * @param presentCount Number of present chunks.
     * @param notPresentCount Number of desired but not-present chunks.
     */
    add(spatialScale, renderScale, presentCount, notPresentCount) {
        let { spatialScales, numHistogramRows, value } = this;
        let spatialScaleIndex = spatialScales.get(spatialScale);
        if (spatialScaleIndex === undefined) {
            spatialScaleIndex = spatialScales.size;
            spatialScales.set(spatialScale, spatialScaleIndex);
        }
        if (spatialScaleIndex >= numHistogramRows) {
            this.numHistogramRows = numHistogramRows *= 2;
            const newValue = new Uint32Array(numHistogramRows * numRenderScaleHistogramBins * 2);
            newValue.set(value);
            this.value = value = newValue;
        }
        const index = spatialScaleIndex * numRenderScaleHistogramBins * 2 +
            Math.min(Math.max(0, Math.round(getRenderScaleHistogramOffset(renderScale))), numRenderScaleHistogramBins - 1);
        value[index] += presentCount;
        value[index + numRenderScaleHistogramBins] += notPresentCount;
    }
}


/***/ }),

/***/ "./src/neuroglancer/rendered_data_panel.css":
/*!**************************************************!*\
  !*** ./src/neuroglancer/rendered_data_panel.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/rendered_data_panel.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/rendered_data_panel.ts ***!
  \*************************************************/
/*! exports provided: FramePickingData, PickRequest, pickRadius, pickDiameter, pickOffsetSequence, clearOutOfBoundsPickData, RenderedDataPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FramePickingData", function() { return FramePickingData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PickRequest", function() { return PickRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pickRadius", function() { return pickRadius; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pickDiameter", function() { return pickDiameter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pickOffsetSequence", function() { return pickOffsetSequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearOutOfBoundsPickData", function() { return clearOutOfBoundsPickData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderedDataPanel", function() { return RenderedDataPanel; });
/* harmony import */ var neuroglancer_rendered_data_panel_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/rendered_data_panel.css */ "./src/neuroglancer/rendered_data_panel.css");
/* harmony import */ var neuroglancer_rendered_data_panel_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_rendered_data_panel_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/noselect.css */ "./src/neuroglancer/noselect.css");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var neuroglancer_annotation_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/annotation/selection */ "./src/neuroglancer/annotation/selection.ts");
/* harmony import */ var neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/annotation/type_handler */ "./src/neuroglancer/annotation/type_handler.ts");
/* harmony import */ var neuroglancer_display_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/display_context */ "./src/neuroglancer/display_context.ts");
/* harmony import */ var neuroglancer_object_picking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/object_picking */ "./src/neuroglancer/object_picking.ts");
/* harmony import */ var neuroglancer_util_automatic_focus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/automatic_focus */ "./src/neuroglancer/util/automatic_focus.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/keyboard_bindings */ "./src/neuroglancer/util/keyboard_bindings.ts");
/* harmony import */ var neuroglancer_util_mouse_bindings__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/mouse_bindings */ "./src/neuroglancer/util/mouse_bindings.ts");
/* harmony import */ var neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/mouse_drag */ "./src/neuroglancer/util/mouse_drag.ts");
/* harmony import */ var neuroglancer_util_touch_bindings__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/util/touch_bindings */ "./src/neuroglancer/util/touch_bindings.ts");
/* harmony import */ var neuroglancer_util_wheel_zoom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/util/wheel_zoom */ "./src/neuroglancer/util/wheel_zoom.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














const tempVec3 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
class FramePickingData {
    constructor() {
        this.pickIDs = new neuroglancer_object_picking__WEBPACK_IMPORTED_MODULE_5__["PickIDManager"]();
        this.viewportWidth = 0;
        this.viewportHeight = 0;
        this.invTransform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["mat4"].create();
        this.frameNumber = -1;
    }
}
class PickRequest {
    constructor() {
        this.buffer = null;
        this.glWindowX = 0;
        this.glWindowY = 0;
    }
}
const pickRequestInterval = 30;
const pickRadius = 12;
const pickDiameter = 1 + pickRadius * 2;
/**
 * Sequence of offsets into C order (pickDiamater, pickDiamater) array in order of increasing
 * distance from center.
 */
const pickOffsetSequence = (() => {
    const maxDist2 = pickRadius ** 2;
    const getDist2 = (x, y) => (x - pickRadius) ** 2 + (y - pickRadius) ** 2;
    let offsets = new Uint32Array(pickDiameter * pickDiameter);
    let count = 0;
    for (let x = 0; x < pickDiameter; ++x) {
        for (let y = 0; y < pickDiameter; ++y) {
            if (getDist2(x, y) > maxDist2)
                continue;
            offsets[count++] = y * pickDiameter + x;
        }
    }
    offsets = offsets.subarray(0, count);
    offsets.sort((a, b) => {
        const x1 = a % pickDiameter;
        const y1 = (a - x1) / pickDiameter;
        const x2 = b % pickDiameter;
        const y2 = (b - x2) / pickDiameter;
        return getDist2(x1, y1) - getDist2(x2, y2);
    });
    return offsets;
})();
/**
 * Sets array elements to 0 that would be outside the viewport.
 *
 * @param buffer Array view, which contains a C order (pickDiameter, pickDiameter) array.
 * @param baseOffset Offset into `buffer` corresponding to (0, 0).
 * @param stride Stride between consecutive elements of the array.
 * @param glWindowX Center x position, must be integer.
 * @param glWindowY Center y position, must be integer.
 * @param viewportWidth Width of viewport in pixels.
 * @param viewportHeight Width of viewport in pixels.
 */
function clearOutOfBoundsPickData(buffer, baseOffset, stride, glWindowX, glWindowY, viewportWidth, viewportHeight) {
    const startX = glWindowX - pickRadius;
    const startY = glWindowY - pickRadius;
    if (startX >= 0 && startY >= 0 && startX + pickDiameter <= viewportWidth &&
        startY + pickDiameter <= viewportHeight) {
        return;
    }
    for (let relativeY = 0; relativeY < pickDiameter; ++relativeY) {
        for (let relativeX = 0; relativeX < pickDiameter; ++relativeX) {
            const x = startX + relativeX;
            const y = startY + relativeY;
            if (x < 0 || y < 0 || x >= viewportWidth || y >= viewportHeight) {
                buffer[baseOffset + (y * pickDiameter + x) * stride] = 0;
            }
        }
    }
}
class RenderedDataPanel extends neuroglancer_display_context__WEBPACK_IMPORTED_MODULE_4__["RenderedPanel"] {
    constructor(context, element, viewer) {
        super(context, element, viewer.visibility);
        this.viewer = viewer;
        /**
         * Current mouse position within the viewport, or -1 if the mouse is not in the viewport.
         */
        this.mouseX = -1;
        this.mouseY = -1;
        /**
         * If `false`, either the mouse is not within the viewport, or a picking request was already
         * issued for the current mouseX and mouseY after the most recent frame was rendered; when the
         * current pick requests complete, no additional pick requests will be issued.
         *
         * If `true`, a picking request was not issued for the current mouseX and mouseY due to all pick
         * buffers being in use; when a pick buffer becomes available, an additional pick request will be
         * issued.
         */
        this.pickRequestPending = false;
        this.mouseStateForcer = () => this.blockOnPickRequest();
        this.pickingData = [new FramePickingData(), new FramePickingData()];
        this.pickRequests = [new PickRequest(), new PickRequest()];
        this.pickBufferContents = new Float32Array(2 * 4 * pickDiameter * pickDiameter);
        /**
         * Timer id for checking if outstanding pick requests have completed.
         */
        this.pickTimerId = -1;
        this.nextPickRequestTime = 0;
        this.pendingPickRequestTimerId = -1;
        this.pendingPickRequestTimerExpired = () => {
            this.pendingPickRequestTimerId = -1;
            if (!this.pickRequestPending)
                return;
            this.attemptToIssuePickRequest();
        };
        this.inputEventMap = viewer.inputEventMap;
        element.classList.add('neuroglancer-rendered-data-panel');
        element.classList.add('neuroglancer-panel');
        element.classList.add('neuroglancer-noselect');
        this.registerDisposer(new neuroglancer_util_automatic_focus__WEBPACK_IMPORTED_MODULE_6__["AutomaticallyFocusedElement"](element));
        this.registerDisposer(new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_9__["KeyboardEventBinder"](element, this.inputEventMap));
        this.registerDisposer(new neuroglancer_util_mouse_bindings__WEBPACK_IMPORTED_MODULE_10__["MouseEventBinder"](element, this.inputEventMap));
        this.registerDisposer(new neuroglancer_util_touch_bindings__WEBPACK_IMPORTED_MODULE_12__["TouchEventBinder"](element, this.inputEventMap));
        this.registerEventListener(element, 'mousemove', this.onMousemove.bind(this));
        this.registerEventListener(element, 'touchstart', this.onTouchstart.bind(this));
        this.registerEventListener(element, 'mouseleave', this.onMouseout.bind(this));
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'snap', () => {
            this.navigationState.pose.snap();
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'zoom-in', () => {
            this.navigationState.zoomBy(0.5);
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'zoom-out', () => {
            this.navigationState.zoomBy(2.0);
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'highlight', () => {
            this.viewer.layerManager.invokeAction('highlight');
        });
        for (let axis = 0; axis < 3; ++axis) {
            let axisName = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["AXES_NAMES"][axis];
            for (let sign of [-1, +1]) {
                let signStr = (sign < 0) ? '-' : '+';
                Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, `rotate-relative-${axisName}${signStr}`, () => {
                    this.navigationState.pose.rotateRelative(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["kAxes"][axis], sign * 0.1);
                });
                let tempOffset = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create();
                Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, `${axisName}${signStr}`, () => {
                    let { navigationState } = this;
                    let offset = tempOffset;
                    offset[0] = 0;
                    offset[1] = 0;
                    offset[2] = 0;
                    offset[axis] = sign;
                    navigationState.pose.translateVoxelsRelative(offset);
                });
            }
        }
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'zoom-via-wheel', (event) => {
            const e = event.detail;
            this.onMousemove(e);
            this.zoomByMouse(Object(neuroglancer_util_wheel_zoom__WEBPACK_IMPORTED_MODULE_13__["getWheelZoomAmount"])(e));
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'translate-via-mouse-drag', (e) => {
            Object(neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_11__["startRelativeMouseDrag"])(e.detail, (_event, deltaX, deltaY) => {
                this.translateByViewportPixels(deltaX, deltaY);
            });
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'translate-in-plane-via-touchtranslate', (e) => {
            const { detail } = e;
            this.translateByViewportPixels(detail.deltaX, detail.deltaY);
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'translate-z-via-touchtranslate', (e) => {
            const { detail } = e;
            let { navigationState } = this;
            let offset = tempVec3;
            offset[0] = 0;
            offset[1] = 0;
            offset[2] = detail.deltaY + detail.deltaX;
            navigationState.pose.translateVoxelsRelative(offset);
        });
        for (const amount of [1, 10]) {
            Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, `z+${amount}-via-wheel`, (event) => {
                const e = event.detail;
                let { navigationState } = this;
                let offset = tempVec3;
                let delta = e.deltaY !== 0 ? e.deltaY : e.deltaX;
                offset[0] = 0;
                offset[1] = 0;
                offset[2] = (delta > 0 ? -1 : 1) * amount;
                navigationState.pose.translateVoxelsRelative(offset);
            });
        }
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'move-to-mouse-position', () => {
            let { mouseState } = this.viewer;
            if (mouseState.updateUnconditionally()) {
                let position = this.navigationState.pose.position;
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].copy(position.spatialCoordinates, mouseState.position);
                position.changed.dispatch();
            }
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'snap', () => this.navigationState.pose.snap());
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'select-annotation', () => {
            const { mouseState, layerManager } = this.viewer;
            const state = Object(neuroglancer_annotation_selection__WEBPACK_IMPORTED_MODULE_2__["getSelectedAnnotation"])(mouseState, layerManager);
            if (state === undefined) {
                return;
            }
            const userLayer = state.layer.layer;
            if (userLayer !== null) {
                this.viewer.selectedLayer.layer = state.layer;
                this.viewer.selectedLayer.visible = true;
                userLayer.tabs.value = 'annotations';
                userLayer.selectedAnnotation.value = {
                    id: state.id,
                    partIndex: state.partIndex
                };
            }
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'move-annotation', (e) => {
            const { mouseState } = this.viewer;
            const selectedAnnotationId = mouseState.pickedAnnotationId;
            const annotationLayer = mouseState.pickedAnnotationLayer;
            if (annotationLayer !== undefined) {
                if (selectedAnnotationId !== undefined) {
                    e.stopPropagation();
                    let annotationRef = annotationLayer.source.getReference(selectedAnnotationId);
                    let ann = annotationRef.value;
                    const handler = Object(neuroglancer_annotation_type_handler__WEBPACK_IMPORTED_MODULE_3__["getAnnotationTypeRenderHandler"])(ann.type);
                    const pickedOffset = mouseState.pickedOffset;
                    let repPoint = handler.getRepresentativePoint(annotationLayer.objectToGlobal, ann, mouseState.pickedOffset);
                    let totDeltaVec = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec2"].set(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec2"].create(), 0, 0);
                    if (mouseState.updateUnconditionally()) {
                        Object(neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_11__["startRelativeMouseDrag"])(e.detail, (_event, deltaX, deltaY) => {
                            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec2"].add(totDeltaVec, totDeltaVec, [deltaX, deltaY]);
                            let newRepPt = this.translateDataPointByViewportPixels(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].create(), repPoint, totDeltaVec[0], totDeltaVec[1]);
                            let newAnnotation = handler.updateViaRepresentativePoint(ann, newRepPt, annotationLayer.globalToObject, pickedOffset);
                            annotationLayer.source.update(annotationRef, newAnnotation);
                        }, (_event) => {
                            annotationRef.dispose();
                        });
                    }
                }
            }
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'delete-annotation', () => {
            const { mouseState } = this.viewer;
            const selectedAnnotationId = mouseState.pickedAnnotationId;
            const annotationLayer = mouseState.pickedAnnotationLayer;
            if (annotationLayer !== undefined && !annotationLayer.source.readonly &&
                selectedAnnotationId !== undefined) {
                const ref = annotationLayer.source.getReference(selectedAnnotationId);
                try {
                    annotationLayer.source.delete(ref);
                }
                finally {
                    ref.dispose();
                }
            }
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_7__["registerActionListener"])(element, 'zoom-via-touchpinch', (e) => {
            const { detail } = e;
            this.handleMouseMove(detail.centerX, detail.centerY);
            const ratio = detail.prevDistance / detail.distance;
            if (ratio > 0.1 && ratio < 10) {
                this.zoomByMouse(ratio);
            }
        });
    }
    cancelPickRequests() {
        const { gl } = this;
        for (const request of this.pickRequests) {
            const { sync } = request;
            if (sync !== null) {
                gl.deleteSync(sync);
            }
            request.sync = null;
        }
        clearTimeout(this.pickTimerId);
        this.pickTimerId = -1;
    }
    checkForResize() {
        const { clientWidth, clientHeight } = this.element;
        if (clientWidth !== this.width || clientHeight !== this.height) {
            this.width = clientWidth;
            this.height = clientHeight;
            this.panelSizeChanged();
        }
    }
    issuePickRequestInternal(pickRequest) {
        const { gl } = this;
        let { buffer } = pickRequest;
        if (buffer === null) {
            buffer = pickRequest.buffer = gl.createBuffer();
            gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, buffer);
            gl.bufferData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 2 * 4 * 4 * pickDiameter * pickDiameter, WebGL2RenderingContext.STREAM_READ);
        }
        else {
            gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, buffer);
        }
        let glWindowX = this.mouseX;
        let glWindowY = this.height - this.mouseY;
        this.issuePickRequest(glWindowX, glWindowY);
        pickRequest.sync = gl.fenceSync(WebGL2RenderingContext.SYNC_GPU_COMMANDS_COMPLETE, 0);
        pickRequest.frameNumber = this.context.frameNumber;
        pickRequest.glWindowX = glWindowX;
        pickRequest.glWindowY = glWindowY;
        gl.flush();
        // TODO(jbms): maybe call gl.flush to ensure fence is submitted
        gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null);
        if (this.pickTimerId === -1) {
            this.scheduleCheckForPickRequestCompletion();
        }
        this.pickRequestPending = false;
        const { pickRequests } = this;
        if (pickRequest !== pickRequests[0]) {
            pickRequests[1] = pickRequests[0];
            pickRequests[0] = pickRequest;
        }
        this.nextPickRequestTime = Date.now() + pickRequestInterval;
    }
    completePickInternal(pickRequest) {
        const { gl } = this;
        const { pickBufferContents } = this;
        gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, pickRequest.buffer);
        gl.getBufferSubData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 0, pickBufferContents);
        gl.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null);
        const { pickingData } = this;
        const { frameNumber } = pickRequest;
        this.completePickRequest(pickRequest.glWindowX, pickRequest.glWindowY, pickBufferContents, pickingData[0].frameNumber === frameNumber ? pickingData[0] : pickingData[1]);
    }
    scheduleCheckForPickRequestCompletion() {
        this.pickTimerId = setTimeout(() => {
            this.pickTimerId = -1;
            this.checkForPickRequestCompletion();
        }, 0);
    }
    checkForPickRequestCompletion(checkingBeforeDraw = false, block = false) {
        let currentFrameNumber = this.context.frameNumber;
        let cancelIfNotReadyFrameNumber = -1;
        if (checkingBeforeDraw) {
            --currentFrameNumber;
            cancelIfNotReadyFrameNumber = currentFrameNumber - 1;
        }
        const { pickRequests } = this;
        const { gl } = this;
        let remaining = false;
        let cancelRemaining = false;
        let available;
        for (const pickRequest of pickRequests) {
            const { sync } = pickRequest;
            if (sync === null)
                continue;
            const { frameNumber } = pickRequest;
            if (!cancelRemaining && frameNumber >= currentFrameNumber - 1) {
                if (block ||
                    gl.getSyncParameter(sync, WebGL2RenderingContext.SYNC_STATUS) ===
                        WebGL2RenderingContext.SIGNALED) {
                    this.completePickInternal(pickRequest);
                    cancelRemaining = true;
                }
                else if (frameNumber !== cancelIfNotReadyFrameNumber) {
                    remaining = true;
                    continue;
                }
            }
            gl.deleteSync(sync);
            pickRequest.sync = null;
            available = pickRequest;
        }
        const { pickTimerId } = this;
        if (remaining && pickTimerId === -1) {
            this.scheduleCheckForPickRequestCompletion();
        }
        else if (!remaining && pickTimerId !== -1) {
            clearTimeout(pickTimerId);
            this.pickTimerId = -1;
        }
        if (!checkingBeforeDraw && available !== undefined && this.pickRequestPending &&
            this.canIssuePickRequest()) {
            this.issuePickRequestInternal(available);
        }
    }
    blockOnPickRequest() {
        if (this.pickRequestPending) {
            this.cancelPickRequests();
            this.nextPickRequestTime = 0;
            this.attemptToIssuePickRequest();
        }
        this.checkForPickRequestCompletion(/*checkingBeforeDraw=*/ false, /*block=*/ true);
    }
    draw() {
        this.checkForResize();
        const { width, height } = this;
        if (width === 0 || height === 0)
            return;
        this.checkForPickRequestCompletion(true);
        const { pickingData } = this;
        pickingData[0] = pickingData[1];
        const currentFrameNumber = this.context.frameNumber;
        const newPickingData = pickingData[1];
        newPickingData.frameNumber = currentFrameNumber;
        newPickingData.viewportWidth = width;
        newPickingData.viewportHeight = height;
        newPickingData.pickIDs.clear();
        if (!this.drawWithPicking(newPickingData)) {
            newPickingData.frameNumber = -1;
            return;
        }
        // For the new frame, allow new pick requests regardless of interval since last request.
        this.nextPickRequestTime = 0;
        if (this.mouseX > 0) {
            this.attemptToIssuePickRequest();
        }
    }
    canIssuePickRequest() {
        const time = Date.now();
        const { nextPickRequestTime, pendingPickRequestTimerId } = this;
        if (time < nextPickRequestTime) {
            if (pendingPickRequestTimerId == -1) {
                this.pendingPickRequestTimerId =
                    setTimeout(this.pendingPickRequestTimerExpired, nextPickRequestTime - time);
            }
            return false;
        }
        return true;
    }
    attemptToIssuePickRequest() {
        if (!this.canIssuePickRequest())
            return;
        const currentFrameNumber = this.context.frameNumber;
        const { gl } = this;
        const { pickRequests } = this;
        // Try to find an available PickRequest object.
        for (const pickRequest of pickRequests) {
            let { sync } = pickRequest;
            if (sync !== null) {
                if (pickRequest.frameNumber < currentFrameNumber - 1) {
                    gl.deleteSync(sync);
                }
                else {
                    continue;
                }
            }
            this.issuePickRequestInternal(pickRequest);
            return;
        }
    }
    /**
     * Called each time the mouse position relative to the top level of the rendered viewport changes.
     */
    updateMousePosition(mouseX, mouseY) {
        if (mouseX === this.mouseX && mouseY === this.mouseY) {
            return;
        }
        this.mouseX = mouseX;
        this.mouseY = mouseY;
        if (mouseX < 0) {
            // Mouse moved out of the viewport.
            this.pickRequestPending = false;
            this.cancelPickRequests();
            return;
        }
        const currentFrameNumber = this.context.frameNumber;
        const pickingData = this.pickingData[1];
        if (pickingData.frameNumber !== currentFrameNumber ||
            this.width !== pickingData.viewportWidth || this.height !== pickingData.viewportHeight) {
            // Viewport size has changed since the last frame, which means a redraw is pending.  Don't
            // issue pick request now.  Once will be issued automatically after the redraw.
            return;
        }
        this.pickRequestPending = true;
        this.attemptToIssuePickRequest();
    }
    onMouseout(_event) {
        this.updateMousePosition(-1, -1);
        this.viewer.mouseState.setForcer(undefined);
    }
    handleMouseMove(clientX, clientY) {
        let { element } = this;
        const bounds = element.getBoundingClientRect();
        const mouseX = clientX - bounds.left;
        const mouseY = clientY - bounds.top;
        const { mouseState } = this.viewer;
        mouseState.pageX = clientX + window.scrollX;
        mouseState.pageY = clientY + window.scrollY;
        mouseState.setForcer(this.mouseStateForcer);
        this.updateMousePosition(mouseX, mouseY);
    }
    onMousemove(event) {
        let { element } = this;
        if (event.target !== element) {
            return;
        }
        this.handleMouseMove(event.clientX, event.clientY);
    }
    onTouchstart(event) {
        let { element } = this;
        if (event.target !== element || event.targetTouches.length !== 1) {
            return;
        }
        const { clientX, clientY } = event.targetTouches[0];
        this.handleMouseMove(clientX, clientY);
    }
    disposed() {
        let { mouseState } = this.viewer;
        mouseState.removeForcer(this.mouseStateForcer);
        const { gl } = this;
        this.cancelPickRequests();
        const { pendingPickRequestTimerId } = this;
        if (pendingPickRequestTimerId !== -1) {
            clearTimeout(pendingPickRequestTimerId);
        }
        for (const request of this.pickRequests) {
            gl.deleteBuffer(request.buffer);
        }
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/segment_color.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/segment_color.ts ***!
  \*******************************************/
/*! exports provided: SegmentColorShaderManager, SegmentColorHash, SegmentStatedColorShaderManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentColorShaderManager", function() { return SegmentColorShaderManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentColorHash", function() { return SegmentColorHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentStatedColorShaderManager", function() { return SegmentStatedColorShaderManager; });
/* harmony import */ var neuroglancer_gpu_hash_hash_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/gpu_hash/hash_function */ "./src/neuroglancer/gpu_hash/hash_function.ts");
/* harmony import */ var neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/gpu_hash/shader */ "./src/neuroglancer/gpu_hash/shader.ts");
/* harmony import */ var neuroglancer_util_colorspace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/colorspace */ "./src/neuroglancer/util/colorspace.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/webgl/shader_lib */ "./src/neuroglancer/webgl/shader_lib.ts");
/* harmony import */ var _util_random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/random */ "./src/neuroglancer/util/random.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const NUM_COMPONENTS = 2;
class SegmentColorShaderManager {
    constructor(prefix) {
        this.prefix = prefix;
        this.seedName = this.prefix + '_seed';
    }
    defineShader(builder) {
        const { seedName } = this;
        builder.addUniform('highp uint', seedName);
        builder.addFragmentCode(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_4__["glsl_uint64"]);
        builder.addFragmentCode(neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["glsl_hashCombine"]);
        builder.addFragmentCode(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_4__["glsl_hsvToRgb"]);
        let s = `
vec3 ${this.prefix}(uint64_t x) {
  uint h = hashCombine(${seedName}, x);
  vec${NUM_COMPONENTS} v;
`;
        for (let i = 0; i < NUM_COMPONENTS; ++i) {
            s += `
  v[${i}] = float(h & 0xFFu) / 255.0;
  h >>= 8u;
`;
        }
        s += `
  vec3 hsv = vec3(v.x, 0.5 + v.y * 0.5, 1.0);
  return hsvToRgb(hsv);
}
`;
        builder.addFragmentCode(s);
    }
    enable(gl, shader, segmentColorHash) {
        gl.uniform1ui(shader.uniform(this.seedName), segmentColorHash.hashSeed);
    }
}
let tempColor = new Float32Array(3);
class SegmentColorHash {
    constructor(hashSeed = Object(_util_random__WEBPACK_IMPORTED_MODULE_5__["getRandomUint32"])()) {
        this.hashSeed = hashSeed;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
    }
    static getDefault() {
        return new SegmentColorHash(0);
    }
    compute(out, x) {
        let h = Object(neuroglancer_gpu_hash_hash_function__WEBPACK_IMPORTED_MODULE_0__["hashCombine"])(this.hashSeed, x.low);
        h = Object(neuroglancer_gpu_hash_hash_function__WEBPACK_IMPORTED_MODULE_0__["hashCombine"])(h, x.high);
        const c0 = (h & 0xFF) / 255;
        const c1 = ((h >> 8) & 0xFF) / 255;
        Object(neuroglancer_util_colorspace__WEBPACK_IMPORTED_MODULE_2__["hsvToRgb"])(out, c0, 0.5 + 0.5 * c1, 1.0);
        return out;
    }
    computeCssColor(x) {
        this.compute(tempColor, x);
        return `rgb(${tempColor[0] * 100}%,${tempColor[1] * 100}%,${tempColor[2] * 100}%)`;
    }
    randomize() {
        this.hashSeed = Object(_util_random__WEBPACK_IMPORTED_MODULE_5__["getRandomUint32"])();
        this.changed.dispatch();
    }
    toString() {
        return `new SegmentColorHash(${this.hashSeed})`;
    }
    toJSON() {
        return this.hashSeed === 0 ? undefined : this.hashSeed;
    }
    reset() {
        this.restoreState(0);
    }
    restoreState(x) {
        const newSeed = x >>> 0;
        if (newSeed !== this.hashSeed) {
            this.hashSeed = newSeed;
            this.changed.dispatch();
        }
    }
}
/**
 * Adds the shader code to get a segment's color if it is present in the map.
 */
class SegmentStatedColorShaderManager {
    constructor(prefix) {
        this.prefix = prefix;
        this.hashMapShaderManager = new neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["HashMapShaderManager"]('segmentStatedColorHash');
    }
    defineShader(builder) {
        this.hashMapShaderManager.defineShader(builder);
        let s = `
bool ${this.getFunctionName}(uint64_t x, out vec3 value) {
  uint64_t uint64Value;
  if (${this.hashMapShaderManager.getFunctionName}(x, uint64Value)) {
    uint uintValue = uint64Value.value[0];
    value.x = float((uintValue & 0xff0000u) >> 16) / 255.0;
    value.y = float((uintValue & 0x00ff00u) >>  8) / 255.0;
    value.z = float((uintValue & 0x0000ffu))       / 255.0;
    return true;
  }
  return false;
}
`;
        builder.addFragmentCode(s);
    }
    get getFunctionName() {
        return `${this.prefix}_get`;
    }
    enable(gl, shader, hashTable) {
        this.hashMapShaderManager.enable(gl, shader, hashTable);
    }
    disable(gl, shader) {
        this.hashMapShaderManager.disable(gl, shader);
    }
}


/***/ }),

/***/ "./src/neuroglancer/segmentation_display_state/base.ts":
/*!*************************************************************!*\
  !*** ./src/neuroglancer/segmentation_display_state/base.ts ***!
  \*************************************************************/
/*! exports provided: getObjectKey, forEachVisibleSegment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getObjectKey", function() { return getObjectKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachVisibleSegment", function() { return forEachVisibleSegment; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a string key for identifying a uint64 object id.  This is faster than
 * Uint64.prototype.toString().
 */
function getObjectKey(objectId) {
    return `${objectId.low},${objectId.high}`;
}
function forEachVisibleSegment(state, callback) {
    let { visibleSegments, segmentEquivalences } = state;
    for (let rootObjectId of visibleSegments) {
        // TODO(jbms): Remove this check if logic is added to ensure that it always holds.
        if (!segmentEquivalences.disjointSets.isMinElement(rootObjectId)) {
            continue;
        }
        for (let objectId of segmentEquivalences.setElements(rootObjectId)) {
            callback(objectId, rootObjectId);
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/segmentation_display_state/frontend.ts":
/*!*****************************************************************!*\
  !*** ./src/neuroglancer/segmentation_display_state/frontend.ts ***!
  \*****************************************************************/
/*! exports provided: Uint64MapEntry, SegmentSelectionState, registerRedrawWhenSegmentationDisplayStateChanged, registerRedrawWhenSegmentationDisplayStateWithAlphaChanged, registerRedrawWhenSegmentationDisplayState3DChanged, getObjectColor, SegmentationLayerSharedObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64MapEntry", function() { return Uint64MapEntry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentSelectionState", function() { return SegmentSelectionState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerRedrawWhenSegmentationDisplayStateChanged", function() { return registerRedrawWhenSegmentationDisplayStateChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerRedrawWhenSegmentationDisplayStateWithAlphaChanged", function() { return registerRedrawWhenSegmentationDisplayStateWithAlphaChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerRedrawWhenSegmentationDisplayState3DChanged", function() { return registerRedrawWhenSegmentationDisplayState3DChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getObjectColor", function() { return getObjectColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentationLayerSharedObject", function() { return SegmentationLayerSharedObject; });
/* harmony import */ var neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/shared_watchable_value */ "./src/neuroglancer/shared_watchable_value.ts");
/* harmony import */ var neuroglancer_util_colorspace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/colorspace */ "./src/neuroglancer/util/colorspace.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








class Uint64MapEntry {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
    toString() {
        return `${this.key}${this.value}`;
    }
}
class SegmentSelectionState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__["RefCounted"] {
    constructor() {
        super(...arguments);
        this.selectedSegment = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__["Uint64"]();
        this.hasSelectedSegment = false;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__["NullarySignal"]();
    }
    set(value) {
        if (value == null) {
            if (this.hasSelectedSegment) {
                this.hasSelectedSegment = false;
                this.changed.dispatch();
            }
        }
        else {
            let existingValue = this.selectedSegment;
            if (!this.hasSelectedSegment || value.low !== existingValue.low ||
                value.high !== existingValue.high) {
                existingValue.low = value.low;
                existingValue.high = value.high;
                this.hasSelectedSegment = true;
                this.changed.dispatch();
            }
        }
    }
    isSelected(value) {
        return this.hasSelectedSegment && neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__["Uint64"].equal(value, this.selectedSegment);
    }
    bindTo(layerSelectedValues, userLayer) {
        let temp = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__["Uint64"]();
        this.registerDisposer(layerSelectedValues.changed.add(() => {
            let value = layerSelectedValues.get(userLayer);
            if (typeof value === 'number') {
                temp.low = value;
                temp.high = 0;
                value = temp;
            }
            else if (value instanceof Uint64MapEntry) {
                value = value.value;
            }
            this.set(value);
        }));
    }
}
function registerRedrawWhenSegmentationDisplayStateChanged(displayState, renderLayer) {
    const dispatchRedrawNeeded = renderLayer.redrawNeeded.dispatch;
    renderLayer.registerDisposer(displayState.segmentColorHash.changed.add(dispatchRedrawNeeded));
    renderLayer.registerDisposer(displayState.visibleSegments.changed.add(dispatchRedrawNeeded));
    renderLayer.registerDisposer(displayState.saturation.changed.add(dispatchRedrawNeeded));
    renderLayer.registerDisposer(displayState.highlightedSegments.changed.add(dispatchRedrawNeeded));
    renderLayer.registerDisposer(displayState.segmentEquivalences.changed.add(dispatchRedrawNeeded));
    renderLayer.registerDisposer(displayState.segmentSelectionState.changed.add(dispatchRedrawNeeded));
}
function registerRedrawWhenSegmentationDisplayStateWithAlphaChanged(displayState, renderLayer) {
    registerRedrawWhenSegmentationDisplayStateChanged(displayState, renderLayer);
    renderLayer.registerDisposer(displayState.objectAlpha.changed.add(renderLayer.redrawNeeded.dispatch));
}
function registerRedrawWhenSegmentationDisplayState3DChanged(displayState, renderLayer) {
    registerRedrawWhenSegmentationDisplayStateWithAlphaChanged(displayState, renderLayer);
    renderLayer.registerDisposer(displayState.objectToDataTransform.changed.add(renderLayer.redrawNeeded.dispatch));
    renderLayer.registerDisposer(displayState.renderScaleTarget.changed.add(renderLayer.redrawNeeded.dispatch));
}
/**
 * Temporary values used by getObjectColor.
 */
const tempColor = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_3__["vec4"].create();
const tempStatedColor = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__["Uint64"]();
/**
 * Returns the alpha-premultiplied color to use.
 */
function getObjectColor(displayState, objectId, alpha = 1) {
    const color = tempColor;
    color[3] = alpha;
    if (displayState.segmentStatedColors.has(objectId)) {
        // If displayState maps the ID to a color, use it
        displayState.segmentStatedColors.get(objectId, tempStatedColor);
        color[0] = ((tempStatedColor.low & 0xff0000) >>> 16) / 255.0;
        color[1] = ((tempStatedColor.low & 0x00ff00) >>> 8) / 255.0;
        color[2] = ((tempStatedColor.low & 0x0000ff)) / 255.0;
    }
    else {
        displayState.segmentColorHash.compute(color, objectId);
    }
    if (displayState.segmentSelectionState.isSelected(objectId)) {
        for (let i = 0; i < 3; ++i) {
            color[i] = color[i] * 0.5 + 0.5;
        }
    }
    // Apply saturation
    let hsv = new Float32Array(3);
    Object(neuroglancer_util_colorspace__WEBPACK_IMPORTED_MODULE_1__["rgbToHsv"])(hsv, color[0], color[1], color[2]);
    hsv[1] *= displayState.saturation.value;
    let rgb = new Float32Array(3);
    Object(neuroglancer_util_colorspace__WEBPACK_IMPORTED_MODULE_1__["hsvToRgb"])(rgb, hsv[0], hsv[1], hsv[2]);
    color[0] = rgb[0];
    color[1] = rgb[1];
    color[2] = rgb[2];
    // Color highlighted segments
    if (displayState.highlightedSegments.has(objectId)) {
        // Make it vivid blue for selection
        color[0] = 0.2;
        color[1] = 0.2;
        color[2] = 2.0;
        color[3] = 1.0;
    }
    color[0] *= alpha;
    color[1] *= alpha;
    color[2] *= alpha;
    return color;
}
const Base = Object(neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_6__["withSharedVisibility"])(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_7__["SharedObject"]);
class SegmentationLayerSharedObject extends Base {
    constructor(chunkManager, displayState) {
        super();
        this.chunkManager = chunkManager;
        this.displayState = displayState;
    }
    initializeCounterpartWithChunkManager(options) {
        let { displayState } = this;
        options['chunkManager'] = this.chunkManager.rpcId;
        options['visibleSegments'] = displayState.visibleSegments.rpcId;
        options['segmentEquivalences'] = displayState.segmentEquivalences.rpcId;
        options['objectToDataTransform'] =
            this.registerDisposer(neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_0__["SharedWatchableValue"].makeFromExisting(this.chunkManager.rpc, this.displayState.objectToDataTransform))
                .rpcId;
        options['renderScaleTarget'] =
            this.registerDisposer(neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_0__["SharedWatchableValue"].makeFromExisting(this.chunkManager.rpc, this.displayState.renderScaleTarget))
                .rpcId;
        super.initializeCounterpart(this.chunkManager.rpc, options);
    }
}


/***/ }),

/***/ "./src/neuroglancer/segmentation_user_layer.css":
/*!******************************************************!*\
  !*** ./src/neuroglancer/segmentation_user_layer.css ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/segmentation_user_layer.ts":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/segmentation_user_layer.ts ***!
  \*****************************************************/
/*! exports provided: SegmentationUserLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentationUserLayer", function() { return SegmentationUserLayer; });
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/noselect.css */ "./src/neuroglancer/noselect.css");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_segmentation_user_layer_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/segmentation_user_layer.css */ "./src/neuroglancer/segmentation_user_layer.css");
/* harmony import */ var neuroglancer_segmentation_user_layer_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_segmentation_user_layer_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/mesh/frontend */ "./src/neuroglancer/mesh/frontend.ts");
/* harmony import */ var neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/overlay */ "./src/neuroglancer/overlay.ts");
/* harmony import */ var neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/render_scale_statistics */ "./src/neuroglancer/render_scale_statistics.ts");
/* harmony import */ var neuroglancer_segment_color__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/segment_color */ "./src/neuroglancer/segment_color.ts");
/* harmony import */ var neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/segmentation_display_state/frontend */ "./src/neuroglancer/segmentation_display_state/frontend.ts");
/* harmony import */ var neuroglancer_shared_disjoint_sets__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/shared_disjoint_sets */ "./src/neuroglancer/shared_disjoint_sets.ts");
/* harmony import */ var neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/skeleton/frontend */ "./src/neuroglancer/skeleton/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_segmentation_renderlayer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/sliceview/volume/segmentation_renderlayer */ "./src/neuroglancer/sliceview/volume/segmentation_renderlayer.ts");
/* harmony import */ var neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/trackable_alpha */ "./src/neuroglancer/trackable_alpha.ts");
/* harmony import */ var neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/trackable_boolean */ "./src/neuroglancer/trackable_boolean.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_uint64_set__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/uint64_set */ "./src/neuroglancer/uint64_set.ts");
/* harmony import */ var neuroglancer_uint64_map__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! neuroglancer/uint64_map */ "./src/neuroglancer/uint64_map.ts");
/* harmony import */ var neuroglancer_user_layer_with_volume_source__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! neuroglancer/user_layer_with_volume_source */ "./src/neuroglancer/user_layer_with_volume_source.ts");
/* harmony import */ var neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! neuroglancer/util/color */ "./src/neuroglancer/util/color.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! neuroglancer/webgl/dynamic_shader */ "./src/neuroglancer/webgl/dynamic_shader.ts");
/* harmony import */ var neuroglancer_widget_enum_widget__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! neuroglancer/widget/enum_widget */ "./src/neuroglancer/widget/enum_widget.ts");
/* harmony import */ var neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! neuroglancer/widget/range */ "./src/neuroglancer/widget/range.ts");
/* harmony import */ var neuroglancer_widget_render_scale_widget__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! neuroglancer/widget/render_scale_widget */ "./src/neuroglancer/widget/render_scale_widget.ts");
/* harmony import */ var neuroglancer_widget_segment_set_widget__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! neuroglancer/widget/segment_set_widget */ "./src/neuroglancer/widget/segment_set_widget.ts");
/* harmony import */ var neuroglancer_widget_shader_code_widget__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! neuroglancer/widget/shader_code_widget */ "./src/neuroglancer/widget/shader_code_widget.ts");
/* harmony import */ var neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! neuroglancer/widget/tab_view */ "./src/neuroglancer/widget/tab_view.ts");
/* harmony import */ var neuroglancer_widget_uint64_entry_widget__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! neuroglancer/widget/uint64_entry_widget */ "./src/neuroglancer/widget/uint64_entry_widget.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
































const SELECTED_ALPHA_JSON_KEY = 'selectedAlpha';
const NOT_SELECTED_ALPHA_JSON_KEY = 'notSelectedAlpha';
const OBJECT_ALPHA_JSON_KEY = 'objectAlpha';
const SATURATION_JSON_KEY = 'saturation';
const HIDE_SEGMENT_ZERO_JSON_KEY = 'hideSegmentZero';
const MESH_JSON_KEY = 'mesh';
const SKELETONS_JSON_KEY = 'skeletons';
const SEGMENTS_JSON_KEY = 'segments';
const HIGHLIGHTS_JSON_KEY = 'highlights';
const EQUIVALENCES_JSON_KEY = 'equivalences';
const COLOR_SEED_JSON_KEY = 'colorSeed';
const SEGMENT_STATED_COLORS_JSON_KEY = 'segmentColors';
const MESH_RENDER_SCALE_JSON_KEY = 'meshRenderScale';
const SKELETON_RENDERING_JSON_KEY = 'skeletonRendering';
const SKELETON_SHADER_JSON_KEY = 'skeletonShader';
const Base = Object(neuroglancer_user_layer_with_volume_source__WEBPACK_IMPORTED_MODULE_18__["UserLayerWithVolumeSourceMixin"])(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_2__["UserLayer"]);
class SegmentationUserLayer extends Base {
    constructor(manager, x) {
        super(manager, x);
        this.manager = manager;
        this.displayState = {
            segmentColorHash: neuroglancer_segment_color__WEBPACK_IMPORTED_MODULE_7__["SegmentColorHash"].getDefault(),
            segmentStatedColors: neuroglancer_uint64_map__WEBPACK_IMPORTED_MODULE_17__["Uint64Map"].makeWithCounterpart(this.manager.worker),
            segmentSelectionState: new neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_8__["SegmentSelectionState"](),
            selectedAlpha: Object(neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_13__["trackableAlphaValue"])(0.5),
            saturation: Object(neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_13__["trackableAlphaValue"])(1.0),
            notSelectedAlpha: Object(neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_13__["trackableAlphaValue"])(0),
            objectAlpha: Object(neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_13__["trackableAlphaValue"])(1.0),
            hideSegmentZero: new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_14__["TrackableBoolean"](true, true),
            visibleSegments: neuroglancer_uint64_set__WEBPACK_IMPORTED_MODULE_16__["Uint64Set"].makeWithCounterpart(this.manager.worker),
            highlightedSegments: neuroglancer_uint64_set__WEBPACK_IMPORTED_MODULE_16__["Uint64Set"].makeWithCounterpart(this.manager.worker),
            segmentEquivalences: neuroglancer_shared_disjoint_sets__WEBPACK_IMPORTED_MODULE_9__["SharedDisjointUint64Sets"].makeWithCounterpart(this.manager.worker),
            objectToDataTransform: this.transform,
            skeletonRenderingOptions: new neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__["SkeletonRenderingOptions"](),
            shaderError: Object(neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_23__["makeWatchableShaderError"])(),
            renderScaleHistogram: new neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_6__["RenderScaleHistogram"](),
            renderScaleTarget: Object(neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_6__["trackableRenderScaleTarget"])(1),
        };
        // Dispatched when either meshLayer or skeletonLayer changes.
        this.objectLayerStateChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_21__["NullarySignal"]();
        this.displayState.visibleSegments.changed.add(this.specificationChanged.dispatch);
        this.displayState.segmentEquivalences.changed.add(this.specificationChanged.dispatch);
        this.displayState.segmentSelectionState.bindTo(manager.layerSelectedValues, this);
        this.displayState.selectedAlpha.changed.add(this.specificationChanged.dispatch);
        this.displayState.saturation.changed.add(this.specificationChanged.dispatch);
        this.displayState.notSelectedAlpha.changed.add(this.specificationChanged.dispatch);
        this.displayState.objectAlpha.changed.add(this.specificationChanged.dispatch);
        this.displayState.hideSegmentZero.changed.add(this.specificationChanged.dispatch);
        this.displayState.skeletonRenderingOptions.changed.add(this.specificationChanged.dispatch);
        this.displayState.segmentColorHash.changed.add(this.specificationChanged.dispatch);
        this.displayState.segmentStatedColors.changed.add(this.specificationChanged.dispatch);
        this.displayState.renderScaleTarget.changed.add(this.specificationChanged.dispatch);
        this.tabs.add('rendering', { label: 'Rendering', order: -100, getter: () => new DisplayOptionsTab(this) });
        this.tabs.default = 'rendering';
    }
    get volumeOptions() {
        return { volumeType: neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_11__["VolumeType"].SEGMENTATION };
    }
    restoreState(specification) {
        super.restoreState(specification);
        this.displayState.selectedAlpha.restoreState(specification[SELECTED_ALPHA_JSON_KEY]);
        this.displayState.saturation.restoreState(specification[SATURATION_JSON_KEY]);
        this.displayState.notSelectedAlpha.restoreState(specification[NOT_SELECTED_ALPHA_JSON_KEY]);
        this.displayState.objectAlpha.restoreState(specification[OBJECT_ALPHA_JSON_KEY]);
        this.displayState.hideSegmentZero.restoreState(specification[HIDE_SEGMENT_ZERO_JSON_KEY]);
        const { skeletonRenderingOptions } = this.displayState;
        skeletonRenderingOptions.restoreState(specification[SKELETON_RENDERING_JSON_KEY]);
        const skeletonShader = specification[SKELETON_SHADER_JSON_KEY];
        if (skeletonShader !== undefined) {
            skeletonRenderingOptions.shader.restoreState(skeletonShader);
        }
        this.displayState.segmentColorHash.restoreState(specification[COLOR_SEED_JSON_KEY]);
        this.displayState.renderScaleTarget.restoreState(specification[MESH_RENDER_SCALE_JSON_KEY]);
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__["verifyObjectProperty"])(specification, EQUIVALENCES_JSON_KEY, y => {
            this.displayState.segmentEquivalences.restoreState(y);
        });
        const restoreSegmentsList = (key, segments) => {
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__["verifyObjectProperty"])(specification, key, y => {
                if (y !== undefined) {
                    let { segmentEquivalences } = this.displayState;
                    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__["parseArray"])(y, value => {
                        let id = neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_22__["Uint64"].parseString(String(value), 10);
                        segments.add(segmentEquivalences.get(id));
                    });
                }
            });
        };
        restoreSegmentsList(SEGMENTS_JSON_KEY, this.displayState.visibleSegments);
        restoreSegmentsList(HIGHLIGHTS_JSON_KEY, this.displayState.highlightedSegments);
        this.displayState.highlightedSegments.changed.add(() => {
            this.specificationChanged.dispatch();
        });
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__["verifyObjectProperty"])(specification, SEGMENT_STATED_COLORS_JSON_KEY, y => {
            if (y !== undefined) {
                let { segmentEquivalences } = this.displayState;
                let result = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__["verifyObjectAsMap"])(y, x => Object(neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_19__["parseRGBColorSpecification"])(String(x)));
                for (let [idStr, colorVec] of result) {
                    const id = neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_22__["Uint64"].parseString(String(idStr));
                    const color = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_22__["Uint64"](Object(neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_19__["packColor"])(colorVec));
                    this.displayState.segmentStatedColors.set(segmentEquivalences.get(id), color);
                }
            }
        });
        const { multiscaleSource } = this;
        let meshPath = this.meshPath = specification[MESH_JSON_KEY] === null ?
            null :
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__["verifyOptionalString"])(specification[MESH_JSON_KEY]);
        let skeletonsPath = this.skeletonsPath =
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__["verifyObjectProperty"])(specification, SKELETONS_JSON_KEY, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_20__["verifyOptionalString"]);
        let remaining = 0;
        if (meshPath != null) {
            ++remaining;
            this.manager.dataSourceProvider.getMeshSource(this.manager.chunkManager, meshPath)
                .then(meshSource => {
                if (!this.wasDisposed) {
                    this.addMesh(meshSource);
                    if (--remaining === 0) {
                        this.isReady = true;
                    }
                }
            });
        }
        if (skeletonsPath !== undefined) {
            ++remaining;
            this.manager.dataSourceProvider.getSkeletonSource(this.manager.chunkManager, skeletonsPath)
                .then(skeletonSource => {
                if (!this.wasDisposed) {
                    this.addSkeletonSource(skeletonSource);
                    if (--remaining === 0) {
                        this.isReady = true;
                    }
                }
            });
        }
        if (multiscaleSource !== undefined) {
            ++remaining;
            multiscaleSource.then(volume => {
                if (!this.wasDisposed) {
                    const { displayState } = this;
                    this.addRenderLayer(new neuroglancer_sliceview_volume_segmentation_renderlayer__WEBPACK_IMPORTED_MODULE_12__["SegmentationRenderLayer"](volume, Object.assign({}, displayState, { transform: displayState.objectToDataTransform, renderScaleHistogram: this.sliceViewRenderScaleHistogram, renderScaleTarget: this.sliceViewRenderScaleTarget })));
                    if (meshPath === undefined && skeletonsPath === undefined) {
                        ++remaining;
                        Promise.resolve(volume.getMeshSource()).then(objectSource => {
                            if (this.wasDisposed) {
                                if (objectSource !== null) {
                                    objectSource.dispose();
                                }
                                return;
                            }
                            if (--remaining === 0) {
                                this.isReady = true;
                            }
                            if ((objectSource instanceof neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["MeshSource"]) ||
                                (objectSource instanceof neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["MultiscaleMeshSource"])) {
                                this.addMesh(objectSource);
                            }
                            else if (objectSource instanceof neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__["SkeletonSource"]) {
                                this.addSkeletonSource(objectSource);
                            }
                        });
                    }
                    if (--remaining === 0) {
                        this.isReady = true;
                    }
                }
            });
        }
    }
    addMesh(meshSource) {
        if (meshSource instanceof neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["MeshSource"]) {
            this.meshLayer = new neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["MeshLayer"](this.manager.chunkManager, meshSource, this.displayState);
        }
        else {
            this.meshLayer =
                new neuroglancer_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["MultiscaleMeshLayer"](this.manager.chunkManager, meshSource, this.displayState);
        }
        this.addRenderLayer(this.meshLayer);
        this.objectLayerStateChanged.dispatch();
    }
    addSkeletonSource(skeletonSource) {
        let base = new neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__["SkeletonLayer"](this.manager.chunkManager, skeletonSource, this.manager.voxelSize, this.displayState);
        this.skeletonLayer = base;
        this.addRenderLayer(new neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__["PerspectiveViewSkeletonLayer"](base.addRef()));
        this.addRenderLayer(new neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__["SliceViewPanelSkeletonLayer"](/* transfer ownership */ base));
        this.objectLayerStateChanged.dispatch();
    }
    toJSON() {
        const x = super.toJSON();
        x['type'] = 'segmentation';
        x[MESH_JSON_KEY] = this.meshPath;
        x[SKELETONS_JSON_KEY] = this.skeletonsPath;
        x[SELECTED_ALPHA_JSON_KEY] = this.displayState.selectedAlpha.toJSON();
        x[NOT_SELECTED_ALPHA_JSON_KEY] = this.displayState.notSelectedAlpha.toJSON();
        x[SATURATION_JSON_KEY] = this.displayState.saturation.toJSON();
        x[OBJECT_ALPHA_JSON_KEY] = this.displayState.objectAlpha.toJSON();
        x[HIDE_SEGMENT_ZERO_JSON_KEY] = this.displayState.hideSegmentZero.toJSON();
        x[COLOR_SEED_JSON_KEY] = this.displayState.segmentColorHash.toJSON();
        let { segmentStatedColors } = this.displayState;
        if (segmentStatedColors.size > 0) {
            let json = segmentStatedColors.toJSON();
            // Convert colors from decimal integers to CSS "#RRGGBB" format.
            Object.keys(json).map(k => json[k] = '#' + parseInt(json[k], 10).toString(16).padStart(6, '0'));
            x[SEGMENT_STATED_COLORS_JSON_KEY] = json;
        }
        let { visibleSegments } = this.displayState;
        if (visibleSegments.size > 0) {
            x[SEGMENTS_JSON_KEY] = visibleSegments.toJSON();
        }
        let { highlightedSegments } = this.displayState;
        if (highlightedSegments.size > 0) {
            x[HIGHLIGHTS_JSON_KEY] = highlightedSegments.toJSON();
        }
        let { segmentEquivalences } = this.displayState;
        if (segmentEquivalences.size > 0) {
            x[EQUIVALENCES_JSON_KEY] = segmentEquivalences.toJSON();
        }
        x[SKELETON_RENDERING_JSON_KEY] = this.displayState.skeletonRenderingOptions.toJSON();
        x[MESH_RENDER_SCALE_JSON_KEY] = this.displayState.renderScaleTarget.toJSON();
        return x;
    }
    transformPickedValue(value) {
        if (value == null) {
            return value;
        }
        let { segmentEquivalences } = this.displayState;
        if (segmentEquivalences.size === 0) {
            return value;
        }
        if (typeof value === 'number') {
            value = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_22__["Uint64"](value, 0);
        }
        let mappedValue = segmentEquivalences.get(value);
        if (neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_22__["Uint64"].equal(mappedValue, value)) {
            return value;
        }
        return new neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_8__["Uint64MapEntry"](value, mappedValue);
    }
    handleAction(action) {
        switch (action) {
            case 'recolor': {
                this.displayState.segmentColorHash.randomize();
                break;
            }
            case 'clear-segments': {
                this.displayState.visibleSegments.clear();
                break;
            }
            case 'select': {
                let { segmentSelectionState } = this.displayState;
                if (segmentSelectionState.hasSelectedSegment) {
                    let segment = segmentSelectionState.selectedSegment;
                    let { visibleSegments } = this.displayState;
                    if (visibleSegments.has(segment)) {
                        visibleSegments.delete(segment);
                    }
                    else {
                        visibleSegments.add(segment);
                    }
                }
                break;
            }
            case 'highlight': {
                let { segmentSelectionState } = this.displayState;
                if (segmentSelectionState.hasSelectedSegment) {
                    let segment = segmentSelectionState.selectedSegment;
                    let { highlightedSegments } = this.displayState;
                    if (highlightedSegments.has(segment)) {
                        highlightedSegments.delete(segment);
                    }
                    else {
                        highlightedSegments.add(segment);
                    }
                }
                break;
            }
        }
    }
}
function makeSkeletonShaderCodeWidget(layer) {
    return new neuroglancer_widget_shader_code_widget__WEBPACK_IMPORTED_MODULE_28__["ShaderCodeWidget"]({
        fragmentMain: layer.displayState.skeletonRenderingOptions.shader,
        shaderError: layer.displayState.shaderError,
        fragmentMainStartLine: neuroglancer_skeleton_frontend__WEBPACK_IMPORTED_MODULE_10__["FRAGMENT_MAIN_START"],
    });
}
class DisplayOptionsTab extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_29__["Tab"] {
    constructor(layer) {
        super();
        this.layer = layer;
        this.visibleSegmentWidget = this.registerDisposer(new neuroglancer_widget_segment_set_widget__WEBPACK_IMPORTED_MODULE_27__["SegmentSetWidget"](this.layer.displayState));
        this.addSegmentWidget = this.registerDisposer(new neuroglancer_widget_uint64_entry_widget__WEBPACK_IMPORTED_MODULE_30__["Uint64EntryWidget"]());
        this.selectedAlphaWidget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_25__["RangeWidget"](this.layer.displayState.selectedAlpha));
        this.notSelectedAlphaWidget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_25__["RangeWidget"](this.layer.displayState.notSelectedAlpha));
        this.saturationWidget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_25__["RangeWidget"](this.layer.displayState.saturation));
        this.objectAlphaWidget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_25__["RangeWidget"](this.layer.displayState.objectAlpha));
        const { element } = this;
        element.classList.add('segmentation-dropdown');
        let { selectedAlphaWidget, notSelectedAlphaWidget, saturationWidget, objectAlphaWidget } = this;
        selectedAlphaWidget.promptElement.textContent = 'Opacity (on)';
        notSelectedAlphaWidget.promptElement.textContent = 'Opacity (off)';
        saturationWidget.promptElement.textContent = 'Saturation';
        objectAlphaWidget.promptElement.textContent = 'Opacity (3d)';
        if (this.layer.volumePath !== undefined) {
            element.appendChild(this.selectedAlphaWidget.element);
            element.appendChild(this.notSelectedAlphaWidget.element);
            element.appendChild(this.saturationWidget.element);
            {
                const renderScaleWidget = this.registerDisposer(new neuroglancer_widget_render_scale_widget__WEBPACK_IMPORTED_MODULE_26__["RenderScaleWidget"](this.layer.sliceViewRenderScaleHistogram, this.layer.sliceViewRenderScaleTarget));
                renderScaleWidget.label.textContent = 'Resolution (slice)';
                element.appendChild(renderScaleWidget.element);
            }
        }
        const has3dLayer = this.registerDisposer(new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_15__["ComputedWatchableValue"](() => this.layer.meshPath || this.layer.meshLayer || this.layer.skeletonsPath ||
            this.layer.skeletonLayer ?
            true :
            false, this.layer.objectLayerStateChanged));
        this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_14__["ElementVisibilityFromTrackableBoolean"](has3dLayer, this.objectAlphaWidget.element));
        {
            const renderScaleWidget = this.registerDisposer(new neuroglancer_widget_render_scale_widget__WEBPACK_IMPORTED_MODULE_26__["RenderScaleWidget"](this.layer.displayState.renderScaleHistogram, this.layer.displayState.renderScaleTarget));
            renderScaleWidget.label.textContent = 'Resolution (mesh)';
            element.appendChild(renderScaleWidget.element);
            this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_14__["ElementVisibilityFromTrackableBoolean"](has3dLayer, renderScaleWidget.element));
        }
        element.appendChild(this.objectAlphaWidget.element);
        {
            const checkbox = this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_14__["TrackableBooleanCheckbox"](layer.displayState.hideSegmentZero));
            checkbox.element.className =
                'neuroglancer-segmentation-dropdown-hide-segment-zero neuroglancer-noselect';
            const label = document.createElement('label');
            label.className =
                'neuroglancer-segmentation-dropdown-hide-segment-zero neuroglancer-noselect';
            label.appendChild(document.createTextNode('Hide segment ID 0'));
            label.appendChild(checkbox.element);
            element.appendChild(label);
        }
        this.addSegmentWidget.element.classList.add('add-segment');
        this.addSegmentWidget.element.title = 'Add one or more segment IDs';
        element.appendChild(this.registerDisposer(this.addSegmentWidget).element);
        this.registerDisposer(this.addSegmentWidget.valuesEntered.add((values) => {
            for (const value of values) {
                this.layer.displayState.visibleSegments.add(value);
            }
        }));
        element.appendChild(this.registerDisposer(this.visibleSegmentWidget).element);
        const maybeAddSkeletonShaderUI = () => {
            if (this.codeWidget !== undefined) {
                return;
            }
            if (this.layer.skeletonsPath === null || this.layer.skeletonLayer === undefined) {
                return;
            }
            const addViewSpecificSkeletonRenderingControls = (options, viewName) => {
                {
                    const widget = this.registerDisposer(new neuroglancer_widget_enum_widget__WEBPACK_IMPORTED_MODULE_24__["EnumSelectWidget"](options.mode));
                    const label = document.createElement('label');
                    label.className =
                        'neuroglancer-segmentation-dropdown-skeleton-render-mode neuroglancer-noselect';
                    label.appendChild(document.createTextNode(`Skeleton mode (${viewName})`));
                    label.appendChild(widget.element);
                    element.appendChild(label);
                }
                {
                    const widget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_25__["RangeWidget"](options.lineWidth, { min: 1, max: 40, step: 1 }));
                    widget.promptElement.textContent = `Skeleton line width (${viewName})`;
                    element.appendChild(widget.element);
                }
            };
            addViewSpecificSkeletonRenderingControls(layer.displayState.skeletonRenderingOptions.params2d, '2d');
            addViewSpecificSkeletonRenderingControls(layer.displayState.skeletonRenderingOptions.params3d, '3d');
            let topRow = document.createElement('div');
            topRow.className = 'neuroglancer-segmentation-dropdown-skeleton-shader-header';
            let label = document.createElement('div');
            label.style.flex = '1';
            label.textContent = 'Skeleton shader:';
            let helpLink = document.createElement('a');
            let helpButton = document.createElement('button');
            helpButton.type = 'button';
            helpButton.textContent = '?';
            helpButton.className = 'help-link';
            helpLink.appendChild(helpButton);
            helpLink.title = 'Documentation on skeleton rendering';
            helpLink.target = '_blank';
            helpLink.href =
                'https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md';
            let maximizeButton = document.createElement('button');
            maximizeButton.innerHTML = '&square;';
            maximizeButton.className = 'maximize-button';
            maximizeButton.title = 'Show larger editor view';
            this.registerEventListener(maximizeButton, 'click', () => {
                new ShaderCodeOverlay(this.layer);
            });
            topRow.appendChild(label);
            topRow.appendChild(maximizeButton);
            topRow.appendChild(helpLink);
            element.appendChild(topRow);
            const codeWidget = this.codeWidget =
                this.registerDisposer(makeSkeletonShaderCodeWidget(this.layer));
            element.appendChild(codeWidget.element);
            codeWidget.textEditor.refresh();
        };
        this.registerDisposer(this.layer.objectLayerStateChanged.add(maybeAddSkeletonShaderUI));
        maybeAddSkeletonShaderUI();
        this.visibility.changed.add(() => {
            if (this.visible) {
                if (this.codeWidget !== undefined) {
                    this.codeWidget.textEditor.refresh();
                }
            }
        });
    }
}
class ShaderCodeOverlay extends neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_5__["Overlay"] {
    constructor(layer) {
        super();
        this.layer = layer;
        this.codeWidget = this.registerDisposer(makeSkeletonShaderCodeWidget(this.layer));
        this.content.classList.add('neuroglancer-segmentation-layer-skeleton-shader-overlay');
        this.content.appendChild(this.codeWidget.element);
        this.codeWidget.textEditor.refresh();
    }
}
Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_3__["registerLayerType"])('segmentation', SegmentationUserLayer);
Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_3__["registerVolumeLayerType"])(neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_11__["VolumeType"].SEGMENTATION, SegmentationUserLayer);


/***/ }),

/***/ "./src/neuroglancer/shared_disjoint_sets.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/shared_disjoint_sets.ts ***!
  \**************************************************/
/*! exports provided: SharedDisjointUint64Sets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedDisjointUint64Sets", function() { return SharedDisjointUint64Sets; });
/* harmony import */ var neuroglancer_util_disjoint_sets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disjoint_sets */ "./src/neuroglancer/util/disjoint_sets.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





const RPC_TYPE_ID = 'DisjointUint64Sets';
const ADD_METHOD_ID = 'DisjointUint64Sets.add';
const CLEAR_METHOD_ID = 'DisjointUint64Sets.clear';
let SharedDisjointUint64Sets = class SharedDisjointUint64Sets extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_4__["SharedObjectCounterpart"] {
    constructor() {
        super(...arguments);
        this.disjointSets = new neuroglancer_util_disjoint_sets__WEBPACK_IMPORTED_MODULE_0__["DisjointUint64Sets"]();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
    }
    /**
     * For compatibility with `WatchableValueInterface`.
     */
    get value() {
        return this;
    }
    static makeWithCounterpart(rpc) {
        let obj = new this();
        obj.initializeCounterpart(rpc);
        return obj;
    }
    disposed() {
        this.disjointSets = undefined;
        this.changed = undefined;
        super.disposed();
    }
    link(a, b) {
        if (this.disjointSets.link(a, b)) {
            let { rpc } = this;
            if (rpc) {
                rpc.invoke(ADD_METHOD_ID, { 'id': this.rpcId, 'al': a.low, 'ah': a.high, 'bl': b.low, 'bh': b.high });
            }
            this.changed.dispatch();
        }
    }
    get(x) {
        return this.disjointSets.get(x);
    }
    clear() {
        if (this.disjointSets.clear()) {
            let { rpc } = this;
            if (rpc) {
                rpc.invoke(CLEAR_METHOD_ID, { 'id': this.rpcId });
            }
            this.changed.dispatch();
        }
    }
    setElements(a) {
        return this.disjointSets.setElements(a);
    }
    get size() {
        return this.disjointSets.size;
    }
    toJSON() {
        return this.disjointSets.toJSON();
    }
    /**
     * Restores the state from a JSON representation.
     */
    restoreState(obj) {
        this.clear();
        if (obj !== undefined) {
            let ids = [new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_3__["Uint64"](), new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_3__["Uint64"]()];
            Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["parseArray"])(obj, z => {
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["parseArray"])(z, (s, index) => {
                    ids[index % 2].parseString(String(s), 10);
                    if (index !== 0) {
                        this.link(ids[0], ids[1]);
                    }
                });
            });
        }
    }
};
SharedDisjointUint64Sets = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_4__["registerSharedObject"])(RPC_TYPE_ID)
], SharedDisjointUint64Sets);

const tempA = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_3__["Uint64"]();
const tempB = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_3__["Uint64"]();
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_4__["registerRPC"])(ADD_METHOD_ID, function (x) {
    let obj = this.get(x['id']);
    tempA.low = x['al'];
    tempA.high = x['ah'];
    tempB.low = x['bl'];
    tempB.high = x['bh'];
    if (obj.disjointSets.link(tempA, tempB)) {
        obj.changed.dispatch();
    }
});
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_4__["registerRPC"])(CLEAR_METHOD_ID, function (x) {
    let obj = this.get(x['id']);
    if (obj.disjointSets.clear()) {
        obj.changed.dispatch();
    }
});


/***/ }),

/***/ "./src/neuroglancer/shared_watchable_value.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/shared_watchable_value.ts ***!
  \****************************************************/
/*! exports provided: SharedWatchableValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedWatchableValue", function() { return SharedWatchableValue; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SharedWatchableValue_1;
/**
 * @file Facility for sharing arbitrary values that support structural cloning between threads.
 */


const CHANGED_RPC_METHOD_ID = 'SharedWatchableValue.changed';
let SharedWatchableValue = SharedWatchableValue_1 = class SharedWatchableValue extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_1__["SharedObjectCounterpart"] {
    constructor(rpc, options = {}) {
        super(rpc, options);
        /**
         * The value is being updated to reflect a remote change.
         * @internal
         */
        this.updatingValue_ = false;
        if (rpc !== undefined) {
            this.base = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["WatchableValue"](options['value']);
            this.setupChangedHandler();
        }
    }
    initializeCounterpart(rpc, options = {}) {
        options['value'] = this.value;
        super.initializeCounterpart(rpc, options);
    }
    setupChangedHandler() {
        this.registerDisposer(this.base.changed.add(() => {
            if (this.updatingValue_) {
                this.updatingValue_ = false;
            }
            else {
                const { rpc } = this;
                if (rpc !== null) {
                    rpc.invoke(CHANGED_RPC_METHOD_ID, { 'id': this.rpcId, 'value': this.value });
                }
            }
        }));
    }
    static makeFromExisting(rpc, base) {
        let obj = new SharedWatchableValue_1();
        obj.base = base;
        obj.setupChangedHandler();
        obj.initializeCounterpart(rpc);
        return obj;
    }
    static make(rpc, value) {
        return SharedWatchableValue_1.makeFromExisting(rpc, new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["WatchableValue"](value));
    }
    get value() {
        return this.base.value;
    }
    set value(value) {
        this.base.value = value;
    }
    get changed() {
        return this.base.changed;
    }
};
SharedWatchableValue = SharedWatchableValue_1 = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_1__["registerSharedObject"])('SharedWatchableValue')
], SharedWatchableValue);

Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_1__["registerRPC"])(CHANGED_RPC_METHOD_ID, function (x) {
    const obj = this.get(x['id']);
    obj.updatingValue_ = true;
    obj.base.value = x['value'];
    obj.updatingValue_ = false;
});


/***/ }),

/***/ "./src/neuroglancer/single_mesh/base.ts":
/*!**********************************************!*\
  !*** ./src/neuroglancer/single_mesh/base.ts ***!
  \**********************************************/
/*! exports provided: SINGLE_MESH_LAYER_RPC_ID, GET_SINGLE_MESH_INFO_RPC_ID, SINGLE_MESH_CHUNK_KEY, SingleMeshSourceParameters, SingleMeshSourceParametersWithInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SINGLE_MESH_LAYER_RPC_ID", function() { return SINGLE_MESH_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GET_SINGLE_MESH_INFO_RPC_ID", function() { return GET_SINGLE_MESH_INFO_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SINGLE_MESH_CHUNK_KEY", function() { return SINGLE_MESH_CHUNK_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleMeshSourceParameters", function() { return SingleMeshSourceParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleMeshSourceParametersWithInfo", function() { return SingleMeshSourceParametersWithInfo; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SINGLE_MESH_LAYER_RPC_ID = 'single_mesh/SingleMeshLayer';
const GET_SINGLE_MESH_INFO_RPC_ID = 'single_mesh/getSingleMeshInfo';
const SINGLE_MESH_CHUNK_KEY = '';
class SingleMeshSourceParameters {
}
class SingleMeshSourceParametersWithInfo extends SingleMeshSourceParameters {
}
SingleMeshSourceParametersWithInfo.RPC_ID = 'single_mesh/SingleMeshSource';


/***/ }),

/***/ "./src/neuroglancer/single_mesh/frontend.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/single_mesh/frontend.ts ***!
  \**************************************************/
/*! exports provided: FRAGMENT_MAIN_START, getTrackableFragmentMain, getTrackableAttributeNames, SingleMeshDisplayState, getShaderAttributeType, SingleMeshShaderManager, VertexChunkData, SingleMeshChunk, getAttributeTextureFormats, SingleMeshSource, SingleMeshLayer, getSingleMeshSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_MAIN_START", function() { return FRAGMENT_MAIN_START; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTrackableFragmentMain", function() { return getTrackableFragmentMain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTrackableAttributeNames", function() { return getTrackableAttributeNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleMeshDisplayState", function() { return SingleMeshDisplayState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getShaderAttributeType", function() { return getShaderAttributeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleMeshShaderManager", function() { return SingleMeshShaderManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexChunkData", function() { return VertexChunkData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleMeshChunk", function() { return SingleMeshChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAttributeTextureFormats", function() { return getAttributeTextureFormats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleMeshSource", function() { return SingleMeshSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleMeshLayer", function() { return SingleMeshLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSingleMeshSource", function() { return getSingleMeshSource; });
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/coordinate_transform */ "./src/neuroglancer/coordinate_transform.ts");
/* harmony import */ var neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/perspective_view/render_layer */ "./src/neuroglancer/perspective_view/render_layer.ts");
/* harmony import */ var neuroglancer_single_mesh_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/single_mesh/base */ "./src/neuroglancer/single_mesh/base.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/data_type */ "./src/neuroglancer/util/data_type.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_webgl_colormaps__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/webgl/colormaps */ "./src/neuroglancer/webgl/colormaps.ts");
/* harmony import */ var neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/webgl/dynamic_shader */ "./src/neuroglancer/webgl/dynamic_shader.ts");
/* harmony import */ var neuroglancer_webgl_index_emulation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/webgl/index_emulation */ "./src/neuroglancer/webgl/index_emulation.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/* harmony import */ var neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/webgl/shader_lib */ "./src/neuroglancer/webgl/shader_lib.ts");
/* harmony import */ var neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/webgl/texture_access */ "./src/neuroglancer/webgl/texture_access.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















const FRAGMENT_MAIN_START = '//NEUROGLANCER_SINGLE_MESH_LAYER_FRAGMENT_MAIN_START';
const DEFAULT_FRAGMENT_MAIN = `void main() {
  emitGray();
}
`;
function getTrackableFragmentMain(value = DEFAULT_FRAGMENT_MAIN) {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_5__["TrackableValue"](value, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyString"]);
}
function getTrackableAttributeNames() {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_5__["TrackableValue"]([], x => Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["parseArray"])(x, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyOptionalString"]));
}
class SingleMeshDisplayState {
    constructor() {
        this.shaderError = Object(neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_12__["makeWatchableShaderError"])();
        this.fragmentMain = getTrackableFragmentMain();
        this.attributeNames = getTrackableAttributeNames();
        this.objectToDataTransform = new neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_2__["CoordinateTransform"]();
    }
}
function getShaderAttributeType(info) {
    return Object(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_15__["getShaderType"])(info.dataType, info.numComponents);
}
const vertexAttributeSamplerSymbols = [];
const vertexPositionTextureFormat = Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__["computeTextureFormat"])(new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__["TextureFormat"](), neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_6__["DataType"].FLOAT32, 3);
const vertexNormalTextureFormat = vertexPositionTextureFormat;
class SingleMeshShaderManager {
    constructor(attributeNames, attributeInfo, fragmentMain) {
        this.attributeNames = attributeNames;
        this.attributeInfo = attributeInfo;
        this.fragmentMain = fragmentMain;
        this.tempLightVec = new Float32Array(4);
        this.textureAccessHelper = new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__["OneDimensionalTextureAccessHelper"]('vertexData');
        this.indexBufferHelper = new neuroglancer_webgl_index_emulation__WEBPACK_IMPORTED_MODULE_13__["IndexBufferAttributeHelper"]('vertexIndex');
    }
    defineAttributeAccess(builder, vertexIndexVariable) {
        let { textureAccessHelper } = this;
        textureAccessHelper.defineShader(builder);
        let numAttributes = 2;
        const { attributeNames } = this;
        for (const attributeName of attributeNames) {
            if (attributeName !== undefined) {
                ++numAttributes;
            }
        }
        for (let j = vertexAttributeSamplerSymbols.length; j < numAttributes; ++j) {
            vertexAttributeSamplerSymbols[j] =
                Symbol(`SingleMeshShaderManager.vertexAttributeTextureUnit${j}`);
        }
        numAttributes = 0;
        builder.addTextureSampler(`sampler2D`, 'uVertexAttributeSampler0', vertexAttributeSamplerSymbols[numAttributes++]);
        builder.addTextureSampler(`sampler2D`, 'uVertexAttributeSampler1', vertexAttributeSamplerSymbols[numAttributes++]);
        builder.addVertexCode(textureAccessHelper.getAccessor('readVertexPosition', 'uVertexAttributeSampler0', neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_6__["DataType"].FLOAT32, 3));
        builder.addVertexCode(textureAccessHelper.getAccessor('readVertexNormal', 'uVertexAttributeSampler1', neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_6__["DataType"].FLOAT32, 3));
        let vertexMain = `
vec3 vertexPosition = readVertexPosition(${vertexIndexVariable});
vec3 vertexNormal = readVertexNormal(${vertexIndexVariable});
`;
        this.attributeInfo.forEach((info, i) => {
            const attributeName = attributeNames[i];
            if (attributeName !== undefined) {
                builder.addTextureSampler(`${Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__["getSamplerPrefixForDataType"])(info.dataType)}sampler2D`, `uVertexAttributeSampler${numAttributes}`, vertexAttributeSamplerSymbols[numAttributes]);
                const attributeType = getShaderAttributeType(info);
                builder.addVarying(`highp ${attributeType}`, `vCustom${i}`);
                builder.addFragmentCode(`
#define ${attributeNames[i]} vCustom${i}
`);
                builder.addVertexCode(textureAccessHelper.getAccessor(`readAttribute${i}`, `uVertexAttributeSampler${numAttributes}`, info.dataType, info.numComponents));
                vertexMain += `vCustom${i} = readAttribute${i}(${vertexIndexVariable});\n`;
                ++numAttributes;
            }
        });
        builder.addVertexMain(vertexMain);
    }
    defineShader(builder) {
        builder.require(neuroglancer_webgl_index_emulation__WEBPACK_IMPORTED_MODULE_13__["countingBufferShaderModule"]);
        this.indexBufferHelper.defineShader(builder);
        builder.addVarying('highp float', 'vLightingFactor');
        builder.addUniform('highp vec4', 'uLightDirection');
        builder.addUniform('highp vec4', 'uColor');
        builder.addUniform('highp mat4', 'uModelMatrix');
        builder.addUniform('highp mat4', 'uProjection');
        builder.addUniform('highp uint', 'uPickID');
        builder.addVarying('highp uint', 'vPickID', 'flat');
        builder.addVertexMain(`
uint triangleIndex = getPrimitiveIndex() / 3u;
vPickID = uPickID + triangleIndex;
`);
        builder.addFragmentCode(`
void emitPremultipliedRGBA(vec4 color) {
  emit(vec4(color.rgb * vLightingFactor, color.a), vPickID);
}
void emitRGBA(vec4 color) {
  color = clamp(color, 0.0, 1.0);
  color.xyz *= color.a;
  emitPremultipliedRGBA(color);
}
void emitRGB(vec3 color) {
  emitRGBA(vec4(color, 1.0));
}
void emitGray() {
  emitRGB(vec3(1.0, 1.0, 1.0));
}
`);
        builder.addFragmentCode(neuroglancer_webgl_colormaps__WEBPACK_IMPORTED_MODULE_11__["glsl_COLORMAPS"]);
        // Make sure defineAttributeAccess is the last thing that adds fragment code prior to
        // this.fragmentMain, so that the #define attributes don't mess anything up.
        this.defineAttributeAccess(builder, 'vertexIndex');
        builder.addVertexMain(`
gl_Position = uProjection * (uModelMatrix * vec4(vertexPosition, 1.0));
vec3 normal = normalize((uModelMatrix * vec4(vertexNormal, 0.0)).xyz);
vLightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;
`);
        builder.setFragmentMainFunction(FRAGMENT_MAIN_START + '\n' + this.fragmentMain);
    }
    beginLayer(gl, shader, renderContext) {
        let { dataToDevice, lightDirection, ambientLighting, directionalLighting } = renderContext;
        gl.uniformMatrix4fv(shader.uniform('uProjection'), false, dataToDevice);
        let lightVec = this.tempLightVec;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_7__["vec3"].scale(lightVec, lightDirection, directionalLighting);
        lightVec[3] = ambientLighting;
        gl.uniform4fv(shader.uniform('uLightDirection'), lightVec);
    }
    setPickID(gl, shader, pickID) {
        gl.uniform1ui(shader.uniform('uPickID'), pickID);
    }
    beginObject(gl, shader, objectToDataMatrix) {
        gl.uniformMatrix4fv(shader.uniform('uModelMatrix'), false, objectToDataMatrix);
    }
    getShader(gl, emitter) {
        const key = {
            attributeNames: this.attributeNames,
            attributeInfo: this.attributeInfo,
            fragmentMain: this.fragmentMain
        };
        return gl.memoize.get(`single_mesh/SingleMeshShaderManager:${Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_9__["getObjectId"])(emitter)}:${Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["stableStringify"])(key)}`, () => {
            let builder = new neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_14__["ShaderBuilder"](gl);
            builder.require(emitter);
            this.defineShader(builder);
            return builder.build();
        });
    }
    bindVertexData(gl, shader, data) {
        this.textureAccessHelper.setupTextureLayout(gl, shader, data);
        let index = 0;
        const bindTexture = (texture) => {
            const textureUnit = WebGL2RenderingContext.TEXTURE0 +
                shader.textureUnit(vertexAttributeSamplerSymbols[index]);
            gl.activeTexture(textureUnit);
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            ++index;
        };
        bindTexture(data.vertexTexture);
        bindTexture(data.normalTexture);
        const { attributeNames } = this;
        data.vertexAttributeTextures.forEach((texture, i) => {
            if (attributeNames[i] !== undefined) {
                bindTexture(texture);
            }
        });
    }
    disableVertexData(gl, shader) {
        let numTextures = 2;
        let numVertexAttributes = this.attributeInfo.length;
        let { attributeNames } = this;
        for (let i = 0; i < numVertexAttributes; ++i) {
            if (attributeNames[i] !== undefined) {
                ++numTextures;
            }
        }
        for (let i = 0; i < numTextures; ++i) {
            let curTextureUnit = shader.textureUnit(vertexAttributeSamplerSymbols[i]) + WebGL2RenderingContext.TEXTURE0;
            gl.activeTexture(curTextureUnit);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }
    drawFragment(gl, shader, chunk, countingBuffer) {
        countingBuffer.ensure(chunk.numIndices).bind(shader);
        this.bindVertexData(gl, shader, chunk.vertexData);
        this.indexBufferHelper.bind(chunk.indexBuffer, shader);
        gl.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, chunk.numIndices);
    }
    endLayer(gl, shader) {
        Object(neuroglancer_webgl_index_emulation__WEBPACK_IMPORTED_MODULE_13__["disableCountingBuffer"])(gl, shader);
        this.indexBufferHelper.disable(shader);
        this.disableVertexData(gl, shader);
    }
}
class VertexChunkData {
    copyToGPU(gl, attributeFormats) {
        let numVertices = this.vertexPositions.length / 3;
        Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__["compute1dTextureLayout"])(this, gl, /*texelsPerElement=*/ 1, numVertices);
        const getBufferTexture = (data, format) => {
            let texture = gl.createTexture();
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__["setOneDimensionalTextureData"])(gl, this, format, data);
            return texture;
        };
        this.vertexTexture = getBufferTexture(this.vertexPositions, vertexPositionTextureFormat);
        this.normalTexture = getBufferTexture(this.vertexNormals, vertexNormalTextureFormat);
        this.vertexAttributeTextures =
            this.vertexAttributes.map((data, i) => getBufferTexture(data, attributeFormats[i]));
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
    freeGPUMemory(gl) {
        gl.deleteTexture(this.vertexTexture);
        gl.deleteTexture(this.normalTexture);
        let { vertexAttributeTextures } = this;
        for (const buffer of vertexAttributeTextures) {
            gl.deleteTexture(buffer);
        }
        vertexAttributeTextures.length = 0;
    }
}
class SingleMeshChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["Chunk"] {
    constructor(source, x) {
        super(source);
        const vertexData = this.vertexData = new VertexChunkData();
        vertexData.vertexPositions = x['vertexPositions'];
        vertexData.vertexNormals = x['vertexNormals'];
        vertexData.vertexAttributes = x['vertexAttributes'];
        let indices = this.indices = x['indices'];
        this.numIndices = indices.length;
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        this.vertexData.copyToGPU(gl, this.source.attributeTextureFormats);
        this.indexBuffer = Object(neuroglancer_webgl_index_emulation__WEBPACK_IMPORTED_MODULE_13__["makeIndexBuffer"])(gl, this.indices);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        this.vertexData.freeGPUMemory(gl);
        this.indexBuffer.dispose();
    }
}
function getAttributeTextureFormats(vertexAttributes) {
    return vertexAttributes.map(x => Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__["computeTextureFormat"])(new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_16__["TextureFormat"](), x.dataType, x.numComponents));
}
class SingleMeshSource extends (Object(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["WithParameters"])(neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["ChunkSource"], neuroglancer_single_mesh_base__WEBPACK_IMPORTED_MODULE_4__["SingleMeshSourceParametersWithInfo"])) {
    constructor() {
        super(...arguments);
        this.attributeTextureFormats = getAttributeTextureFormats(this.info.vertexAttributes);
    }
    get info() {
        return this.parameters.info;
    }
    getChunk(x) {
        return new SingleMeshChunk(this, x);
    }
}
const SharedObjectWithSharedVisibility = Object(neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_10__["withSharedVisibility"])(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_17__["SharedObject"]);
class SingleMeshLayerSharedObject extends SharedObjectWithSharedVisibility {
}
class SingleMeshLayer extends neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_3__["PerspectiveViewRenderLayer"] {
    constructor(source, displayState) {
        super();
        this.source = source;
        this.displayState = displayState;
        this.shaders = new Map();
        this.sharedObject = this.registerDisposer(new SingleMeshLayerSharedObject());
        this.fallbackFragmentMain = DEFAULT_FRAGMENT_MAIN;
        this.countingBuffer = this.registerDisposer(Object(neuroglancer_webgl_index_emulation__WEBPACK_IMPORTED_MODULE_13__["getCountingBuffer"])(this.gl));
        this.displayState.shaderError.value = undefined;
        const shaderChanged = () => {
            this.shaderManager = undefined;
            this.displayState.shaderError.value = undefined;
            this.disposeShaders();
            this.redrawNeeded.dispatch();
        };
        this.registerDisposer(displayState.fragmentMain.changed.add(shaderChanged));
        this.registerDisposer(displayState.attributeNames.changed.add(shaderChanged));
        this.registerDisposer(displayState.objectToDataTransform.changed.add(() => {
            this.redrawNeeded.dispatch();
        }));
        this.displayState.shaderError.value = undefined;
        const { sharedObject } = this;
        sharedObject.visibility.add(this.visibility);
        sharedObject.RPC_TYPE_ID = neuroglancer_single_mesh_base__WEBPACK_IMPORTED_MODULE_4__["SINGLE_MESH_LAYER_RPC_ID"];
        sharedObject.initializeCounterpart(source.chunkManager.rpc, {
            'chunkManager': source.chunkManager.rpcId,
            'source': source.addCounterpartRef(),
        });
        this.setReady(true);
    }
    disposeShaders() {
        let { shaders } = this;
        for (let shader of shaders.values()) {
            if (shader !== null) {
                shader.dispose();
            }
        }
        shaders.clear();
    }
    disposed() {
        this.disposeShaders();
        super.disposed();
    }
    makeShaderManager(fragmentMain = this.displayState.fragmentMain.value) {
        return new SingleMeshShaderManager(this.displayState.attributeNames.value, this.source.info.vertexAttributes, fragmentMain);
    }
    getShader(emitter) {
        let { shaders } = this;
        let shader = shaders.get(emitter);
        if (shader === undefined) {
            shader = null;
            let { shaderManager } = this;
            if (shaderManager === undefined) {
                shaderManager = this.shaderManager = this.makeShaderManager();
            }
            const fragmentMain = this.displayState.fragmentMain.value;
            try {
                shader = shaderManager.getShader(this.gl, emitter);
                this.fallbackFragmentMain = fragmentMain;
                this.displayState.shaderError.value = null;
            }
            catch (shaderError) {
                this.displayState.shaderError.value = shaderError;
                let { fallbackFragmentMain } = this;
                if (fallbackFragmentMain !== fragmentMain) {
                    shaderManager = this.shaderManager = this.makeShaderManager(fallbackFragmentMain);
                    try {
                        shader = shaderManager.getShader(this.gl, emitter);
                    }
                    catch (otherShaderError) {
                    }
                }
            }
            shaders.set(emitter, shader);
        }
        return shader;
    }
    get isTransparent() {
        return this.displayState.fragmentMain.value.match(/emitRGBA|emitPremultipliedRGBA/) !== null;
    }
    get gl() {
        return this.source.gl;
    }
    draw(renderContext) {
        if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
            // No need for a separate pick ID pass.
            return;
        }
        let chunk = this.source.chunks.get(neuroglancer_single_mesh_base__WEBPACK_IMPORTED_MODULE_4__["SINGLE_MESH_CHUNK_KEY"]);
        if (chunk === undefined || chunk.state !== neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY) {
            return;
        }
        let shader = this.getShader(renderContext.emitter);
        if (shader === null) {
            return;
        }
        let { gl } = this;
        let shaderManager = this.shaderManager;
        shader.bind();
        shaderManager.beginLayer(gl, shader, renderContext);
        let { pickIDs } = renderContext;
        shaderManager.beginObject(gl, shader, this.displayState.objectToDataTransform.transform);
        if (renderContext.emitPickID) {
            shaderManager.setPickID(gl, shader, pickIDs.register(this, chunk.numIndices / 3));
        }
        shaderManager.drawFragment(gl, shader, chunk, this.countingBuffer);
        shaderManager.endLayer(gl, shader);
    }
    drawPicking(renderContext) {
        this.draw(renderContext);
    }
    transformPickedValue(_pickedValue, pickedOffset) {
        let chunk = this.source.chunks.get(neuroglancer_single_mesh_base__WEBPACK_IMPORTED_MODULE_4__["SINGLE_MESH_CHUNK_KEY"]);
        if (chunk === undefined) {
            return undefined;
        }
        let startIndex = pickedOffset * 3;
        let { indices } = chunk;
        if (startIndex >= indices.length) {
            return undefined;
        }
        // FIXME: compute closest vertex position.  For now just use first vertex.
        let vertexIndex = indices[startIndex];
        let values = [];
        let attributeNames = this.displayState.attributeNames.value;
        chunk.vertexData.vertexAttributes.forEach((attributes, i) => {
            const attributeName = attributeNames[i];
            if (attributeName !== undefined) {
                values.push(`${attributeName}=${attributes[vertexIndex].toPrecision(6)}`);
            }
        });
        return values.join(', ');
    }
}
function getSingleMeshInfo(chunkManager, parameters) {
    return chunkManager.memoize.getUncounted({ type: 'single_mesh:getMeshInfo', parameters }, () => chunkManager.rpc.promiseInvoke(neuroglancer_single_mesh_base__WEBPACK_IMPORTED_MODULE_4__["GET_SINGLE_MESH_INFO_RPC_ID"], { 'chunkManager': chunkManager.addCounterpartRef(), 'parameters': parameters }));
}
function getSingleMeshSource(chunkManager, parameters) {
    return getSingleMeshInfo(chunkManager, parameters)
        .then(info => chunkManager.getChunkSource(SingleMeshSource, { parameters: Object.assign({}, parameters, { info }) }));
}


/***/ }),

/***/ "./src/neuroglancer/single_mesh_user_layer.css":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/single_mesh_user_layer.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/single_mesh_user_layer.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/single_mesh_user_layer.ts ***!
  \****************************************************/
/*! exports provided: SingleMeshUserLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleMeshUserLayer", function() { return SingleMeshUserLayer; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/overlay */ "./src/neuroglancer/overlay.ts");
/* harmony import */ var neuroglancer_single_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/single_mesh/frontend */ "./src/neuroglancer/single_mesh/frontend.ts");
/* harmony import */ var neuroglancer_user_layer_with_coordinate_transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/user_layer_with_coordinate_transform */ "./src/neuroglancer/user_layer_with_coordinate_transform.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_widget_shader_code_widget__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/widget/shader_code_widget */ "./src/neuroglancer/widget/shader_code_widget.ts");
/* harmony import */ var neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/widget/tab_view */ "./src/neuroglancer/widget/tab_view.ts");
/* harmony import */ var _single_mesh_user_layer_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./single_mesh_user_layer.css */ "./src/neuroglancer/single_mesh_user_layer.css");
/* harmony import */ var _single_mesh_user_layer_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_single_mesh_user_layer_css__WEBPACK_IMPORTED_MODULE_11__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












function makeValidIdentifier(x) {
    return x.split(/[^a-zA-Z0-9]+/).filter(y => y).join('_');
}
function pickAttributeNames(existingNames) {
    const seenNames = new Set();
    let result = [];
    for (let existingName of existingNames) {
        let name = makeValidIdentifier(existingName);
        let suffix = '';
        let suffixNumber = 0;
        while (seenNames.has(name + suffix)) {
            suffix = '' + (++suffixNumber);
        }
        result.push(name + suffix);
    }
    return result;
}
const BaseUserLayer = Object(neuroglancer_user_layer_with_coordinate_transform__WEBPACK_IMPORTED_MODULE_5__["UserLayerWithCoordinateTransformMixin"])(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__["UserLayer"]);
class SingleMeshUserLayer extends BaseUserLayer {
    constructor(manager, x) {
        super(manager, x);
        this.manager = manager;
        this.displayState = new neuroglancer_single_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["SingleMeshDisplayState"]();
        this.displayState.objectToDataTransform = this.transform;
        this.parameters = {
            meshSourceUrl: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(x, 'source', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyString"]),
            attributeSourceUrls: Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(x, 'vertexAttributeSources', y => {
                if (y !== undefined) {
                    return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["parseArray"])(y, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyString"]);
                }
                else {
                    return [];
                }
            }),
        };
        this.displayState.fragmentMain.restoreState(x['shader']);
        this.userSpecifiedAttributeNames = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyObjectProperty"])(x, 'vertexAttributeNames', y => {
            if (y === undefined) {
                return undefined;
            }
            return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["parseArray"])(y, z => {
                let result = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_8__["verifyOptionalString"])(z);
                if (result) {
                    return result;
                }
                return undefined;
            });
        });
        Object(neuroglancer_single_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["getSingleMeshSource"])(manager.chunkManager, this.parameters).then(source => {
            if (this.wasDisposed) {
                return;
            }
            this.meshSource = source;
            const defaultAttributeNames = this.defaultAttributeNames =
                pickAttributeNames(source.info.vertexAttributes.map(a => a.name));
            const { userSpecifiedAttributeNames } = this;
            let initialAttributeNames;
            if (userSpecifiedAttributeNames !== undefined &&
                userSpecifiedAttributeNames.length === defaultAttributeNames.length) {
                initialAttributeNames = userSpecifiedAttributeNames;
                this.userSpecifiedAttributeNames = undefined;
            }
            else {
                initialAttributeNames = Array.from(defaultAttributeNames);
            }
            this.displayState.attributeNames.value = initialAttributeNames;
            this.addRenderLayer(new neuroglancer_single_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["SingleMeshLayer"](source, this.displayState));
            this.isReady = true;
        });
        this.registerDisposer(this.displayState.fragmentMain.changed.add(() => {
            this.specificationChanged.dispatch();
        }));
        this.registerDisposer(this.displayState.attributeNames.changed.add(() => {
            this.specificationChanged.dispatch();
        }));
        this.tabs.add('rendering', { label: 'Rendering', order: -100, getter: () => new DisplayOptionsTab(this) });
        this.tabs.default = 'rendering';
    }
    toJSON() {
        let x = super.toJSON();
        x['type'] = 'mesh';
        let { parameters } = this;
        let { attributeSourceUrls } = parameters;
        x['source'] = this.parameters.meshSourceUrl;
        if (attributeSourceUrls) {
            x['vertexAttributeSources'] = attributeSourceUrls;
        }
        x['shader'] = this.displayState.fragmentMain.toJSON();
        let persistentAttributeNames = undefined;
        if (this.meshSource === undefined) {
            persistentAttributeNames = this.userSpecifiedAttributeNames;
        }
        else {
            const defaultAttributeNames = this.defaultAttributeNames;
            const attributeNames = this.displayState.attributeNames.value;
            // Check if equal.
            let equal = true;
            const numAttributes = attributeNames.length;
            for (let i = 0; i < numAttributes; ++i) {
                if (attributeNames[i] !== defaultAttributeNames[i]) {
                    equal = false;
                    break;
                }
            }
            if (equal) {
                persistentAttributeNames = undefined;
            }
            else {
                persistentAttributeNames = Array.from(attributeNames);
            }
        }
        x['vertexAttributeNames'] = persistentAttributeNames;
        return x;
    }
}
function makeShaderCodeWidget(layer) {
    return new neuroglancer_widget_shader_code_widget__WEBPACK_IMPORTED_MODULE_9__["ShaderCodeWidget"]({
        fragmentMain: layer.displayState.fragmentMain,
        shaderError: layer.displayState.shaderError,
        fragmentMainStartLine: neuroglancer_single_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["FRAGMENT_MAIN_START"],
    });
}
/**
 * Time in milliseconds during which the input field must not be modified before the shader is
 * recompiled.
 */
const SHADER_UPDATE_DELAY = 500;
class VertexAttributeWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_6__["RefCounted"] {
    constructor(attributeNames, getAttributeInfo) {
        super();
        this.attributeNames = attributeNames;
        this.getAttributeInfo = getAttributeInfo;
        this.element = document.createElement('div');
        this.debouncedValueUpdater = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
            this.updateAttributeNames();
        }, SHADER_UPDATE_DELAY);
        this.element.className = 'neuroglancer-single-mesh-attribute-widget';
        this.updateInputElements();
        this.registerDisposer(attributeNames.changed.add(() => {
            this.updateInputElements();
        }));
    }
    updateInputElements() {
        const attributeNames = this.attributeNames;
        let { attributeNameElements } = this;
        if (attributeNameElements === undefined) {
            let attributeInfo = this.getAttributeInfo();
            if (attributeInfo === undefined) {
                return;
            }
            attributeNameElements = this.attributeNameElements = new Array();
            let previousSource = undefined;
            let numAttributes = attributeNames.value.length;
            let { element } = this;
            for (let i = 0; i < numAttributes; ++i) {
                let info = attributeInfo[i];
                let { source } = info;
                if (source !== previousSource && source !== undefined) {
                    previousSource = source;
                    let div = document.createElement('div');
                    div.className = 'neuroglancer-single-mesh-source-header';
                    div.textContent = source;
                    element.appendChild(div);
                }
                let div = document.createElement('div');
                div.className = 'neuroglancer-single-mesh-attribute';
                let input = document.createElement('input');
                input.title = info.name;
                this.registerEventListener(input, 'input', this.debouncedValueUpdater);
                input.type = 'text';
                div.textContent = Object(neuroglancer_single_mesh_frontend__WEBPACK_IMPORTED_MODULE_4__["getShaderAttributeType"])(info);
                div.appendChild(input);
                if (info.min !== undefined && info.max !== undefined) {
                    let minMaxText = document.createElement('span');
                    minMaxText.className = 'neuroglancer-single-mesh-attribute-range';
                    minMaxText.textContent = `[${info.min.toPrecision(6)}, ${info.max.toPrecision(6)}]`;
                    div.appendChild(minMaxText);
                }
                attributeNameElements[i] = input;
                element.appendChild(div);
            }
        }
        const attributeNamesValue = attributeNames.value;
        attributeNamesValue.forEach((name, i) => {
            attributeNameElements[i].value = name || '';
        });
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_7__["removeFromParent"])(this.element);
    }
    updateAttributeNames() {
        const attributeNames = this.attributeNames.value;
        const attributeNameElements = this.attributeNameElements;
        let changed = false;
        attributeNames.forEach((name, i) => {
            let newName = attributeNameElements[i].value;
            if (!newName) {
                newName = undefined;
            }
            if (newName !== name) {
                changed = true;
                attributeNames[i] = newName;
            }
        });
        if (changed) {
            this.attributeNames.changed.dispatch();
        }
    }
}
function makeVertexAttributeWidget(layer) {
    return new VertexAttributeWidget(layer.displayState.attributeNames, () => layer.meshSource && layer.meshSource.info.vertexAttributes);
}
class DisplayOptionsTab extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_10__["Tab"] {
    constructor(layer) {
        super();
        this.layer = layer;
        this.attributeWidget = this.registerDisposer(makeVertexAttributeWidget(this.layer));
        this.codeWidget = this.registerDisposer(makeShaderCodeWidget(this.layer));
        const { element } = this;
        element.classList.add('neuroglancer-single-mesh-dropdown');
        let topRow = document.createElement('div');
        topRow.className = 'neuroglancer-single-mesh-dropdown-top-row';
        let spacer = document.createElement('div');
        spacer.style.flex = '1';
        let helpLink = document.createElement('a');
        let helpButton = document.createElement('button');
        helpButton.type = 'button';
        helpButton.textContent = '?';
        helpButton.className = 'help-link';
        helpLink.appendChild(helpButton);
        helpLink.title = 'Documentation on single mesh layer rendering';
        helpLink.target = '_blank';
        helpLink.href =
            'https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md';
        let maximizeButton = document.createElement('button');
        maximizeButton.innerHTML = '&square;';
        maximizeButton.className = 'maximize-button';
        maximizeButton.title = 'Show larger editor view';
        this.registerEventListener(maximizeButton, 'click', () => {
            new ShaderCodeOverlay(this.layer);
        });
        topRow.appendChild(spacer);
        topRow.appendChild(maximizeButton);
        topRow.appendChild(helpLink);
        element.appendChild(topRow);
        element.appendChild(this.attributeWidget.element);
        element.appendChild(this.codeWidget.element);
        this.codeWidget.textEditor.refresh();
        this.visibility.changed.add(() => {
            if (this.visible) {
                this.codeWidget.textEditor.refresh();
            }
        });
    }
}
class ShaderCodeOverlay extends neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_3__["Overlay"] {
    constructor(layer) {
        super();
        this.layer = layer;
        this.attributeWidget = this.registerDisposer(makeVertexAttributeWidget(this.layer));
        this.codeWidget = this.registerDisposer(makeShaderCodeWidget(this.layer));
        this.content.classList.add('neuroglancer-single-mesh-layer-shader-overlay');
        this.content.appendChild(this.attributeWidget.element);
        this.content.appendChild(this.codeWidget.element);
        this.codeWidget.textEditor.refresh();
    }
}
Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_2__["registerLayerType"])('mesh', SingleMeshUserLayer);


/***/ }),

/***/ "./src/neuroglancer/skeleton/base.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/skeleton/base.ts ***!
  \*******************************************/
/*! exports provided: SKELETON_LAYER_RPC_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SKELETON_LAYER_RPC_ID", function() { return SKELETON_LAYER_RPC_ID; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SKELETON_LAYER_RPC_ID = 'skeleton/SkeletonLayer';


/***/ }),

/***/ "./src/neuroglancer/skeleton/frontend.ts":
/*!***********************************************!*\
  !*** ./src/neuroglancer/skeleton/frontend.ts ***!
  \***********************************************/
/*! exports provided: FRAGMENT_MAIN_START, getTrackableFragmentMain, SkeletonRenderMode, TrackableSkeletonRenderMode, TrackableSkeletonLineWidth, SkeletonRenderingOptions, SkeletonLayer, PerspectiveViewSkeletonLayer, SliceViewPanelSkeletonLayer, SkeletonChunk, SkeletonSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_MAIN_START", function() { return FRAGMENT_MAIN_START; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTrackableFragmentMain", function() { return getTrackableFragmentMain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonRenderMode", function() { return SkeletonRenderMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableSkeletonRenderMode", function() { return TrackableSkeletonRenderMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableSkeletonLineWidth", function() { return TrackableSkeletonLineWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonRenderingOptions", function() { return SkeletonRenderingOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonLayer", function() { return SkeletonLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveViewSkeletonLayer", function() { return PerspectiveViewSkeletonLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewPanelSkeletonLayer", function() { return SliceViewPanelSkeletonLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonChunk", function() { return SkeletonChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonSource", function() { return SkeletonSource; });
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/perspective_view/render_layer */ "./src/neuroglancer/perspective_view/render_layer.ts");
/* harmony import */ var neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/segmentation_display_state/base */ "./src/neuroglancer/segmentation_display_state/base.ts");
/* harmony import */ var neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/segmentation_display_state/frontend */ "./src/neuroglancer/segmentation_display_state/frontend.ts");
/* harmony import */ var neuroglancer_skeleton_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/skeleton/base */ "./src/neuroglancer/skeleton/base.ts");
/* harmony import */ var neuroglancer_sliceview_panel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/sliceview/panel */ "./src/neuroglancer/sliceview/panel.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/data_type */ "./src/neuroglancer/util/data_type.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/util/trackable */ "./src/neuroglancer/util/trackable.ts");
/* harmony import */ var neuroglancer_util_trackable_enum__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/util/trackable_enum */ "./src/neuroglancer/util/trackable_enum.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/* harmony import */ var neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/webgl/circles */ "./src/neuroglancer/webgl/circles.ts");
/* harmony import */ var neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! neuroglancer/webgl/dynamic_shader */ "./src/neuroglancer/webgl/dynamic_shader.ts");
/* harmony import */ var neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! neuroglancer/webgl/lines */ "./src/neuroglancer/webgl/lines.ts");
/* harmony import */ var neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! neuroglancer/webgl/texture_access */ "./src/neuroglancer/webgl/texture_access.ts");
/* harmony import */ var neuroglancer_webgl_colormaps__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! neuroglancer/webgl/colormaps */ "./src/neuroglancer/webgl/colormaps.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





















const tempMat2 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__["mat4"].create();
const DEFAULT_FRAGMENT_MAIN = `void main() {
  emitDefault();
}
`;
const FRAGMENT_MAIN_START = '//NEUROGLANCER_SKELETON_LAYER_FRAGMENT_MAIN_START';
function getTrackableFragmentMain(value = DEFAULT_FRAGMENT_MAIN) {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_7__["TrackableValue"](value, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyString"]);
}
const vertexAttributeSamplerSymbols = [];
const vertexPositionTextureFormat = Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__["computeTextureFormat"])(new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__["TextureFormat"](), neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_8__["DataType"].FLOAT32, 3);
class RenderHelper extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_9__["RefCounted"] {
    constructor(base, targetIsSliceView) {
        super();
        this.base = base;
        this.targetIsSliceView = targetIsSliceView;
        this.textureAccessHelper = new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__["OneDimensionalTextureAccessHelper"]('vertexData');
        this.lineShader = this.registerDisposer(new neuroglancer_webgl_lines__WEBPACK_IMPORTED_MODULE_18__["LineShader"](this.gl, 1));
        this.circleShader = this.registerDisposer(new neuroglancer_webgl_circles__WEBPACK_IMPORTED_MODULE_16__["CircleShader"](this.gl, 2));
        this.edgeShaderGetter = Object(neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_17__["parameterizedEmitterDependentShaderGetter"])(this, this.gl, { type: 'skeleton/SkeletonShaderManager/edge', vertexAttributes: this.vertexAttributes }, this.base.fallbackFragmentMain, this.base.displayState.skeletonRenderingOptions.shader, this.base.displayState.shaderError, (builder, fragmentMain) => {
            this.defineAttributeAccess(builder);
            this.lineShader.defineShader(builder);
            builder.addAttribute('highp uvec2', 'aVertexIndex');
            this.defineCommonShader(builder);
            let vertexMain = `
highp vec3 vertexA = readAttribute0(aVertexIndex.x);
highp vec3 vertexB = readAttribute0(aVertexIndex.y);
emitLine(uProjection, vertexA, vertexB);
highp uint lineEndpointIndex = getLineEndpointIndex();
highp uint vertexIndex = aVertexIndex.x * lineEndpointIndex + aVertexIndex.y * (1u - lineEndpointIndex);
`;
            builder.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGB(vec3 color) {
  emit(vec4(color * uColor.a, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
void emitDefault() {
  //emit(vec4(uColor.rgb, uColor.a * ${this.getCrossSectionFadeFactor()}), uPickID);
  emit(vec4(uColor.rgb, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
`);
            builder.addFragmentCode(neuroglancer_webgl_colormaps__WEBPACK_IMPORTED_MODULE_20__["glsl_COLORMAPS"]);
            const { vertexAttributes } = this;
            const numAttributes = vertexAttributes.length;
            for (let i = 1; i < numAttributes; ++i) {
                const info = vertexAttributes[i];
                builder.addVarying(`highp ${info.glslDataType}`, `vCustom${i}`);
                vertexMain += `vCustom${i} = readAttribute${i}(vertexIndex);\n`;
                builder.addFragmentCode(`#define ${info.name} vCustom${i}\n`);
            }
            builder.setVertexMain(vertexMain);
            builder.setFragmentMainFunction(FRAGMENT_MAIN_START + '\n' + fragmentMain);
        });
        this.nodeShaderGetter = Object(neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_17__["parameterizedEmitterDependentShaderGetter"])(this, this.gl, { type: 'skeleton/SkeletonShaderManager/node', vertexAttributes: this.vertexAttributes }, this.base.fallbackFragmentMain, this.base.displayState.skeletonRenderingOptions.shader, this.base.displayState.shaderError, (builder, fragmentMain) => {
            this.defineAttributeAccess(builder);
            this.circleShader.defineShader(builder, /*crossSectionFade=*/ this.targetIsSliceView);
            this.defineCommonShader(builder);
            let vertexMain = `
highp uint vertexIndex = uint(gl_InstanceID);
highp vec3 vertexPosition = readAttribute0(vertexIndex);
emitCircle(uProjection * vec4(vertexPosition, 1.0));
`;
            builder.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGBA(vec4 color) {
  vec4 borderColor = color;
  emit(getCircleColor(color, borderColor), uPickID);
}
void emitRGB(vec3 color) {
  emitRGBA(vec4(color, 1.0));
}
void emitDefault() {
  emitRGBA(uColor);
}
`);
            builder.addFragmentCode(neuroglancer_webgl_colormaps__WEBPACK_IMPORTED_MODULE_20__["glsl_COLORMAPS"]);
            const { vertexAttributes } = this;
            const numAttributes = vertexAttributes.length;
            for (let i = 1; i < numAttributes; ++i) {
                const info = vertexAttributes[i];
                builder.addVarying(`highp ${info.glslDataType}`, `vCustom${i}`);
                vertexMain += `vCustom${i} = readAttribute${i}(vertexIndex);\n`;
                builder.addFragmentCode(`#define ${info.name} vCustom${i}\n`);
            }
            builder.setVertexMain(vertexMain);
            builder.setFragmentMainFunction(FRAGMENT_MAIN_START + '\n' + fragmentMain);
        });
    }
    get vertexAttributes() {
        return this.base.vertexAttributes;
    }
    defineCommonShader(builder) {
        builder.addUniform('highp vec4', 'uColor');
        builder.addUniform('highp mat4', 'uProjection');
        builder.addUniform('highp uint', 'uPickID');
    }
    get gl() {
        return this.base.gl;
    }
    defineAttributeAccess(builder) {
        const { textureAccessHelper } = this;
        textureAccessHelper.defineShader(builder);
        const numAttributes = this.vertexAttributes.length;
        for (let j = vertexAttributeSamplerSymbols.length; j < numAttributes; ++j) {
            vertexAttributeSamplerSymbols[j] = Symbol(`SkeletonShader.vertexAttributeTextureUnit${j}`);
        }
        this.vertexAttributes.forEach((info, i) => {
            builder.addTextureSampler(`${Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__["getSamplerPrefixForDataType"])(info.dataType)}sampler2D`, `uVertexAttributeSampler${i}`, vertexAttributeSamplerSymbols[i]);
            builder.addVertexCode(textureAccessHelper.getAccessor(`readAttribute${i}`, `uVertexAttributeSampler${i}`, info.dataType, info.numComponents));
        });
    }
    getCrossSectionFadeFactor() {
        if (this.targetIsSliceView) {
            return `(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))`;
        }
        else {
            return `(1.0)`;
        }
    }
    beginLayer(gl, shader, renderContext, objectToDataMatrix) {
        let { dataToDevice } = renderContext;
        let mat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__["mat4"].multiply(tempMat2, dataToDevice, objectToDataMatrix);
        gl.uniformMatrix4fv(shader.uniform('uProjection'), false, mat);
    }
    setColor(gl, shader, color) {
        gl.uniform4fv(shader.uniform('uColor'), color);
    }
    setPickID(gl, shader, pickID) {
        gl.uniform1ui(shader.uniform('uPickID'), pickID);
    }
    drawSkeleton(gl, edgeShader, nodeShader, skeletonChunk, renderContext, lineWidth, pointDiameter) {
        const { vertexAttributes } = this;
        const numAttributes = vertexAttributes.length;
        const { vertexAttributeTextures } = skeletonChunk;
        for (let i = 0; i < numAttributes; ++i) {
            const textureUnit = WebGL2RenderingContext.TEXTURE0 +
                edgeShader.textureUnit(vertexAttributeSamplerSymbols[i]);
            gl.activeTexture(textureUnit);
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, vertexAttributeTextures[i]);
        }
        // Draw edges
        {
            edgeShader.bind();
            this.textureAccessHelper.setupTextureLayout(gl, edgeShader, skeletonChunk);
            const aVertexIndex = edgeShader.attribute('aVertexIndex');
            skeletonChunk.indexBuffer.bindToVertexAttribI(aVertexIndex, 2, WebGL2RenderingContext.UNSIGNED_INT);
            gl.vertexAttribDivisor(aVertexIndex, 1);
            this.lineShader.draw(edgeShader, renderContext, lineWidth, this.targetIsSliceView ? 1.0 : 0.0, skeletonChunk.numIndices / 2);
            gl.vertexAttribDivisor(aVertexIndex, 0);
            gl.disableVertexAttribArray(aVertexIndex);
        }
        if (nodeShader !== null) {
            nodeShader.bind();
            this.textureAccessHelper.setupTextureLayout(gl, nodeShader, skeletonChunk);
            this.circleShader.draw(nodeShader, renderContext, {
                interiorRadiusInPixels: pointDiameter / 2,
                borderWidthInPixels: 0,
                featherWidthInPixels: this.targetIsSliceView ? 1.0 : 0.0,
            }, skeletonChunk.numVertices);
        }
    }
    endLayer(gl, shader) {
        const { vertexAttributes } = this;
        const numAttributes = vertexAttributes.length;
        for (let i = 0; i < numAttributes; ++i) {
            let curTextureUnit = shader.textureUnit(vertexAttributeSamplerSymbols[i]) + WebGL2RenderingContext.TEXTURE0;
            gl.activeTexture(curTextureUnit);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }
}
var SkeletonRenderMode;
(function (SkeletonRenderMode) {
    SkeletonRenderMode[SkeletonRenderMode["LINES"] = 0] = "LINES";
    SkeletonRenderMode[SkeletonRenderMode["LINES_AND_POINTS"] = 1] = "LINES_AND_POINTS";
})(SkeletonRenderMode || (SkeletonRenderMode = {}));
class TrackableSkeletonRenderMode extends neuroglancer_util_trackable_enum__WEBPACK_IMPORTED_MODULE_14__["TrackableEnum"] {
    constructor(value, defaultValue = value) {
        super(SkeletonRenderMode, value, defaultValue);
    }
}
class TrackableSkeletonLineWidth extends neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_7__["TrackableValue"] {
    constructor(value, defaultValue = value) {
        super(value, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_11__["verifyFinitePositiveFloat"], defaultValue);
    }
}
class SkeletonRenderingOptions {
    constructor() {
        this.compound = new neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_13__["CompoundTrackable"]();
        this.shader = getTrackableFragmentMain();
        this.params2d = {
            mode: new TrackableSkeletonRenderMode(SkeletonRenderMode.LINES_AND_POINTS),
            lineWidth: new TrackableSkeletonLineWidth(5),
        };
        this.params3d = {
            mode: new TrackableSkeletonRenderMode(SkeletonRenderMode.LINES),
            lineWidth: new TrackableSkeletonLineWidth(2),
        };
        const { compound } = this;
        compound.add('shader', this.shader);
        compound.add('mode2d', this.params2d.mode);
        compound.add('lineWidth2d', this.params2d.lineWidth);
        compound.add('mode3d', this.params3d.mode);
        compound.add('lineWidth3d', this.params3d.lineWidth);
    }
    get changed() {
        return this.compound.changed;
    }
    reset() {
        this.compound.reset();
    }
    restoreState(obj) {
        if (obj === undefined)
            return;
        this.compound.restoreState(obj);
    }
    toJSON() {
        const obj = this.compound.toJSON();
        for (const _ in obj)
            return obj;
        return undefined;
    }
}
class SkeletonLayer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_9__["RefCounted"] {
    constructor(chunkManager, source, voxelSizeObject, displayState) {
        super();
        this.chunkManager = chunkManager;
        this.source = source;
        this.voxelSizeObject = voxelSizeObject;
        this.displayState = displayState;
        this.tempMat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__["mat4"].create();
        this.redrawNeeded = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_12__["NullarySignal"]();
        this.fallbackFragmentMain = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_7__["WatchableValue"](DEFAULT_FRAGMENT_MAIN);
        Object(neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_4__["registerRedrawWhenSegmentationDisplayState3DChanged"])(displayState, this);
        this.displayState.shaderError.value = undefined;
        const { skeletonRenderingOptions: renderingOptions } = displayState;
        this.registerDisposer(renderingOptions.shader.changed.add(() => {
            this.displayState.shaderError.value = undefined;
            this.redrawNeeded.dispatch();
        }));
        let sharedObject = this.sharedObject =
            this.registerDisposer(new neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_4__["SegmentationLayerSharedObject"](chunkManager, displayState));
        sharedObject.RPC_TYPE_ID = neuroglancer_skeleton_base__WEBPACK_IMPORTED_MODULE_5__["SKELETON_LAYER_RPC_ID"];
        sharedObject.initializeCounterpartWithChunkManager({
            'source': source.addCounterpartRef(),
        });
        const vertexAttributes = this.vertexAttributes = [vertexPositionAttribute];
        for (let [name, info] of source.vertexAttributes) {
            vertexAttributes.push({
                name,
                dataType: info.dataType,
                numComponents: info.numComponents,
                webglDataType: getWebglDataType(info.dataType),
                glslDataType: info.numComponents > 1 ? `vec${info.numComponents}` : 'float',
            });
        }
    }
    get visibility() {
        return this.sharedObject.visibility;
    }
    get gl() {
        return this.chunkManager.chunkQueueManager.gl;
    }
    draw(renderContext, layer, renderHelper, renderOptions) {
        let lineWidth = renderOptions.lineWidth.value;
        let { gl, source, displayState } = this;
        let alpha = Math.min(1.0, displayState.objectAlpha.value);
        if (alpha <= 0.0) {
            // Skip drawing.
            return;
        }
        let pointDiameter;
        if (renderOptions.mode.value === SkeletonRenderMode.LINES_AND_POINTS) {
            pointDiameter = Math.max(10, lineWidth * 2);
        }
        else {
            pointDiameter = lineWidth;
        }
        const edgeShader = renderHelper.edgeShaderGetter(renderContext.emitter);
        const nodeShader = renderHelper.nodeShaderGetter(renderContext.emitter);
        if (edgeShader === null || nodeShader === null) {
            // Shader error, skip drawing.
            return;
        }
        let objectToDataMatrix = this.tempMat;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__["mat4"].identity(objectToDataMatrix);
        if (source.skeletonVertexCoordinatesInVoxels) {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__["mat4"].scale(objectToDataMatrix, objectToDataMatrix, this.voxelSizeObject.size);
        }
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__["mat4"].multiply(objectToDataMatrix, objectToDataMatrix, source.transform);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__["mat4"].multiply(objectToDataMatrix, this.displayState.objectToDataTransform.transform, objectToDataMatrix);
        edgeShader.bind();
        renderHelper.beginLayer(gl, edgeShader, renderContext, objectToDataMatrix);
        nodeShader.bind();
        renderHelper.beginLayer(gl, nodeShader, renderContext, objectToDataMatrix);
        const skeletons = source.chunks;
        const { pickIDs } = renderContext;
        Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_3__["forEachVisibleSegment"])(displayState, (objectId, rootObjectId) => {
            const key = Object(neuroglancer_segmentation_display_state_base__WEBPACK_IMPORTED_MODULE_3__["getObjectKey"])(objectId);
            const skeleton = skeletons.get(key);
            if (skeleton === undefined || skeleton.state !== neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY) {
                return;
            }
            if (renderContext.emitColor) {
                edgeShader.bind();
                renderHelper.setColor(gl, edgeShader, Object(neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_4__["getObjectColor"])(displayState, rootObjectId, alpha));
                nodeShader.bind();
                renderHelper.setColor(gl, nodeShader, Object(neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_4__["getObjectColor"])(displayState, rootObjectId, alpha));
            }
            if (renderContext.emitPickID) {
                edgeShader.bind();
                renderHelper.setPickID(gl, edgeShader, pickIDs.registerUint64(layer, objectId));
                nodeShader.bind();
                renderHelper.setPickID(gl, nodeShader, pickIDs.registerUint64(layer, objectId));
            }
            renderHelper.drawSkeleton(gl, edgeShader, nodeShader, skeleton, renderContext, lineWidth, pointDiameter);
        });
        renderHelper.endLayer(gl, edgeShader);
    }
}
class PerspectiveViewSkeletonLayer extends neuroglancer_perspective_view_render_layer__WEBPACK_IMPORTED_MODULE_2__["PerspectiveViewRenderLayer"] {
    constructor(base) {
        super();
        this.base = base;
        this.renderHelper = this.registerDisposer(new RenderHelper(this.base, false));
        this.renderOptions = this.base.displayState.skeletonRenderingOptions.params3d;
        this.registerDisposer(base);
        this.registerDisposer(base.redrawNeeded.add(this.redrawNeeded.dispatch));
        const { renderOptions } = this;
        this.registerDisposer(renderOptions.mode.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(renderOptions.lineWidth.changed.add(this.redrawNeeded.dispatch));
        this.setReady(true);
        this.registerDisposer(base.visibility.add(this.visibility));
    }
    get gl() {
        return this.base.gl;
    }
    get isTransparent() {
        return this.base.displayState.objectAlpha.value < 1.0;
    }
    draw(renderContext) {
        if (!renderContext.emitColor && renderContext.alreadyEmittedPickID) {
            // No need for a separate pick ID pass.
            return;
        }
        this.base.draw(renderContext, this, this.renderHelper, this.renderOptions);
    }
}
class SliceViewPanelSkeletonLayer extends neuroglancer_sliceview_panel__WEBPACK_IMPORTED_MODULE_6__["SliceViewPanelRenderLayer"] {
    constructor(base) {
        super();
        this.base = base;
        this.renderHelper = this.registerDisposer(new RenderHelper(this.base, true));
        this.renderOptions = this.base.displayState.skeletonRenderingOptions.params2d;
        this.registerDisposer(base);
        const { renderOptions } = this;
        this.registerDisposer(renderOptions.mode.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(renderOptions.lineWidth.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(base.redrawNeeded.add(this.redrawNeeded.dispatch));
        this.setReady(true);
        this.registerDisposer(base.visibility.add(this.visibility));
    }
    get gl() {
        return this.base.gl;
    }
    draw(renderContext) {
        this.base.draw(renderContext, this, this.renderHelper, this.renderOptions);
    }
}
function getWebglDataType(dataType) {
    switch (dataType) {
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_8__["DataType"].FLOAT32:
            return WebGL2RenderingContext.FLOAT;
        default:
            throw new Error(`Data type not supported by WebGL: ${neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_8__["DataType"][dataType]}`);
    }
}
const vertexPositionAttribute = {
    dataType: neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_8__["DataType"].FLOAT32,
    numComponents: 3,
    name: '',
    webglDataType: WebGL2RenderingContext.FLOAT,
    glslDataType: 'vec3',
};
class SkeletonChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["Chunk"] {
    constructor(source, x) {
        super(source);
        this.vertexAttributes = x['vertexAttributes'];
        let indices = this.indices = x['indices'];
        this.numVertices = x['numVertices'];
        this.vertexAttributeOffsets = x['vertexAttributeOffsets'];
        this.numIndices = indices.length;
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__["compute1dTextureLayout"])(this, gl, /*texelsPerElement=*/ 1, this.numVertices);
        const { attributeTextureFormats } = this.source;
        const { vertexAttributes, vertexAttributeOffsets } = this;
        const vertexAttributeTextures = this.vertexAttributeTextures = [];
        for (let i = 0, numAttributes = vertexAttributeOffsets.length; i < numAttributes; ++i) {
            const texture = gl.createTexture();
            gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__["setOneDimensionalTextureData"])(gl, this, attributeTextureFormats[i], vertexAttributes.subarray(vertexAttributeOffsets[i], i + 1 !== numAttributes ? vertexAttributeOffsets[i + 1] : vertexAttributes.length));
            vertexAttributeTextures[i] = texture;
        }
        gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
        this.indexBuffer = neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_15__["Buffer"].fromData(gl, this.indices, WebGL2RenderingContext.ARRAY_BUFFER, WebGL2RenderingContext.STATIC_DRAW);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        const { vertexAttributeTextures } = this;
        for (const texture of vertexAttributeTextures) {
            gl.deleteTexture(texture);
        }
        vertexAttributeTextures.length = 0;
        this.indexBuffer.dispose();
    }
}
const emptyVertexAttributes = new Map();
function getAttributeTextureFormats(vertexAttributes) {
    const attributeTextureFormats = [vertexPositionTextureFormat];
    for (const info of vertexAttributes.values()) {
        attributeTextureFormats.push(Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__["computeTextureFormat"])(new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_19__["TextureFormat"](), info.dataType, info.numComponents));
    }
    return attributeTextureFormats;
}
class SkeletonSource extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["ChunkSource"] {
    get attributeTextureFormats() {
        let attributeTextureFormats = this.attributeTextureFormats_;
        if (attributeTextureFormats === undefined) {
            attributeTextureFormats = this.attributeTextureFormats_ =
                getAttributeTextureFormats(this.vertexAttributes);
        }
        return attributeTextureFormats;
    }
    getChunk(x) {
        return new SkeletonChunk(this, x);
    }
    constructor(chunkManager, options) {
        super(chunkManager, options);
        const { transform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_10__["mat4"].create() } = options;
        this.transform = transform;
    }
    /**
     * Specifies whether the skeleton vertex coordinates are specified in units of voxels rather than
     * nanometers.
     */
    get skeletonVertexCoordinatesInVoxels() {
        return true;
    }
    get vertexAttributes() {
        return emptyVertexAttributes;
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/base.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/sliceview/base.ts ***!
  \********************************************/
/*! exports provided: DATA_TYPE_BYTES, DataType, getTransformedSources, SliceViewBase, DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2, getNearIsotropicBlockSize, getTwoDimensionalBlockSize, getTwoDimensionalBlockSizes, ChunkLayoutPreference, getCombinedTransform, getChunkDataSizes, SliceViewChunkSpecification, SLICEVIEW_RPC_ID, SLICEVIEW_RENDERLAYER_RPC_ID, SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, SLICEVIEW_UPDATE_VIEW_RPC_ID, SLICEVIEW_RENDERLAYER_UPDATE_TRANSFORM_RPC_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransformedSources", function() { return getTransformedSources; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewBase", function() { return SliceViewBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2", function() { return DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNearIsotropicBlockSize", function() { return getNearIsotropicBlockSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTwoDimensionalBlockSize", function() { return getTwoDimensionalBlockSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTwoDimensionalBlockSizes", function() { return getTwoDimensionalBlockSizes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkLayoutPreference", function() { return ChunkLayoutPreference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCombinedTransform", function() { return getCombinedTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChunkDataSizes", function() { return getChunkDataSizes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewChunkSpecification", function() { return SliceViewChunkSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SLICEVIEW_RPC_ID", function() { return SLICEVIEW_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SLICEVIEW_RENDERLAYER_RPC_ID", function() { return SLICEVIEW_RENDERLAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID", function() { return SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID", function() { return SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SLICEVIEW_UPDATE_VIEW_RPC_ID", function() { return SLICEVIEW_UPDATE_VIEW_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SLICEVIEW_RENDERLAYER_UPDATE_TRANSFORM_RPC_ID", function() { return SLICEVIEW_RENDERLAYER_UPDATE_TRANSFORM_RPC_ID; });
/* harmony import */ var neuroglancer_sliceview_chunk_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/chunk_layout */ "./src/neuroglancer/sliceview/chunk_layout.ts");
/* harmony import */ var neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/array */ "./src/neuroglancer/util/array.ts");
/* harmony import */ var neuroglancer_util_compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/compare */ "./src/neuroglancer/util/compare.ts");
/* harmony import */ var neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/data_type */ "./src/neuroglancer/util/data_type.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DATA_TYPE_BYTES", function() { return neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_3__["DATA_TYPE_BYTES"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_3__["DataType"]; });

/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







const DEBUG_CHUNK_INTERSECTIONS = false;
const DEBUG_VISIBLE_SOURCES = false;
const tempVec3 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
/**
 * Average cross-sectional area contained within a chunk of the specified size and rotation.
 *
 * This is estimated by taking the total volume of the chunk and dividing it by the total length of
 * the chunk along the z axis.
 */
function estimateSliceAreaPerChunk(zAxis, chunkLayout) {
    const chunkSize = chunkLayout.size;
    const zAxisRotated = chunkLayout.globalToLocalSpatialVector(tempVec3, zAxis);
    // Minimum and maximum dot product of zAxisRotated with each of the corners of the chunk.  Both
    // are initialized to 0 because the origin of the chunk has a projection of 0.
    let minProjection = 0, maxProjection = 0;
    let chunkVolume = 1;
    for (let i = 0; i < 3; ++i) {
        const chunkSizeValue = chunkSize[i];
        chunkVolume *= chunkSizeValue;
        const projection = chunkSizeValue * zAxisRotated[i];
        minProjection = Math.min(minProjection, projection);
        maxProjection = Math.max(maxProjection, projection);
    }
    const projectionLength = maxProjection - minProjection;
    return chunkVolume / projectionLength;
}
/**
 * All valid chunks are in the range [lowerBound, upperBound).
 *
 * @param lowerBound Output parameter for lowerBound.
 * @param upperBound Output parameter for upperBound.
 * @param sources Sources for which to compute the chunk bounds.
 */
function computeSourcesChunkBounds(sourcesLowerBound, sourcesUpperBound, sources) {
    for (let i = 0; i < 3; ++i) {
        sourcesLowerBound[i] = Number.POSITIVE_INFINITY;
        sourcesUpperBound[i] = Number.NEGATIVE_INFINITY;
    }
    for (let source of sources) {
        let { spec } = source;
        let { lowerChunkBound, upperChunkBound } = spec;
        for (let i = 0; i < 3; ++i) {
            sourcesLowerBound[i] = Math.min(sourcesLowerBound[i], lowerChunkBound[i]);
            sourcesUpperBound[i] = Math.max(sourcesUpperBound[i], upperChunkBound[i]);
        }
    }
}
var BoundsComparisonResult;
(function (BoundsComparisonResult) {
    // Needle is fully outside haystack.
    BoundsComparisonResult[BoundsComparisonResult["FULLY_OUTSIDE"] = 0] = "FULLY_OUTSIDE";
    // Needle is fully inside haystack.
    BoundsComparisonResult[BoundsComparisonResult["FULLY_INSIDE"] = 1] = "FULLY_INSIDE";
    // Needle is partially inside haystack.
    BoundsComparisonResult[BoundsComparisonResult["PARTIALLY_INSIDE"] = 2] = "PARTIALLY_INSIDE";
})(BoundsComparisonResult || (BoundsComparisonResult = {}));
function compareBoundsSingleDimension(needleLower, needleUpper, haystackLower, haystackUpper) {
    if (needleLower >= haystackUpper || needleUpper <= haystackLower) {
        return BoundsComparisonResult.FULLY_OUTSIDE;
    }
    if (needleLower >= haystackLower && needleUpper <= haystackUpper) {
        return BoundsComparisonResult.FULLY_INSIDE;
    }
    return BoundsComparisonResult.PARTIALLY_INSIDE;
}
function compareBounds(needleLowerBound, needleUpperBound, haystackLowerBound, haystackUpperBound) {
    let curResult = BoundsComparisonResult.FULLY_INSIDE;
    for (let i = 0; i < 3; ++i) {
        let newResult = compareBoundsSingleDimension(needleLowerBound[i], needleUpperBound[i], haystackLowerBound[i], haystackUpperBound[i]);
        switch (newResult) {
            case BoundsComparisonResult.FULLY_OUTSIDE:
                return newResult;
            case BoundsComparisonResult.PARTIALLY_INSIDE:
                curResult = newResult;
                break;
        }
    }
    return curResult;
}
function getTransformedSources(renderLayer) {
    const { transform } = renderLayer;
    let { transformedSources } = renderLayer;
    const generation = transform.changed.count;
    if (generation !== renderLayer.transformedSourcesGeneration) {
        renderLayer.transformedSourcesGeneration = generation;
        if (neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].equals(transform.transform, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["identityMat4"])) {
            transformedSources = renderLayer.sources.map(alternatives => alternatives.map(source => ({
                source,
                chunkLayout: source.spec.chunkLayout,
                voxelSize: source.spec.voxelSize
            })));
        }
        else {
            transformedSources = renderLayer.sources.map(alternatives => alternatives.map(source => {
                const chunkLayout = source.spec.chunkLayout;
                const transformedChunkLayout = neuroglancer_sliceview_chunk_layout__WEBPACK_IMPORTED_MODULE_0__["ChunkLayout"].get(chunkLayout.size, getCombinedTransform(chunkLayout.transform, transform));
                return {
                    chunkLayout: transformedChunkLayout,
                    source,
                    voxelSize: transformedChunkLayout.localSpatialVectorToGlobal(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), source.spec.voxelSize),
                };
            }));
        }
        renderLayer.transformedSources = transformedSources;
    }
    return transformedSources;
}
function pickBestAlternativeSource(zAxis, alternatives) {
    let numAlternatives = alternatives.length;
    let bestAlternativeIndex = 0;
    if (DEBUG_VISIBLE_SOURCES) {
        console.log(alternatives);
    }
    if (numAlternatives > 1) {
        let bestSliceArea = 0;
        for (let alternativeIndex = 0; alternativeIndex < numAlternatives; ++alternativeIndex) {
            let alternative = alternatives[alternativeIndex];
            const { chunkLayout } = alternative;
            let sliceArea = estimateSliceAreaPerChunk(zAxis, chunkLayout);
            if (DEBUG_VISIBLE_SOURCES) {
                console.log(`zAxis = ${zAxis}, chunksize = ${chunkLayout.size}, sliceArea = ${sliceArea}`);
            }
            if (sliceArea > bestSliceArea) {
                bestSliceArea = sliceArea;
                bestAlternativeIndex = alternativeIndex;
            }
        }
    }
    return alternatives[bestAlternativeIndex];
}
const tempCorners = [neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create()];
class SliceViewBase extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_5__["SharedObject"] {
    constructor() {
        super();
        this.width = -1;
        this.height = -1;
        this.hasViewportToData = false;
        /**
         * Specifies whether width, height, and viewportToData are valid.
         */
        this.hasValidViewport = false;
        // Transforms (x,y) viewport coordinates in the range:
        //
        // x=[left: -width/2, right: width/2] and
        //
        // y=[top: -height/2, bottom: height/2],
        //
        // to data coordinates.
        this.viewportToData = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].create();
        // Normalized x, y, and z viewport axes in data coordinate space.
        this.viewportAxes = [neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create()];
        // Viewport axes used for selecting visible sources.
        this.previousViewportAxes = [neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create()];
        this.centerDataPosition = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        this.viewportPlaneDistanceToOrigin = 0;
        /**
         * For each visible ChunkLayout, maps each visible GenericVolumeChunkSource to its priority index.
         * Overall chunk priority ordering is based on a lexicographical ordering of (priorityIndex,
         * -distanceToCenter).
         */
        this.visibleChunkLayouts = new Map();
        this.visibleLayers = new Map();
        this.visibleSourcesStale = true;
        /**
         * Size in spatial units (nm) of a single pixel.
         */
        this.pixelSize = 0;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].identity(this.viewportToData);
    }
    /**
     * Called when hasValidViewport == true and the viewport width/height or data transform matrix
     * changes.
     */
    onViewportChanged() { }
    maybeSetHasValidViewport() {
        if (!this.hasValidViewport && this.width !== -1 && this.height !== -1 &&
            this.hasViewportToData) {
            this.hasValidViewport = true;
            this.onHasValidViewport();
        }
        if (this.hasValidViewport) {
            this.onViewportChanged();
        }
    }
    onHasValidViewport() { }
    setViewportSize(width, height) {
        if (width !== this.width || height !== this.height) {
            this.width = width;
            this.height = height;
            this.maybeSetHasValidViewport();
            return true;
        }
        return false;
    }
    setViewportToDataMatrix(mat) {
        if (this.hasViewportToData && neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].equals(this.viewportToData, mat)) {
            return false;
        }
        this.hasViewportToData = true;
        let { viewportToData } = this;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].copy(viewportToData, mat);
        Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["rectifyTransformMatrixIfAxisAligned"])(viewportToData);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(this.centerDataPosition, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kZeroVec"], mat);
        // Initialize to zero to avoid confusing TypeScript compiler.
        let newPixelSize = 0;
        // Swap previousViewportAxes with viewportAxes.
        let viewportAxes = this.viewportAxes;
        let previousViewportAxes = this.previousViewportAxes;
        // Compute axes.
        for (var i = 0; i < 3; ++i) {
            let a = viewportAxes[i];
            Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["transformVectorByMat4"])(a, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][i], viewportToData);
            // a[3] is guaranteed to be 0.
            if (i === 0) {
                newPixelSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].length(a);
            }
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].normalize(a, a);
        }
        this.viewportAxes = viewportAxes;
        this.previousViewportAxes = previousViewportAxes;
        if (!Object(neuroglancer_util_compare__WEBPACK_IMPORTED_MODULE_2__["approxEqual"])(newPixelSize, this.pixelSize) ||
            (neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].dot(viewportAxes[0], previousViewportAxes[0]) < 0.95) ||
            (neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].dot(viewportAxes[1], previousViewportAxes[1]) < 0.95)) {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].copy(previousViewportAxes[0], viewportAxes[0]);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].copy(previousViewportAxes[1], viewportAxes[1]);
            this.visibleSourcesStale = true;
            this.pixelSize = newPixelSize;
        }
        // Compute viewport plane distance to origin.
        this.viewportPlaneDistanceToOrigin = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].dot(this.centerDataPosition, this.viewportAxes[2]);
        this.onViewportToDataMatrixChanged();
        this.maybeSetHasValidViewport();
        return true;
    }
    onViewportToDataMatrixChanged() { }
    /**
     * Computes the list of sources to use for each visible layer, based on the
     * current pixelSize.
     */
    updateVisibleSources() {
        if (!this.visibleSourcesStale) {
            return;
        }
        this.visibleSourcesStale = false;
        // Increase pixel size by a small margin.
        let pixelSize = this.pixelSize * 1.1;
        // console.log("pixelSize", pixelSize);
        let visibleChunkLayouts = this.visibleChunkLayouts;
        const zAxis = this.viewportAxes[2];
        let visibleLayers = this.visibleLayers;
        visibleChunkLayouts.clear();
        for (let [renderLayer, visibleSources] of visibleLayers) {
            visibleSources.length = 0;
            let transformedSources = getTransformedSources(renderLayer);
            let numSources = transformedSources.length;
            let scaleIndex;
            // At the smallest scale, all alternative sources must have the same voxel size, which is
            // considered to be the base voxel size.
            let smallestVoxelSize = transformedSources[0][0].voxelSize;
            const renderScaleTarget = renderLayer.renderScaleTarget.value;
            /**
             * Determines whether we should continue to look for a finer-resolution source *after* one
             * with the specified voxelSize.
             */
            const canImproveOnVoxelSize = (voxelSize) => {
                const targetSize = pixelSize * renderScaleTarget;
                for (let i = 0; i < 3; ++i) {
                    const size = voxelSize[i];
                    // If size <= pixelSize, no need for improvement.
                    // If size === smallestVoxelSize, also no need for improvement.
                    if (size > targetSize && size > 1.01 * smallestVoxelSize[i]) {
                        return true;
                    }
                }
                return false;
            };
            const improvesOnPrevVoxelSize = (voxelSize, prevVoxelSize) => {
                const targetSize = pixelSize * renderScaleTarget;
                for (let i = 0; i < 3; ++i) {
                    const size = voxelSize[i];
                    const prevSize = prevVoxelSize[i];
                    if (Math.abs(targetSize - size) < Math.abs(targetSize - prevSize) &&
                        size < 1.01 * prevSize) {
                        return true;
                    }
                }
                return false;
            };
            /**
             * Registers a source as being visible.  This should be called with consecutively decreasing
             * values of scaleIndex.
             */
            const addVisibleSource = (transformedSource, sourceScaleIndex) => {
                // Add to end of visibleSources list.  We will reverse the list after all sources are
                // added.
                const { source, chunkLayout } = transformedSource;
                visibleSources[visibleSources.length++] = transformedSource;
                let existingSources = visibleChunkLayouts.get(chunkLayout);
                if (existingSources === undefined) {
                    existingSources = new Map();
                    visibleChunkLayouts.set(chunkLayout, existingSources);
                }
                existingSources.set(source, sourceScaleIndex);
            };
            scaleIndex = numSources - 1;
            let prevVoxelSize;
            while (true) {
                const transformedSource = pickBestAlternativeSource(zAxis, transformedSources[scaleIndex]);
                if (prevVoxelSize !== undefined &&
                    !improvesOnPrevVoxelSize(transformedSource.voxelSize, prevVoxelSize)) {
                    break;
                }
                addVisibleSource(transformedSource, scaleIndex);
                if (scaleIndex === 0 || !canImproveOnVoxelSize(transformedSource.voxelSize)) {
                    break;
                }
                prevVoxelSize = transformedSource.voxelSize;
                --scaleIndex;
            }
            // Reverse visibleSources list since we added sources from coarsest to finest resolution, but
            // we want them ordered from finest to coarsest.
            visibleSources.reverse();
        }
    }
    computeVisibleChunks(getLayoutObject, addChunk) {
        this.updateVisibleSources();
        // Lower and upper bound in global data coordinates.
        const globalCorners = tempCorners;
        let { width, height, viewportToData } = this;
        for (let i = 0; i < 3; ++i) {
            globalCorners[0][i] = -neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][0][i] * width / 2 - neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][1][i] * height / 2;
            globalCorners[1][i] = -neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][0][i] * width / 2 + neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][1][i] * height / 2;
            globalCorners[2][i] = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][0][i] * width / 2 - neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][1][i] * height / 2;
            globalCorners[3][i] = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][0][i] * width / 2 + neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kAxes"][1][i] * height / 2;
        }
        for (let i = 0; i < 4; ++i) {
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(globalCorners[i], globalCorners[i], viewportToData);
        }
        // console.log("data bounds", dataLowerBound, dataUpperBound);
        // These variables hold the lower and upper bounds on chunk grid positions that intersect the
        // viewing plane.
        var lowerChunkBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        var upperChunkBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        let sourcesLowerChunkBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        let sourcesUpperChunkBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        // Vertex with maximal dot product with the positive viewport plane normal.
        // Implicitly, negativeVertex = 1 - positiveVertex.
        var positiveVertex = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        var planeNormal = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        // Sources whose bounds partially contain the current bounding box.
        let partiallyVisibleSources = new Array();
        // Sources whose bounds fully contain the current bounding box.
        let fullyVisibleSources = new Array();
        this.visibleChunkLayouts.forEach((visibleSources, chunkLayout) => {
            let layoutObject = getLayoutObject(chunkLayout);
            computeSourcesChunkBounds(sourcesLowerChunkBound, sourcesUpperChunkBound, visibleSources.keys());
            if (DEBUG_CHUNK_INTERSECTIONS) {
                console.log(`Initial sources chunk bounds: ` +
                    `${neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(sourcesLowerChunkBound)}, ${neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(sourcesUpperChunkBound)}`);
            }
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].set(lowerChunkBound, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].set(upperChunkBound, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            chunkLayout.globalToLocalSpatialVector(planeNormal, this.viewportAxes[2]);
            for (let i = 0; i < 3; ++i) {
                positiveVertex[i] = planeNormal[i] > 0 ? 1 : 0;
            }
            // Center position in chunk grid coordinates.
            const planeDistanceToOrigin = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].dot(chunkLayout.globalToLocalGrid(tempVec3, this.centerDataPosition), planeNormal);
            for (let i = 0; i < 4; ++i) {
                const localCorner = chunkLayout.globalToLocalGrid(tempVec3, globalCorners[i]);
                for (let j = 0; j < 3; ++j) {
                    lowerChunkBound[j] = Math.min(lowerChunkBound[j], Math.floor(localCorner[j]));
                    upperChunkBound[j] = Math.max(upperChunkBound[j], Math.floor(localCorner[j]) + 1);
                }
            }
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].max(lowerChunkBound, lowerChunkBound, sourcesLowerChunkBound);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].min(upperChunkBound, upperChunkBound, sourcesUpperChunkBound);
            // console.log('chunkBounds', lowerBound, upperBound);
            // Checks whether [lowerBound, upperBound) intersects the viewport plane.
            //
            // positiveVertexDistanceToOrigin = dot(planeNormal, lowerBound +
            // positiveVertex * (upperBound - lowerBound)) - planeDistanceToOrigin;
            // negativeVertexDistanceToOrigin = dot(planeNormal, lowerBound +
            // negativeVertex * (upperBound - lowerBound)) - planeDistanceToOrigin;
            //
            // positive vertex must have positive distance, and negative vertex must
            // have negative distance.
            function intersectsPlane() {
                var positiveVertexDistanceToOrigin = 0;
                var negativeVertexDistanceToOrigin = 0;
                // Check positive vertex.
                for (let i = 0; i < 3; ++i) {
                    let normalValue = planeNormal[i];
                    let lowerValue = lowerChunkBound[i];
                    let upperValue = upperChunkBound[i];
                    let diff = upperValue - lowerValue;
                    let positiveOffset = positiveVertex[i] * diff;
                    // console.log(
                    //     normalValue, lowerValue, upperValue, diff, positiveOffset,
                    //     positiveVertexDistanceToOrigin, negativeVertexDistanceToOrigin);
                    positiveVertexDistanceToOrigin += normalValue * (lowerValue + positiveOffset);
                    negativeVertexDistanceToOrigin += normalValue * (lowerValue + diff - positiveOffset);
                }
                if (DEBUG_CHUNK_INTERSECTIONS) {
                    console.log(`    planeNormal = ${planeNormal}`);
                    console.log('    {positive,negative}VertexDistanceToOrigin: ', positiveVertexDistanceToOrigin, negativeVertexDistanceToOrigin, planeDistanceToOrigin);
                    console.log('    intersectsPlane:', negativeVertexDistanceToOrigin, planeDistanceToOrigin, positiveVertexDistanceToOrigin);
                }
                if (positiveVertexDistanceToOrigin < planeDistanceToOrigin) {
                    return false;
                }
                return negativeVertexDistanceToOrigin <= planeDistanceToOrigin;
            }
            fullyVisibleSources.length = 0;
            partiallyVisibleSources.length = 0;
            for (let source of visibleSources.keys()) {
                let spec = source.spec;
                let result = compareBounds(lowerChunkBound, upperChunkBound, spec.lowerChunkBound, spec.upperChunkBound);
                if (DEBUG_CHUNK_INTERSECTIONS) {
                    console.log(`Comparing source bounds lowerBound=${neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(lowerChunkBound)}, ` +
                        `upperBound=${neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(upperChunkBound)}, ` +
                        `lowerChunkBound=${neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(spec.lowerChunkBound)}, ` +
                        `upperChunkBound=${neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(spec.upperChunkBound)}, ` +
                        `got ${BoundsComparisonResult[result]}`, spec, source);
                }
                switch (result) {
                    case BoundsComparisonResult.FULLY_INSIDE:
                        fullyVisibleSources.push(source);
                        break;
                    case BoundsComparisonResult.PARTIALLY_INSIDE:
                        partiallyVisibleSources.push(source);
                        break;
                }
            }
            let partiallyVisibleSourcesLength = partiallyVisibleSources.length;
            // Mutates lowerBound and upperBound while running, but leaves them the
            // same once finished.
            function checkBounds(nextSplitDim) {
                if (DEBUG_CHUNK_INTERSECTIONS) {
                    console.log(`chunk bounds: ${lowerChunkBound} ${upperChunkBound} ` +
                        `fullyVisible: ${fullyVisibleSources} partiallyVisible: ` +
                        `${partiallyVisibleSources.slice(0, partiallyVisibleSourcesLength)}`);
                }
                if (fullyVisibleSources.length === 0 && partiallyVisibleSourcesLength === 0) {
                    if (DEBUG_CHUNK_INTERSECTIONS) {
                        console.log('  no visible sources');
                    }
                    return;
                }
                if (DEBUG_CHUNK_INTERSECTIONS) {
                    console.log(`Check bounds: [ ${neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(lowerChunkBound)}, ${neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(upperChunkBound)} ]`);
                }
                var volume = 1;
                for (let i = 0; i < 3; ++i) {
                    volume *= Math.max(0, upperChunkBound[i] - lowerChunkBound[i]);
                }
                if (volume === 0) {
                    if (DEBUG_CHUNK_INTERSECTIONS) {
                        console.log('  volume == 0');
                    }
                    return;
                }
                if (!intersectsPlane()) {
                    if (DEBUG_CHUNK_INTERSECTIONS) {
                        console.log('  doesn\'t intersect plane');
                    }
                    return;
                }
                if (DEBUG_CHUNK_INTERSECTIONS) {
                    console.log('Within bounds: [' + neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(lowerChunkBound) + ', ' + neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].str(upperChunkBound) +
                        ']');
                }
                if (volume === 1) {
                    addChunk(chunkLayout, layoutObject, lowerChunkBound, fullyVisibleSources);
                    return;
                }
                var dimLower, dimUpper, diff;
                while (true) {
                    dimLower = lowerChunkBound[nextSplitDim];
                    dimUpper = upperChunkBound[nextSplitDim];
                    diff = dimUpper - dimLower;
                    if (diff === 1) {
                        nextSplitDim = (nextSplitDim + 1) % 3;
                    }
                    else {
                        break;
                    }
                }
                let splitPoint = dimLower + Math.floor(0.5 * diff);
                let newNextSplitDim = (nextSplitDim + 1) % 3;
                let fullyVisibleSourcesLength = fullyVisibleSources.length;
                upperChunkBound[nextSplitDim] = splitPoint;
                let oldPartiallyVisibleSourcesLength = partiallyVisibleSourcesLength;
                function adjustSources() {
                    partiallyVisibleSourcesLength = Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_1__["partitionArray"])(partiallyVisibleSources, 0, oldPartiallyVisibleSourcesLength, source => {
                        let spec = source.spec;
                        let result = compareBounds(lowerChunkBound, upperChunkBound, spec.lowerChunkBound, spec.upperChunkBound);
                        switch (result) {
                            case BoundsComparisonResult.PARTIALLY_INSIDE:
                                return true;
                            case BoundsComparisonResult.FULLY_INSIDE:
                                fullyVisibleSources.push(source);
                            default:
                                return false;
                        }
                    });
                }
                adjustSources();
                checkBounds(newNextSplitDim);
                // Truncate list of fully visible sources.
                fullyVisibleSources.length = fullyVisibleSourcesLength;
                // Restore partiallyVisibleSources.
                partiallyVisibleSourcesLength = oldPartiallyVisibleSourcesLength;
                upperChunkBound[nextSplitDim] = dimUpper;
                lowerChunkBound[nextSplitDim] = splitPoint;
                adjustSources();
                checkBounds(newNextSplitDim);
                lowerChunkBound[nextSplitDim] = dimLower;
                // Truncate list of fully visible sources.
                fullyVisibleSources.length = fullyVisibleSourcesLength;
                // Restore partiallyVisibleSources.
                partiallyVisibleSourcesLength = oldPartiallyVisibleSourcesLength;
            }
            checkBounds(0);
        });
    }
}
/**
 * By default, choose a chunk size with at most 2^18 = 262144 voxels.
 */
const DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 = 18;
/**
 * Determines a near-isotropic (in global spatial coordinates) block size.  All dimensions will be
 * powers of 2, and will not exceed upperVoxelBound - lowerVoxelBound.  The total number of voxels
 * will not exceed maxVoxelsPerChunkLog2.
 */
function getNearIsotropicBlockSize(options) {
    let { voxelSize, lowerVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kZeroVec"], upperVoxelBound, maxVoxelsPerChunkLog2 = DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2, transform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["identityMat4"], maxBlockSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kInfinityVec"], } = options;
    maxVoxelsPerChunkLog2 -= Math.log2(options.numChannels);
    // Adjust voxelSize by effective scaling factor.
    let temp = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["effectiveScalingFactorFromMat4"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), transform);
    voxelSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].multiply(temp, temp, voxelSize);
    let chunkDataSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].fromValues(1, 1, 1);
    let maxChunkDataSize;
    if (upperVoxelBound === undefined) {
        maxChunkDataSize = maxBlockSize;
    }
    else {
        maxChunkDataSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        for (let i = 0; i < 3; ++i) {
            maxChunkDataSize[i] =
                Math.pow(2, Math.floor(Math.log2(upperVoxelBound[i] - lowerVoxelBound[i])));
        }
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].min(maxChunkDataSize, maxChunkDataSize, maxBlockSize);
    }
    // Determine the dimension in which chunkDataSize should be increased.  This is the smallest
    // dimension (in nanometers) that is < maxChunkDataSize (in voxels).
    //
    // Returns -1 if there is no such dimension.
    function findNextDimension() {
        let minSize = Infinity;
        let minDimension = -1;
        for (let i = 0; i < 3; ++i) {
            if (chunkDataSize[i] >= maxChunkDataSize[i]) {
                continue;
            }
            let size = chunkDataSize[i] * voxelSize[i];
            if (size < minSize) {
                minSize = size;
                minDimension = i;
            }
        }
        return minDimension;
    }
    for (let i = 0; i < maxVoxelsPerChunkLog2; ++i) {
        let nextDim = findNextDimension();
        if (nextDim === -1) {
            break;
        }
        chunkDataSize[nextDim] *= 2;
    }
    return chunkDataSize;
}
/**
 * Computes a 3-d block size that has depth 1 in flatDimension and is near-isotropic (in nanometers)
 * in the other two dimensions.  The remaining options are the same as for
 * getNearIsotropicBlockSize.
 */
function getTwoDimensionalBlockSize(options) {
    let { lowerVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kZeroVec"], upperVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kInfinityVec"], flatDimension, voxelSize, maxVoxelsPerChunkLog2, transform } = options;
    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].subtract(tempVec3, upperVoxelBound, lowerVoxelBound);
    tempVec3[flatDimension] = 1;
    return getNearIsotropicBlockSize({
        voxelSize,
        upperVoxelBound: tempVec3,
        maxVoxelsPerChunkLog2,
        transform,
        numChannels: options.numChannels
    });
}
/**
 * Returns an array of [xy, xz, yz] 2-dimensional block sizes.
 */
function getTwoDimensionalBlockSizes(options) {
    let chunkDataSizes = new Array();
    for (let i = 0; i < 3; ++i) {
        chunkDataSizes[i] = getTwoDimensionalBlockSize({
            numChannels: options.numChannels,
            flatDimension: i,
            voxelSize: options.voxelSize,
            lowerVoxelBound: options.lowerVoxelBound,
            upperVoxelBound: options.upperVoxelBound,
            maxVoxelsPerChunkLog2: options.maxVoxelsPerChunkLog2,
            transform: options.transform,
        });
    }
    return chunkDataSizes;
}
var ChunkLayoutPreference;
(function (ChunkLayoutPreference) {
    /**
     * Indicates that isotropic chunks are desired.
     */
    ChunkLayoutPreference[ChunkLayoutPreference["ISOTROPIC"] = 0] = "ISOTROPIC";
    /**
     * Indicates that 2-D chunks are desired.
     */
    ChunkLayoutPreference[ChunkLayoutPreference["FLAT"] = 1] = "FLAT";
})(ChunkLayoutPreference || (ChunkLayoutPreference = {}));
function getCombinedTransform(transform, options) {
    let additionalTransform = options.transform;
    if (additionalTransform === undefined) {
        if (transform === undefined) {
            return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["identityMat4"];
        }
        return transform;
    }
    if (transform === undefined) {
        return additionalTransform;
    }
    return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].create(), additionalTransform, transform);
}
function getChunkDataSizes(options) {
    if (options.chunkDataSizes !== undefined) {
        return options.chunkDataSizes;
    }
    const { chunkLayoutPreference = ChunkLayoutPreference.ISOTROPIC } = options;
    switch (chunkLayoutPreference) {
        case ChunkLayoutPreference.ISOTROPIC:
            return [getNearIsotropicBlockSize(options)];
        case ChunkLayoutPreference.FLAT:
            let chunkDataSizes = getTwoDimensionalBlockSizes(options);
            chunkDataSizes.push(getNearIsotropicBlockSize(options));
            return chunkDataSizes;
    }
    throw new Error(`Invalid chunk layout preference: ${chunkLayoutPreference}.`);
}
/**
 * Generic specification for SliceView chunks specifying a layout and voxel size.
 */
class SliceViewChunkSpecification {
    constructor(options) {
        let { chunkSize, voxelSize, transform, lowerChunkBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["kZeroVec"], upperChunkBound, } = options;
        this.voxelSize = voxelSize;
        this.chunkLayout = neuroglancer_sliceview_chunk_layout__WEBPACK_IMPORTED_MODULE_0__["ChunkLayout"].get(chunkSize, transform);
        this.lowerChunkBound = lowerChunkBound;
        this.upperChunkBound = upperChunkBound;
    }
    toObject() {
        return {
            transform: this.chunkLayout.transform,
            chunkSize: this.chunkLayout.size,
            voxelSize: this.voxelSize,
            lowerChunkBound: this.lowerChunkBound,
            upperChunkBound: this.upperChunkBound,
        };
    }
}
const SLICEVIEW_RPC_ID = 'SliceView';
const SLICEVIEW_RENDERLAYER_RPC_ID = 'sliceview/RenderLayer';
const SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID = 'SliceView.addVisibleLayer';
const SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID = 'SliceView.removeVisibleLayer';
const SLICEVIEW_UPDATE_VIEW_RPC_ID = 'SliceView.updateView';
const SLICEVIEW_RENDERLAYER_UPDATE_TRANSFORM_RPC_ID = 'SliceView.updateTransform';


/***/ }),

/***/ "./src/neuroglancer/sliceview/bounding_box_shader_helper.ts":
/*!******************************************************************!*\
  !*** ./src/neuroglancer/sliceview/bounding_box_shader_helper.ts ***!
  \******************************************************************/
/*! exports provided: vertexBasePositions, SliceViewShaderBuffers, BoundingBoxCrossSectionRenderHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertexBasePositions", function() { return vertexBasePositions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewShaderBuffers", function() { return SliceViewShaderBuffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxCrossSectionRenderHelper", function() { return BoundingBoxCrossSectionRenderHelper; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for computing the intersection points between an axis-aligned bounding box and a
 * plane in a vertex shader.
 *
 * We use the approach described in the following paper to determine the
 * intersection between the
 * viewport plane and a given 3-D chunk inside of a WebGL vertex shader:
 *
 * A Vertex Program for Efficient Box-Plane Intersection
 * Christof Rezk Salama and Adreas Kolb
 * VMV 2005.
 * http://www.cg.informatik.uni-siegen.de/data/Publications/2005/rezksalamaVMV2005.pdf
 *
 */



const tempVec3 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
const tempVec3b = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
/**
 * Amount by which a computed intersection point may lie outside the [0, 1] range and still be
 * considered valid.  This needs to be non-zero in order to avoid vertex placement artifacts.
 */
const LAMBDA_EPSILON = 1e-3;
/**
 * If the absolute value of the dot product of a cube edge direction and the viewport plane normal
 * is less than this value, intersections along that cube edge will be exluded.  This needs to be
 * non-zero in order to avoid vertex placement artifacts.
 */
const ORTHOGONAL_EPSILON = 1e-3;
function findFrontVertexIndex(planeNormal) {
    // Determine which vertex is front.
    let frontVertexIndex = 0;
    for (var axis_i = 0; axis_i < 3; ++axis_i) {
        // If plane normal is negative in axis direction, then choose the vertex
        // with the maximum axis_i-coordinate.
        if (planeNormal[axis_i] < 0) {
            frontVertexIndex += (1 << axis_i);
        }
    }
    return frontVertexIndex;
}
// Specifies the positions of the 8 corners.
const vertexBasePositions = new Float32Array([
    0, 0, 0,
    1, 0, 0,
    0, 1, 0,
    1, 1, 0,
    0, 0, 1,
    1, 0, 1,
    0, 1, 1,
    1, 1, 1,
]);
class SliceViewShaderBuffers extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl) {
        super();
        this.outputVertexIndices = this.registerDisposer(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_2__["Buffer"].fromData(gl, new Float32Array([0, 1, 2, 3, 4, 5]), gl.ARRAY_BUFFER, gl.STATIC_DRAW));
        // This specifies the original, "uncorrected" vertex positions.
        // var vertexBasePositions = [
        //   0, 0, 0,
        //   1, 0, 0,
        //   0, 1, 0,
        //   0, 0, 1,
        //   1, 0, 1,
        //   1, 1, 0,
        //   0, 1, 1,
        //   1, 1, 1,
        // ];
        // correct_index, vertex_position, uncorrected_index
        // 0:  0, 0, 0   0
        // 1:  1, 0, 0   1
        // 2:  0, 1, 0   2
        // 4:  0, 0, 1   3
        // 5:  1, 0, 1   4
        // 3:  1, 1, 0   5
        // 6:  0, 1, 1   6
        // 7:  1, 1, 1   7
        // This maps uncorrected vertex indices to corrected vertex indices.
        let vertexUncorrectedToCorrected = [0, 1, 2, 4, 5, 3, 6, 7];
        // This maps corrected vertex indices to uncorrected vertex indices.
        let vertexCorrectedToUncorrected = [0, 1, 2, 5, 3, 4, 6, 7];
        // Page 666
        let vertexBaseIndices = [
            0, 1, 1, 4, 4, 7, 4, 7,
            1, 5, 0, 1, 1, 4, 4, 7,
            0, 2, 2, 5, 5, 7, 5, 7,
            2, 6, 0, 2, 2, 5, 5, 7,
            0, 3, 3, 6, 6, 7, 6, 7,
            3, 4, 0, 3, 3, 6, 6, 7,
        ];
        // Determined by looking at the figure and determining the corresponding
        // vertex order for each possible front vertex.
        let vertexPermutation = [
            0, 1, 2, 3, 4, 5, 6, 7,
            1, 4, 5, 0, 3, 7, 2, 6,
            2, 6, 0, 5, 7, 3, 1, 4,
            3, 0, 6, 4, 1, 2, 7, 5,
            4, 3, 7, 1, 0, 6, 5, 2,
            5, 2, 1, 7, 6, 0, 4, 3,
            6, 7, 3, 2, 5, 4, 0, 1,
            7, 5, 4, 6, 2, 1, 3, 0,
        ];
        let vertexIndices = [];
        for (var p = 0; p < 8; ++p) {
            for (var i = 0; i < vertexBaseIndices.length; ++i) {
                const vertexPermutationIndex = vertexCorrectedToUncorrected[p] * 8 + vertexBaseIndices[i];
                vertexIndices.push(vertexUncorrectedToCorrected[vertexPermutation[vertexPermutationIndex]]);
            }
        }
        this.vertexIndices = new Int32Array(vertexIndices);
    }
    static get(gl) {
        return gl.memoize.get('SliceViewShaderBuffers', () => new SliceViewShaderBuffers(gl));
    }
}
class BoundingBoxCrossSectionRenderHelper extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    static get(gl) {
        return gl.memoize.get('BoundingBoxCrossSectionRenderHelper', () => new BoundingBoxCrossSectionRenderHelper(gl));
    }
    constructor(gl) {
        super();
        this.data = this.registerDisposer(SliceViewShaderBuffers.get(gl));
    }
    defineShader(builder) {
        // Slice plane normal.
        builder.addUniform('highp vec3', 'uPlaneNormal');
        // Distance from the origin to the slice plane.
        builder.addUniform('highp float', 'uPlaneDistance');
        // Two-dimensional array of dimensions [6x4], specifying the first and
        // second vertex index for each of the 4 candidate edges to test for each
        // computed vertex.
        builder.addUniform('highp ivec2', 'uVertexIndex', 24);
        // Base vertex positions.
        builder.addUniform('highp vec3', 'uVertexBasePosition', 8);
        builder.addInitializer(shader => {
            shader.gl.uniform3fv(shader.uniform('uVertexBasePosition'), vertexBasePositions);
        });
        builder.addVertexCode(`
vec3 getBoundingBoxPlaneIntersectionVertexPosition(vec3 chunkSize, vec3 boxLower, vec3 lowerClipBound, vec3 upperClipBound, int vertexIndex) {
  for (int e = 0; e < 4; ++e) {
    highp ivec2 vidx = uVertexIndex[vertexIndex*4 + e];
    highp vec3 v1 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.x] + boxLower));
    highp vec3 v2 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.y] + boxLower));
    highp vec3 vDir = v2 - v1;
    highp float denom = dot(vDir, uPlaneNormal);
    if (abs(denom) > ${ORTHOGONAL_EPSILON}) {
      highp float lambda = (uPlaneDistance - dot(v1, uPlaneNormal)) / denom;
      if ((lambda >= -${LAMBDA_EPSILON}) && (lambda <= (1.0 + ${LAMBDA_EPSILON}))) {
        lambda = clamp(lambda, 0.0, 1.0);
        highp vec3 position = v1 + lambda * vDir;
        return position;
      }
    }
  }
  return vec3(0, 0, 0);
}
`);
    }
    computeVertexPositionDebug(chunkSize, uLowerClipBound, uUpperClipBound, uPlaneDistance, uPlaneNormal, uTranslation, vertexIndex) {
        let frontVertexIndex = findFrontVertexIndex(uPlaneNormal);
        let uVertexIndex = this.data.vertexIndices.subarray(frontVertexIndex * 48, (frontVertexIndex + 1) * 48);
        let vidx = [0, 0];
        let v = [neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create(), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create()];
        let vDir = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create(), position = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
        let uVertexBasePosition = (i) => vertexBasePositions.subarray(i * 3, i * 3 + 3);
        for (let e = 0; e < 4; ++e) {
            for (let j = 0; j < 2; ++j) {
                vidx[j] = uVertexIndex[2 * (vertexIndex * 4 + e) + j];
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].multiply(v[j], chunkSize, uVertexBasePosition(vidx[j]));
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].add(v[j], v[j], uTranslation);
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].min(v[j], v[j], uUpperClipBound);
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].max(v[j], v[j], uLowerClipBound);
            }
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].subtract(vDir, v[1], v[0]);
            let denom = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].dot(vDir, uPlaneNormal);
            if (Math.abs(denom) > ORTHOGONAL_EPSILON) {
                let lambda = (uPlaneDistance - neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].dot(v[0], uPlaneNormal)) / denom;
                if ((lambda >= -LAMBDA_EPSILON) && (lambda <= 1.0 + LAMBDA_EPSILON)) {
                    lambda = Math.max(0, Math.min(1, lambda));
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].scaleAndAdd(position, v[0], vDir, lambda);
                    return position;
                }
                else {
                    console.log(`vertex ${vertexIndex}, e = ${e}, skipped, deom = ${denom}, ` +
                        `vDir = ${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3Key"])(vDir)}, ` +
                        `uPlaneNormal = ${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3Key"])(uPlaneNormal)}, ` +
                        `lambda=${lambda}`);
                }
            }
            else {
                console.log(`vertex ${vertexIndex}, e = ${e}, skipped, deom = ${denom}, ` +
                    `vDir = ${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3Key"])(vDir)}, uPlaneNormal = ${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3Key"])(uPlaneNormal)}`);
            }
        }
        return undefined;
    }
    setPlane(shader, planeNormal, planeDistanceToOrigin) {
        const { gl } = shader;
        gl.uniform3fv(shader.uniform('uPlaneNormal'), planeNormal);
        gl.uniform1f(shader.uniform('uPlaneDistance'), planeDistanceToOrigin);
        const frontVertexIndex = findFrontVertexIndex(planeNormal);
        gl.uniform2iv(shader.uniform('uVertexIndex'), this.data.vertexIndices.subarray(frontVertexIndex * 48, (frontVertexIndex + 1) * 48));
    }
    setViewportPlane(shader, viewportZAxis, viewportCenterPosition, dataToObjectTransform) {
        const localPlaneNormal = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["transformVectorByMat4"])(tempVec3, viewportZAxis, dataToObjectTransform);
        const planeDistanceToOrigin = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].dot(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat4(tempVec3b, viewportCenterPosition, dataToObjectTransform), localPlaneNormal);
        this.setPlane(shader, localPlaneNormal, planeDistanceToOrigin);
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/chunk_format_handlers.ts":
/*!*************************************************************!*\
  !*** ./src/neuroglancer/sliceview/chunk_format_handlers.ts ***!
  \*************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var neuroglancer_sliceview_uncompressed_chunk_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/uncompressed_chunk_format */ "./src/neuroglancer/sliceview/uncompressed_chunk_format.ts");
/* harmony import */ var neuroglancer_sliceview_compressed_segmentation_chunk_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/sliceview/compressed_segmentation/chunk_format */ "./src/neuroglancer/sliceview/compressed_segmentation/chunk_format.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/***/ }),

/***/ "./src/neuroglancer/sliceview/chunk_layout.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/sliceview/chunk_layout.ts ***!
  \****************************************************/
/*! exports provided: ChunkLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkLayout", function() { return ChunkLayout; });
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ChunkLayout {
    constructor(size, transform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["identityMat4"]) {
        this.size = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].clone(size);
        this.transform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].clone(transform);
        this.invTransform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].invert(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(), transform);
    }
    toObject(msg) {
        msg['size'] = this.size;
        msg['transform'] = this.transform;
    }
    static get(size, transform = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["identityMat4"]) {
        let cache = ChunkLayout.cache;
        const key = JSON.stringify([Array.from(size), Array.from(transform)]);
        let obj = cache.get(key);
        if (obj === undefined) {
            obj = new ChunkLayout(size, transform);
            cache.set(key, obj);
        }
        return obj;
    }
    static fromObject(msg) {
        return ChunkLayout.get(msg['size'], msg['transform']);
    }
    /**
     * Transform local spatial coordinates to global spatial coordinates.
     */
    localSpatialToGlobal(out, localSpatial) {
        return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(out, localSpatial, this.transform);
    }
    /**
     * Transform global spatial coordinates to local spatial coordinates.
     */
    globalToLocalSpatial(out, globalSpatial) {
        return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(out, globalSpatial, this.invTransform);
    }
    globalToLocalGrid(out, globalSpatial) {
        this.globalToLocalSpatial(out, globalSpatial);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].divide(out, out, this.size);
        return out;
    }
    localSpatialVectorToGlobal(out, localVector) {
        return Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["transformVectorByMat4"])(out, localVector, this.transform);
    }
    globalToLocalSpatialVector(out, globalVector) {
        return Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["transformVectorByMat4"])(out, globalVector, this.invTransform);
    }
    assignLocalSpatialToGlobalMat4(out) {
        return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(out, this.transform);
    }
}
ChunkLayout.cache = new Map();


/***/ }),

/***/ "./src/neuroglancer/sliceview/compressed_segmentation/chunk_format.ts":
/*!****************************************************************************!*\
  !*** ./src/neuroglancer/sliceview/compressed_segmentation/chunk_format.ts ***!
  \****************************************************************************/
/*! exports provided: ChunkFormat, CompressedSegmentationVolumeChunk, CompressedSegmentationChunkFormatHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkFormat", function() { return ChunkFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedSegmentationVolumeChunk", function() { return CompressedSegmentationVolumeChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedSegmentationChunkFormatHandler", function() { return CompressedSegmentationChunkFormatHandler; });
/* harmony import */ var neuroglancer_sliceview_compressed_segmentation_decode_uint32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/compressed_segmentation/decode_uint32 */ "./src/neuroglancer/sliceview/compressed_segmentation/decode_uint32.ts");
/* harmony import */ var neuroglancer_sliceview_compressed_segmentation_decode_uint64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/sliceview/compressed_segmentation/decode_uint64 */ "./src/neuroglancer/sliceview/compressed_segmentation/decode_uint64.ts");
/* harmony import */ var neuroglancer_sliceview_single_texture_chunk_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/sliceview/single_texture_chunk_format */ "./src/neuroglancer/sliceview/single_texture_chunk_format.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/webgl/shader_lib */ "./src/neuroglancer/webgl/shader_lib.ts");
/* harmony import */ var neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/webgl/texture_access */ "./src/neuroglancer/webgl/texture_access.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










class TextureLayout extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["RefCounted"] {
    constructor(gl, chunkDataSize, subchunkSize, dataLength) {
        super();
        this.chunkDataSize = chunkDataSize;
        this.subchunkSize = subchunkSize;
        Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_9__["compute1dTextureLayout"])(this, gl, /*texelsPerElement=*/ 1, dataLength);
        let subchunkGridSize = this.subchunkGridSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create();
        for (let i = 0; i < 3; ++i) {
            subchunkGridSize[i] = Math.ceil(chunkDataSize[i] / subchunkSize[i]);
        }
    }
    static get(gl, chunkDataSize, subchunkSize, dataLength) {
        return gl.memoize.get(`sliceview.CompressedSegmentationTextureLayout:${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3Key"])(chunkDataSize)},` +
            `${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3Key"])(subchunkSize)},${dataLength}`, () => new TextureLayout(gl, chunkDataSize, subchunkSize, dataLength));
    }
}
const textureFormat = Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_9__["computeTextureFormat"])(new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_9__["TextureFormat"](), neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"].UINT32);
class ChunkFormat extends neuroglancer_sliceview_single_texture_chunk_format__WEBPACK_IMPORTED_MODULE_2__["SingleTextureChunkFormat"] {
    constructor(dataType, subchunkSize, numChannels, key) {
        super(key);
        this.dataType = dataType;
        this.subchunkSize = subchunkSize;
        this.numChannels = numChannels;
        this.textureAccessHelper = new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_9__["OneDimensionalTextureAccessHelper"]('chunkData');
    }
    static get(gl, dataType, subchunkSize, numChannels) {
        let shaderKey = `sliceview.CompressedSegmentationChunkFormat:${dataType}:${numChannels}`;
        let cacheKey = `${shaderKey}:${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3Key"])(subchunkSize)}`;
        return gl.memoize.get(cacheKey, () => new ChunkFormat(dataType, subchunkSize, numChannels, shaderKey));
    }
    get shaderSamplerType() {
        return 'usampler2D';
    }
    defineShader(builder) {
        super.defineShader(builder);
        let { textureAccessHelper } = this;
        textureAccessHelper.defineShader(builder);
        let local = (x) => 'compressedSegmentationChunkFormat_' + x;
        builder.addUniform('highp ivec3', 'uSubchunkGridSize');
        builder.addUniform('highp ivec3', 'uSubchunkSize');
        builder.addFragmentCode(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_8__["glsl_getFortranOrderIndex"]);
        const { dataType } = this;
        const glslType = Object(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_8__["getShaderType"])(dataType);
        if (dataType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"].UINT64) {
            builder.addFragmentCode(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_8__["glsl_uint64"]);
        }
        else {
            builder.addFragmentCode(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_8__["glsl_uint32"]);
        }
        builder.addFragmentCode(textureAccessHelper.getAccessor(local('readTextureValue'), 'uVolumeChunkSampler', neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"].UINT32, 1));
        let fragmentCode = `
uint ${local('getChannelOffset')}(int channelIndex) {
  if (channelIndex == 0) {
    return ${this.numChannels}u;
  }
  return ${local('readTextureValue')}(uint(channelIndex)).value;
}
${glslType} getDataValue (int channelIndex) {
  ivec3 chunkPosition = getPositionWithinChunk();

  // TODO: maybe premultiply this and store as uniform.
  ivec3 subchunkGridPosition = chunkPosition / uSubchunkSize;
  int subchunkGridOffset = getFortranOrderIndex(subchunkGridPosition, uSubchunkGridSize);

  int channelOffset = int(${local('getChannelOffset')}(channelIndex));

  // TODO: Maybe just combine this offset into subchunkGridStrides.
  int subchunkHeaderOffset = subchunkGridOffset * 2 + channelOffset;

  highp uint subchunkHeader0 = ${local('readTextureValue')}(uint(subchunkHeaderOffset)).value;
  highp uint subchunkHeader1 = ${local('readTextureValue')}(uint(subchunkHeaderOffset + 1)).value;
  highp uint outputValueOffset = (subchunkHeader0 & 0xFFFFFFu) + uint(channelOffset);
  highp uint encodingBits = subchunkHeader0 >> 24u;
  if (encodingBits > 0u) {
    ivec3 subchunkPosition = chunkPosition - subchunkGridPosition * uSubchunkSize;
    int subchunkOffset = getFortranOrderIndex(subchunkPosition, uSubchunkSize);
    uint encodedValueBaseOffset = subchunkHeader1 + uint(channelOffset);
    uint encodedValueOffset = encodedValueBaseOffset + uint(subchunkOffset) * encodingBits / 32u;
    uint encodedValue = ${local('readTextureValue')}(encodedValueOffset).value;
    uint wordOffset = uint(subchunkOffset) * encodingBits % 32u;
    uint encodedValueShifted = encodedValue >> wordOffset;
    uint decodedValue = encodedValueShifted - (encodedValueShifted >> encodingBits << encodingBits);
    outputValueOffset += decodedValue * ${this.dataType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"].UINT64 ? '2u' : '1u'};
  }
  ${glslType} result;
`;
        if (dataType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"].UINT64) {
            fragmentCode += `
  result.value[0] = ${local('readTextureValue')}(outputValueOffset).value;
  result.value[1] = ${local('readTextureValue')}(outputValueOffset+1u).value;
`;
        }
        else {
            fragmentCode += `
  result.value = ${local('readTextureValue')}(outputValueOffset).value;
`;
        }
        fragmentCode += `
  return result;
}
`;
        builder.addFragmentCode(fragmentCode);
    }
    /**
     * Called each time textureLayout changes while drawing chunks.
     */
    setupTextureLayout(gl, shader, textureLayout) {
        const { subchunkGridSize } = textureLayout;
        gl.uniform3i(shader.uniform('uSubchunkGridSize'), subchunkGridSize[0], subchunkGridSize[1], subchunkGridSize[2]);
        this.textureAccessHelper.setupTextureLayout(gl, shader, textureLayout);
    }
    setTextureData(gl, textureLayout, data) {
        Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_9__["setOneDimensionalTextureData"])(gl, textureLayout, textureFormat, data);
    }
    getTextureLayout(gl, chunkDataSize, dataLength) {
        return TextureLayout.get(gl, chunkDataSize, this.subchunkSize, dataLength);
    }
    beginSource(gl, shader) {
        super.beginSource(gl, shader);
        const { subchunkSize } = this;
        gl.uniform3i(shader.uniform('uSubchunkSize'), subchunkSize[0], subchunkSize[1], subchunkSize[2]);
    }
}
class CompressedSegmentationVolumeChunk extends neuroglancer_sliceview_single_texture_chunk_format__WEBPACK_IMPORTED_MODULE_2__["SingleTextureVolumeChunk"] {
    setTextureData(gl) {
        let { data } = this;
        let { chunkFormat } = this;
        let textureLayout = this.textureLayout =
            chunkFormat.getTextureLayout(gl, this.chunkDataSize, data.length);
        chunkFormat.setTextureData(gl, textureLayout, data);
    }
    getChannelValueAt(dataPosition, channel) {
        let { chunkDataSize, chunkFormat } = this;
        let { data } = this;
        let offset = data[channel];
        if (chunkFormat.dataType === neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"].UINT64) {
            let result = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_7__["Uint64"]();
            Object(neuroglancer_sliceview_compressed_segmentation_decode_uint64__WEBPACK_IMPORTED_MODULE_1__["readSingleChannelValue"])(result, data, /*baseOffset=*/ offset, chunkDataSize, chunkFormat.subchunkSize, dataPosition);
            return result;
        }
        else {
            return Object(neuroglancer_sliceview_compressed_segmentation_decode_uint32__WEBPACK_IMPORTED_MODULE_0__["readSingleChannelValue"])(data, /*baseOffset=*/ offset, chunkDataSize, chunkFormat.subchunkSize, dataPosition);
        }
    }
}
class CompressedSegmentationChunkFormatHandler extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["RefCounted"] {
    constructor(gl, spec) {
        super();
        let { dataType } = spec;
        if (dataType !== neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"].UINT64 && dataType !== neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"].UINT32) {
            throw new Error(`Unsupported compressed segmentation data type: ${neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_3__["DataType"][dataType]}`);
        }
        this.chunkFormat = this.registerDisposer(ChunkFormat.get(gl, spec.dataType, spec.compressedSegmentationBlockSize, spec.numChannels));
    }
    getChunk(source, x) {
        return new CompressedSegmentationVolumeChunk(source, x);
    }
}
Object(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_4__["registerChunkFormatHandler"])((gl, spec) => {
    if (spec.compressedSegmentationBlockSize != null) {
        return new CompressedSegmentationChunkFormatHandler(gl, spec);
    }
    return null;
});


/***/ }),

/***/ "./src/neuroglancer/sliceview/compressed_segmentation/decode_common.ts":
/*!*****************************************************************************!*\
  !*** ./src/neuroglancer/sliceview/compressed_segmentation/decode_common.ts ***!
  \*****************************************************************************/
/*! exports provided: decodeValueOffset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeValueOffset", function() { return decodeValueOffset; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Support for decompressing uint32 and uint64 segment label chunks.
 */
/**
 * Determines the offset of the value at the specified dataPosition in a single-channel compressed
 * segmentation.
 *
 * @param baseOffset The base offset into `data' at which the compressed data for this channel
 * starts.
 * @param chunkDataSize A 3-element array specifying the size of the volume,
 * @param blockSize A 3-element array specifying the block size ued for compression.
 * @param dataPosition A 3-element array specifying the position within the volume from which to
 * read.
 * @returns The offset into `data', relative to baseOffset, at which the value is located.
 */
function decodeValueOffset(data, baseOffset, chunkDataSize, blockSize, dataPosition, uint32sPerElement) {
    let gridOffset = 0, subchunkOffset = 0, gridStride = 1, subchunkStride = 1;
    for (let i = 0; i < 3; ++i) {
        let posValue = dataPosition[i];
        let subchunkSizeValue = blockSize[i];
        let gridSubscript = Math.floor(posValue / subchunkSizeValue);
        let subchunkSubscript = posValue % subchunkSizeValue;
        gridOffset += gridSubscript * gridStride;
        gridStride *= Math.ceil(chunkDataSize[i] / subchunkSizeValue);
        subchunkOffset += subchunkSubscript * subchunkStride;
        subchunkStride *= subchunkSizeValue;
    }
    let subchunkHeaderOffset = baseOffset + gridOffset * 2;
    let subchunkHeader0 = data[subchunkHeaderOffset];
    let subchunkHeader1 = data[subchunkHeaderOffset + 1];
    let outputValueOffset = subchunkHeader0 & 0xFFFFFF;
    let encodingBits = (subchunkHeader0 >> 24) & 0xFF;
    if (encodingBits > 0) {
        let encodedValueBaseOffset = baseOffset + subchunkHeader1 & 0xFFFFFF;
        let encodedValueOffset = encodedValueBaseOffset + Math.floor(subchunkOffset * encodingBits / 32.0);
        let encodedValue = data[encodedValueOffset];
        let wordOffset = (subchunkOffset * encodingBits) % 32;
        let decodedValue = (encodedValue >> wordOffset) & ((1 << encodingBits) - 1);
        outputValueOffset += uint32sPerElement * decodedValue;
    }
    return outputValueOffset;
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/compressed_segmentation/decode_uint32.ts":
/*!*****************************************************************************!*\
  !*** ./src/neuroglancer/sliceview/compressed_segmentation/decode_uint32.ts ***!
  \*****************************************************************************/
/*! exports provided: readSingleChannelValue, readValue, decodeChannel, decodeChannels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readSingleChannelValue", function() { return readSingleChannelValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readValue", function() { return readValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeChannel", function() { return decodeChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeChannels", function() { return decodeChannels; });
/* harmony import */ var neuroglancer_sliceview_compressed_segmentation_decode_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/compressed_segmentation/decode_common */ "./src/neuroglancer/sliceview/compressed_segmentation/decode_common.ts");
// DO NOT EDIT.  Generated from
// templates/neuroglancer/sliceview/compressed_segmentation/decode.template.ts.
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Support for decompressing uint64 segment label chunks.
 */

/**
 * Reads the single value at the specified dataPosition in a single-channel compressed segmentation.
 *
 * @param baseOffset The base offset into `data' at which the compressed data for this channel
 * starts.
 * @param chunkDataSize A 3-element array specifying the size of the volume.
 * @param blockSize A 3-element array specifying the block size ued for compression.
 * @param dataPosition A 3-element array specifying the position within the volume from which to
 * read.
 *
 * Stores the result in `out'.
 */
function readSingleChannelValue(data, baseOffset, chunkDataSize, blockSize, dataPosition) {
    let outputValueOffset = Object(neuroglancer_sliceview_compressed_segmentation_decode_common__WEBPACK_IMPORTED_MODULE_0__["decodeValueOffset"])(data, baseOffset, chunkDataSize, blockSize, dataPosition, 1) + baseOffset;
    return data[outputValueOffset];
}
/**
 * Reads the single value (of a single channel) at the specified dataPosition in a multi-channel
 * compressed segmentation.
 *
 * @param dataPosition A 4-element [x, y, z, channel] array specifying the position to read.
 */
function readValue(data, baseOffset, chunkDataSize, blockSize, dataPosition) {
    return readSingleChannelValue(data, baseOffset + data[dataPosition[3]], chunkDataSize, blockSize, dataPosition);
}
/**
 * Decodes a single channel of a compressed segmentation.
 *
 * This is not particularly efficient, because it is intended for testing purposes only.
 */
function decodeChannel(out, data, baseOffset, chunkDataSize, blockSize) {
    const expectedLength = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2] * 1;
    if (expectedLength !== out.length) {
        throw new Error(`Output length ${out.length} is not equal to expected length ${expectedLength}.`);
    }
    let vx = chunkDataSize[0];
    let vy = chunkDataSize[1];
    let vz = chunkDataSize[2];
    let dataPosition = [0, 0, 0];
    let outputOffset = 0;
    for (let z = 0; z < vz; ++z) {
        dataPosition[2] = z;
        for (let y = 0; y < vy; ++y) {
            dataPosition[1] = y;
            for (let x = 0; x < vx; ++x) {
                dataPosition[0] = x;
                let outputValueOffset = Object(neuroglancer_sliceview_compressed_segmentation_decode_common__WEBPACK_IMPORTED_MODULE_0__["decodeValueOffset"])(data, baseOffset, chunkDataSize, blockSize, dataPosition, 1) +
                    baseOffset;
                out[outputOffset++] = data[outputValueOffset];
            }
        }
    }
    return out;
}
/**
 * Decodes a multi-channel compressed segmentation.
 *
 * This is not particularly efficient, because it is intended for testing purposes only.
 */
function decodeChannels(out, data, baseOffset, chunkDataSize, blockSize) {
    const channelOutputLength = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2] * 1;
    const expectedLength = channelOutputLength * chunkDataSize[3];
    if (expectedLength !== out.length) {
        throw new Error(`Output length ${out.length} is not equal to expected length ${expectedLength}.`);
    }
    const numChannels = chunkDataSize[3];
    for (let channel = 0; channel < numChannels; ++channel) {
        decodeChannel(out.subarray(channelOutputLength * channel, channelOutputLength * (channel + 1)), data, baseOffset + data[channel], chunkDataSize, blockSize);
    }
    return out;
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/compressed_segmentation/decode_uint64.ts":
/*!*****************************************************************************!*\
  !*** ./src/neuroglancer/sliceview/compressed_segmentation/decode_uint64.ts ***!
  \*****************************************************************************/
/*! exports provided: readSingleChannelValue, readValue, decodeChannel, decodeChannels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readSingleChannelValue", function() { return readSingleChannelValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readValue", function() { return readValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeChannel", function() { return decodeChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeChannels", function() { return decodeChannels; });
/* harmony import */ var neuroglancer_sliceview_compressed_segmentation_decode_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/compressed_segmentation/decode_common */ "./src/neuroglancer/sliceview/compressed_segmentation/decode_common.ts");
// DO NOT EDIT.  Generated from
// templates/neuroglancer/sliceview/compressed_segmentation/decode.template.ts.
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Support for decompressing uint64 segment label chunks.
 */

/**
 * Reads the single value at the specified dataPosition in a single-channel compressed segmentation.
 *
 * @param baseOffset The base offset into `data' at which the compressed data for this channel
 * starts.
 * @param chunkDataSize A 3-element array specifying the size of the volume.
 * @param blockSize A 3-element array specifying the block size ued for compression.
 * @param dataPosition A 3-element array specifying the position within the volume from which to
 * read.
 *
 * Stores the result in `out'.
 */
function readSingleChannelValue(out, data, baseOffset, chunkDataSize, blockSize, dataPosition) {
    let outputValueOffset = Object(neuroglancer_sliceview_compressed_segmentation_decode_common__WEBPACK_IMPORTED_MODULE_0__["decodeValueOffset"])(data, baseOffset, chunkDataSize, blockSize, dataPosition, 2) + baseOffset;
    out.low = data[outputValueOffset];
    out.high = data[outputValueOffset + 1];
    return out;
}
/**
 * Reads the single value (of a single channel) at the specified dataPosition in a multi-channel
 * compressed segmentation.
 *
 * @param dataPosition A 4-element [x, y, z, channel] array specifying the position to read.
 */
function readValue(out, data, baseOffset, chunkDataSize, blockSize, dataPosition) {
    return readSingleChannelValue(out, data, baseOffset + data[dataPosition[3]], chunkDataSize, blockSize, dataPosition);
}
/**
 * Decodes a single channel of a compressed segmentation.
 *
 * This is not particularly efficient, because it is intended for testing purposes only.
 */
function decodeChannel(out, data, baseOffset, chunkDataSize, blockSize) {
    const expectedLength = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2] * 2;
    if (expectedLength !== out.length) {
        throw new Error(`Output length ${out.length} is not equal to expected length ${expectedLength}.`);
    }
    let vx = chunkDataSize[0];
    let vy = chunkDataSize[1];
    let vz = chunkDataSize[2];
    let dataPosition = [0, 0, 0];
    let outputOffset = 0;
    for (let z = 0; z < vz; ++z) {
        dataPosition[2] = z;
        for (let y = 0; y < vy; ++y) {
            dataPosition[1] = y;
            for (let x = 0; x < vx; ++x) {
                dataPosition[0] = x;
                let outputValueOffset = Object(neuroglancer_sliceview_compressed_segmentation_decode_common__WEBPACK_IMPORTED_MODULE_0__["decodeValueOffset"])(data, baseOffset, chunkDataSize, blockSize, dataPosition, 2) +
                    baseOffset;
                out[outputOffset++] = data[outputValueOffset];
                out[outputOffset++] = data[outputValueOffset + 1];
            }
        }
    }
    return out;
}
/**
 * Decodes a multi-channel compressed segmentation.
 *
 * This is not particularly efficient, because it is intended for testing purposes only.
 */
function decodeChannels(out, data, baseOffset, chunkDataSize, blockSize) {
    const channelOutputLength = chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2] * 2;
    const expectedLength = channelOutputLength * chunkDataSize[3];
    if (expectedLength !== out.length) {
        throw new Error(`Output length ${out.length} is not equal to expected length ${expectedLength}.`);
    }
    const numChannels = chunkDataSize[3];
    for (let channel = 0; channel < numChannels; ++channel) {
        decodeChannel(out.subarray(channelOutputLength * channel, channelOutputLength * (channel + 1)), data, baseOffset + data[channel], chunkDataSize, blockSize);
    }
    return out;
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/frontend.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/sliceview/frontend.ts ***!
  \************************************************/
/*! exports provided: SliceView, SliceViewChunkSource, SliceViewChunk, SliceViewRenderHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceView", function() { return SliceView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewChunkSource", function() { return SliceViewChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewChunk", function() { return SliceViewChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewRenderHelper", function() { return SliceViewRenderHelper; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/sliceview/base */ "./src/neuroglancer/sliceview/base.ts");
/* harmony import */ var neuroglancer_sliceview_renderlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/renderlayer */ "./src/neuroglancer/sliceview/renderlayer.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/webgl/offscreen */ "./src/neuroglancer/webgl/offscreen.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/* harmony import */ var neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/webgl/square_corners_buffer */ "./src/neuroglancer/webgl/square_corners_buffer.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};














const tempMat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].create();
class FrontendSliceViewBase extends neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_3__["SliceViewBase"] {
}
const Base = Object(neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_9__["withSharedVisibility"])(FrontendSliceViewBase);
let SliceView = class SliceView extends Base {
    constructor(chunkManager, layerManager, navigationState) {
        super();
        this.chunkManager = chunkManager;
        this.layerManager = layerManager;
        this.navigationState = navigationState;
        this.gl = this.chunkManager.gl;
        this.dataToViewport = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].create();
        // Transforms viewport coordinates to OpenGL normalized device coordinates
        // [left: -1, right: 1], [top: 1, bottom: -1].
        this.viewportToDevice = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].create();
        // Equals viewportToDevice * dataToViewport.
        this.dataToDevice = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].create();
        this.visibleChunks = new Map();
        this.viewChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_8__["NullarySignal"]();
        this.renderingStale = true;
        this.visibleChunksStale = true;
        this.visibleLayerList = new Array();
        this.newVisibleLayers = new Set();
        this.offscreenFramebuffer = this.registerDisposer(new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_10__["FramebufferConfiguration"](this.gl, { colorBuffers: Object(neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_10__["makeTextureBuffers"])(this.gl, 1), depthBuffer: new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_10__["StencilBuffer"](this.gl) }));
        this.numVisibleChunks = 0;
        this.updateVisibleLayers = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
            this.updateVisibleLayersNow();
        }, 0));
        this.invalidateVisibleSources = (() => {
            this.visibleSourcesStale = true;
            this.viewChanged.dispatch();
        });
        this.visibleLayerDisposers = new Map();
        this.setViewportSizeDebounced = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()((width, height) => this.setViewportSize(width, height), 0));
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].identity(this.dataToViewport);
        const rpc = this.chunkManager.rpc;
        this.initializeCounterpart(rpc, {
            'chunkManager': chunkManager.rpcId,
        });
        this.registerDisposer(navigationState.changed.add(() => {
            this.updateViewportFromNavigationState();
        }));
        this.updateViewportFromNavigationState();
        this.registerDisposer(layerManager.layersChanged.add(() => {
            if (this.hasValidViewport) {
                this.updateVisibleLayers();
            }
        }));
        this.viewChanged.add(() => {
            this.renderingStale = true;
        });
        this.registerDisposer(chunkManager.chunkQueueManager.visibleChunksChanged.add(this.viewChanged.dispatch));
        this.updateViewportFromNavigationState();
        this.updateVisibleLayers();
    }
    isReady() {
        this.setViewportSizeDebounced.flush();
        if (!this.hasValidViewport) {
            return false;
        }
        this.maybeUpdateVisibleChunks();
        let numValidChunks = 0;
        for (const visibleSources of this.visibleLayers.values()) {
            for (const { chunkLayout, source } of visibleSources) {
                // FIXME: handle change to chunkLayout
                const visibleChunks = this.visibleChunks.get(chunkLayout);
                if (!visibleChunks) {
                    return false;
                }
                const { chunks } = source;
                for (const key of visibleChunks) {
                    const chunk = chunks.get(key);
                    if (chunk && chunk.state === neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_1__["ChunkState"].GPU_MEMORY) {
                        ++numValidChunks;
                    }
                }
            }
        }
        return numValidChunks === this.numVisibleChunks;
    }
    updateViewportFromNavigationState() {
        let { navigationState } = this;
        if (!navigationState.valid) {
            return;
        }
        navigationState.toMat4(tempMat);
        this.setViewportToDataMatrix(tempMat);
    }
    bindVisibleRenderLayer(renderLayer, disposers) {
        disposers.push(renderLayer.redrawNeeded.add(this.viewChanged.dispatch));
        disposers.push(renderLayer.transform.changed.add(this.invalidateVisibleSources));
        disposers.push(renderLayer.renderScaleTarget.changed.add(this.invalidateVisibleSources));
        const { renderScaleHistogram } = renderLayer;
        if (renderScaleHistogram !== undefined) {
            disposers.push(renderScaleHistogram.visibility.add(this.visibility));
        }
    }
    updateVisibleLayersNow() {
        if (this.wasDisposed) {
            return false;
        }
        if (!this.hasValidViewport) {
            return false;
        }
        let visibleLayers = this.visibleLayers;
        let rpc = this.rpc;
        let rpcMessage = { 'id': this.rpcId };
        let newVisibleLayers = this.newVisibleLayers;
        let changed = false;
        let visibleLayerList = this.visibleLayerList;
        const { visibleLayerDisposers } = this;
        visibleLayerList.length = 0;
        for (let renderLayer of this.layerManager.readyRenderLayers()) {
            if (renderLayer instanceof neuroglancer_sliceview_renderlayer__WEBPACK_IMPORTED_MODULE_4__["RenderLayer"]) {
                newVisibleLayers.add(renderLayer);
                visibleLayerList.push(renderLayer);
                if (!visibleLayers.has(renderLayer)) {
                    visibleLayers.set(renderLayer.addRef(), []);
                    const disposers = [];
                    visibleLayerDisposers.set(renderLayer, disposers);
                    this.bindVisibleRenderLayer(renderLayer, disposers);
                    rpcMessage['layerId'] = renderLayer.rpcId;
                    rpc.invoke(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_3__["SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID"], rpcMessage);
                    changed = true;
                }
            }
        }
        for (let renderLayer of visibleLayers.keys()) {
            if (!newVisibleLayers.has(renderLayer)) {
                visibleLayers.delete(renderLayer);
                const disposers = this.visibleLayerDisposers.get(renderLayer);
                this.visibleLayerDisposers.delete(renderLayer);
                Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["invokeDisposers"])(disposers);
                rpcMessage['layerId'] = renderLayer.rpcId;
                rpc.invoke(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_3__["SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID"], rpcMessage);
                renderLayer.dispose();
                changed = true;
            }
        }
        newVisibleLayers.clear();
        if (changed) {
            this.visibleSourcesStale = true;
        }
        // Unconditionally call viewChanged, because layers may have been reordered even if the set of
        // sources is the same.
        this.viewChanged.dispatch();
        return changed;
    }
    onViewportChanged() {
        var { width, height, viewportToDevice, dataToViewport, dataToDevice } = this;
        // FIXME: Make this adjustable.
        const sliceThickness = 10;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].ortho(viewportToDevice, -width / 2, width / 2, height / 2, -height / 2, -sliceThickness, sliceThickness);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].multiply(dataToDevice, viewportToDevice, dataToViewport);
        this.visibleChunksStale = true;
        this.viewChanged.dispatch();
    }
    setViewportSize(width, height) {
        this.setViewportSizeDebounced.cancel();
        if (super.setViewportSize(width, height)) {
            this.rpc.invoke(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_3__["SLICEVIEW_UPDATE_VIEW_RPC_ID"], { id: this.rpcId, width: width, height: height });
            // this.chunkManager.scheduleUpdateChunkPriorities();
            return true;
        }
        return false;
    }
    onViewportToDataMatrixChanged() {
        let { viewportToData, dataToViewport } = this;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].invert(dataToViewport, viewportToData);
        Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["rectifyTransformMatrixIfAxisAligned"])(dataToViewport);
        this.rpc.invoke(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_3__["SLICEVIEW_UPDATE_VIEW_RPC_ID"], { id: this.rpcId, viewportToData: viewportToData });
    }
    onHasValidViewport() {
        this.updateVisibleLayers();
    }
    updateRendering() {
        this.setViewportSizeDebounced.flush();
        if (!this.renderingStale || !this.hasValidViewport || this.width === 0 || this.height === 0) {
            return;
        }
        this.renderingStale = false;
        this.maybeUpdateVisibleChunks();
        let { gl, offscreenFramebuffer, width, height } = this;
        offscreenFramebuffer.bind(width, height);
        gl.disable(gl.SCISSOR_TEST);
        // we have viewportToData
        // we need: matrix that maps input x to the output x axis, scaled by
        gl.clearStencil(0);
        gl.clearColor(0, 0, 0, 0);
        gl.colorMask(true, true, true, true);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.STENCIL_TEST);
        gl.disable(gl.DEPTH_TEST);
        gl.stencilOpSeparate(
        /*face=*/ gl.FRONT_AND_BACK, /*sfail=*/ gl.KEEP, /*dpfail=*/ gl.KEEP, 
        /*dppass=*/ gl.REPLACE);
        let renderLayerNum = 0;
        for (let renderLayer of this.visibleLayerList) {
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.stencilFuncSeparate(
            /*face=*/ gl.FRONT_AND_BACK, 
            /*func=*/ gl.GREATER, 
            /*ref=*/ 1, 
            /*mask=*/ 1);
            renderLayer.setGLBlendMode(gl, renderLayerNum);
            renderLayer.draw(this);
            ++renderLayerNum;
        }
        gl.disable(gl.BLEND);
        gl.disable(gl.STENCIL_TEST);
        offscreenFramebuffer.unbind();
    }
    maybeUpdateVisibleChunks() {
        this.updateVisibleLayers.flush();
        if (!this.visibleChunksStale && !this.visibleSourcesStale) {
            return false;
        }
        this.visibleChunksStale = false;
        this.updateVisibleChunks();
        return true;
    }
    updateVisibleChunks() {
        let allVisibleChunks = this.visibleChunks;
        function getLayoutObject(chunkLayout) {
            let visibleChunks = allVisibleChunks.get(chunkLayout);
            if (visibleChunks === undefined) {
                visibleChunks = [];
                allVisibleChunks.set(chunkLayout, visibleChunks);
            }
            else {
                visibleChunks.length = 0;
            }
            return visibleChunks;
        }
        let numVisibleChunks = 0;
        function addChunk(_chunkLayout, visibleChunks, positionInChunks, fullyVisibleSources) {
            let key = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3Key"])(positionInChunks);
            visibleChunks[visibleChunks.length] = key;
            numVisibleChunks += fullyVisibleSources.length;
        }
        this.computeVisibleChunks(getLayoutObject, addChunk);
        this.numVisibleChunks = numVisibleChunks;
    }
    disposed() {
        for (const [renderLayer, disposers] of this.visibleLayerDisposers) {
            Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["invokeDisposers"])(disposers);
            renderLayer.dispose();
        }
        this.visibleLayerDisposers.clear();
        this.visibleLayers.clear();
        this.visibleLayerList.length = 0;
    }
};
SliceView = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_13__["registerSharedObjectOwner"])(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_3__["SLICEVIEW_RPC_ID"])
], SliceView);

class SliceViewChunkSource extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_2__["ChunkSource"] {
    constructor(chunkManager, options) {
        super(chunkManager, options);
        this.spec = options.spec;
    }
    static encodeOptions(options) {
        const encoding = super.encodeOptions(options);
        encoding.spec = options.spec.toObject();
        return encoding;
    }
    initializeCounterpart(rpc, options) {
        options['spec'] = this.spec.toObject();
        super.initializeCounterpart(rpc, options);
    }
}
class SliceViewChunk extends neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_2__["Chunk"] {
    constructor(source, x) {
        super(source);
        this.chunkGridPosition = x['chunkGridPosition'];
        this.state = neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_1__["ChunkState"].SYSTEM_MEMORY;
    }
}
/**
 * Helper for rendering a SliceView that has been pre-rendered to a texture.
 */
class SliceViewRenderHelper extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["RefCounted"] {
    constructor(gl, emitter) {
        super();
        this.gl = gl;
        this.copyVertexPositionsBuffer = Object(neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_12__["getSquareCornersBuffer"])(this.gl);
        this.textureCoordinateAdjustment = new Float32Array(4);
        let builder = new neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_11__["ShaderBuilder"](gl);
        builder.addVarying('vec2', 'vTexCoord');
        builder.addUniform('sampler2D', 'uSampler');
        builder.addInitializer(shader => {
            gl.uniform1i(shader.uniform('uSampler'), 0);
        });
        builder.addUniform('vec4', 'uColorFactor');
        builder.addUniform('vec4', 'uBackgroundColor');
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.addUniform('vec4', 'uTextureCoordinateAdjustment');
        builder.require(emitter);
        builder.setFragmentMain(`
vec4 sampledColor = texture(uSampler, vTexCoord);
if (sampledColor.a == 0.0) {
  sampledColor = uBackgroundColor;
}
emit(sampledColor * uColorFactor, 0u);
`);
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.setVertexMain(`
vTexCoord = uTextureCoordinateAdjustment.xy + 0.5 * (aVertexPosition.xy + 1.0) * uTextureCoordinateAdjustment.zw;
gl_Position = uProjectionMatrix * aVertexPosition;
`);
        this.shader = this.registerDisposer(builder.build());
    }
    draw(texture, projectionMatrix, colorFactor, backgroundColor, xStart, yStart, xEnd, yEnd) {
        let { gl, shader, textureCoordinateAdjustment } = this;
        textureCoordinateAdjustment[0] = xStart;
        textureCoordinateAdjustment[1] = yStart;
        textureCoordinateAdjustment[2] = xEnd - xStart;
        textureCoordinateAdjustment[3] = yEnd - yStart;
        shader.bind();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, projectionMatrix);
        gl.uniform4fv(shader.uniform('uColorFactor'), colorFactor);
        gl.uniform4fv(shader.uniform('uBackgroundColor'), backgroundColor);
        gl.uniform4fv(shader.uniform('uTextureCoordinateAdjustment'), textureCoordinateAdjustment);
        let aVertexPosition = shader.attribute('aVertexPosition');
        this.copyVertexPositionsBuffer.bindToVertexAttrib(aVertexPosition, /*components=*/ 2);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        gl.disableVertexAttribArray(aVertexPosition);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    static get(gl, emitter) {
        return gl.memoize.get(`sliceview/SliceViewRenderHelper:${Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_7__["getObjectId"])(emitter)}`, () => new SliceViewRenderHelper(gl, emitter));
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/panel.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/sliceview/panel.ts ***!
  \*********************************************/
/*! exports provided: OffscreenTextures, SliceViewPanelRenderLayer, SliceViewPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffscreenTextures", function() { return OffscreenTextures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewPanelRenderLayer", function() { return SliceViewPanelRenderLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceViewPanel", function() { return SliceViewPanel; });
/* harmony import */ var neuroglancer_axes_lines__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/axes_lines */ "./src/neuroglancer/axes_lines.ts");
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_object_picking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/object_picking */ "./src/neuroglancer/object_picking.ts");
/* harmony import */ var neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/rendered_data_panel */ "./src/neuroglancer/rendered_data_panel.ts");
/* harmony import */ var neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/frontend */ "./src/neuroglancer/sliceview/frontend.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/mouse_drag */ "./src/neuroglancer/util/mouse_drag.ts");
/* harmony import */ var neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/webgl/offscreen */ "./src/neuroglancer/webgl/offscreen.ts");
/* harmony import */ var neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/widget/scale_bar */ "./src/neuroglancer/widget/scale_bar.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










var OffscreenTextures;
(function (OffscreenTextures) {
    OffscreenTextures[OffscreenTextures["COLOR"] = 0] = "COLOR";
    OffscreenTextures[OffscreenTextures["PICK"] = 1] = "PICK";
    OffscreenTextures[OffscreenTextures["NUM_TEXTURES"] = 2] = "NUM_TEXTURES";
})(OffscreenTextures || (OffscreenTextures = {}));
function sliceViewPanelEmitColor(builder) {
    builder.addOutputBuffer('vec4', 'out_fragColor', null);
    builder.addFragmentCode(`
void emit(vec4 color, highp uint pickId) {
  out_fragColor = color;
}
`);
}
function sliceViewPanelEmitPickID(builder) {
    builder.addOutputBuffer('highp float', 'out_pickId', null);
    builder.addFragmentCode(`
void emit(vec4 color, highp uint pickId) {
  out_pickId = float(pickId);
}
`);
}
class SliceViewPanelRenderLayer extends neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__["VisibilityTrackedRenderLayer"] {
    draw(_renderContext) {
        // Must be overridden by subclasses.
    }
    isReady() {
        return true;
    }
}
const tempVec4 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec4"].create();
class SliceViewPanel extends neuroglancer_rendered_data_panel__WEBPACK_IMPORTED_MODULE_3__["RenderedDataPanel"] {
    constructor(context, element, sliceView, viewer) {
        super(context, element, viewer);
        this.sliceView = sliceView;
        this.axesLineHelper = this.registerDisposer(neuroglancer_axes_lines__WEBPACK_IMPORTED_MODULE_0__["AxesLineHelper"].get(this.gl));
        this.sliceViewRenderHelper = this.registerDisposer(neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_4__["SliceViewRenderHelper"].get(this.gl, sliceViewPanelEmitColor));
        this.colorFactor = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec4"].fromValues(1, 1, 1, 1);
        this.pickIDs = new neuroglancer_object_picking__WEBPACK_IMPORTED_MODULE_2__["PickIDManager"]();
        this.visibleLayerTracker = Object(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__["makeRenderedPanelVisibleLayerTracker"])(this.viewer.layerManager, SliceViewPanelRenderLayer, this.viewer.visibleLayerRoles, this);
        this.offscreenFramebuffer = this.registerDisposer(new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_8__["FramebufferConfiguration"](this.gl, {
            colorBuffers: [
                new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_8__["TextureBuffer"](this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE),
                new neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_8__["TextureBuffer"](this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT),
            ]
        }));
        this.offscreenCopyHelper = this.registerDisposer(neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_8__["OffscreenCopyHelper"].get(this.gl));
        this.scaleBarCopyHelper = this.registerDisposer(neuroglancer_webgl_offscreen__WEBPACK_IMPORTED_MODULE_8__["OffscreenCopyHelper"].get(this.gl));
        this.scaleBarTexture = this.registerDisposer(new neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_9__["ScaleBarTexture"](this.gl));
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(element, 'rotate-via-mouse-drag', (e) => {
            const { mouseState } = this.viewer;
            if (mouseState.updateUnconditionally()) {
                const initialPosition = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].clone(mouseState.position);
                Object(neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_7__["startRelativeMouseDrag"])(e.detail, (_event, deltaX, deltaY) => {
                    let { viewportAxes } = this.sliceView;
                    this.viewer.navigationState.pose.rotateAbsolute(viewportAxes[1], -deltaX / 4.0 * Math.PI / 180.0, initialPosition);
                    this.viewer.navigationState.pose.rotateAbsolute(viewportAxes[0], -deltaY / 4.0 * Math.PI / 180.0, initialPosition);
                });
            }
        });
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(element, 'rotate-in-plane-via-touchrotate', (e) => {
            const { detail } = e;
            const { mouseState } = this.viewer;
            this.handleMouseMove(detail.centerX, detail.centerY);
            if (mouseState.updateUnconditionally()) {
                const { viewportAxes } = this.sliceView;
                this.navigationState.pose.rotateAbsolute(viewportAxes[2], detail.angle - detail.prevAngle, mouseState.position);
            }
        });
        this.registerDisposer(sliceView);
        this.registerDisposer(viewer.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw()));
        this.registerDisposer(sliceView.visibility.add(this.visibility));
        this.registerDisposer(sliceView.viewChanged.add(() => {
            if (this.visible) {
                context.scheduleRedraw();
            }
        }));
        this.registerDisposer(viewer.showAxisLines.changed.add(() => {
            if (this.visible) {
                this.scheduleRedraw();
            }
        }));
        this.registerDisposer(viewer.showScaleBar.changed.add(() => {
            if (this.visible) {
                this.context.scheduleRedraw();
            }
        }));
        this.registerDisposer(viewer.scaleBarOptions.changed.add(() => {
            if (this.visible) {
                this.context.scheduleRedraw();
            }
        }));
    }
    get navigationState() {
        return this.sliceView.navigationState;
    }
    translateByViewportPixels(deltaX, deltaY) {
        const { position } = this.viewer.navigationState;
        const pos = position.spatialCoordinates;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].set(pos, -deltaX, -deltaY, 0);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(pos, pos, this.sliceView.viewportToData);
        position.changed.dispatch();
    }
    translateDataPointByViewportPixels(out, orig, deltaX, deltaY) {
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(out, orig, this.sliceView.dataToViewport);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].set(out, out[0] + deltaX, out[1] + deltaY, out[2]);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(out, out, this.sliceView.viewportToData);
        return out;
    }
    isReady() {
        if (!this.visible) {
            return false;
        }
        if (!this.sliceView.isReady()) {
            return false;
        }
        let visibleLayers = this.visibleLayerTracker.getVisibleLayers();
        for (let renderLayer of visibleLayers) {
            if (!renderLayer.isReady()) {
                return false;
            }
        }
        return true;
    }
    drawWithPicking(pickingData) {
        let { sliceView } = this;
        sliceView.setViewportSize(this.width, this.height);
        sliceView.updateRendering();
        if (!sliceView.hasValidViewport) {
            return false;
        }
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].copy(pickingData.invTransform, sliceView.viewportToData);
        const { gl } = this;
        const { width, height, dataToDevice } = sliceView;
        this.offscreenFramebuffer.bind(width, height);
        gl.disable(WebGL2RenderingContext.SCISSOR_TEST);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
        // Draw axes lines.
        // FIXME: avoid use of temporary matrix
        let mat = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].create();
        const backgroundColor = tempVec4;
        const crossSectionBackgroundColor = this.viewer.crossSectionBackgroundColor.value;
        backgroundColor[0] = crossSectionBackgroundColor[0];
        backgroundColor[1] = crossSectionBackgroundColor[1];
        backgroundColor[2] = crossSectionBackgroundColor[2];
        backgroundColor[3] = 1;
        this.offscreenFramebuffer.bindSingle(OffscreenTextures.COLOR);
        this.sliceViewRenderHelper.draw(sliceView.offscreenFramebuffer.colorBuffers[0].texture, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["identityMat4"], this.colorFactor, backgroundColor, 0, 0, 1, 1);
        let visibleLayers = this.visibleLayerTracker.getVisibleLayers();
        let { pickIDs } = this;
        pickIDs.clear();
        let renderContext = {
            dataToDevice: sliceView.dataToDevice,
            pickIDs: pickIDs,
            emitter: sliceViewPanelEmitColor,
            emitColor: true,
            emitPickID: false,
            viewportWidth: width,
            viewportHeight: height,
            sliceView,
        };
        gl.enable(WebGL2RenderingContext.BLEND);
        gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
        for (let renderLayer of visibleLayers) {
            renderLayer.draw(renderContext);
        }
        gl.disable(WebGL2RenderingContext.BLEND);
        this.offscreenFramebuffer.bindSingle(OffscreenTextures.PICK);
        renderContext.emitColor = false;
        renderContext.emitPickID = true;
        renderContext.emitter = sliceViewPanelEmitPickID;
        for (let renderLayer of visibleLayers) {
            renderLayer.draw(renderContext);
        }
        if (this.viewer.showAxisLines.value || this.viewer.showScaleBar.value) {
            if (this.viewer.showAxisLines.value) {
                // Construct matrix that maps [-1, +1] x/y range to the full viewport data
                // coordinates.
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["mat4"].copy(mat, dataToDevice);
                for (let i = 0; i < 3; ++i) {
                    mat[12 + i] = 0;
                }
                for (let i = 0; i < 4; ++i) {
                    mat[2 + 4 * i] = 0;
                }
                let axisLength = Math.min(width, height) / 4 * 1.5;
                let pixelSize = sliceView.pixelSize;
                for (let i = 0; i < 12; ++i) {
                    // pixelSize is nm / pixel
                    //
                    mat[i] *= axisLength * pixelSize;
                }
            }
            this.offscreenFramebuffer.bindSingle(OffscreenTextures.COLOR);
            if (this.viewer.showAxisLines.value) {
                this.axesLineHelper.draw(mat);
            }
            if (this.viewer.showScaleBar.value) {
                gl.enable(WebGL2RenderingContext.BLEND);
                gl.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                const options = this.viewer.scaleBarOptions.value;
                const { scaleBarTexture } = this;
                const { dimensions } = scaleBarTexture;
                dimensions.targetLengthInPixels = Math.min(options.maxWidthFraction * width, options.maxWidthInPixels * options.scaleFactor);
                dimensions.nanometersPerPixel = sliceView.pixelSize;
                scaleBarTexture.update(options);
                gl.viewport(options.leftPixelOffset * options.scaleFactor, options.bottomPixelOffset * options.scaleFactor, scaleBarTexture.width, scaleBarTexture.height);
                this.scaleBarCopyHelper.draw(scaleBarTexture.texture);
                gl.disable(WebGL2RenderingContext.BLEND);
            }
        }
        this.offscreenFramebuffer.unbind();
        // Draw the texture over the whole viewport.
        this.setGLViewport();
        this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[OffscreenTextures.COLOR].texture);
        return true;
    }
    panelSizeChanged() {
        this.sliceView.setViewportSizeDebounced(this.width, this.height);
    }
    issuePickRequest(glWindowX, glWindowY) {
        const { offscreenFramebuffer } = this;
        offscreenFramebuffer.readPixelFloat32IntoBuffer(OffscreenTextures.PICK, glWindowX, glWindowY, 0);
    }
    completePickRequest(glWindowX, glWindowY, data, pickingData) {
        const { mouseState } = this.viewer;
        mouseState.pickedRenderLayer = null;
        const out = mouseState.position;
        const { viewportWidth, viewportHeight } = pickingData;
        const y = pickingData.viewportHeight - glWindowY;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].set(out, glWindowX - viewportWidth / 2, y - viewportHeight / 2, 0);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(out, out, pickingData.invTransform);
        this.pickIDs.setMouseState(mouseState, data[0]);
        mouseState.setActive(true);
    }
    /**
     * Zooms by the specified factor, maintaining the data position that projects to the current mouse
     * position.
     */
    zoomByMouse(factor) {
        let { navigationState } = this;
        if (!navigationState.valid) {
            return;
        }
        let { sliceView } = this;
        let { width, height } = sliceView;
        let { mouseX, mouseY } = this;
        mouseX -= width / 2;
        mouseY -= height / 2;
        let oldZoom = this.navigationState.zoomFactor.value;
        // oldPosition + (mouseX * viewportAxes[0] + mouseY * viewportAxes[1]) * oldZoom
        //     === newPosition + (mouseX * viewportAxes[0] + mouseY * viewportAxes[1]) * newZoom
        // Therefore, we compute newPosition by:
        // newPosition = oldPosition + (viewportAxes[0] * mouseX +
        //                              viewportAxes[1] * mouseY) * (oldZoom - newZoom).
        navigationState.zoomBy(factor);
        let newZoom = navigationState.zoomFactor.value;
        let { spatialCoordinates } = navigationState.position;
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].scaleAndAdd(spatialCoordinates, spatialCoordinates, sliceView.viewportAxes[0], mouseX * (oldZoom - newZoom));
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].scaleAndAdd(spatialCoordinates, spatialCoordinates, sliceView.viewportAxes[1], mouseY * (oldZoom - newZoom));
        navigationState.position.changed.dispatch();
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/renderlayer.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/sliceview/renderlayer.ts ***!
  \***************************************************/
/*! exports provided: RenderLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderLayer", function() { return RenderLayer; });
/* harmony import */ var neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/coordinate_transform */ "./src/neuroglancer/coordinate_transform.ts");
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/render_scale_statistics */ "./src/neuroglancer/render_scale_statistics.ts");
/* harmony import */ var neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/shared_watchable_value */ "./src/neuroglancer/shared_watchable_value.ts");
/* harmony import */ var neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/base */ "./src/neuroglancer/sliceview/base.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







class RenderLayer extends neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__["RenderLayer"] {
    constructor(chunkManager, sources, options) {
        super();
        this.chunkManager = chunkManager;
        this.sources = sources;
        this.rpcId = null;
        this.transformedSourcesGeneration = -1;
        const { transform = new neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_0__["CoordinateTransform"](), renderScaleTarget = Object(neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_2__["trackableRenderScaleTarget"])(1) } = options;
        this.renderScaleTarget = renderScaleTarget;
        this.renderScaleHistogram = options.renderScaleHistogram;
        this.transform = transform;
        const transformedSources = Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_4__["getTransformedSources"])(this);
        {
            const { source, chunkLayout } = transformedSources[0][0];
            const { spec } = source;
            const voxelSize = this.voxelSize =
                chunkLayout.localSpatialVectorToGlobal(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].create(), spec.voxelSize);
            for (let i = 0; i < 3; ++i) {
                voxelSize[i] = Math.abs(voxelSize[i]);
            }
        }
        const sharedObject = this.registerDisposer(new neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_6__["SharedObject"]());
        const rpc = this.chunkManager.rpc;
        sharedObject.RPC_TYPE_ID = neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_4__["SLICEVIEW_RENDERLAYER_RPC_ID"];
        const sourceIds = sources.map(alternatives => alternatives.map(source => source.rpcId));
        sharedObject.initializeCounterpart(rpc, {
            sources: sourceIds,
            transform: transform.transform,
            renderScaleTarget: this.registerDisposer(neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_3__["SharedWatchableValue"].makeFromExisting(rpc, this.renderScaleTarget))
                .rpcId
        });
        this.rpcId = sharedObject.rpcId;
        this.registerDisposer(transform.changed.add(() => {
            rpc.invoke(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_4__["SLICEVIEW_RENDERLAYER_UPDATE_TRANSFORM_RPC_ID"], { id: this.rpcId, value: transform.transform });
        }));
        this.setReady(true);
    }
    get gl() {
        return this.chunkManager.chunkQueueManager.gl;
    }
    setGLBlendMode(gl, renderLayerNum) {
        // Default blend mode for non-blend-mode-aware layers
        if (renderLayerNum > 0) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/single_texture_chunk_format.ts":
/*!*******************************************************************!*\
  !*** ./src/neuroglancer/sliceview/single_texture_chunk_format.ts ***!
  \*******************************************************************/
/*! exports provided: SingleTextureChunkFormat, SingleTextureVolumeChunk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleTextureChunkFormat", function() { return SingleTextureChunkFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingleTextureVolumeChunk", function() { return SingleTextureVolumeChunk; });
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const textureUnitSymbol = Symbol('SingleTextureVolumeChunk.textureUnit');
const textureLayoutSymbol = Symbol('SingleTextureVolumeChunk.textureLayout');
class SingleTextureChunkFormat extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(shaderKey) {
        super();
        this.shaderKey = shaderKey;
    }
    defineShader(builder) {
        builder.addTextureSampler(this.shaderSamplerType, 'uVolumeChunkSampler', textureUnitSymbol);
    }
    beginDrawing(gl, shader) {
        let textureUnit = shader.textureUnit(textureUnitSymbol);
        gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + textureUnit);
        shader[textureLayoutSymbol] = null;
    }
    endDrawing(gl, shader) {
        gl.bindTexture(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_2__["textureTargetForSamplerType"][this.shaderSamplerType], null);
        shader[textureLayoutSymbol] = null;
    }
    bindChunk(gl, shader, chunk) {
        let textureLayout = chunk.textureLayout;
        let existingTextureLayout = shader[textureLayoutSymbol];
        if (existingTextureLayout !== textureLayout) {
            shader[textureLayoutSymbol] = textureLayout;
            this.setupTextureLayout(gl, shader, textureLayout);
        }
        gl.bindTexture(neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_2__["textureTargetForSamplerType"][this.shaderSamplerType], chunk.texture);
    }
    /**
     * Does nothing, but may be overridden by subclass.
     */
    beginSource(_gl, _shader) { }
}
class SingleTextureVolumeChunk extends neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_0__["VolumeChunk"] {
    constructor(source, x) {
        super(source, x);
        this.texture = null;
        this.data = x['data'];
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        let texture = this.texture = gl.createTexture();
        const textureTarget = neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_2__["textureTargetForSamplerType"][this.chunkFormat.shaderSamplerType];
        gl.bindTexture(textureTarget, texture);
        this.setTextureData(gl);
        gl.bindTexture(textureTarget, null);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        gl.deleteTexture(this.texture);
        this.texture = null;
        this.textureLayout.dispose();
        this.textureLayout = null;
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/uncompressed_chunk_format.ts":
/*!*****************************************************************!*\
  !*** ./src/neuroglancer/sliceview/uncompressed_chunk_format.ts ***!
  \*****************************************************************/
/*! exports provided: ChunkFormat, UncompressedVolumeChunk, UncompressedChunkFormatHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkFormat", function() { return ChunkFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UncompressedVolumeChunk", function() { return UncompressedVolumeChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UncompressedChunkFormatHandler", function() { return UncompressedChunkFormatHandler; });
/* harmony import */ var neuroglancer_sliceview_single_texture_chunk_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/single_texture_chunk_format */ "./src/neuroglancer/sliceview/single_texture_chunk_format.ts");
/* harmony import */ var neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/sliceview/volume/base */ "./src/neuroglancer/sliceview/volume/base.ts");
/* harmony import */ var neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/sliceview/volume/frontend */ "./src/neuroglancer/sliceview/volume/frontend.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/webgl/shader_lib */ "./src/neuroglancer/webgl/shader_lib.ts");
/* harmony import */ var neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/webgl/texture_access */ "./src/neuroglancer/webgl/texture_access.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








class TextureLayout extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(chunkDataSize, numChannels) {
        super();
        this.chunkDataSize = chunkDataSize;
        this.numChannels = numChannels;
    }
    static get(gl, chunkDataSize, numChannels) {
        return gl.memoize.get(`sliceview.UncompressedTextureLayout:${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3Key"])(chunkDataSize)},${numChannels}`, () => new TextureLayout(chunkDataSize, numChannels));
    }
}
class ChunkFormat extends neuroglancer_sliceview_single_texture_chunk_format__WEBPACK_IMPORTED_MODULE_0__["SingleTextureChunkFormat"] {
    constructor(_gl, dataType, numChannels, key) {
        super(key);
        this.dataType = dataType;
        this.numChannels = numChannels;
        Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_7__["computeTextureFormat"])(this, dataType);
        this.textureAccessHelper = new neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_7__["ThreeDimensionalTextureAccessHelper"]('chunkData');
    }
    get shaderSamplerType() {
        return `${this.samplerPrefix}sampler3D`;
    }
    static get(gl, dataType, numChannels) {
        let key = `sliceview.UncompressedChunkFormat:${dataType}:${numChannels}`;
        return gl.memoize.get(key, () => new ChunkFormat(gl, dataType, numChannels, key));
    }
    defineShader(builder) {
        super.defineShader(builder);
        let { textureAccessHelper } = this;
        builder.addFragmentCode(textureAccessHelper.getAccessor('readVolumeData', 'uVolumeChunkSampler', this.dataType));
        let { numChannels } = this;
        if (numChannels > 1) {
            builder.addUniform('highp int', 'uChannelStride');
            builder.addFragmentCode(`
highp int getChannelOffset(highp int channelIndex) {
  return channelIndex * uChannelStride;
}
`);
        }
        else {
            builder.addFragmentCode(`highp int getChannelOffset(highp int channelIndex) { return 0; }`);
        }
        const shaderType = Object(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_6__["getShaderType"])(this.dataType);
        builder.addFragmentCode(`
${shaderType} getDataValue (highp int channelIndex) {
  highp ivec3 p = getPositionWithinChunk();
  return readVolumeData(ivec3(p.x, p.y, p.z + getChannelOffset(channelIndex)));
}
`);
    }
    /**
     * Called each time textureLayout changes while drawing chunks.
     */
    setupTextureLayout(gl, shader, textureLayout) {
        if (this.numChannels > 1) {
            gl.uniform1i(shader.uniform('uChannelStride'), textureLayout.chunkDataSize[2]);
        }
    }
    getTextureLayout(gl, chunkDataSize) {
        return TextureLayout.get(gl, chunkDataSize, this.numChannels);
    }
    setTextureData(gl, textureLayout, data) {
        const { chunkDataSize } = textureLayout;
        Object(neuroglancer_webgl_texture_access__WEBPACK_IMPORTED_MODULE_7__["setThreeDimensionalTextureData"])(gl, this, data, chunkDataSize[0], chunkDataSize[1], chunkDataSize[2] * this.numChannels);
    }
}
class UncompressedVolumeChunk extends neuroglancer_sliceview_single_texture_chunk_format__WEBPACK_IMPORTED_MODULE_0__["SingleTextureVolumeChunk"] {
    setTextureData(gl) {
        let { source } = this;
        let { chunkFormatHandler } = source;
        let { chunkFormat } = chunkFormatHandler;
        let textureLayout;
        if (this.chunkDataSize === source.spec.chunkDataSize) {
            this.textureLayout = textureLayout = chunkFormatHandler.textureLayout.addRef();
        }
        else {
            this.textureLayout = textureLayout = chunkFormat.getTextureLayout(gl, this.chunkDataSize);
        }
        this.chunkFormat.setTextureData(gl, textureLayout, this.data);
    }
    getChannelValueAt(dataPosition, channel) {
        let { chunkFormat } = this;
        let chunkDataSize = this.chunkDataSize;
        let index = dataPosition[0] +
            chunkDataSize[0] *
                (dataPosition[1] + chunkDataSize[1] * (dataPosition[2] + chunkDataSize[2] * channel));
        let dataType = chunkFormat.dataType;
        let data = this.data;
        switch (dataType) {
            case neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT8:
            case neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_1__["DataType"].FLOAT32:
            case neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT16:
            case neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT32:
                return data[index];
            case neuroglancer_sliceview_volume_base__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT64: {
                let index2 = index * 2;
                return new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_5__["Uint64"](data[index2], data[index2 + 1]);
            }
        }
        throw new Error('Invalid data type: ' + dataType);
    }
}
class UncompressedChunkFormatHandler extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(gl, spec) {
        super();
        this.chunkFormat = this.registerDisposer(ChunkFormat.get(gl, spec.dataType, spec.numChannels));
        this.textureLayout =
            this.registerDisposer(this.chunkFormat.getTextureLayout(gl, spec.chunkDataSize));
    }
    getChunk(source, x) {
        return new UncompressedVolumeChunk(source, x);
    }
}
Object(neuroglancer_sliceview_volume_frontend__WEBPACK_IMPORTED_MODULE_2__["registerChunkFormatHandler"])((gl, spec) => {
    if (spec.compressedSegmentationBlockSize == null) {
        return new UncompressedChunkFormatHandler(gl, spec);
    }
    return null;
});


/***/ }),

/***/ "./src/neuroglancer/sliceview/vector_graphics/base.ts":
/*!************************************************************!*\
  !*** ./src/neuroglancer/sliceview/vector_graphics/base.ts ***!
  \************************************************************/
/*! exports provided: VectorGraphicsType, VectorGraphicsChunkSpecification, VECTOR_GRAPHICS_RPC_ID, VECTOR_GRAPHICS_RENDERLAYER_RPC_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorGraphicsType", function() { return VectorGraphicsType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorGraphicsChunkSpecification", function() { return VectorGraphicsChunkSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VECTOR_GRAPHICS_RPC_ID", function() { return VECTOR_GRAPHICS_RPC_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VECTOR_GRAPHICS_RENDERLAYER_RPC_ID", function() { return VECTOR_GRAPHICS_RENDERLAYER_RPC_ID; });
/* harmony import */ var neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/base */ "./src/neuroglancer/sliceview/base.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var VectorGraphicsType;
(function (VectorGraphicsType) {
    VectorGraphicsType[VectorGraphicsType["LINE"] = 0] = "LINE";
    VectorGraphicsType[VectorGraphicsType["POINT"] = 1] = "POINT";
})(VectorGraphicsType || (VectorGraphicsType = {}));
/**
 * Specifies a chunk layout and voxel size.
 */
class VectorGraphicsChunkSpecification extends neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["SliceViewChunkSpecification"] {
    constructor(options) {
        super(options);
    }
    static make(options) {
        return new VectorGraphicsChunkSpecification(Object.assign({}, options, { transform: Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["getCombinedTransform"])(options.transform, options.vectorGraphicsSourceOptions) }));
    }
    static fromObject(msg) {
        return new VectorGraphicsChunkSpecification(msg);
    }
    toObject() {
        return super.toObject();
    }
}
const VECTOR_GRAPHICS_RPC_ID = 'vectorgraphics';
const VECTOR_GRAPHICS_RENDERLAYER_RPC_ID = 'vectorgraphics/RenderLayer';


/***/ }),

/***/ "./src/neuroglancer/sliceview/vector_graphics/frontend.ts":
/*!****************************************************************!*\
  !*** ./src/neuroglancer/sliceview/vector_graphics/frontend.ts ***!
  \****************************************************************/
/*! exports provided: RenderLayer, VectorGraphicsChunk, VectorGraphicsChunkSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderLayer", function() { return RenderLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorGraphicsChunk", function() { return VectorGraphicsChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorGraphicsChunkSource", function() { return VectorGraphicsChunkSource; });
/* harmony import */ var neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/frontend */ "./src/neuroglancer/sliceview/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_renderlayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/sliceview/renderlayer */ "./src/neuroglancer/sliceview/renderlayer.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/* harmony import */ var neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/webgl/dynamic_shader */ "./src/neuroglancer/webgl/dynamic_shader.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class RenderLayer extends neuroglancer_sliceview_renderlayer__WEBPACK_IMPORTED_MODULE_1__["RenderLayer"] {
    constructor(multiscaleSource, { sourceOptions = {} } = {}) {
        super(multiscaleSource.chunkManager, multiscaleSource.getSources(sourceOptions), {});
        this.shader = undefined;
        this.rpcId = null;
        this.shaderGetter = this.registerDisposer(new neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_3__["ShaderGetter"](this.gl, builder => this.defineShader(builder), () => this.getShaderKey()));
    }
    defineShader(builder) {
        builder.addFragmentCode(`
void emit(vec4 color) {
  v4f_fragColor = color;
}
void emitRGBA(vec4 rgba) {
  emit(vec4(rgba.rgb, rgba.a * uOpacity));
}
void emitRGB(vec3 rgb) {
  emit(vec4(rgb, uOpacity));
}
void emitGrayscale(float value) {
  emit(vec4(value, value, value, uOpacity));
}
void emitTransparent() {
  emit(vec4(0.0, 0.0, 0.0, 0.0));
}
`);
    }
    beginSlice(_sliceView) {
        let shader = this.shaderGetter.get();
        if (shader === undefined) {
            return undefined;
        }
        shader.bind();
        return shader;
    }
}
class VectorGraphicsChunk extends neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_0__["SliceViewChunk"] {
    constructor(source, x) {
        super(source, x);
        this.vertexPositions = x['vertexPositions'];
        this.numPoints = Math.floor(this.vertexPositions.length / 3);
    }
    copyToGPU(gl) {
        super.copyToGPU(gl);
        this.vertexBuffer = neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_2__["Buffer"].fromData(gl, this.vertexPositions, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
    }
    freeGPUMemory(gl) {
        super.freeGPUMemory(gl);
        this.vertexBuffer.dispose();
    }
}
class VectorGraphicsChunkSource extends neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_0__["SliceViewChunkSource"] {
    getChunk(x) {
        return new VectorGraphicsChunk(this, x);
    }
    /**
     * Specifies whether the point vertex coordinates are specified in units of voxels rather than
     * nanometers.
     */
    get vectorGraphicsCoordinatesInVoxels() {
        return true;
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/vector_graphics/vector_graphics_line_renderlayer.ts":
/*!****************************************************************************************!*\
  !*** ./src/neuroglancer/sliceview/vector_graphics/vector_graphics_line_renderlayer.ts ***!
  \****************************************************************************************/
/*! exports provided: VectorGraphicsLineRenderLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorGraphicsLineRenderLayer", function() { return VectorGraphicsLineRenderLayer; });
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_sliceview_vector_graphics_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/sliceview/vector_graphics/frontend */ "./src/neuroglancer/sliceview/vector_graphics/frontend.ts");
/* harmony import */ var neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/trackable_alpha */ "./src/neuroglancer/trackable_alpha.ts");
/* harmony import */ var neuroglancer_trackable_finite_float__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/trackable_finite_float */ "./src/neuroglancer/trackable_finite_float.ts");
/* harmony import */ var neuroglancer_trackable_vec3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/trackable_vec3 */ "./src/neuroglancer/trackable_vec3.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







const tempMat4 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].create();
class VectorGraphicsLineRenderLayer extends neuroglancer_sliceview_vector_graphics_frontend__WEBPACK_IMPORTED_MODULE_1__["RenderLayer"] {
    constructor(multiscaleSource, { opacity = Object(neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_2__["trackableAlphaValue"])(0.5), lineWidth = Object(neuroglancer_trackable_finite_float__WEBPACK_IMPORTED_MODULE_3__["trackableFiniteFloat"])(10.0), color = Object(neuroglancer_trackable_vec3__WEBPACK_IMPORTED_MODULE_4__["trackableVec3"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["vec3"].fromValues(255.0, 255.0, 255.0)), sourceOptions = {}, } = {}) {
        super(multiscaleSource, { sourceOptions });
        this.opacity = opacity;
        this.registerDisposer(opacity.changed.add(() => {
            this.redrawNeeded.dispatch();
        }));
        this.lineWidth = lineWidth;
        this.registerDisposer(lineWidth.changed.add(() => {
            this.redrawNeeded.dispatch();
        }));
        this.color = color;
        this.registerDisposer(color.changed.add(() => {
            this.redrawNeeded.dispatch();
        }));
        let gl = this.gl;
        let vertexIndex = new Float32Array([1, 0, 0, 1, 1, 0, 0, 1]);
        this.vertexIndexBuffer =
            this.registerDisposer(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_6__["Buffer"].fromData(gl, vertexIndex, gl.ARRAY_BUFFER, gl.STATIC_DRAW));
        let normalDirection = new Float32Array([1, 1, -1, -1]);
        this.normalDirectionBuffer = this.registerDisposer(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_6__["Buffer"].fromData(gl, normalDirection, gl.ARRAY_BUFFER, gl.STATIC_DRAW));
    }
    getShaderKey() {
        return `vectorgraphics.VectorGraphicsLineRenderLayer`;
    }
    defineShader(builder) {
        super.defineShader(builder);
        builder.addUniform('highp float', 'uOpacity');
        builder.addUniform('highp float', 'ulineWidth');
        builder.addUniform('highp vec3', 'uColor');
        builder.addVarying('vec3', 'vNormal');
        builder.addAttribute('highp float', 'aNormalDirection');
        builder.addAttribute('highp vec2', 'aVertexIndex');
        builder.addAttribute('highp vec3', 'aVertexFirst');
        builder.addAttribute('highp vec3', 'aVertexSecond');
        builder.addUniform('highp mat4', 'uProjection');
        builder.setFragmentMain(`
float distance = length(vNormal);

float antialiasing = 0.5;

if (distance >= 1.0 - antialiasing) {
  emitRGBA(vec4(uColor, (distance - 1.0) / -antialiasing ));
}
else if (distance < 1.0 - antialiasing) {
  emitRGB(uColor);
}
`);
        builder.setVertexMain(`
vec3 direction = vec3(0., 0., 0.);
direction.z = aNormalDirection;

vec3 difference = aVertexSecond - aVertexFirst;
difference.z = 0.;

vec3 normal = cross(difference, direction);
normal = normalize(normal);
vNormal = normal;

vec4 delta = vec4(normal * ulineWidth, 0.0);
vec4 pos = vec4(aVertexFirst * aVertexIndex.x + aVertexSecond * aVertexIndex.y, 1.0);

gl_Position = uProjection * (pos + delta);
`);
    }
    beginSlice(_sliceView) {
        super.beginSlice(_sliceView);
        let gl = this.gl;
        let shader = this.shader;
        gl.uniform1f(shader.uniform('uOpacity'), this.opacity.value);
        gl.uniform1f(shader.uniform('ulineWidth'), this.lineWidth.value);
        gl.uniform3fv(shader.uniform('uColor'), this.color.value);
        this.vertexIndexBuffer.bindToVertexAttrib(shader.attribute('aVertexIndex'), 
        /*components=*/ 2);
        this.normalDirectionBuffer.bindToVertexAttrib(shader.attribute('aNormalDirection'), 
        /*components=*/ 1);
        return shader;
    }
    endSlice(shader) {
        let gl = this.gl;
        gl.disableVertexAttribArray(shader.attribute('aVertexIndex'));
        gl.disableVertexAttribArray(shader.attribute('aNormalDirection'));
        gl.disableVertexAttribArray(shader.attribute('aVertexFirst'));
        gl.disableVertexAttribArray(shader.attribute('aVertexSecond'));
    }
    draw(sliceView) {
        let visibleSources = sliceView.visibleLayers.get(this);
        if (visibleSources.length === 0) {
            return;
        }
        let gl = this.gl;
        let shader = this.beginSlice(sliceView);
        if (shader === undefined) {
            console.log('error: shader undefined');
            return;
        }
        for (let transformedSource of visibleSources) {
            const chunkLayout = transformedSource.chunkLayout;
            const source = transformedSource.source;
            let voxelSize = source.spec.voxelSize;
            let chunks = source.chunks;
            let objectToDataMatrix = tempMat4;
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].identity(objectToDataMatrix);
            if (source.vectorGraphicsCoordinatesInVoxels) {
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].scale(objectToDataMatrix, objectToDataMatrix, voxelSize);
            }
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].multiply(objectToDataMatrix, chunkLayout.transform, objectToDataMatrix);
            // Compute projection matrix that transforms vertex coordinates to device coordinates
            gl.uniformMatrix4fv(shader.uniform('uProjection'), false, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_5__["mat4"].multiply(tempMat4, sliceView.dataToDevice, objectToDataMatrix));
            let visibleChunks = sliceView.visibleChunks.get(chunkLayout);
            if (!visibleChunks) {
                continue;
            }
            for (let key of visibleChunks) {
                let chunk = chunks.get(key);
                if (chunk && chunk.state === neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY) {
                    let numInstances = chunk.numPoints / 2; // Two points == One vector
                    const aVertexFirst = shader.attribute('aVertexFirst');
                    chunk.vertexBuffer.bindToVertexAttrib(aVertexFirst, 
                    /*components=*/ 3, 
                    /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
                    /*normalized=*/ false, 
                    /*stride=*/ 6 * 4, 
                    /*offset=*/ 0);
                    gl.vertexAttribDivisor(aVertexFirst, 1);
                    const aVertexSecond = shader.attribute('aVertexSecond');
                    chunk.vertexBuffer.bindToVertexAttrib(aVertexSecond, 
                    /*components=*/ 3, 
                    /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
                    /*normalized=*/ false, 
                    /*stride=*/ 6 * 4, 
                    /*offset=*/ 3 * 4);
                    gl.vertexAttribDivisor(aVertexSecond, 1);
                    gl.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, 4, numInstances);
                    gl.vertexAttribDivisor(aVertexFirst, 0);
                    gl.vertexAttribDivisor(aVertexSecond, 0);
                }
            }
        }
        this.endSlice(shader);
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/volume/base.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/sliceview/volume/base.ts ***!
  \***************************************************/
/*! exports provided: DATA_TYPE_BYTES, DataType, VolumeType, DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2, VolumeChunkSpecification, VOLUME_RPC_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeType", function() { return VolumeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2", function() { return DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkSpecification", function() { return VolumeChunkSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VOLUME_RPC_ID", function() { return VOLUME_RPC_ID; });
/* harmony import */ var neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/base */ "./src/neuroglancer/sliceview/base.ts");
/* harmony import */ var neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/data_type */ "./src/neuroglancer/util/data_type.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DATA_TYPE_BYTES", function() { return neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DATA_TYPE_BYTES"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"]; });

/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Specifies the interpretation of volumetric data.
 */
var VolumeType;
(function (VolumeType) {
    VolumeType[VolumeType["UNKNOWN"] = 0] = "UNKNOWN";
    VolumeType[VolumeType["IMAGE"] = 1] = "IMAGE";
    VolumeType[VolumeType["SEGMENTATION"] = 2] = "SEGMENTATION";
})(VolumeType || (VolumeType = {}));
/**
 * By default, choose a chunk size with at most 2^18 = 262144 voxels.
 */
const DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 = 18;
/**
 * Specifies a chunk layout and voxel size.
 */
class VolumeChunkSpecification extends neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["SliceViewChunkSpecification"] {
    constructor(options) {
        let { lowerVoxelBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["kZeroVec"], upperVoxelBound, chunkDataSize, voxelSize, transform, baseVoxelOffset = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["kZeroVec"] } = options;
        let { lowerClipBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create(), voxelSize, lowerVoxelBound), upperClipBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create(), voxelSize, upperVoxelBound) } = options;
        const chunkSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create(), chunkDataSize, voxelSize);
        let lowerChunkBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
        let upperChunkBound = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create();
        for (let i = 0; i < 3; ++i) {
            lowerChunkBound[i] = Math.floor(lowerVoxelBound[i] / chunkDataSize[i]);
            upperChunkBound[i] = Math.floor((upperVoxelBound[i] - 1) / chunkDataSize[i] + 1);
        }
        super({ voxelSize, transform, lowerChunkBound, upperChunkBound, chunkSize });
        this.baseVoxelOffset = baseVoxelOffset;
        this.lowerClipBound = lowerClipBound;
        this.upperClipBound = upperClipBound;
        this.lowerVoxelBound = lowerVoxelBound;
        this.upperVoxelBound = upperVoxelBound;
        this.chunkDataSize = chunkDataSize;
        let dataType = this.dataType = options.dataType;
        let numChannels = this.numChannels = options.numChannels;
        this.chunkBytes = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["prod3"])(chunkDataSize) * neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DATA_TYPE_BYTES"][dataType] * numChannels;
        this.compressedSegmentationBlockSize = options.compressedSegmentationBlockSize;
    }
    static make(options) {
        return new VolumeChunkSpecification(Object.assign({}, options, { transform: Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["getCombinedTransform"])(options.transform, options.volumeSourceOptions) }));
    }
    static fromObject(msg) {
        return new VolumeChunkSpecification(msg);
    }
    toObject() {
        return Object.assign({}, super.toObject(), { numChannels: this.numChannels, chunkDataSize: this.chunkDataSize, dataType: this.dataType, lowerVoxelBound: this.lowerVoxelBound, upperVoxelBound: this.upperVoxelBound, lowerClipBound: this.lowerClipBound, upperClipBound: this.upperClipBound, baseVoxelOffset: this.baseVoxelOffset, compressedSegmentationBlockSize: this.compressedSegmentationBlockSize });
    }
    /**
     * Returns a VolumeChunkSpecification with default compression specified if suitable for the
     * volumeType.
     */
    static withDefaultCompression(options) {
        let { compressedSegmentationBlockSize, dataType, voxelSize, transform, lowerVoxelBound, upperVoxelBound } = options;
        transform = Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["getCombinedTransform"])(transform, options.volumeSourceOptions);
        if (compressedSegmentationBlockSize === undefined &&
            options.volumeType === VolumeType.SEGMENTATION &&
            (dataType === neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT32 || dataType === neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT64)) {
            compressedSegmentationBlockSize = Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["getNearIsotropicBlockSize"])({
                numChannels: options.numChannels,
                voxelSize,
                transform,
                lowerVoxelBound,
                upperVoxelBound,
                maxVoxelsPerChunkLog2: 9,
                maxBlockSize: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].min(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].create(), options.chunkDataSize, options.maxCompressedSegmentationBlockSize || neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["kInfinityVec"]),
            });
        }
        return new VolumeChunkSpecification(Object.assign({}, options, { compressedSegmentationBlockSize, transform }));
    }
    static getDefaults(options) {
        const adjustedOptions = Object.assign({}, options, { transform: Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["getCombinedTransform"])(options.transform, options.volumeSourceOptions) });
        let { chunkDataSizes = Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_0__["getChunkDataSizes"])(adjustedOptions) } = options;
        return chunkDataSizes.map(chunkDataSize => VolumeChunkSpecification.withDefaultCompression(Object.assign({}, options, { chunkDataSize })));
    }
}
const VOLUME_RPC_ID = 'volume';


/***/ }),

/***/ "./src/neuroglancer/sliceview/volume/frontend.ts":
/*!*******************************************************!*\
  !*** ./src/neuroglancer/sliceview/volume/frontend.ts ***!
  \*******************************************************/
/*! exports provided: registerChunkFormatHandler, getChunkFormatHandler, VolumeChunkSource, VolumeChunk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerChunkFormatHandler", function() { return registerChunkFormatHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChunkFormatHandler", function() { return getChunkFormatHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunkSource", function() { return VolumeChunkSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VolumeChunk", function() { return VolumeChunk; });
/* harmony import */ var neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/frontend */ "./src/neuroglancer/sliceview/frontend.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const tempChunkGridPosition = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
const tempLocalPosition = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
var chunkFormatHandlers = new Array();
function registerChunkFormatHandler(factory) {
    chunkFormatHandlers.push(factory);
}
function getChunkFormatHandler(gl, spec) {
    for (let handler of chunkFormatHandlers) {
        let result = handler(gl, spec);
        if (result != null) {
            return result;
        }
    }
    throw new Error('No chunk format handler found.');
}
class VolumeChunkSource extends neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_0__["SliceViewChunkSource"] {
    constructor(chunkManager, options) {
        super(chunkManager, options);
        this.chunkFormatHandler =
            this.registerDisposer(getChunkFormatHandler(chunkManager.chunkQueueManager.gl, this.spec));
    }
    get chunkFormat() {
        return this.chunkFormatHandler.chunkFormat;
    }
    getValueAt(position, chunkLayout = this.spec.chunkLayout) {
        const chunkGridPosition = tempChunkGridPosition;
        const localPosition = tempLocalPosition;
        let spec = this.spec;
        let chunkSize = chunkLayout.size;
        chunkLayout.globalToLocalSpatial(localPosition, position);
        for (let i = 0; i < 3; ++i) {
            const chunkSizeValue = chunkSize[i];
            const localPositionValue = localPosition[i];
            chunkGridPosition[i] = Math.floor(localPositionValue / chunkSizeValue);
        }
        let key = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3Key"])(chunkGridPosition);
        let chunk = this.chunks.get(key);
        if (!chunk) {
            return null;
        }
        // Reuse temporary variable.
        const dataPosition = chunkGridPosition;
        const voxelSize = spec.voxelSize;
        for (let i = 0; i < 3; ++i) {
            dataPosition[i] =
                Math.floor((localPosition[i] - chunkGridPosition[i] * chunkSize[i]) / voxelSize[i]);
        }
        let chunkDataSize = chunk.chunkDataSize;
        for (let i = 0; i < 3; ++i) {
            if (dataPosition[i] >= chunkDataSize[i]) {
                return undefined;
            }
        }
        let { numChannels } = spec;
        if (numChannels === 1) {
            return chunk.getChannelValueAt(dataPosition, 0);
        }
        else {
            let result = new Array(numChannels);
            for (let i = 0; i < numChannels; ++i) {
                result[i] = chunk.getChannelValueAt(dataPosition, i);
            }
            return result;
        }
    }
    getChunk(x) {
        return this.chunkFormatHandler.getChunk(this, x);
    }
}
class VolumeChunk extends neuroglancer_sliceview_frontend__WEBPACK_IMPORTED_MODULE_0__["SliceViewChunk"] {
    get chunkFormat() {
        return this.source.chunkFormat;
    }
    constructor(source, x) {
        super(source, x);
        this.chunkDataSize = x['chunkDataSize'] || source.spec.chunkDataSize;
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/volume/image_renderlayer.ts":
/*!****************************************************************!*\
  !*** ./src/neuroglancer/sliceview/volume/image_renderlayer.ts ***!
  \****************************************************************/
/*! exports provided: FRAGMENT_MAIN_START, getTrackableFragmentMain, ImageRenderLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_MAIN_START", function() { return FRAGMENT_MAIN_START; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTrackableFragmentMain", function() { return getTrackableFragmentMain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageRenderLayer", function() { return ImageRenderLayer; });
/* harmony import */ var neuroglancer_sliceview_volume_renderlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/volume/renderlayer */ "./src/neuroglancer/sliceview/volume/renderlayer.ts");
/* harmony import */ var neuroglancer_trackable_blend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/trackable_blend */ "./src/neuroglancer/trackable_blend.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_webgl_colormaps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/webgl/colormaps */ "./src/neuroglancer/webgl/colormaps.ts");
/* harmony import */ var neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/webgl/dynamic_shader */ "./src/neuroglancer/webgl/dynamic_shader.ts");
/* harmony import */ var neuroglancer_webgl_shader_ui_controls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/webgl/shader_ui_controls */ "./src/neuroglancer/webgl/shader_ui_controls.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const FRAGMENT_MAIN_START = '//NEUROGLANCER_IMAGE_RENDERLAYER_FRAGMENT_MAIN_START';
const DEFAULT_FRAGMENT_MAIN = `void main() {
  emitGrayscale(toNormalized(getDataValue()));
}
`;
function getTrackableFragmentMain(value = DEFAULT_FRAGMENT_MAIN) {
    return Object(neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_4__["makeTrackableFragmentMain"])(value);
}
class ImageRenderLayer extends neuroglancer_sliceview_volume_renderlayer__WEBPACK_IMPORTED_MODULE_0__["RenderLayer"] {
    constructor(multiscaleSource, options) {
        const { opacity, blendMode, shaderControlState } = options;
        super(multiscaleSource, Object.assign({}, options, { fallbackShaderParameters: new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_2__["WatchableValue"](Object(neuroglancer_webgl_shader_ui_controls__WEBPACK_IMPORTED_MODULE_5__["parseShaderUiControls"])(DEFAULT_FRAGMENT_MAIN)), encodeShaderParameters: p => p.source, shaderParameters: shaderControlState.parseResult }));
        this.shaderControlState = shaderControlState;
        this.opacity = opacity;
        this.blendMode = blendMode;
        this.registerDisposer(opacity.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(blendMode.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(shaderControlState.changed.add(this.redrawNeeded.dispatch));
    }
    defineShader(builder, shaderParseResult) {
        if (shaderParseResult.errors.length !== 0) {
            throw new Error('Invalid UI control specification');
        }
        builder.addUniform('highp float', 'uOpacity');
        builder.addFragmentCode(`
void emitRGBA(vec4 rgba) {
  emit(vec4(rgba.rgb, rgba.a * uOpacity));
}
void emitRGB(vec3 rgb) {
  emit(vec4(rgb, uOpacity));
}
void emitGrayscale(float value) {
  emit(vec4(value, value, value, uOpacity));
}
void emitTransparent() {
  emit(vec4(0.0, 0.0, 0.0, 0.0));
}
`);
        builder.addFragmentCode(neuroglancer_webgl_colormaps__WEBPACK_IMPORTED_MODULE_3__["glsl_COLORMAPS"]);
        Object(neuroglancer_webgl_shader_ui_controls__WEBPACK_IMPORTED_MODULE_5__["addControlsToBuilder"])(shaderParseResult.controls, builder);
        builder.setFragmentMainFunction(FRAGMENT_MAIN_START + '\n' + shaderParseResult.code);
    }
    initializeShader(_sliceView, shader, parameters) {
        const { gl } = this;
        gl.uniform1f(shader.uniform('uOpacity'), this.opacity.value);
        Object(neuroglancer_webgl_shader_ui_controls__WEBPACK_IMPORTED_MODULE_5__["setControlsInShader"])(gl, shader, this.shaderControlState, parameters.controls);
    }
    setGLBlendMode(gl, renderLayerNum) {
        const blendModeValue = this.blendMode.value;
        if (blendModeValue === neuroglancer_trackable_blend__WEBPACK_IMPORTED_MODULE_1__["BLEND_MODES"].ADDITIVE || renderLayerNum > 0) {
            gl.enable(gl.BLEND);
            neuroglancer_trackable_blend__WEBPACK_IMPORTED_MODULE_1__["BLEND_FUNCTIONS"].get(blendModeValue)(gl);
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/volume/renderlayer.ts":
/*!**********************************************************!*\
  !*** ./src/neuroglancer/sliceview/volume/renderlayer.ts ***!
  \**********************************************************/
/*! exports provided: glsl_getPositionWithinChunk, RenderLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_getPositionWithinChunk", function() { return glsl_getPositionWithinChunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderLayer", function() { return RenderLayer; });
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/sliceview/base */ "./src/neuroglancer/sliceview/base.ts");
/* harmony import */ var neuroglancer_sliceview_bounding_box_shader_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/sliceview/bounding_box_shader_helper */ "./src/neuroglancer/sliceview/bounding_box_shader_helper.ts");
/* harmony import */ var neuroglancer_sliceview_renderlayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/sliceview/renderlayer */ "./src/neuroglancer/sliceview/renderlayer.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/* harmony import */ var neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/webgl/dynamic_shader */ "./src/neuroglancer/webgl/dynamic_shader.ts");
/* harmony import */ var neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/webgl/shader_lib */ "./src/neuroglancer/webgl/shader_lib.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








const DEBUG_VERTICES = false;
/**
 * Extra amount by which the chunk position computed in the vertex shader is shifted in the
 * direction of the component-wise absolute value of the plane normal.  In Neuroglancer, a
 * cross-section plane exactly on the boundary between two voxels is a common occurrence and is
 * intended to result in the display of the "next" (i.e. higher coordinate) plane rather than the
 * "previous" (lower coordinate) plane.  However, due to various sources of floating point
 * inaccuracy (in particular, shader code which has relaxed rules), values exactly on the boundary
 * between voxels may be slightly shifted in either direction.  To ensure that this doesn't result
 * in the display of the wrong data (i.e. the previous rather than next plane), we always shift
 * toward the "next" plane by this small amount.
 */
const CHUNK_POSITION_EPSILON = 1e-3;
const glsl_getPositionWithinChunk = `
highp ivec3 getPositionWithinChunk () {
  return ivec3(min(vChunkPosition, uChunkDataSize - 1.0));
}
`;
const tempMat4 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].create();
const tempVec3 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
class VolumeSliceVertexComputationManager extends neuroglancer_sliceview_bounding_box_shader_helper__WEBPACK_IMPORTED_MODULE_2__["BoundingBoxCrossSectionRenderHelper"] {
    static get(gl) {
        return gl.memoize.get('volume.VolumeSliceVertexComputationManager', () => new VolumeSliceVertexComputationManager(gl));
    }
    defineShader(builder) {
        super.defineShader(builder);
        // A number in [0, 6) specifying which vertex to compute.
        builder.addAttribute('highp float', 'aVertexIndexFloat');
        // Specifies translation of the current chunk.
        builder.addUniform('highp vec3', 'uTranslation');
        // Matrix by which computed vertices will be transformed.
        builder.addUniform('highp mat4', 'uProjectionMatrix');
        // Chunk size in voxels.
        builder.addUniform('highp vec3', 'uChunkDataSize');
        // Size of a voxel in nanometers.
        builder.addUniform('highp vec3', 'uVoxelSize');
        builder.addUniform('highp vec3', 'uLowerClipBound');
        builder.addUniform('highp vec3', 'uUpperClipBound');
        // Position within chunk of vertex, in floating point range [0, chunkDataSize].
        builder.addVarying('highp vec3', 'vChunkPosition');
        builder.setVertexMain(`
vec3 chunkSize = uChunkDataSize * uVoxelSize;
vec3 position = getBoundingBoxPlaneIntersectionVertexPosition(chunkSize, uTranslation, uLowerClipBound, uUpperClipBound, int(aVertexIndexFloat));
gl_Position = uProjectionMatrix * vec4(position, 1.0);
vChunkPosition = (position - uTranslation) / uVoxelSize +
    ${CHUNK_POSITION_EPSILON} * abs(uPlaneNormal);
`);
        builder.addFragmentCode(glsl_getPositionWithinChunk);
    }
    computeVerticesDebug(uChunkDataSize, uVoxelSize, uLowerClipBound, uUpperClipBound, uPlaneDistance, uPlaneNormal, uTranslation, uProjectionMatrix) {
        let chunkSize = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].multiply(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), uChunkDataSize, uVoxelSize);
        let gl_Position = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), vChunkPosition = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create(), planeNormalAbs = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].fromValues(Math.abs(uPlaneNormal[0]), Math.abs(uPlaneNormal[1]), Math.abs(uPlaneNormal[2]));
        for (let vertexIndex = 0; vertexIndex < 6; ++vertexIndex) {
            const position = this.computeVertexPositionDebug(chunkSize, uLowerClipBound, uUpperClipBound, uPlaneDistance, uPlaneNormal, uTranslation, vertexIndex);
            if (position === undefined) {
                console.log('no intersection found');
                return;
            }
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].transformMat4(gl_Position, position, uProjectionMatrix);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].sub(vChunkPosition, position, uTranslation);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].divide(vChunkPosition, vChunkPosition, uVoxelSize);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].scaleAndAdd(vChunkPosition, vChunkPosition, planeNormalAbs, CHUNK_POSITION_EPSILON);
            console.log(`vertex ${vertexIndex}, at ${gl_Position}, vChunkPosition = ${vChunkPosition}`);
        }
    }
    beginSlice(_gl, shader) {
        let aVertexIndexFloat = shader.attribute('aVertexIndexFloat');
        this.data.outputVertexIndices.bindToVertexAttrib(aVertexIndexFloat, 1);
    }
    endSlice(gl, shader) {
        let aVertexIndexFloat = shader.attribute('aVertexIndexFloat');
        gl.disableVertexAttribArray(aVertexIndexFloat);
    }
    beginSource(gl, shader, sliceView, dataToDeviceMatrix, spec, chunkLayout) {
        this.setViewportPlane(shader, sliceView.viewportAxes[2], sliceView.centerDataPosition, chunkLayout.invTransform);
        // Compute projection matrix that transforms chunk layout coordinates to device coordinates.
        gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["mat4"].multiply(tempMat4, dataToDeviceMatrix, chunkLayout.transform));
        gl.uniform3fv(shader.uniform('uVoxelSize'), spec.voxelSize);
        gl.uniform3fv(shader.uniform('uLowerClipBound'), spec.lowerClipBound);
        gl.uniform3fv(shader.uniform('uUpperClipBound'), spec.upperClipBound);
        if (DEBUG_VERTICES) {
            window['debug_sliceView_uVoxelSize'] = spec.voxelSize;
            window['debug_sliceView_uLowerClipBound'] = spec.lowerClipBound;
            window['debug_sliceView_uUpperClipBound'] = spec.upperClipBound;
            window['debug_sliceView'] = sliceView;
            window['debug_sliceView_dataToDevice'] = dataToDeviceMatrix;
        }
    }
    setupChunkDataSize(gl, shader, chunkDataSize) {
        gl.uniform3fv(shader.uniform('uChunkDataSize'), chunkDataSize);
        if (DEBUG_VERTICES) {
            window['debug_sliceView_chunkDataSize'] = chunkDataSize;
        }
    }
    drawChunk(gl, shader, chunkPosition) {
        gl.uniform3fv(shader.uniform('uTranslation'), chunkPosition);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 6);
        if (DEBUG_VERTICES) {
            let sliceView = window['debug_sliceView'];
            let chunkDataSize = window['debug_sliceView_chunkDataSize'];
            let voxelSize = window['debug_sliceView_uVoxelSize'];
            let lowerClipBound = window['debug_sliceView_uLowerClipBound'];
            let upperClipBound = window['debug_sliceView_uUpperClipBound'];
            console.log(`Drawing chunk: ${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3Key"])(chunkPosition)} of data size ${Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3Key"])(chunkDataSize)}`);
            let dataToDeviceMatrix = window['debug_sliceView_dataToDevice'];
            this.computeVerticesDebug(chunkDataSize, voxelSize, lowerClipBound, upperClipBound, sliceView.viewportPlaneDistanceToOrigin, sliceView.viewportAxes[2], chunkPosition, dataToDeviceMatrix);
        }
    }
}
function medianOf3(a, b, c) {
    return a > b ? (c > a ? a : (b > c ? b : c)) : (c > b ? b : (a > c ? a : c));
}
class RenderLayer extends neuroglancer_sliceview_renderlayer__WEBPACK_IMPORTED_MODULE_3__["RenderLayer"] {
    constructor(multiscaleSource, options) {
        const { shaderError = Object(neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_6__["makeWatchableShaderError"])(), shaderParameters } = options;
        const { sourceOptions = {} } = options;
        super(multiscaleSource.chunkManager, multiscaleSource.getSources(sourceOptions), options);
        const { gl } = this;
        this.shaderParameters = shaderParameters;
        this.registerDisposer(shaderParameters.changed.add(this.redrawNeeded.dispatch));
        this.shaderGetter = Object(neuroglancer_webgl_dynamic_shader__WEBPACK_IMPORTED_MODULE_6__["parameterizedContextDependentShaderGetter"])(this, gl, {
            memoizeKey: `volume/RenderLayer:${Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_5__["getObjectId"])(this.constructor)}`,
            fallbackParameters: options.fallbackShaderParameters,
            parameters: shaderParameters,
            encodeParameters: options.encodeShaderParameters,
            shaderError,
            defineShader: (builder, parameters, chunkFormat) => {
                this.vertexComputationManager.defineShader(builder);
                builder.addOutputBuffer('vec4', 'v4f_fragData0', 0);
                builder.addFragmentCode(`
void emit(vec4 color) {
  v4f_fragData0 = color;
}
`);
                chunkFormat.defineShader(builder);
                builder.addFragmentCode(`
${Object(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_7__["getShaderType"])(this.dataType)} getDataValue() { return getDataValue(0); }
`);
                this.defineShader(builder, parameters);
            },
            getContextKey: context => context.shaderKey,
        });
        this.vertexComputationManager = VolumeSliceVertexComputationManager.get(gl);
        const transformedSources = Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_1__["getTransformedSources"])(this);
        {
            const { source, chunkLayout } = transformedSources[0][0];
            const spec = source.spec;
            const boundingBox = this.boundingBox = new neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["BoundingBox"](neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].fromValues(Infinity, Infinity, Infinity), neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].fromValues(-Infinity, -Infinity, -Infinity));
            const globalCorner = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
            const localCorner = tempVec3;
            for (let cornerIndex = 0; cornerIndex < 8; ++cornerIndex) {
                for (let i = 0; i < 3; ++i) {
                    localCorner[i] = cornerIndex & (1 << i) ? spec.upperClipBound[i] : spec.lowerClipBound[i];
                }
                chunkLayout.localSpatialToGlobal(globalCorner, localCorner);
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].min(boundingBox.lower, boundingBox.lower, globalCorner);
                neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].max(boundingBox.upper, boundingBox.upper, globalCorner);
            }
        }
    }
    get dataType() {
        return this.sources[0][0].spec.dataType;
    }
    getValueAt(position) {
        for (let alternatives of Object(neuroglancer_sliceview_base__WEBPACK_IMPORTED_MODULE_1__["getTransformedSources"])(this)) {
            for (let transformedSource of alternatives) {
                const source = transformedSource.source;
                let result = source.getValueAt(position, transformedSource.chunkLayout);
                if (result != null) {
                    return result;
                }
            }
        }
        return null;
    }
    beginChunkFormat(sliceView, chunkFormat) {
        const { gl } = this;
        const shaderResult = this.shaderGetter(chunkFormat);
        const { shader, parameters, fallback } = shaderResult;
        if (shader !== null) {
            shader.bind();
            this.vertexComputationManager.beginSlice(gl, shader);
            this.initializeShader(sliceView, shader, parameters, fallback);
            chunkFormat.beginDrawing(gl, shader);
        }
        return shaderResult;
    }
    endSlice(_sliceView, shader, _parameters) {
        const { gl } = this;
        this.vertexComputationManager.endSlice(gl, shader);
    }
    draw(sliceView) {
        let visibleSources = sliceView.visibleLayers.get(this);
        if (visibleSources.length === 0) {
            return;
        }
        const { gl } = this;
        let chunkPosition = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].create();
        const { renderScaleHistogram, vertexComputationManager } = this;
        if (renderScaleHistogram !== undefined) {
            renderScaleHistogram.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
        }
        let shaderResult;
        let shader = null;
        let prevChunkFormat;
        const endShader = () => {
            if (shader === null)
                return;
            prevChunkFormat.endDrawing(gl, shader);
            this.endSlice(sliceView, shader, shaderResult.parameters);
        };
        for (let transformedSource of visibleSources) {
            const chunkLayout = transformedSource.chunkLayout;
            const source = transformedSource.source;
            let originalChunkSize = chunkLayout.size;
            let chunkDataSize;
            let visibleChunks = sliceView.visibleChunks.get(chunkLayout);
            if (!visibleChunks) {
                continue;
            }
            const chunkFormat = source.chunkFormat;
            if (chunkFormat !== prevChunkFormat) {
                prevChunkFormat = chunkFormat;
                endShader();
                shaderResult = this.beginChunkFormat(sliceView, chunkFormat);
                shader = shaderResult.shader;
            }
            if (shader === null)
                continue;
            const chunks = source.chunks;
            vertexComputationManager.beginSource(gl, shader, sliceView, sliceView.dataToDevice, source.spec, chunkLayout);
            chunkFormat.beginSource(gl, shader);
            let presentCount = 0, notPresentCount = 0;
            for (let key of visibleChunks) {
                let chunk = chunks.get(key);
                if (chunk && chunk.state === neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_0__["ChunkState"].GPU_MEMORY) {
                    let newChunkDataSize = chunk.chunkDataSize;
                    if (chunkDataSize === undefined || !neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].equals(chunkDataSize, newChunkDataSize)) {
                        chunkDataSize = newChunkDataSize;
                        vertexComputationManager.setupChunkDataSize(gl, shader, chunkDataSize);
                    }
                    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_4__["vec3"].multiply(chunkPosition, originalChunkSize, chunk.chunkGridPosition);
                    chunkFormat.bindChunk(gl, shader, chunk);
                    vertexComputationManager.drawChunk(gl, shader, chunkPosition);
                    ++presentCount;
                }
                else {
                    ++notPresentCount;
                }
            }
            if ((presentCount !== 0 || notPresentCount !== 0) && renderScaleHistogram !== undefined) {
                const { voxelSize } = transformedSource;
                // TODO(jbms): replace median hack with more accurate estimate, e.g. based on ellipsoid
                // cross section.
                const medianVoxelSize = medianOf3(voxelSize[0], voxelSize[1], voxelSize[2]);
                renderScaleHistogram.add(medianVoxelSize, medianVoxelSize / sliceView.pixelSize, presentCount, notPresentCount);
            }
        }
        endShader();
    }
}


/***/ }),

/***/ "./src/neuroglancer/sliceview/volume/segmentation_renderlayer.ts":
/*!***********************************************************************!*\
  !*** ./src/neuroglancer/sliceview/volume/segmentation_renderlayer.ts ***!
  \***********************************************************************/
/*! exports provided: EquivalencesHashMap, SegmentationRenderLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquivalencesHashMap", function() { return EquivalencesHashMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentationRenderLayer", function() { return SegmentationRenderLayer; });
/* harmony import */ var neuroglancer_gpu_hash_hash_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/gpu_hash/hash_table */ "./src/neuroglancer/gpu_hash/hash_table.ts");
/* harmony import */ var neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/gpu_hash/shader */ "./src/neuroglancer/gpu_hash/shader.ts");
/* harmony import */ var neuroglancer_segment_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/segment_color */ "./src/neuroglancer/segment_color.ts");
/* harmony import */ var neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/segmentation_display_state/frontend */ "./src/neuroglancer/segmentation_display_state/frontend.ts");
/* harmony import */ var neuroglancer_sliceview_volume_renderlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/sliceview/volume/renderlayer */ "./src/neuroglancer/sliceview/volume/renderlayer.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class EquivalencesHashMap {
    constructor(disjointSets) {
        this.disjointSets = disjointSets;
        this.generation = Number.NaN;
        this.hashMap = new neuroglancer_gpu_hash_hash_table__WEBPACK_IMPORTED_MODULE_0__["HashMapUint64"]();
    }
    update() {
        let { disjointSets } = this;
        const { generation } = disjointSets;
        if (this.generation !== generation) {
            this.generation = generation;
            let { hashMap } = this;
            hashMap.clear();
            for (let [objectId, minObjectId] of disjointSets.mappings()) {
                hashMap.set(objectId, minObjectId);
            }
        }
    }
}
class SegmentationRenderLayer extends neuroglancer_sliceview_volume_renderlayer__WEBPACK_IMPORTED_MODULE_4__["RenderLayer"] {
    constructor(multiscaleSource, displayState) {
        super(multiscaleSource, {
            shaderParameters: new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_5__["AggregateWatchableValue"](refCounted => ({
                hasEquivalences: refCounted.registerDisposer(Object(neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_5__["makeCachedDerivedWatchableValue"])(x => x.size !== 0, [displayState.segmentEquivalences])),
                hasHighlightedSegments: refCounted.registerDisposer(Object(neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_5__["makeCachedDerivedWatchableValue"])(x => x.size !== 0, [displayState.highlightedSegments])),
                hasSegmentStatedColors: refCounted.registerDisposer(Object(neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_5__["makeCachedDerivedWatchableValue"])(x => x.size !== 0, [displayState.segmentStatedColors])),
                hideSegmentZero: displayState.hideSegmentZero,
            })),
            transform: displayState.transform,
            renderScaleHistogram: displayState.renderScaleHistogram,
            renderScaleTarget: displayState.renderScaleTarget,
        });
        this.displayState = displayState;
        this.segmentColorShaderManager = new neuroglancer_segment_color__WEBPACK_IMPORTED_MODULE_2__["SegmentColorShaderManager"]('segmentColorHash');
        this.segmentStatedColorShaderManager = new neuroglancer_segment_color__WEBPACK_IMPORTED_MODULE_2__["SegmentStatedColorShaderManager"]('segmentStatedColor');
        this.gpuSegmentStatedColorHashTable = neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["GPUHashTable"].get(this.gl, this.displayState.segmentStatedColors.hashTable);
        this.hashTableManager = new neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["HashSetShaderManager"]('visibleSegments');
        this.gpuHashTable = neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["GPUHashTable"].get(this.gl, this.displayState.visibleSegments.hashTable);
        this.hashTableManagerHighlighted = new neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["HashSetShaderManager"]('highlightedSegments');
        this.gpuHashTableHighlighted = neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["GPUHashTable"].get(this.gl, this.displayState.highlightedSegments.hashTable);
        this.equivalencesShaderManager = new neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["HashMapShaderManager"]('equivalences');
        this.equivalencesHashMap = new EquivalencesHashMap(this.displayState.segmentEquivalences.disjointSets);
        this.gpuEquivalencesHashTable = neuroglancer_gpu_hash_shader__WEBPACK_IMPORTED_MODULE_1__["GPUHashTable"].get(this.gl, this.equivalencesHashMap.hashMap);
        this.registerDisposer(this.shaderParameters);
        Object(neuroglancer_segmentation_display_state_frontend__WEBPACK_IMPORTED_MODULE_3__["registerRedrawWhenSegmentationDisplayStateChanged"])(displayState, this);
        this.registerDisposer(displayState.selectedAlpha.changed.add(this.redrawNeeded.dispatch));
        this.registerDisposer(displayState.notSelectedAlpha.changed.add(this.redrawNeeded.dispatch));
    }
    defineShader(builder, parameters) {
        this.hashTableManager.defineShader(builder);
        builder.addFragmentCode(`
uint64_t getUint64DataValue() {
  return toUint64(getDataValue());
}
`);
        if (parameters.hasEquivalences) {
            this.equivalencesShaderManager.defineShader(builder);
            builder.addFragmentCode(`
uint64_t getMappedObjectId() {
  uint64_t value = getUint64DataValue();
  uint64_t mappedValue;
  if (${this.equivalencesShaderManager.getFunctionName}(value, mappedValue)) {
    return mappedValue;
  }
  return value;
}
`);
        }
        else {
            builder.addFragmentCode(`
uint64_t getMappedObjectId() {
  return getUint64DataValue();
}
`);
        }
        this.segmentColorShaderManager.defineShader(builder);
        builder.addUniform('highp uvec2', 'uSelectedSegment');
        builder.addUniform('highp uint', 'uShowAllSegments');
        builder.addUniform('highp float', 'uSelectedAlpha');
        builder.addUniform('highp float', 'uNotSelectedAlpha');
        builder.addUniform('highp float', 'uSaturation');
        let fragmentMain = `
  uint64_t value = getMappedObjectId();

  float alpha = uSelectedAlpha;
  float saturation = uSaturation;
`;
        if (parameters.hideSegmentZero) {
            fragmentMain += `
  if (value.value[0] == 0u && value.value[1] == 0u) {
    emit(vec4(vec4(0, 0, 0, 0)));
    return;
  }
`;
        }
        fragmentMain += `
  bool has = uShowAllSegments != 0u ? true : ${this.hashTableManager.hasFunctionName}(value);
  if (uSelectedSegment == value.value) {
    saturation = has ? 0.5 : 0.75;
  } else if (!has) {
    alpha = uNotSelectedAlpha;
  }
`;
        // If the value has a mapped color, use it; otherwise, compute the color.
        if (parameters.hasSegmentStatedColors) {
            this.segmentStatedColorShaderManager.defineShader(builder);
            fragmentMain += `
  vec3 rgb;
  if (!${this.segmentStatedColorShaderManager.getFunctionName}(value, rgb)) {
    rgb = segmentColorHash(value);
  }
`;
        }
        else {
            fragmentMain += `
  vec3 rgb = segmentColorHash(value);
`;
        }
        if (parameters.hasHighlightedSegments) {
            this.hashTableManagerHighlighted.defineShader(builder);
            // Override color for all highlighted segments.
            fragmentMain += `
  if (${this.hashTableManagerHighlighted.hasFunctionName}(value)) {
    rgb = vec3(0.2,0.2,2.0);
    saturation = 1.0;
  };
`;
        }
        fragmentMain += `
  emit(vec4(mix(vec3(1.0,1.0,1.0), rgb, saturation), alpha));
`;
        builder.setFragmentMain(fragmentMain);
    }
    initializeShader(_sliceView, shader, parameters) {
        const { gl } = this;
        const { displayState } = this;
        const { segmentSelectionState, visibleSegments } = this.displayState;
        let selectedSegmentLow = 0, selectedSegmentHigh = 0;
        if (segmentSelectionState.hasSelectedSegment) {
            let seg = segmentSelectionState.selectedSegment;
            selectedSegmentLow = seg.low;
            selectedSegmentHigh = seg.high;
        }
        gl.uniform1f(shader.uniform('uSelectedAlpha'), this.displayState.selectedAlpha.value);
        gl.uniform1f(shader.uniform('uSaturation'), this.displayState.saturation.value);
        gl.uniform1f(shader.uniform('uNotSelectedAlpha'), this.displayState.notSelectedAlpha.value);
        gl.uniform2ui(shader.uniform('uSelectedSegment'), selectedSegmentLow, selectedSegmentHigh);
        gl.uniform1ui(shader.uniform('uShowAllSegments'), visibleSegments.hashTable.size ? 0 : 1);
        this.hashTableManager.enable(gl, shader, this.gpuHashTable);
        if (parameters.hasHighlightedSegments) {
            this.hashTableManagerHighlighted.enable(gl, shader, this.gpuHashTableHighlighted);
        }
        if (parameters.hasEquivalences) {
            this.equivalencesHashMap.update();
            this.equivalencesShaderManager.enable(gl, shader, this.gpuEquivalencesHashTable);
        }
        this.segmentColorShaderManager.enable(gl, shader, displayState.segmentColorHash);
        if (parameters.hasSegmentStatedColors) {
            this.segmentStatedColorShaderManager.enable(gl, shader, this.gpuSegmentStatedColorHashTable);
        }
    }
    endSlice(sliceView, shader, parameters) {
        const { gl } = this;
        this.hashTableManager.disable(gl, shader);
        if (parameters.hasHighlightedSegments) {
            this.hashTableManagerHighlighted.disable(gl, shader);
        }
        if (parameters.hasEquivalences) {
            this.equivalencesShaderManager.disable(gl, shader);
        }
        if (parameters.hasSegmentStatedColors) {
            this.segmentStatedColorShaderManager.disable(gl, shader);
        }
        super.endSlice(sliceView, shader, parameters);
    }
}


/***/ }),

/***/ "./src/neuroglancer/status.css":
/*!*************************************!*\
  !*** ./src/neuroglancer/status.css ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/status.ts":
/*!************************************!*\
  !*** ./src/neuroglancer/status.ts ***!
  \************************************/
/*! exports provided: DEFAULT_STATUS_DELAY, StatusMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_STATUS_DELAY", function() { return DEFAULT_STATUS_DELAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusMessage", function() { return StatusMessage; });
/* harmony import */ var _status_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./status.css */ "./src/neuroglancer/status.css");
/* harmony import */ var _status_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_status_css__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let statusContainer = null;
var DEFAULT_STATUS_DELAY = 200;
class StatusMessage {
    constructor(delay = false) {
        if (statusContainer === null) {
            statusContainer = document.createElement('ul');
            statusContainer.id = 'statusContainer';
            const el = document.getElementById('neuroglancer-container');
            if (el) {
                el.appendChild(statusContainer);
            }
            else {
                document.body.appendChild(statusContainer);
            }
        }
        let element = document.createElement('li');
        this.element = element;
        if (delay === true) {
            delay = DEFAULT_STATUS_DELAY;
        }
        if (delay !== false) {
            this.setVisible(false);
            this.timer = setTimeout(this.setVisible.bind(this, true), delay);
        }
        else {
            this.timer = null;
        }
        statusContainer.appendChild(element);
    }
    dispose() {
        statusContainer.removeChild(this.element);
        this.element = undefined;
        if (this.timer !== null) {
            clearTimeout(this.timer);
        }
    }
    setText(text, makeVisible) {
        this.element.textContent = text;
        if (makeVisible) {
            this.setVisible(true);
        }
    }
    setHTML(text, makeVisible) {
        this.element.innerHTML = text;
        if (makeVisible) {
            this.setVisible(true);
        }
    }
    setVisible(value) {
        if (this.timer !== null) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.element.style.display = value ? 'block' : 'none';
    }
    static forPromise(promise, options) {
        let status = new StatusMessage(options.delay);
        status.setText(options.initialMessage);
        let dispose = status.dispose.bind(status);
        promise.then(dispose, reason => {
            let msg;
            if (reason instanceof Error) {
                msg = reason.message;
            }
            else {
                msg = '' + reason;
            }
            let { errorPrefix = '' } = options;
            status.setErrorMessage(errorPrefix + msg);
            status.setVisible(true);
        });
        return promise;
    }
    setErrorMessage(message) {
        this.element.textContent = message + ' ';
        let button = document.createElement('button');
        button.textContent = 'Dismiss';
        button.addEventListener('click', () => {
            this.dispose();
        });
        this.element.appendChild(button);
    }
    static showMessage(message) {
        const msg = new StatusMessage();
        msg.element.textContent = message;
        msg.setVisible(true);
        return msg;
    }
    static showTemporaryMessage(message, closeAfter = 2000) {
        const msg = this.showMessage(message);
        setTimeout(() => msg.dispose(), closeAfter);
        return msg;
    }
}


/***/ }),

/***/ "./src/neuroglancer/trackable_alpha.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/trackable_alpha.ts ***!
  \*********************************************/
/*! exports provided: trackableAlphaValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackableAlphaValue", function() { return trackableAlphaValue; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Convenience interface for creating TrackableValue instances designed to represent alpha
 * (opacity) values.
 */


function trackableAlphaValue(initialValue = 0.5) {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["TrackableValue"](initialValue, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verifyFloat01"]);
}


/***/ }),

/***/ "./src/neuroglancer/trackable_blend.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/trackable_blend.ts ***!
  \*********************************************/
/*! exports provided: BLEND_MODES, BLEND_FUNCTIONS, trackableBlendModeValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_MODES", function() { return BLEND_MODES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_FUNCTIONS", function() { return BLEND_FUNCTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackableBlendModeValue", function() { return trackableBlendModeValue; });
/* harmony import */ var neuroglancer_util_trackable_enum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/trackable_enum */ "./src/neuroglancer/util/trackable_enum.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var BLEND_MODES;
(function (BLEND_MODES) {
    BLEND_MODES[BLEND_MODES["DEFAULT"] = 0] = "DEFAULT";
    BLEND_MODES[BLEND_MODES["ADDITIVE"] = 1] = "ADDITIVE";
})(BLEND_MODES || (BLEND_MODES = {}));
const BLEND_FUNCTIONS = new Map([
    [
        BLEND_MODES.DEFAULT,
        (gl) => {
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }
    ],
    [
        BLEND_MODES.ADDITIVE,
        (gl) => {
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        }
    ]
]);
function trackableBlendModeValue(initialValue = BLEND_MODES.DEFAULT) {
    return new neuroglancer_util_trackable_enum__WEBPACK_IMPORTED_MODULE_0__["TrackableEnum"](BLEND_MODES, initialValue);
}


/***/ }),

/***/ "./src/neuroglancer/trackable_boolean.ts":
/*!***********************************************!*\
  !*** ./src/neuroglancer/trackable_boolean.ts ***!
  \***********************************************/
/*! exports provided: TrackableBoolean, TrackableBooleanCheckbox, ElementVisibilityFromTrackableBoolean */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableBoolean", function() { return TrackableBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableBooleanCheckbox", function() { return TrackableBooleanCheckbox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ElementVisibilityFromTrackableBoolean", function() { return ElementVisibilityFromTrackableBoolean; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class TrackableBoolean {
    constructor(value_, defaultValue = value_) {
        this.value_ = value_;
        this.defaultValue = defaultValue;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
    }
    get value() {
        return this.value_;
    }
    set value(newValue) {
        if (newValue !== this.value_) {
            this.value_ = newValue;
            this.changed.dispatch();
        }
    }
    toggle() {
        this.value = !this.value;
    }
    toJSON() {
        let { value_ } = this;
        if (value_ === this.defaultValue) {
            return undefined;
        }
        return this.value_;
    }
    restoreState(x) {
        if (x === true || x === false) {
            this.value = x;
            return;
        }
        this.value = this.defaultValue;
    }
    reset() {
        this.value = this.defaultValue;
    }
}
class TrackableBooleanCheckbox extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(model) {
        super();
        this.model = model;
        this.element = document.createElement('input');
        let { element } = this;
        element.type = 'checkbox';
        this.registerDisposer(model.changed.add(() => {
            this.updateCheckbox();
        }));
        this.updateCheckbox();
        this.registerEventListener(element, 'change', function (_e) {
            model.value = this.checked;
        });
        // Prevent the checkbox from becoming focused.
        element.addEventListener('mousedown', (event) => {
            event.preventDefault();
        });
    }
    updateCheckbox() {
        this.element.checked = this.model.value;
    }
    disposed() {
        let { element } = this;
        let { parentElement } = element;
        if (parentElement) {
            parentElement.removeChild(element);
        }
        super.disposed();
    }
}
class ElementVisibilityFromTrackableBoolean extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(model, element) {
        super();
        this.model = model;
        this.element = element;
        this.initialDisplay = this.element.style.display;
        this.updateVisibility();
        this.registerDisposer(model.changed.add(this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => this.updateVisibility(), 0))));
    }
    updateVisibility() {
        this.element.style.display = this.model.value ? this.initialDisplay : 'none';
    }
}


/***/ }),

/***/ "./src/neuroglancer/trackable_finite_float.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/trackable_finite_float.ts ***!
  \****************************************************/
/*! exports provided: trackableFiniteFloat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackableFiniteFloat", function() { return trackableFiniteFloat; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Convenience interface for creating TrackableValue instances designed to represent alpha
 * (opacity) values.
 */


function trackableFiniteFloat(initialValue = 1.0) {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["TrackableValue"](initialValue, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verifyFiniteFloat"]);
}


/***/ }),

/***/ "./src/neuroglancer/trackable_value.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/trackable_value.ts ***!
  \*********************************************/
/*! exports provided: WatchableValue, TrackableValue, makeDerivedWatchableValue, makeCachedLazyDerivedWatchableValue, CachedWatchableValue, makeCachedDerivedWatchableValue, AggregateWatchableValue, ComputedWatchableValue, WatchableRefCounted, TrackableRefCounted, WatchableSet, registerNested */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WatchableValue", function() { return WatchableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableValue", function() { return TrackableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDerivedWatchableValue", function() { return makeDerivedWatchableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCachedLazyDerivedWatchableValue", function() { return makeCachedLazyDerivedWatchableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachedWatchableValue", function() { return CachedWatchableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCachedDerivedWatchableValue", function() { return makeCachedDerivedWatchableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AggregateWatchableValue", function() { return AggregateWatchableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComputedWatchableValue", function() { return ComputedWatchableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WatchableRefCounted", function() { return WatchableRefCounted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableRefCounted", function() { return TrackableRefCounted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WatchableSet", function() { return WatchableSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerNested", function() { return registerNested; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WatchableValue {
    constructor(value_) {
        this.value_ = value_;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
    }
    get value() {
        return this.value_;
    }
    set value(newValue) {
        if (newValue !== this.value_) {
            this.value_ = newValue;
            this.changed.dispatch();
        }
    }
}
class TrackableValue extends WatchableValue {
    constructor(value, validator, defaultValue = value) {
        super(value);
        this.validator = validator;
        this.defaultValue = defaultValue;
    }
    toJSON() {
        let { value_ } = this;
        if (value_ === this.defaultValue) {
            return undefined;
        }
        return this.value_;
    }
    reset() {
        this.value = this.defaultValue;
    }
    restoreState(x) {
        if (x !== undefined) {
            let { validator } = this;
            try {
                this.value = validator(x);
                return;
            }
            catch (ignoredError) {
            }
        }
        this.value = this.defaultValue;
    }
}
class DerivedWatchableValue extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(f, ws) {
        super();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
        this.f = f;
        this.ws = ws;
        for (const w of ws) {
            this.registerDisposer(w.changed.add(this.changed.dispatch));
        }
    }
    get value() {
        return this.f(...this.ws.map(w => w.value));
    }
}
function makeDerivedWatchableValue(f, ...ws) {
    return new DerivedWatchableValue(f, ws);
}
class CachedLazyDerivedWatchableValue extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(f, ws) {
        super();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
        this.valueGeneration = -1;
        this.f = f;
        this.ws = ws;
        for (const w of ws) {
            this.registerDisposer(w.changed.add(this.changed.dispatch));
        }
    }
    get value() {
        const generation = this.changed.count;
        if (generation !== this.valueGeneration) {
            this.value_ = this.f(...this.ws.map(w => w.value));
            this.valueGeneration = generation;
        }
        return this.value_;
    }
}
function makeCachedLazyDerivedWatchableValue(f, ...ws) {
    return new CachedLazyDerivedWatchableValue(f, ws);
}
class CachedWatchableValue extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(base, isEqual = (a, b) => a === b) {
        super();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
        this.value = base.value;
        this.registerDisposer(base.changed.add(() => {
            const newValue = base.value;
            if (!isEqual(this.value, newValue)) {
                this.value = newValue;
                this.changed.dispatch();
            }
        }));
    }
}
function makeCachedDerivedWatchableValue(f, ws, isEqual) {
    const derived = new DerivedWatchableValue(f, ws);
    const cached = new CachedWatchableValue(derived, isEqual);
    cached.registerDisposer(derived);
    return cached;
}
class AggregateWatchableValue extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(getWatchables) {
        super();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
        const watchables = getWatchables(this);
        const keys = Object.keys(watchables);
        const updateValue = () => {
            const obj = {};
            for (const k of keys) {
                obj[k] = watchables[k].value;
            }
            this.value = obj;
            this.changed.dispatch();
        };
        updateValue();
        for (const k of keys) {
            const watchable = watchables[k];
            // Ensure a unique function is used each time in case the same watchable is assigned to
            // multiple properties.
            this.registerDisposer(watchable.changed.add(() => updateValue()));
        }
    }
}
class ComputedWatchableValue extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(f, ...signals) {
        super();
        this.f = f;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
        for (const signal of signals) {
            this.registerDisposer(signal.add(this.changed.dispatch));
        }
    }
    get value() {
        return this.f();
    }
}
class WatchableRefCounted extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor() {
        super(...arguments);
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
    }
    get value() {
        return this.value_;
    }
    set value(value) {
        const { value_ } = this;
        this.value_ = value;
        if (value_ !== undefined) {
            value_.dispose();
            value_.unregisterDisposer(this.valueHandler);
            this.valueHandler = undefined;
        }
        if (value !== undefined) {
            const valueHandler = this.valueHandler = () => {
                if (this.value_ === value) {
                    this.value_ = undefined;
                    this.changed.dispatch();
                }
            };
            value.registerDisposer(valueHandler);
        }
        if (value !== value_) {
            this.changed.dispatch();
        }
    }
    reset() {
        this.value = undefined;
    }
    disposed() {
        if (this.value_ !== undefined) {
            this.value_.unregisterDisposer(this.valueHandler);
            this.value_.dispose();
        }
        this.value_ = undefined;
        super.disposed();
    }
}
class TrackableRefCounted extends WatchableRefCounted {
    constructor(validator, jsonConverter) {
        super();
        this.validator = validator;
        this.jsonConverter = jsonConverter;
    }
    toJSON() {
        const { value } = this;
        return value && this.jsonConverter(value);
    }
    restoreState(x) {
        this.value = this.validator(x);
    }
}
class WatchableSet {
    constructor(values) {
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
        if (values === undefined) {
            this.values = new Set();
        }
        else {
            this.values = new Set(values);
        }
    }
    add(x) {
        const { values } = this;
        if (!values.has(x)) {
            values.add(x);
            this.changed.dispatch();
        }
        return this;
    }
    delete(x) {
        const { values } = this;
        if (values.delete(x)) {
            this.changed.dispatch();
            return true;
        }
        return false;
    }
    has(x) {
        return this.values.has(x);
    }
    get size() {
        return this.values.size;
    }
    [Symbol.iterator]() {
        return this.values[Symbol.iterator]();
    }
    clear() {
        const { values } = this;
        if (values.size > 0) {
            values.clear();
            this.changed.dispatch();
        }
    }
}
function registerNested(baseState, f) {
    let value;
    let context;
    function updateValue() {
        value = baseState.value;
        context = new neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"]();
        f(context, value);
    }
    const handleChange = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
        if (baseState.value !== value) {
            context.dispose();
            updateValue();
        }
    }, 0);
    const signalDisposer = baseState.changed.add(handleChange);
    updateValue();
    return () => {
        handleChange.cancel();
        signalDisposer();
        context.dispose();
    };
}


/***/ }),

/***/ "./src/neuroglancer/trackable_vec3.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/trackable_vec3.ts ***!
  \********************************************/
/*! exports provided: trackableVec3, TrackableVec3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackableVec3", function() { return trackableVec3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableVec3", function() { return TrackableVec3; });
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function trackableVec3(defaultValue = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].create()) {
    return new TrackableVec3(defaultValue, defaultValue);
}
class TrackableVec3 {
    constructor(value_, defaultValue) {
        this.value_ = value_;
        this.defaultValue = defaultValue;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
    }
    get value() {
        return this.value_;
    }
    set value(newValue) {
        if (newValue !== this.value_) {
            this.value_ = newValue;
            this.changed.dispatch();
        }
    }
    toJSON() {
        let { value_ } = this;
        if (value_ === this.defaultValue) {
            return undefined;
        }
        return this.value_.toString();
    }
    restoreState(x) {
        try {
            this.value = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verify3dVec"])(x.split(','));
        }
        catch (e) {
            this.value = this.defaultValue;
        }
    }
    reset() {
        this.value = this.defaultValue;
    }
}


/***/ }),

/***/ "./src/neuroglancer/ui/annotations.css":
/*!*********************************************!*\
  !*** ./src/neuroglancer/ui/annotations.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/annotations.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/ui/annotations.ts ***!
  \********************************************/
/*! exports provided: AnnotationSegmentListWidget, SelectedAnnotationState, getPositionSummary, AnnotationLayerView, AnnotationDetailsTab, AnnotationTab, PlacePointTool, PlaceBoundingBoxTool, PlaceLineTool, getAnnotationRenderOptions, UserLayerWithAnnotationsMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationSegmentListWidget", function() { return AnnotationSegmentListWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectedAnnotationState", function() { return SelectedAnnotationState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPositionSummary", function() { return getPositionSummary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationLayerView", function() { return AnnotationLayerView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationDetailsTab", function() { return AnnotationDetailsTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationTab", function() { return AnnotationTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlacePointTool", function() { return PlacePointTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaceBoundingBoxTool", function() { return PlaceBoundingBoxTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaceLineTool", function() { return PlaceLineTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAnnotationRenderOptions", function() { return getAnnotationRenderOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserLayerWithAnnotationsMixin", function() { return UserLayerWithAnnotationsMixin; });
/* harmony import */ var _annotations_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotations.css */ "./src/neuroglancer/ui/annotations.css");
/* harmony import */ var _annotations_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_annotations_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/annotation/frontend */ "./src/neuroglancer/annotation/frontend.ts");
/* harmony import */ var neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/annotation/frontend_source */ "./src/neuroglancer/annotation/frontend_source.ts");
/* harmony import */ var neuroglancer_annotation_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/annotation/selection */ "./src/neuroglancer/annotation/selection.ts");
/* harmony import */ var neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/trackable_alpha */ "./src/neuroglancer/trackable_alpha.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_ui_tool__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/ui/tool */ "./src/neuroglancer/ui/tool.ts");
/* harmony import */ var neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/color */ "./src/neuroglancer/util/color.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_spatial_units__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/util/spatial_units */ "./src/neuroglancer/util/spatial_units.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_widget_close_button__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! neuroglancer/widget/close_button */ "./src/neuroglancer/widget/close_button.ts");
/* harmony import */ var neuroglancer_widget_color__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! neuroglancer/widget/color */ "./src/neuroglancer/widget/color.ts");
/* harmony import */ var neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! neuroglancer/widget/range */ "./src/neuroglancer/widget/range.ts");
/* harmony import */ var neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! neuroglancer/widget/tab_view */ "./src/neuroglancer/widget/tab_view.ts");
/* harmony import */ var neuroglancer_widget_text_icon_button__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! neuroglancer/widget/text_icon_button */ "./src/neuroglancer/widget/text_icon_button.ts");
/* harmony import */ var neuroglancer_widget_uint64_entry_widget__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! neuroglancer/widget/uint64_entry_widget */ "./src/neuroglancer/widget/uint64_entry_widget.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file User interface for display and editing annotations.
 */
























class AnnotationSegmentListWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(reference, annotationLayer) {
        super();
        this.reference = reference;
        this.annotationLayer = annotationLayer;
        this.element = document.createElement('div');
        this.addSegmentWidget = this.registerDisposer(new neuroglancer_widget_uint64_entry_widget__WEBPACK_IMPORTED_MODULE_23__["Uint64EntryWidget"]());
        this.debouncedUpdateView = lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(() => this.updateView(), 0);
        this.element.className = 'neuroglancer-annotation-segment-list';
        const { addSegmentWidget } = this;
        addSegmentWidget.element.style.display = 'inline-block';
        addSegmentWidget.element.title = 'Associate segments';
        this.element.appendChild(addSegmentWidget.element);
        this.registerDisposer(annotationLayer.segmentationState.changed.add(this.debouncedUpdateView));
        this.registerDisposer(() => this.unregisterSegmentationState());
        this.registerDisposer(this.addSegmentWidget.valuesEntered.add(values => {
            const annotation = this.reference.value;
            if (annotation == null) {
                return;
            }
            const existingSegments = annotation.segments;
            const segments = [...(existingSegments || []), ...values];
            const newAnnotation = Object.assign({}, annotation, { segments });
            this.annotationLayer.source.update(this.reference, newAnnotation);
            this.annotationLayer.source.commit(this.reference);
        }));
        this.registerDisposer(reference.changed.add(this.debouncedUpdateView));
        this.updateView();
    }
    unregisterSegmentationState() {
        const { segmentationState } = this;
        if (segmentationState != null) {
            segmentationState.visibleSegments.changed.remove(this.debouncedUpdateView);
            segmentationState.segmentColorHash.changed.remove(this.debouncedUpdateView);
            segmentationState.segmentSelectionState.changed.remove(this.debouncedUpdateView);
            this.segmentationState = undefined;
        }
    }
    updateView() {
        const segmentationState = this.annotationLayer.segmentationState.value;
        if (segmentationState !== this.segmentationState) {
            this.unregisterSegmentationState();
            this.segmentationState = segmentationState;
            if (segmentationState != null) {
                segmentationState.visibleSegments.changed.add(this.debouncedUpdateView);
                segmentationState.segmentColorHash.changed.add(this.debouncedUpdateView);
                segmentationState.segmentSelectionState.changed.add(this.debouncedUpdateView);
            }
        }
        const { element } = this;
        // Remove existing segment representations.
        for (let child = this.addSegmentWidget.element.nextElementSibling; child !== null;) {
            const next = child.nextElementSibling;
            element.removeChild(child);
            child = next;
        }
        element.style.display = 'none';
        const annotation = this.reference.value;
        if (annotation == null) {
            return;
        }
        const segments = annotation.segments;
        if (segmentationState === null) {
            return;
        }
        element.style.display = '';
        if (segments === undefined || segments.length === 0) {
            return;
        }
        const segmentColorHash = segmentationState ? segmentationState.segmentColorHash : undefined;
        segments.forEach((segment, index) => {
            if (index !== 0) {
                element.appendChild(document.createTextNode(' '));
            }
            const child = document.createElement('span');
            child.title =
                'Double click to toggle segment visibility, control+click to disassociate segment from annotation.';
            child.className = 'neuroglancer-annotation-segment-item';
            child.textContent = segment.toString();
            if (segmentationState !== undefined) {
                child.style.backgroundColor = segmentColorHash.computeCssColor(segment);
                child.addEventListener('mouseenter', () => {
                    segmentationState.segmentSelectionState.set(segment);
                });
                child.addEventListener('mouseleave', () => {
                    segmentationState.segmentSelectionState.set(null);
                });
                child.addEventListener('dblclick', (event) => {
                    if (event.ctrlKey) {
                        return;
                    }
                    if (segmentationState.visibleSegments.has(segment)) {
                        segmentationState.visibleSegments.delete(segment);
                    }
                    else {
                        segmentationState.visibleSegments.add(segment);
                    }
                });
            }
            child.addEventListener('click', (event) => {
                if (!event.ctrlKey) {
                    return;
                }
                const existingSegments = annotation.segments || [];
                const newSegments = existingSegments.filter(x => !neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_16__["Uint64"].equal(segment, x));
                const newAnnotation = Object.assign({}, annotation, { segments: newSegments ? newSegments : undefined });
                this.annotationLayer.source.update(this.reference, newAnnotation);
                this.annotationLayer.source.commit(this.reference);
            });
            element.appendChild(child);
        });
    }
}
class SelectedAnnotationState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_10__["RefCounted"] {
    constructor(annotationLayerState) {
        super();
        this.annotationLayerState = annotationLayerState;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_14__["NullarySignal"]();
        this.referenceChanged = (() => {
            this.validate();
            this.changed.dispatch();
        });
        this.validate = (() => {
            const updatedLayer = this.updateAnnotationLayer();
            const { annotationLayer } = this;
            if (annotationLayer !== undefined) {
                const value = this.value_;
                if (value !== undefined) {
                    let reference = this.reference_;
                    if (reference !== undefined && reference.id !== value.id) {
                        // Id changed.
                        value.id = reference.id;
                    }
                    else if (reference === undefined) {
                        reference = this.reference_ = annotationLayer.source.getReference(value.id);
                        reference.changed.add(this.referenceChanged);
                    }
                    if (reference.value === null) {
                        this.unbindReference();
                        this.value = undefined;
                        return;
                    }
                }
                else {
                    this.unbindReference();
                }
            }
            if (updatedLayer) {
                this.changed.dispatch();
            }
        });
        this.registerDisposer(annotationLayerState);
        this.registerDisposer(annotationLayerState.changed.add(this.validate));
        this.updateAnnotationLayer();
        this.reference_ = undefined;
        this.value_ = undefined;
    }
    get reference() {
        return this.reference_;
    }
    get value() {
        return this.value_;
    }
    get validValue() {
        return this.annotationLayer && this.value_;
    }
    set value(value) {
        this.value_ = value;
        const reference = this.reference_;
        if (reference !== undefined) {
            if (value === undefined || reference.id !== value.id) {
                this.unbindReference();
            }
        }
        this.validate();
        this.changed.dispatch();
    }
    updateAnnotationLayer() {
        const annotationLayer = this.annotationLayerState.value;
        if (annotationLayer === this.annotationLayer) {
            return false;
        }
        this.unbindLayer();
        this.annotationLayer = annotationLayer;
        if (annotationLayer !== undefined) {
            annotationLayer.source.changed.add(this.validate);
        }
        return true;
    }
    unbindLayer() {
        if (this.annotationLayer !== undefined) {
            this.annotationLayer.source.changed.remove(this.validate);
            this.annotationLayer = undefined;
        }
    }
    disposed() {
        this.unbindLayer();
        this.unbindReference();
        super.disposed();
    }
    unbindReference() {
        const reference = this.reference_;
        if (reference !== undefined) {
            reference.changed.remove(this.referenceChanged);
            this.reference_ = undefined;
        }
    }
    toJSON() {
        const value = this.value_;
        if (value === undefined) {
            return undefined;
        }
        if (value.partIndex === 0) {
            return value.id;
        }
        return value;
    }
    reset() {
        this.value = undefined;
    }
    restoreState(x) {
        if (x === undefined) {
            this.value = undefined;
            return;
        }
        if (typeof x === 'string') {
            this.value = { 'id': x, 'partIndex': 0 };
            return;
        }
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["verifyObject"])(x);
        this.value = {
            'id': Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["verifyObjectProperty"])(x, 'id', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["verifyString"]),
            'partIndex': Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["verifyObjectProperty"])(x, 'partIndex', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["verifyOptionalInt"]),
        };
    }
}
const tempVec3 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].create();
function makePointLink(point, transform, voxelSize, setSpatialCoordinates) {
    const spatialPoint = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].create(), point, transform);
    const positionText = Object(neuroglancer_util_spatial_units__WEBPACK_IMPORTED_MODULE_15__["formatIntegerPoint"])(voxelSize.voxelFromSpatial(tempVec3, spatialPoint));
    if (setSpatialCoordinates !== undefined) {
        const element = document.createElement('span');
        element.className = 'neuroglancer-voxel-coordinates-link';
        element.textContent = positionText;
        element.title = `Center view on voxel coordinates ${positionText}.`;
        element.addEventListener('click', () => {
            setSpatialCoordinates(spatialPoint);
        });
        return element;
    }
    else {
        return document.createTextNode(positionText);
    }
}
function getPositionSummary(element, annotation, transform, voxelSize, setSpatialCoordinates) {
    const makePointLinkWithTransform = (point) => makePointLink(point, transform, voxelSize, setSpatialCoordinates);
    switch (annotation.type) {
        case neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].AXIS_ALIGNED_BOUNDING_BOX:
        case neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].LINE:
            element.appendChild(makePointLinkWithTransform(annotation.pointA));
            element.appendChild(document.createTextNode(''));
            element.appendChild(makePointLinkWithTransform(annotation.pointB));
            break;
        case neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].POINT:
            element.appendChild(makePointLinkWithTransform(annotation.point));
            break;
        case neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].ELLIPSOID:
            element.appendChild(makePointLinkWithTransform(annotation.center));
            const transformedRadii = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["transformVectorByMat4"])(tempVec3, annotation.radii, transform);
            voxelSize.voxelFromSpatial(transformedRadii, transformedRadii);
            element.appendChild(document.createTextNode('' + Object(neuroglancer_util_spatial_units__WEBPACK_IMPORTED_MODULE_15__["formatIntegerBounds"])(transformedRadii)));
            break;
    }
}
function getCenterPosition(annotation, transform) {
    const center = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].create();
    switch (annotation.type) {
        case neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].AXIS_ALIGNED_BOUNDING_BOX:
        case neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].LINE:
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].add(center, annotation.pointA, annotation.pointB);
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].scale(center, center, 0.5);
            break;
        case neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].POINT:
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].copy(center, annotation.point);
            break;
        case neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].ELLIPSOID:
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].copy(center, annotation.center);
            break;
    }
    return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].transformMat4(center, center, transform);
}
class AnnotationLayerView extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_21__["Tab"] {
    constructor(layer, state, annotationLayer, voxelSize, setSpatialCoordinates) {
        super();
        this.layer = layer;
        this.state = state;
        this.annotationLayer = annotationLayer;
        this.voxelSize = voxelSize;
        this.setSpatialCoordinates = setSpatialCoordinates;
        this.annotationListContainer = document.createElement('ul');
        this.annotationListElements = new Map();
        this.updated = false;
        this.element.classList.add('neuroglancer-annotation-layer-view');
        this.annotationListContainer.classList.add('neuroglancer-annotation-list');
        this.registerDisposer(state);
        this.registerDisposer(voxelSize);
        this.registerDisposer(annotationLayer);
        const { source } = annotationLayer;
        const updateView = () => {
            this.updated = false;
            this.updateView();
        };
        this.registerDisposer(source.childAdded.add((annotation) => this.addAnnotationElement(annotation)));
        this.registerDisposer(source.childUpdated.add((annotation) => this.updateAnnotationElement(annotation)));
        this.registerDisposer(source.childDeleted.add((annotationId) => this.deleteAnnotationElement(annotationId)));
        this.registerDisposer(this.visibility.changed.add(() => this.updateView()));
        this.registerDisposer(annotationLayer.transform.changed.add(updateView));
        this.updateView();
        const toolbox = document.createElement('div');
        toolbox.className = 'neuroglancer-annotation-toolbox';
        layer.initializeAnnotationLayerViewTab(this);
        {
            const widget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_20__["RangeWidget"](this.annotationLayer.fillOpacity));
            widget.promptElement.textContent = 'Fill opacity';
            this.element.appendChild(widget.element);
        }
        const colorPicker = this.registerDisposer(new neuroglancer_widget_color__WEBPACK_IMPORTED_MODULE_19__["ColorWidget"](this.annotationLayer.color));
        colorPicker.element.title = 'Change annotation display color';
        toolbox.appendChild(colorPicker.element);
        if (!annotationLayer.source.readonly) {
            const pointButton = document.createElement('button');
            pointButton.textContent = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeHandler"])(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].POINT).icon;
            pointButton.title = 'Annotate point';
            pointButton.addEventListener('click', () => {
                this.layer.tool.value = new PlacePointTool(this.layer, {});
            });
            toolbox.appendChild(pointButton);
            const boundingBoxButton = document.createElement('button');
            boundingBoxButton.textContent =
                Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeHandler"])(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].AXIS_ALIGNED_BOUNDING_BOX).icon;
            boundingBoxButton.title = 'Annotate bounding box';
            boundingBoxButton.addEventListener('click', () => {
                this.layer.tool.value = new PlaceBoundingBoxTool(this.layer, {});
            });
            toolbox.appendChild(boundingBoxButton);
            const lineButton = document.createElement('button');
            lineButton.textContent = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeHandler"])(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].LINE).icon;
            lineButton.title = 'Annotate line';
            lineButton.addEventListener('click', () => {
                this.layer.tool.value = new PlaceLineTool(this.layer, {});
            });
            toolbox.appendChild(lineButton);
            const ellipsoidButton = document.createElement('button');
            ellipsoidButton.textContent = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeHandler"])(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].ELLIPSOID).icon;
            ellipsoidButton.title = 'Annotate ellipsoid';
            ellipsoidButton.addEventListener('click', () => {
                this.layer.tool.value = new PlaceSphereTool(this.layer, {});
            });
            toolbox.appendChild(ellipsoidButton);
        }
        this.element.appendChild(toolbox);
        this.element.appendChild(this.annotationListContainer);
        this.annotationListContainer.addEventListener('mouseleave', () => {
            this.annotationLayer.hoverState.value = undefined;
        });
        this.registerDisposer(this.annotationLayer.hoverState.changed.add(() => this.updateHoverView()));
        this.registerDisposer(this.state.changed.add(() => this.updateSelectionView()));
    }
    clearSelectionClass() {
        const { previousSelectedId } = this;
        if (previousSelectedId !== undefined) {
            const element = this.annotationListElements.get(previousSelectedId);
            if (element !== undefined) {
                element.classList.remove('neuroglancer-annotation-selected');
            }
            this.previousSelectedId = undefined;
        }
    }
    clearHoverClass() {
        const { previousHoverId } = this;
        if (previousHoverId !== undefined) {
            const element = this.annotationListElements.get(previousHoverId);
            if (element !== undefined) {
                element.classList.remove('neuroglancer-annotation-hover');
            }
            this.previousHoverId = undefined;
        }
    }
    updateSelectionView() {
        const selectedValue = this.state.value;
        let newSelectedId;
        if (selectedValue !== undefined) {
            newSelectedId = selectedValue.id;
        }
        const { previousSelectedId } = this;
        if (newSelectedId === previousSelectedId) {
            return;
        }
        this.clearSelectionClass();
        if (newSelectedId !== undefined) {
            const element = this.annotationListElements.get(newSelectedId);
            if (element !== undefined) {
                element.classList.add('neuroglancer-annotation-selected');
                element.scrollIntoView();
            }
        }
        this.previousSelectedId = newSelectedId;
    }
    updateHoverView() {
        const selectedValue = this.annotationLayer.hoverState.value;
        let newHoverId;
        if (selectedValue !== undefined) {
            newHoverId = selectedValue.id;
        }
        const { previousHoverId } = this;
        if (newHoverId === previousHoverId) {
            return;
        }
        this.clearHoverClass();
        if (newHoverId !== undefined) {
            const element = this.annotationListElements.get(newHoverId);
            if (element !== undefined) {
                element.classList.add('neuroglancer-annotation-hover');
            }
        }
        this.previousHoverId = newHoverId;
    }
    addAnnotationElementHelper(annotation) {
        this.annotationListContainer.appendChild(this.makeAnnotationListElement(annotation));
    }
    updateView() {
        if (!this.visible) {
            return;
        }
        if (this.updated) {
            return;
        }
        const { annotationLayer, annotationListContainer, annotationListElements } = this;
        const { source } = annotationLayer;
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeChildren"])(annotationListContainer);
        annotationListElements.clear();
        for (const annotation of source) {
            this.addAnnotationElementHelper(annotation);
        }
        this.resetOnUpdate();
    }
    addAnnotationElement(annotation) {
        if (!this.visible) {
            this.updated = false;
            return;
        }
        if (!this.updated) {
            this.updateView();
            return;
        }
        this.addAnnotationElementHelper(annotation);
        this.resetOnUpdate();
    }
    updateAnnotationElement(annotation) {
        if (!this.visible) {
            this.updated = false;
            return;
        }
        if (!this.updated) {
            this.updateView();
            return;
        }
        const { annotationListElements } = this;
        const element = annotationListElements.get(annotation.id);
        if (!element) {
            return;
        }
        const { annotationListContainer } = this;
        const newElement = this.makeAnnotationListElement(annotation);
        annotationListContainer.replaceChild(newElement, element);
        annotationListElements.set(annotation.id, newElement);
        this.resetOnUpdate();
    }
    deleteAnnotationElement(annotationId) {
        if (!this.visible) {
            this.updated = false;
            return;
        }
        if (!this.updated) {
            this.updateView();
            return;
        }
        let element = this.annotationListElements.get(annotationId);
        if (element) {
            Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeFromParent"])(element);
            this.annotationListElements.delete(annotationId);
        }
        this.resetOnUpdate();
    }
    resetOnUpdate() {
        this.clearHoverClass();
        this.clearSelectionClass();
        this.updated = true;
        this.updateHoverView();
        this.updateSelectionView();
    }
    makeAnnotationListElement(annotation) {
        const transform = this.annotationLayer.objectToGlobal;
        const element = document.createElement('li');
        element.title = 'Click to select, right click to recenter view.';
        const icon = document.createElement('div');
        icon.className = 'neuroglancer-annotation-icon';
        icon.textContent = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeHandler"])(annotation.type).icon;
        element.appendChild(icon);
        const position = document.createElement('div');
        position.className = 'neuroglancer-annotation-position';
        getPositionSummary(position, annotation, transform, this.voxelSize, this.setSpatialCoordinates);
        element.appendChild(position);
        if (annotation.description) {
            const description = document.createElement('div');
            description.className = 'neuroglancer-annotation-description';
            description.textContent = annotation.description;
            element.appendChild(description);
        }
        this.annotationListElements.set(annotation.id, element);
        element.addEventListener('mouseenter', () => {
            this.annotationLayer.hoverState.value = { id: annotation.id, partIndex: 0 };
        });
        element.addEventListener('click', () => {
            this.state.value = { id: annotation.id, partIndex: 0 };
        });
        element.addEventListener('mouseup', (event) => {
            if (event.button === 2) {
                this.setSpatialCoordinates(getCenterPosition(annotation, this.annotationLayer.objectToGlobal));
            }
        });
        return element;
    }
}
class AnnotationDetailsTab extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_21__["Tab"] {
    constructor(state, voxelSize, setSpatialCoordinates) {
        super();
        this.state = state;
        this.voxelSize = voxelSize;
        this.setSpatialCoordinates = setSpatialCoordinates;
        this.valid = false;
        this.mouseEntered = false;
        this.element.classList.add('neuroglancer-annotation-details');
        this.registerDisposer(state);
        this.registerDisposer(voxelSize);
        this.registerDisposer(this.state.changed.add(() => {
            this.valid = false;
            this.updateView();
        }));
        this.registerDisposer(this.visibility.changed.add(() => this.updateView()));
        this.state.changed.add(() => {
            this.valid = false;
            this.updateView();
        });
        this.element.addEventListener('mouseenter', () => {
            this.mouseEntered = true;
            if (this.hoverState !== undefined) {
                this.hoverState.value = this.state.value;
            }
        });
        this.element.addEventListener('mouseleave', () => {
            this.mouseEntered = false;
            if (this.hoverState !== undefined) {
                this.hoverState.value = undefined;
            }
        });
        this.updateView();
    }
    updateView() {
        if (!this.visible) {
            this.element.style.display = 'none';
            this.hoverState = undefined;
            return;
        }
        this.element.style.display = null;
        if (this.valid) {
            return;
        }
        const { element } = this;
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_11__["removeChildren"])(element);
        this.valid = true;
        const { reference } = this.state;
        if (reference === undefined) {
            return;
        }
        const value = this.state.value;
        const annotation = reference.value;
        if (annotation == null) {
            return;
        }
        const annotationLayer = this.state.annotationLayerState.value;
        this.hoverState = annotationLayer.hoverState;
        if (this.mouseEntered) {
            this.hoverState.value = value;
        }
        const { objectToGlobal } = annotationLayer;
        const { voxelSize } = this;
        const handler = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeHandler"])(annotation.type);
        const title = document.createElement('div');
        title.className = 'neuroglancer-annotation-details-title';
        const icon = document.createElement('div');
        icon.className = 'neuroglancer-annotation-details-icon';
        icon.textContent = handler.icon;
        const titleText = document.createElement('div');
        titleText.className = 'neuroglancer-annotation-details-title-text';
        titleText.textContent = `${handler.description}`;
        title.appendChild(icon);
        title.appendChild(titleText);
        if (!annotationLayer.source.readonly) {
            const deleteButton = Object(neuroglancer_widget_text_icon_button__WEBPACK_IMPORTED_MODULE_22__["makeTextIconButton"])('', 'Delete annotation');
            deleteButton.addEventListener('click', () => {
                const ref = annotationLayer.source.getReference(value.id);
                try {
                    annotationLayer.source.delete(ref);
                }
                finally {
                    ref.dispose();
                }
            });
            title.appendChild(deleteButton);
        }
        const closeButton = Object(neuroglancer_widget_close_button__WEBPACK_IMPORTED_MODULE_18__["makeCloseButton"])();
        closeButton.title = 'Hide annotation details';
        closeButton.addEventListener('click', () => {
            this.state.value = undefined;
        });
        title.appendChild(closeButton);
        element.appendChild(title);
        const position = document.createElement('div');
        position.className = 'neuroglancer-annotation-details-position';
        getPositionSummary(position, annotation, objectToGlobal, voxelSize, this.setSpatialCoordinates);
        element.appendChild(position);
        if (annotation.type === neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].AXIS_ALIGNED_BOUNDING_BOX) {
            const volume = document.createElement('div');
            volume.className = 'neuroglancer-annotation-details-volume';
            volume.textContent =
                Object(neuroglancer_util_spatial_units__WEBPACK_IMPORTED_MODULE_15__["formatBoundingBoxVolume"])(annotation.pointA, annotation.pointB, objectToGlobal);
            element.appendChild(volume);
            // FIXME: only do this if it is axis aligned
            const spatialOffset = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["transformVectorByMat4"])(tempVec3, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].subtract(tempVec3, annotation.pointA, annotation.pointB), objectToGlobal);
            const voxelVolume = document.createElement('div');
            voxelVolume.className = 'neuroglancer-annotation-details-volume-in-voxels';
            const voxelOffset = voxelSize.voxelFromSpatial(tempVec3, spatialOffset);
            voxelVolume.textContent = `${Object(neuroglancer_util_spatial_units__WEBPACK_IMPORTED_MODULE_15__["formatIntegerBounds"])(voxelOffset)}`;
            element.appendChild(voxelVolume);
        }
        else if (annotation.type === neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].LINE) {
            const spatialOffset = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["transformVectorByMat4"])(tempVec3, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].subtract(tempVec3, annotation.pointA, annotation.pointB), objectToGlobal);
            const length = document.createElement('div');
            length.className = 'neuroglancer-annotation-details-length';
            const spatialLengthText = Object(neuroglancer_util_spatial_units__WEBPACK_IMPORTED_MODULE_15__["formatLength"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].length(spatialOffset));
            let voxelLengthText = '';
            if (voxelSize.valid) {
                const voxelLength = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].length(voxelSize.voxelFromSpatial(tempVec3, spatialOffset));
                voxelLengthText = `, ${Math.round(voxelLength)} vx`;
            }
            length.textContent = spatialLengthText + voxelLengthText;
            element.appendChild(length);
        }
        let { segmentListWidget } = this;
        if (segmentListWidget !== undefined) {
            if (segmentListWidget.reference !== reference) {
                segmentListWidget.dispose();
                this.unregisterDisposer(segmentListWidget);
                segmentListWidget = this.segmentListWidget = undefined;
            }
        }
        if (segmentListWidget === undefined) {
            this.segmentListWidget = segmentListWidget =
                this.registerDisposer(new AnnotationSegmentListWidget(reference, annotationLayer));
        }
        element.appendChild(segmentListWidget.element);
        const description = document.createElement('textarea');
        description.value = annotation.description || '';
        description.rows = 3;
        description.className = 'neuroglancer-annotation-details-description';
        description.placeholder = 'Description';
        if (annotationLayer.source.readonly) {
            description.readOnly = true;
        }
        else {
            description.addEventListener('change', () => {
                const x = description.value;
                annotationLayer.source.update(reference, Object.assign({}, annotation, { description: x ? x : undefined }));
                annotationLayer.source.commit(reference);
            });
        }
        element.appendChild(description);
    }
}
class AnnotationTab extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_21__["Tab"] {
    constructor(layer, state, voxelSize, setSpatialCoordinates) {
        super();
        this.layer = layer;
        this.state = state;
        this.voxelSize = voxelSize;
        this.setSpatialCoordinates = setSpatialCoordinates;
        this.stack = this.registerDisposer(new neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_21__["StackView"](annotationLayerState => {
            return new AnnotationLayerView(this.layer, this.state.addRef(), annotationLayerState.addRef(), this.voxelSize.addRef(), this.setSpatialCoordinates);
        }, this.visibility));
        this.detailsTab = this.registerDisposer(new AnnotationDetailsTab(this.state, this.voxelSize.addRef(), this.setSpatialCoordinates));
        this.registerDisposer(state);
        this.registerDisposer(voxelSize);
        const { element } = this;
        element.classList.add('neuroglancer-annotations-tab');
        element.appendChild(this.stack.element);
        element.appendChild(this.detailsTab.element);
        const updateDetailsVisibility = () => {
            this.detailsTab.visibility.value = this.state.validValue !== undefined && this.visible ?
                neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_17__["WatchableVisibilityPriority"].VISIBLE :
                neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_17__["WatchableVisibilityPriority"].IGNORED;
        };
        this.registerDisposer(this.state.changed.add(updateDetailsVisibility));
        this.registerDisposer(this.visibility.changed.add(updateDetailsVisibility));
        const setAnnotationLayerView = () => {
            this.stack.selected = this.state.annotationLayerState.value;
        };
        this.registerDisposer(this.state.annotationLayerState.changed.add(setAnnotationLayerView));
        setAnnotationLayerView();
    }
}
function getSelectedAssocatedSegment(annotationLayer) {
    let segments;
    const segmentationState = annotationLayer.segmentationState.value;
    if (segmentationState != null) {
        if (segmentationState.segmentSelectionState.hasSelectedSegment) {
            segments = [segmentationState.segmentSelectionState.selectedSegment.clone()];
        }
    }
    return segments;
}
class PlaceAnnotationTool extends neuroglancer_ui_tool__WEBPACK_IMPORTED_MODULE_8__["Tool"] {
    constructor(layer, options) {
        super();
        this.layer = layer;
        if (layer.annotationLayerState === undefined) {
            throw new Error(`Invalid layer for annotation tool.`);
        }
        this.annotationDescription = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["verifyObjectProperty"])(options, 'description', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_13__["verifyOptionalString"]);
    }
    get annotationLayer() {
        return this.layer.annotationLayerState.value;
    }
}
const ANNOTATE_POINT_TOOL_ID = 'annotatePoint';
const ANNOTATE_LINE_TOOL_ID = 'annotateLine';
const ANNOTATE_BOUNDING_BOX_TOOL_ID = 'annotateBoundingBox';
const ANNOTATE_ELLIPSOID_TOOL_ID = 'annotateSphere';
class PlacePointTool extends PlaceAnnotationTool {
    constructor(layer, options) {
        super(layer, options);
    }
    trigger(mouseState) {
        const { annotationLayer } = this;
        if (annotationLayer === undefined) {
            // Not yet ready.
            return;
        }
        if (mouseState.active) {
            const annotation = {
                id: '',
                description: '',
                segments: getSelectedAssocatedSegment(annotationLayer),
                point: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].create(), mouseState.position, annotationLayer.globalToObject),
                type: neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].POINT,
            };
            const reference = annotationLayer.source.add(annotation, /*commit=*/ true);
            this.layer.selectedAnnotation.value = { id: reference.id };
            reference.dispose();
        }
    }
    get description() {
        return `annotate point`;
    }
    toJSON() {
        return ANNOTATE_POINT_TOOL_ID;
    }
}
function getMousePositionInAnnotationCoordinates(mouseState, annotationLayer) {
    return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].create(), mouseState.position, annotationLayer.globalToObject);
}
class TwoStepAnnotationTool extends PlaceAnnotationTool {
    trigger(mouseState) {
        const { annotationLayer } = this;
        if (annotationLayer === undefined) {
            // Not yet ready.
            return;
        }
        if (mouseState.active) {
            const updatePointB = () => {
                const state = this.inProgressAnnotation;
                const reference = state.reference;
                const newAnnotation = this.getUpdatedAnnotation(reference.value, mouseState, annotationLayer);
                state.annotationLayer.source.update(reference, newAnnotation);
                this.layer.selectedAnnotation.value = { id: reference.id };
            };
            if (this.inProgressAnnotation === undefined) {
                const reference = annotationLayer.source.add(this.getInitialAnnotation(mouseState, annotationLayer), /*commit=*/ false);
                this.layer.selectedAnnotation.value = { id: reference.id };
                const mouseDisposer = mouseState.changed.add(updatePointB);
                const disposer = () => {
                    mouseDisposer();
                    reference.dispose();
                };
                this.inProgressAnnotation = {
                    annotationLayer,
                    reference,
                    disposer,
                };
            }
            else {
                updatePointB();
                this.inProgressAnnotation.annotationLayer.source.commit(this.inProgressAnnotation.reference);
                this.inProgressAnnotation.disposer();
                this.inProgressAnnotation = undefined;
            }
        }
    }
    disposed() {
        this.deactivate();
        super.disposed();
    }
    deactivate() {
        if (this.inProgressAnnotation !== undefined) {
            this.inProgressAnnotation.annotationLayer.source.delete(this.inProgressAnnotation.reference);
            this.inProgressAnnotation.disposer();
            this.inProgressAnnotation = undefined;
        }
    }
}
class PlaceTwoCornerAnnotationTool extends TwoStepAnnotationTool {
    getInitialAnnotation(mouseState, annotationLayer) {
        const point = getMousePositionInAnnotationCoordinates(mouseState, annotationLayer);
        return {
            id: '',
            type: this.annotationType,
            description: '',
            pointA: point,
            pointB: point,
        };
    }
    getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer) {
        const point = getMousePositionInAnnotationCoordinates(mouseState, annotationLayer);
        return Object.assign({}, oldAnnotation, { pointB: point });
    }
}
class PlaceBoundingBoxTool extends PlaceTwoCornerAnnotationTool {
    get description() {
        return `annotate bounding box`;
    }
    toJSON() {
        return ANNOTATE_BOUNDING_BOX_TOOL_ID;
    }
}
PlaceBoundingBoxTool.prototype.annotationType = neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].AXIS_ALIGNED_BOUNDING_BOX;
class PlaceLineTool extends PlaceTwoCornerAnnotationTool {
    get description() {
        return `annotate line`;
    }
    getInitialAnnotation(mouseState, annotationLayer) {
        const result = super.getInitialAnnotation(mouseState, annotationLayer);
        result.segments = getSelectedAssocatedSegment(annotationLayer);
        return result;
    }
    getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer) {
        const result = super.getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer);
        const segments = result.segments;
        if (segments !== undefined && segments.length > 0) {
            segments.length = 1;
        }
        let newSegments = getSelectedAssocatedSegment(annotationLayer);
        if (newSegments && segments) {
            newSegments = newSegments.filter(x => segments.findIndex(y => neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_16__["Uint64"].equal(x, y)) === -1);
        }
        result.segments = [...(segments || []), ...(newSegments || [])] || false;
        return result;
    }
    toJSON() {
        return ANNOTATE_LINE_TOOL_ID;
    }
}
PlaceLineTool.prototype.annotationType = neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].LINE;
class PlaceSphereTool extends TwoStepAnnotationTool {
    getInitialAnnotation(mouseState, annotationLayer) {
        const point = getMousePositionInAnnotationCoordinates(mouseState, annotationLayer);
        return {
            type: neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].ELLIPSOID,
            id: '',
            description: '',
            segments: getSelectedAssocatedSegment(annotationLayer),
            center: point,
            radii: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].fromValues(0, 0, 0),
        };
    }
    getUpdatedAnnotation(oldAnnotation, mouseState, annotationLayer) {
        const spatialCenter = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].transformMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].create(), oldAnnotation.center, annotationLayer.objectToGlobal);
        const radius = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].distance(spatialCenter, mouseState.position);
        const tempMatrix = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat3"].create();
        tempMatrix[0] = tempMatrix[4] = tempMatrix[8] = 1 / (radius * radius);
        const objectToGlobalLinearTransform = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat3FromMat4"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat3"].create(), annotationLayer.objectToGlobal);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat3"].multiply(tempMatrix, tempMatrix, objectToGlobalLinearTransform);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat3"].transpose(objectToGlobalLinearTransform, objectToGlobalLinearTransform);
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["mat3"].multiply(tempMatrix, objectToGlobalLinearTransform, tempMatrix);
        return Object.assign({}, oldAnnotation, { radii: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].fromValues(1 / Math.sqrt(tempMatrix[0]), 1 / Math.sqrt(tempMatrix[4]), 1 / Math.sqrt(tempMatrix[8])) });
    }
    get description() {
        return `annotate ellipsoid`;
    }
    toJSON() {
        return ANNOTATE_ELLIPSOID_TOOL_ID;
    }
}
Object(neuroglancer_ui_tool__WEBPACK_IMPORTED_MODULE_8__["registerTool"])(ANNOTATE_POINT_TOOL_ID, (layer, options) => new PlacePointTool(layer, options));
Object(neuroglancer_ui_tool__WEBPACK_IMPORTED_MODULE_8__["registerTool"])(ANNOTATE_BOUNDING_BOX_TOOL_ID, (layer, options) => new PlaceBoundingBoxTool(layer, options));
Object(neuroglancer_ui_tool__WEBPACK_IMPORTED_MODULE_8__["registerTool"])(ANNOTATE_LINE_TOOL_ID, (layer, options) => new PlaceLineTool(layer, options));
Object(neuroglancer_ui_tool__WEBPACK_IMPORTED_MODULE_8__["registerTool"])(ANNOTATE_ELLIPSOID_TOOL_ID, (layer, options) => new PlaceSphereTool(layer, options));
function getAnnotationRenderOptions(userLayer) {
    return { color: userLayer.annotationColor, fillOpacity: userLayer.annotationFillOpacity };
}
const SELECTED_ANNOTATION_JSON_KEY = 'selectedAnnotation';
const ANNOTATION_COLOR_JSON_KEY = 'annotationColor';
const ANNOTATION_FILL_OPACITY_JSON_KEY = 'annotationFillOpacity';
function UserLayerWithAnnotationsMixin(Base) {
    class C extends Base {
        constructor(...args) {
            super(...args);
            this.annotationLayerState = this.registerDisposer(new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_7__["WatchableRefCounted"]());
            this.selectedAnnotation = this.registerDisposer(new SelectedAnnotationState(this.annotationLayerState.addRef()));
            this.annotationColor = new neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_9__["TrackableRGB"](neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_12__["vec3"].fromValues(1, 1, 0));
            this.annotationFillOpacity = Object(neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_6__["trackableAlphaValue"])(0.0);
            this.selectedAnnotation.changed.add(this.specificationChanged.dispatch);
            this.annotationColor.changed.add(this.specificationChanged.dispatch);
            this.annotationFillOpacity.changed.add(this.specificationChanged.dispatch);
            this.tabs.add('annotations', {
                label: 'Annotations',
                order: 10,
                getter: () => new AnnotationTab(this, this.selectedAnnotation.addRef(), this.manager.voxelSize.addRef(), point => this.manager.setSpatialCoordinates(point))
            });
            this.annotationLayerState.changed.add(() => {
                const state = this.annotationLayerState.value;
                if (state !== undefined) {
                    const annotationLayer = new neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_3__["AnnotationLayer"](this.manager.chunkManager, state.addRef());
                    Object(neuroglancer_annotation_selection__WEBPACK_IMPORTED_MODULE_5__["setAnnotationHoverStateFromMouseState"])(state, this.manager.layerSelectedValues.mouseState);
                    this.addRenderLayer(new neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_3__["SliceViewAnnotationLayer"](annotationLayer));
                    this.addRenderLayer(new neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_3__["PerspectiveViewAnnotationLayer"](annotationLayer.addRef()));
                    if (annotationLayer.source instanceof neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_4__["MultiscaleAnnotationSource"]) {
                        const dataFetchLayer = this.registerDisposer(new neuroglancer_annotation_frontend_source__WEBPACK_IMPORTED_MODULE_4__["DataFetchSliceViewRenderLayer"](annotationLayer.source.addRef()));
                        this.registerDisposer(Object(neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_7__["registerNested"])(state.filterBySegmentation, (context, value) => {
                            if (!value) {
                                this.addRenderLayer(dataFetchLayer.addRef());
                                context.registerDisposer(() => this.removeRenderLayer(dataFetchLayer));
                            }
                        }));
                    }
                }
            });
        }
        restoreState(specification) {
            super.restoreState(specification);
            this.selectedAnnotation.restoreState(specification[SELECTED_ANNOTATION_JSON_KEY]);
            this.annotationColor.restoreState(specification[ANNOTATION_COLOR_JSON_KEY]);
            this.annotationFillOpacity.restoreState(specification[ANNOTATION_FILL_OPACITY_JSON_KEY]);
        }
        toJSON() {
            const x = super.toJSON();
            x[SELECTED_ANNOTATION_JSON_KEY] = this.selectedAnnotation.toJSON();
            x[ANNOTATION_COLOR_JSON_KEY] = this.annotationColor.toJSON();
            x[ANNOTATION_FILL_OPACITY_JSON_KEY] = this.annotationFillOpacity.toJSON();
            return x;
        }
        initializeAnnotationLayerViewTab(tab) {
            tab;
        }
    }
    return C;
}


/***/ }),

/***/ "./src/neuroglancer/ui/button.css":
/*!****************************************!*\
  !*** ./src/neuroglancer/ui/button.css ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/context_menu.css":
/*!**********************************************!*\
  !*** ./src/neuroglancer/ui/context_menu.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/context_menu.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/ui/context_menu.ts ***!
  \*********************************************/
/*! exports provided: positionContextMenu, ContextMenu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionContextMenu", function() { return positionContextMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextMenu", function() { return ContextMenu; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var _context_menu_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context_menu.css */ "./src/neuroglancer/ui/context_menu.css");
/* harmony import */ var _context_menu_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_context_menu_css__WEBPACK_IMPORTED_MODULE_3__);
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




function positionContextMenu(menu, event) {
    // Set the display to block before checking the offset, or the offset will be
    // reported as 0 and the context menu wont display correctly when too close to
    // the right side of the browser window.
    menu.style.display = 'block';
    const { offsetWidth, offsetHeight } = menu;
    const viewportWidth = document.documentElement.clientWidth;
    const viewportHeight = document.documentElement.clientHeight;
    const posX = document.documentElement.scrollLeft + Math.min(viewportWidth - offsetWidth, event.clientX);
    const posY = document.documentElement.scrollTop + Math.min(viewportHeight - offsetHeight, event.clientY);
    menu.style.left = posX + 'px';
    menu.style.top = posY + 'px';
}
class ContextMenu extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(parent) {
        super();
        this.element = document.createElement('div');
        this.parentDisposers = new Map();
        this.disabledValue = false;
        this.opened = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
        this.closed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
        const { element } = this;
        element.className = 'neuroglancer-context-menu';
        element.style.display = 'none';
        element.tabIndex = -1;
        document.body.appendChild(element);
        if (parent !== undefined) {
            this.registerParent(parent);
        }
    }
    get disabled() {
        return this.disabledValue;
    }
    set disabled(value) {
        if (this.disabledValue !== value) {
            this.disabledValue = value;
            if (value) {
                this.hide();
            }
        }
    }
    get open() {
        return this.menuDisposer !== undefined;
    }
    registerParent(parent) {
        const { parentDisposers } = this;
        if (parentDisposers.has(parent)) {
            return;
        }
        parentDisposers.set(parent, Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(parent, 'contextmenu', (event) => {
            this.show(event);
            event.stopPropagation();
            event.preventDefault();
        }));
    }
    show(originalEvent) {
        if (this.disabledValue) {
            return;
        }
        this.hide();
        const { element } = this;
        const mousedownDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(document, 'mousedown', (event) => {
            if (event.target instanceof Node && !element.contains(event.target)) {
                this.hide();
            }
        }, /*capture=*/ true);
        const keydownDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(document, 'keydown', (event) => {
            if (event.code === 'Escape') {
                this.hide();
            }
        }, /*capture=*/ true);
        const menuDisposer = () => {
            keydownDisposer();
            mousedownDisposer();
            element.style.display = 'none';
        };
        this.opened.dispatch();
        positionContextMenu(element, originalEvent);
        this.menuDisposer = menuDisposer;
    }
    unregisterParent(parent) {
        const { parentDisposers } = this;
        const disposer = parentDisposers.get(parent);
        if (disposer !== undefined) {
            disposer();
            parentDisposers.delete(parent);
        }
    }
    disposed() {
        const { parentDisposers } = this;
        for (const disposer of parentDisposers.values()) {
            disposer();
        }
        parentDisposers.clear();
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_1__["removeFromParent"])(this.element);
    }
    hide() {
        if (this.menuDisposer !== undefined) {
            this.menuDisposer();
            this.menuDisposer = undefined;
            this.closed.dispatch();
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/ui/default_clipboard_handling.ts":
/*!***********************************************************!*\
  !*** ./src/neuroglancer/ui/default_clipboard_handling.ts ***!
  \***********************************************************/
/*! exports provided: bindDefaultCopyHandler, parsePositionString, bindDefaultPasteHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindDefaultCopyHandler", function() { return bindDefaultCopyHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePositionString", function() { return parsePositionString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindDefaultPasteHandler", function() { return bindDefaultPasteHandler; });
/* harmony import */ var neuroglancer_util_clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/clipboard */ "./src/neuroglancer/util/clipboard.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/trackable */ "./src/neuroglancer/util/trackable.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function bindDefaultCopyHandler(viewer) {
    viewer.registerEventListener(document, 'copy', (event) => {
        if (Object(neuroglancer_util_clipboard__WEBPACK_IMPORTED_MODULE_0__["eventHasInputTextTarget"])(event)) {
            return;
        }
        const stateJson = Object(neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_2__["getCachedJson"])(viewer.state).value;
        const { clipboardData } = event;
        if (clipboardData !== null) {
            clipboardData.setData('text/plain', JSON.stringify(stateJson, undefined, '  '));
        }
        event.preventDefault();
    });
}
/**
 * Checks if s consists of 3 numbers separated by whitespace or commas, with optional parentheses or
 * brackets before and after.
 *
 * @param s The string to parse.
 * @return The parsed vector, or undefined if parsing failed.
 */
function parsePositionString(s) {
    const match = s.match(/^[\[\]{}()\s,]*(\d+(?:\.\d+)?)[,\s]+(\d+(?:\.\d+)?)[,\s]+(\d+(?:\.\d+)?)[\[\]{}()\s,]*$/);
    if (match !== null) {
        return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].fromValues(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]));
    }
    return undefined;
}
function bindDefaultPasteHandler(viewer) {
    viewer.registerEventListener(document, 'paste', (event) => {
        if (Object(neuroglancer_util_clipboard__WEBPACK_IMPORTED_MODULE_0__["eventHasInputTextTarget"])(event)) {
            return;
        }
        const { clipboardData } = event;
        if (clipboardData !== null) {
            const data = clipboardData.getData('text/plain');
            const parsedPosition = parsePositionString(data);
            if (parsedPosition !== undefined) {
                viewer.navigationState.position.setVoxelCoordinates(parsedPosition);
            }
        }
        event.preventDefault();
    });
}


/***/ }),

/***/ "./src/neuroglancer/ui/default_input_event_bindings.ts":
/*!*************************************************************!*\
  !*** ./src/neuroglancer/ui/default_input_event_bindings.ts ***!
  \*************************************************************/
/*! exports provided: getDefaultGlobalBindings, getDefaultRenderedDataPanelBindings, getDefaultPerspectivePanelBindings, getDefaultSliceViewPanelBindings, setDefaultInputEventBindings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultGlobalBindings", function() { return getDefaultGlobalBindings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultRenderedDataPanelBindings", function() { return getDefaultRenderedDataPanelBindings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultPerspectivePanelBindings", function() { return getDefaultPerspectivePanelBindings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultSliceViewPanelBindings", function() { return getDefaultSliceViewPanelBindings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDefaultInputEventBindings", function() { return setDefaultInputEventBindings; });
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let defaultGlobalBindings;
function getDefaultGlobalBindings() {
    if (defaultGlobalBindings === undefined) {
        const map = new neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_0__["EventActionMap"]();
        map.set('keyl', 'recolor');
        map.set('keyx', 'clear-segments');
        map.set('keys', 'toggle-show-slices');
        map.set('keyb', 'toggle-scale-bar');
        map.set('shift+keyb', 'toggle-default-annotations');
        map.set('keya', 'toggle-axis-lines');
        map.set('keyo', 'toggle-orthographic-projection');
        for (let i = 1; i <= 9; ++i) {
            map.set('digit' + i, 'toggle-layer-' + i);
            map.set('control+digit' + i, 'select-layer-' + i);
        }
        map.set('keyn', 'add-layer');
        map.set('keyh', 'help');
        map.set('space', 'toggle-layout');
        map.set('shift+space', 'toggle-layout-alternative');
        map.set('backslash', 'toggle-show-statistics');
        defaultGlobalBindings = map;
    }
    return defaultGlobalBindings;
}
let defaultRenderedDataPanelBindings;
function getDefaultRenderedDataPanelBindings() {
    if (defaultRenderedDataPanelBindings === undefined) {
        defaultRenderedDataPanelBindings = neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_0__["EventActionMap"].fromObject({
            'arrowleft': 'x-',
            'arrowright': 'x+',
            'arrowup': 'y-',
            'arrowdown': 'y+',
            'comma': 'z-',
            'period': 'z+',
            'keyz': 'snap',
            'control+equal': 'zoom-in',
            'control+shift+equal': 'zoom-in',
            'control+minus': 'zoom-out',
            'keyr': 'rotate-relative-z-',
            'keye': 'rotate-relative-z+',
            'shift+arrowdown': 'rotate-relative-x-',
            'shift+arrowup': 'rotate-relative-x+',
            'shift+arrowleft': 'rotate-relative-y-',
            'shift+arrowright': 'rotate-relative-y+',
            'at:control+wheel': { action: 'zoom-via-wheel', preventDefault: true },
            'at:wheel': { action: 'z+1-via-wheel', preventDefault: true },
            'at:shift+wheel': { action: 'z+10-via-wheel', preventDefault: true },
            'at:dblclick0': 'select',
            'at:control+mousedown0': 'annotate',
            'at:mousedown2': 'move-to-mouse-position',
            'at:control+mousedown2': 'select-annotation',
            'at:alt+mousedown0': 'move-annotation',
            'at:control+alt+mousedown2': 'delete-annotation',
            'at:touchpinch': 'zoom-via-touchpinch',
            'at:touchrotate': 'rotate-in-plane-via-touchrotate',
            'at:touchtranslate2': 'translate-in-plane-via-touchtranslate',
            'at:touchhold1': 'move-to-mouse-position',
            'at:touchtap1x2': 'select',
            'at:touchtap2x3': 'snap',
        }, { label: 'All Data Panels' });
    }
    return defaultRenderedDataPanelBindings;
}
let defaultPerspectivePanelBindings;
function getDefaultPerspectivePanelBindings() {
    if (defaultPerspectivePanelBindings === undefined) {
        defaultPerspectivePanelBindings = neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_0__["EventActionMap"].fromObject({
            'at:mousedown0': { action: 'rotate-via-mouse-drag', stopPropagation: true },
            'at:shift+mousedown0': { action: 'translate-via-mouse-drag', stopPropagation: true },
            'at:touchtranslate1': 'rotate-out-of-plane-via-touchtranslate',
        }, { parents: [[getDefaultRenderedDataPanelBindings(), Number.NEGATIVE_INFINITY]] });
    }
    return defaultPerspectivePanelBindings;
}
let defaultSliceViewPanelBindings;
function getDefaultSliceViewPanelBindings() {
    if (defaultSliceViewPanelBindings === undefined) {
        defaultSliceViewPanelBindings = neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_0__["EventActionMap"].fromObject({
            'at:mousedown0': { action: 'translate-via-mouse-drag', stopPropagation: true },
            'at:shift+mousedown0': { action: 'rotate-via-mouse-drag', stopPropagation: true },
            'at:touchtranslate1': 'translate-z-via-touchtranslate',
        }, { parents: [[getDefaultRenderedDataPanelBindings(), Number.NEGATIVE_INFINITY]] });
    }
    return defaultSliceViewPanelBindings;
}
function setDefaultInputEventBindings(inputEventBindings) {
    inputEventBindings.global.addParent(getDefaultGlobalBindings(), Number.NEGATIVE_INFINITY);
    inputEventBindings.sliceView.addParent(getDefaultSliceViewPanelBindings(), Number.NEGATIVE_INFINITY);
    inputEventBindings.perspectiveView.addParent(getDefaultPerspectivePanelBindings(), Number.NEGATIVE_INFINITY);
}


/***/ }),

/***/ "./src/neuroglancer/ui/default_viewer.css":
/*!************************************************!*\
  !*** ./src/neuroglancer/ui/default_viewer.css ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/default_viewer.ts":
/*!***********************************************!*\
  !*** ./src/neuroglancer/ui/default_viewer.ts ***!
  \***********************************************/
/*! exports provided: makeDefaultViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDefaultViewer", function() { return makeDefaultViewer; });
/* harmony import */ var _default_viewer_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default_viewer.css */ "./src/neuroglancer/ui/default_viewer.css");
/* harmony import */ var _default_viewer_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_default_viewer_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_ui_disable_default_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/ui/disable_default_actions */ "./src/neuroglancer/ui/disable_default_actions.ts");
/* harmony import */ var _minimal_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./minimal_viewer */ "./src/neuroglancer/ui/minimal_viewer.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function makeDefaultViewer(options) {
    Object(neuroglancer_ui_disable_default_actions__WEBPACK_IMPORTED_MODULE_1__["disableContextMenu"])();
    Object(neuroglancer_ui_disable_default_actions__WEBPACK_IMPORTED_MODULE_1__["disableWheel"])();
    return Object(_minimal_viewer__WEBPACK_IMPORTED_MODULE_2__["makeMinimalViewer"])(options);
}


/***/ }),

/***/ "./src/neuroglancer/ui/default_viewer_setup.ts":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/ui/default_viewer_setup.ts ***!
  \*****************************************************/
/*! exports provided: setupDefaultViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupDefaultViewer", function() { return setupDefaultViewer; });
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_ui_default_clipboard_handling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/ui/default_clipboard_handling */ "./src/neuroglancer/ui/default_clipboard_handling.ts");
/* harmony import */ var neuroglancer_ui_default_input_event_bindings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/ui/default_input_event_bindings */ "./src/neuroglancer/ui/default_input_event_bindings.ts");
/* harmony import */ var neuroglancer_ui_default_viewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/ui/default_viewer */ "./src/neuroglancer/ui/default_viewer.ts");
/* harmony import */ var neuroglancer_ui_url_hash_binding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/ui/url_hash_binding */ "./src/neuroglancer/ui/url_hash_binding.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Sets up the default neuroglancer viewer.
 */
function setupDefaultViewer() {
    let viewer = window['viewer'] = Object(neuroglancer_ui_default_viewer__WEBPACK_IMPORTED_MODULE_3__["makeDefaultViewer"])();
    Object(neuroglancer_ui_default_input_event_bindings__WEBPACK_IMPORTED_MODULE_2__["setDefaultInputEventBindings"])(viewer.inputEventBindings);
    const hashBinding = viewer.registerDisposer(new neuroglancer_ui_url_hash_binding__WEBPACK_IMPORTED_MODULE_4__["UrlHashBinding"](viewer.state));
    viewer.registerDisposer(hashBinding.parseError.changed.add(() => {
        const { value } = hashBinding.parseError;
        if (value !== undefined) {
            const status = new neuroglancer_status__WEBPACK_IMPORTED_MODULE_0__["StatusMessage"]();
            status.setErrorMessage(`Error parsing state: ${value.message}`);
            console.log('Error parsing state', value);
        }
        hashBinding.parseError;
    }));
    hashBinding.updateFromUrlHash();
    Object(neuroglancer_ui_default_clipboard_handling__WEBPACK_IMPORTED_MODULE_1__["bindDefaultCopyHandler"])(viewer);
    Object(neuroglancer_ui_default_clipboard_handling__WEBPACK_IMPORTED_MODULE_1__["bindDefaultPasteHandler"])(viewer);
    return viewer;
}


/***/ }),

/***/ "./src/neuroglancer/ui/disable_default_actions.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/ui/disable_default_actions.ts ***!
  \********************************************************/
/*! exports provided: disableContextMenu, disableWheel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableContextMenu", function() { return disableContextMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableWheel", function() { return disableWheel; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Prevent context menu on right click, as this interferes with other event handlers for right mouse
 * clicks.
 */
function disableContextMenu() {
    return Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(document, 'contextmenu', (e) => {
        e.preventDefault();
    });
}
function disableWheel() {
    return Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(document, 'wheel', (e) => {
        if (e.ctrlKey) {
            e.preventDefault();
        }
    });
}


/***/ }),

/***/ "./src/neuroglancer/ui/drag_resize.css":
/*!*********************************************!*\
  !*** ./src/neuroglancer/ui/drag_resize.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/drag_resize.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/ui/drag_resize.ts ***!
  \********************************************/
/*! exports provided: DragResizablePanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DragResizablePanel", function() { return DragResizablePanel; });
/* harmony import */ var neuroglancer_ui_drag_resize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/ui/drag_resize.css */ "./src/neuroglancer/ui/drag_resize.css");
/* harmony import */ var neuroglancer_ui_drag_resize_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_ui_drag_resize_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/mouse_drag */ "./src/neuroglancer/util/mouse_drag.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class DragResizablePanel extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(element, visible, size, direction, minSize = 0) {
        super();
        this.element = element;
        this.visible = visible;
        this.size = size;
        this.direction = direction;
        this.minSize = minSize;
        this.gutter = document.createElement('div');
        this.sizeProp = this.direction === 'horizontal' ? 'width' : 'height';
        const { gutter } = this;
        gutter.className = `neuroglancer-resize-gutter-${direction}`;
        element.insertAdjacentElement('beforebegin', gutter);
        this.registerDisposer(visible.changed.add(() => this.updateView()));
        this.registerDisposer(size.changed.add(() => this.updateView()));
        const dragStart = (event) => {
            if ('button' in event && event.button !== 0) {
                return;
            }
            event.preventDefault();
            // Get initial size
            const initialRect = element.getBoundingClientRect();
            let size = initialRect[this.sizeProp];
            const visibleCutoff = this.minSize / 2;
            Object(neuroglancer_util_mouse_drag__WEBPACK_IMPORTED_MODULE_3__["startRelativeMouseDrag"])(event, (_event, deltaX, deltaY) => {
                size -= (direction === 'horizontal' ? deltaX : deltaY);
                if (size < visibleCutoff) {
                    this.visible.value = false;
                }
                else if (this.visible.value === false && size > visibleCutoff) {
                    this.visible.value = true;
                }
                this.size.value = Math.max(this.minSize, size);
            });
        };
        this.registerEventListener(gutter, 'pointerdown', dragStart);
        this.updateView();
    }
    updateView() {
        const { element, gutter } = this;
        const { visible } = this;
        if (!visible.value) {
            element.style.display = 'none';
            gutter.style.display = 'none';
            return;
        }
        element.style.display = '';
        gutter.style.display = '';
        element.style[this.sizeProp] = Math.max(this.minSize, this.size.value) + 'px';
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeFromParent"])(this.gutter);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/ui/layer_drag_and_drop.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/ui/layer_drag_and_drop.ts ***!
  \****************************************************/
/*! exports provided: startLayerDrag, endLayerDrag, getLayerDragInfo, DropLayers, getDefaultLayerDropEfect, getLayerDropEffect, updateLayerDropEffect, getDropLayers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startLayerDrag", function() { return startLayerDrag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "endLayerDrag", function() { return endLayerDrag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayerDragInfo", function() { return getLayerDragInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DropLayers", function() { return DropLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultLayerDropEfect", function() { return getDefaultLayerDropEfect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayerDropEffect", function() { return getLayerDropEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateLayerDropEffect", function() { return updateLayerDropEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDropLayers", function() { return getDropLayers; });
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/drag_and_drop */ "./src/neuroglancer/util/drag_and_drop.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const layerDragTypePrefix = 'neuroglancer-layer\0';
let dragSource;
function startLayerDrag(event, sourceInfo) {
    event.dataTransfer.setData(Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_1__["encodeParametersAsDragType"])(layerDragTypePrefix, sourceInfo.layers.map(layer => ({ name: layer.name, visible: layer.visible }))), JSON.stringify({ layers: sourceInfo.layers.map(layer => layer.toJSON()), layout: sourceInfo.layoutSpec }));
    if (dragSource !== undefined) {
        dragSource.disposer();
    }
    let newDragSource;
    let disposer = () => {
        sourceInfo.manager.unregisterDisposer(disposer);
        for (const layer of sourceInfo.layers) {
            layer.dispose();
        }
        sourceInfo.manager.dispose();
        if (dragSource === newDragSource) {
            dragSource = undefined;
        }
    };
    dragSource = newDragSource = {
        manager: sourceInfo.manager.addRef(),
        layers: sourceInfo.layers.map(x => x.addRef()),
        layoutSpec: sourceInfo.layoutSpec,
        disposer,
    };
}
function endLayerDrag(event) {
    if (dragSource !== undefined) {
        if (event && event.dataTransfer.dropEffect === 'move') {
            const removedLayers = new Set(dragSource.layers);
            dragSource.manager.layerManager.filter((x) => !removedLayers.has(x));
        }
        dragSource.disposer();
    }
}
function getLayerDragInfo(event) {
    return Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_1__["decodeParametersFromDragTypeList"])(event.dataTransfer.types, layerDragTypePrefix);
}
function getCompatibleDragSource(manager) {
    if (dragSource !== undefined && dragSource.manager.rootLayers === manager.rootLayers) {
        return dragSource;
    }
    return undefined;
}
class DropLayers {
    /**
     * Called in the 'drop' event handler to actually initialize the layers if they are external.
     * Returns false if any layers failed to initialized.
     */
    finalize(event) {
        const { dragType } = this;
        if (dragType !== undefined) {
            try {
                const { layers: spec, layout } = JSON.parse(event.dataTransfer.getData(dragType));
                if (!Array.isArray(spec) || this.numSourceLayers !== spec.length) {
                    throw new Error('Invalid layer drop data');
                }
                this.layoutSpec = layout;
                for (const [layer, index] of this.layers) {
                    this.manager.initializeLayerFromSpec(layer, spec[index]);
                }
                return true;
            }
            catch (_a) {
                return false;
            }
        }
        return true;
    }
    get method() {
        if (this.sourceManager !== undefined) {
            if (this.manager === this.sourceManager) {
                return 'move';
            }
            else {
                return 'link';
            }
        }
        else {
            return 'copy';
        }
    }
    compatibleWithMethod(otherMethod) {
        if (this.method === otherMethod) {
            return true;
        }
        if (!this.moveSupported && otherMethod === 'move') {
            return true;
        }
        return false;
    }
}
function getDefaultLayerDropEfect(manager, newTarget = false) {
    const source = getCompatibleDragSource(manager);
    if (source === undefined) {
        return 'copy';
    }
    if (!newTarget && source.manager === manager) {
        return 'move';
    }
    return 'link';
}
function getLayerDropEffect(event, manager, newTarget = false) {
    if (event.shiftKey) {
        return 'copy';
    }
    else if (event.ctrlKey) {
        return 'move';
    }
    else {
        return getDefaultLayerDropEfect(manager, newTarget);
    }
}
function updateLayerDropEffect(event, manager, newTarget = false) {
    return Object(neuroglancer_util_drag_and_drop__WEBPACK_IMPORTED_MODULE_1__["setDropEffect"])(event, getLayerDropEffect(event, manager, newTarget));
}
function getDropLayers(event, manager, forceCopy, allowMove, newTarget) {
    const source = getCompatibleDragSource(manager);
    const moveSupported = !newTarget && source !== undefined && source.manager === manager;
    if (!forceCopy) {
        if (source !== undefined) {
            const result = new DropLayers();
            result.manager = manager;
            result.numSourceLayers = source.layers.length;
            result.sourceManager = source.manager;
            result.moveSupported = moveSupported;
            result.layers = new Map();
            result.layoutSpec = source.layoutSpec;
            if (!newTarget && source.manager === manager) {
                if (allowMove) {
                    source.layers.forEach((layer, index) => {
                        result.layers.set(layer, index);
                    });
                }
                else {
                    return undefined;
                }
            }
            source.layers.forEach((layer, index) => {
                if (newTarget || !manager.layerManager.has(layer)) {
                    result.layers.set(layer.addRef(), index);
                }
            });
            return result;
        }
    }
    const info = getLayerDragInfo(event);
    if (info !== undefined) {
        try {
            const layers = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["parseArray"])(info.parameters, (layerInfo, index) => {
                const name = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(layerInfo, 'name', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyString"]);
                const visible = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(layerInfo, 'visible', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyBoolean"]);
                const newLayer = new neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_0__["ManagedUserLayerWithSpecification"](name, null, manager);
                newLayer.visible = visible;
                return [newLayer, index];
            });
            const result = new DropLayers();
            result.numSourceLayers = layers.length;
            result.moveSupported = moveSupported;
            result.manager = manager;
            result.dragType = info.dragType;
            result.layers = new Map(layers);
            return result;
        }
        catch (_a) {
        }
    }
    return undefined;
}


/***/ }),

/***/ "./src/neuroglancer/ui/layer_side_panel.css":
/*!**************************************************!*\
  !*** ./src/neuroglancer/ui/layer_side_panel.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/layer_side_panel.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/ui/layer_side_panel.ts ***!
  \*************************************************/
/*! exports provided: LayerInfoPanelContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerInfoPanelContainer", function() { return LayerInfoPanelContainer; });
/* harmony import */ var neuroglancer_ui_layer_side_panel_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/ui/layer_side_panel.css */ "./src/neuroglancer/ui/layer_side_panel.css");
/* harmony import */ var neuroglancer_ui_layer_side_panel_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_ui_layer_side_panel_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_widget_close_button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/widget/close_button */ "./src/neuroglancer/widget/close_button.ts");
/* harmony import */ var neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/widget/tab_view */ "./src/neuroglancer/widget/tab_view.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Side panel for displaying/editing layer details.
 */






class UserLayerInfoPanel extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_5__["Tab"] {
    constructor(layer) {
        super();
        this.layer = layer;
        this.tabView = new neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_5__["TabView"](this.layer.tabs.addRef(), this.visibility);
        this.element.appendChild(this.tabView.element);
        this.element.classList.add('neuroglancer-layer-side-panel-info-panel');
        this.tabView.element.style.flex = '1';
    }
}
class EmptyUserLayerInfoPanel extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_5__["Tab"] {
    get layer() {
        return null;
    }
    constructor() {
        super();
        this.element.classList.add('neuroglancer-layer-side-panel-info-panel-empty');
        this.element.textContent =
            'Information about this layer will be available once it finishes loading.';
    }
}
class ManagedUserLayerInfoPanel extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_5__["Tab"] {
    constructor(layer, layerManager, collapse) {
        super();
        this.layer = layer;
        this.layerManager = layerManager;
        this.collapse = collapse;
        this.element = document.createElement('div');
        this.title = document.createElement('div');
        this.layerName = document.createElement('input');
        this.stack = this.registerDisposer(new neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_5__["StackView"](userLayer => {
            if (userLayer === null) {
                return new EmptyUserLayerInfoPanel();
            }
            else {
                return new UserLayerInfoPanel(userLayer);
            }
        }, this.visibility));
        const { element, title, layerName, stack } = this;
        element.className = 'neuroglancer-managed-user-layer-info-panel';
        title.className = 'neuroglancer-layer-side-panel-title';
        stack.element.classList.add('neuroglancer-layer-side-panel-content-container');
        element.appendChild(title);
        element.appendChild(stack.element);
        const collapseButton = Object(neuroglancer_widget_close_button__WEBPACK_IMPORTED_MODULE_4__["makeCloseButton"])();
        collapseButton.title = 'Close side panel';
        collapseButton.addEventListener('click', () => {
            this.collapse();
        });
        title.appendChild(layerName);
        layerName.spellcheck = false;
        layerName.title = 'Rename layer';
        title.appendChild(collapseButton);
        layerName.addEventListener('change', () => this.handleLayerNameViewChanged());
        layerName.addEventListener('blur', () => this.handleLayerNameViewChanged());
        this.registerDisposer(layer.layerChanged.add(() => this.handleLayerNameModelChanged()));
        this.handleUserLayerChanged();
        this.handleLayerNameModelChanged();
    }
    handleUserLayerChanged() {
        if (this.stack.selected !== this.layer.layer) {
            this.stack.invalidateAll();
            this.stack.selected = this.layer.layer;
        }
    }
    handleLayerNameModelChanged() {
        this.layerName.value = this.layer.name;
    }
    handleLayerNameViewChanged() {
        const { layer } = this;
        if (layer !== undefined) {
            let newName = this.layerName.value;
            if (newName !== layer.name) {
                newName = this.layerManager.getUniqueLayerName(newName);
                this.layerName.value = newName;
                layer.name = newName;
                layer.layerChanged.dispatch();
            }
        }
    }
}
class LayerInfoPanelContainer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(state) {
        super();
        this.state = state;
        this.element = document.createElement('div');
        this.stack = this.registerDisposer(new neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_5__["StackView"](layer => new ManagedUserLayerInfoPanel(layer, this.state.layerManager, this.collapse.bind(this))));
        const { element, stack } = this;
        element.className = 'neuroglancer-layer-side-panel';
        stack.element.classList.add('neuroglancer-layer-info-panel-container');
        element.appendChild(stack.element);
        this.registerDisposer(state.changed.add(() => this.handleStateChanged()));
        this.registerDisposer(state.layerManager.layersChanged.add(() => this.handleLayersChanged()));
        this.handleStateChanged();
    }
    handleLayersChanged() {
        const { layerManager } = this.state;
        const { stack } = this;
        for (const layer of stack.tabs.keys()) {
            if (!layerManager.has(layer)) {
                stack.invalidate(layer);
            }
        }
    }
    collapse() {
        const { state } = this;
        if (state.visible === true) {
            this.state.visible = false;
            this.state.changed.dispatch();
        }
    }
    handleStateChanged() {
        const { state } = this;
        const { visible } = state;
        this.element.style.display = visible ? null : 'none';
        this.stack.visibility.value =
            visible ? neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_3__["WatchableVisibilityPriority"].VISIBLE : neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_3__["WatchableVisibilityPriority"].IGNORED;
        this.stack.selected = state.layer;
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeFromParent"])(this.element);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/ui/minimal_viewer.ts":
/*!***********************************************!*\
  !*** ./src/neuroglancer/ui/minimal_viewer.ts ***!
  \***********************************************/
/*! exports provided: makeMinimalViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeMinimalViewer", function() { return makeMinimalViewer; });
/* harmony import */ var neuroglancer_sliceview_chunk_format_handlers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/sliceview/chunk_format_handlers */ "./src/neuroglancer/sliceview/chunk_format_handlers.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_display_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/display_context */ "./src/neuroglancer/display_context.ts");
/* harmony import */ var neuroglancer_viewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/viewer */ "./src/neuroglancer/viewer.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




function makeMinimalViewer(options, target = document.getElementById('neuroglancer-container')) {
    try {
        let display = new neuroglancer_display_context__WEBPACK_IMPORTED_MODULE_2__["DisplayContext"](target);
        return new neuroglancer_viewer__WEBPACK_IMPORTED_MODULE_3__["Viewer"](display, options);
    }
    catch (error) {
        neuroglancer_status__WEBPACK_IMPORTED_MODULE_1__["StatusMessage"].showMessage(`Error: ${error.message}`);
        throw error;
    }
}


/***/ }),

/***/ "./src/neuroglancer/ui/mouse_selection_state_tooltip.css":
/*!***************************************************************!*\
  !*** ./src/neuroglancer/ui/mouse_selection_state_tooltip.css ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/mouse_selection_state_tooltip.ts":
/*!**************************************************************!*\
  !*** ./src/neuroglancer/ui/mouse_selection_state_tooltip.ts ***!
  \**************************************************************/
/*! exports provided: MouseSelectionStateTooltipManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MouseSelectionStateTooltipManager", function() { return MouseSelectionStateTooltipManager; });
/* harmony import */ var _mouse_selection_state_tooltip_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mouse_selection_state_tooltip.css */ "./src/neuroglancer/ui/mouse_selection_state_tooltip.css");
/* harmony import */ var _mouse_selection_state_tooltip_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mouse_selection_state_tooltip_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/annotation */ "./src/neuroglancer/annotation/index.ts");
/* harmony import */ var neuroglancer_annotation_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/annotation/selection */ "./src/neuroglancer/annotation/selection.ts");
/* harmony import */ var neuroglancer_ui_annotations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/ui/annotations */ "./src/neuroglancer/ui/annotations.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_spatial_units__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/spatial_units */ "./src/neuroglancer/util/spatial_units.ts");
/* harmony import */ var neuroglancer_widget_tooltip__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/widget/tooltip */ "./src/neuroglancer/widget/tooltip.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Facility for showing a tooltip based on the mouse selection state.
 */









const annotationTooltipHandlers = new Map([
    [
        neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["AnnotationType"].AXIS_ALIGNED_BOUNDING_BOX,
        (annotation, element, transform, _voxelSize) => {
            const volume = document.createElement('div');
            volume.className = 'neuroglancer-annotation-details-volume';
            volume.textContent = Object(neuroglancer_util_spatial_units__WEBPACK_IMPORTED_MODULE_7__["formatBoundingBoxVolume"])(annotation.pointA, annotation.pointB, transform);
            element.appendChild(volume);
        },
    ],
]);
const TOOLTIP_DELAY = 500;
class MouseSelectionStateTooltipManager extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["RefCounted"] {
    constructor(mouseState, layerManager, voxelSize) {
        super();
        this.mouseState = mouseState;
        this.layerManager = layerManager;
        this.voxelSize = voxelSize;
        this.tooltip = undefined;
        this.debouncedShowTooltip = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(() => this.doCreateTooltip(), TOOLTIP_DELAY));
        this.debouncedShowTooltip0 = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(() => this.doCreateTooltip(), 0));
        this.doCreateTooltip = (() => {
            this.debouncedShowTooltip.cancel();
            this.debouncedShowTooltip0.cancel();
            const { mouseState } = this;
            if (!this.maybeCreateTooltip()) {
                const { tooltip } = this;
                if (tooltip !== undefined) {
                    tooltip.dispose();
                    this.tooltip = undefined;
                }
                this.setReference(undefined);
                return;
            }
            else {
                const tooltip = this.tooltip;
                tooltip.updatePosition(mouseState.pageX, mouseState.pageY);
            }
        });
        this.registerDisposer(mouseState.changed.add(() => this.mouseStateChanged()));
    }
    setReference(reference) {
        const existing = this.reference;
        if (existing !== undefined) {
            existing.changed.remove(this.debouncedShowTooltip0);
            existing.dispose();
            this.reference = undefined;
        }
        this.reference = reference;
        if (reference !== undefined) {
            reference.changed.add(this.debouncedShowTooltip0);
        }
    }
    maybeCreateTooltip() {
        const state = Object(neuroglancer_annotation_selection__WEBPACK_IMPORTED_MODULE_3__["getSelectedAnnotation"])(this.mouseState, this.layerManager);
        if (state === undefined) {
            return false;
        }
        if (!this.voxelSize.valid) {
            return false;
        }
        let { tooltip } = this;
        if (tooltip === undefined) {
            tooltip = this.tooltip = new neuroglancer_widget_tooltip__WEBPACK_IMPORTED_MODULE_8__["Tooltip"]();
            tooltip.element.classList.add('neuroglancer-mouse-selection-tooltip');
        }
        const reference = state.annotationLayer.source.getReference(state.id);
        this.setReference(reference);
        if (reference.value === null) {
            return false;
        }
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_6__["removeChildren"])(tooltip.element);
        const header = document.createElement('div');
        header.className = 'neuroglancer-mouse-selection-tooltip-title';
        header.textContent = `${state.layer.name}`;
        const description = document.createElement('div');
        description.className = 'neuroglancer-mouse-selection-tooltip-description';
        const annotation = reference.value;
        if (annotation === undefined) {
            description.textContent = 'Loading...';
        }
        else {
            description.textContent = annotation.description || '';
        }
        tooltip.element.appendChild(header);
        tooltip.element.appendChild(description);
        if (annotation != null) {
            const { segments } = annotation;
            if (segments !== undefined && segments.length > 0) {
                const segmentContainer = document.createElement('div');
                segmentContainer.className = 'neuroglancer-annotation-segment-list';
                const segmentationState = state.annotationLayer.segmentationState.value;
                const segmentColorHash = segmentationState ? segmentationState.segmentColorHash : undefined;
                segments.forEach((segment, index) => {
                    if (index !== 0) {
                        segmentContainer.appendChild(document.createTextNode(' '));
                    }
                    const child = document.createElement('span');
                    child.className = 'neuroglancer-annotation-segment-item';
                    child.textContent = segment.toString();
                    if (segmentColorHash !== undefined) {
                        child.style.backgroundColor = segmentColorHash.computeCssColor(segment);
                    }
                    segmentContainer.appendChild(child);
                });
                tooltip.element.appendChild(segmentContainer);
            }
            const combinedTransform = state.annotationLayer.objectToGlobal;
            const typeHandler = Object(neuroglancer_annotation__WEBPACK_IMPORTED_MODULE_2__["getAnnotationTypeHandler"])(annotation.type);
            const positionElement = document.createElement('div');
            positionElement.appendChild(document.createTextNode(typeHandler.icon));
            Object(neuroglancer_ui_annotations__WEBPACK_IMPORTED_MODULE_4__["getPositionSummary"])(positionElement, annotation, combinedTransform, this.voxelSize);
            positionElement.className = 'neuroglancer-mouse-selection-tooltip-annotation-corners';
            tooltip.element.appendChild(positionElement);
            const handler = annotationTooltipHandlers.get(annotation.type);
            if (handler !== undefined) {
                handler(annotation, tooltip.element, combinedTransform, this.voxelSize);
            }
        }
        return true;
    }
    mouseStateChanged() {
        const { tooltip } = this;
        if (tooltip !== undefined) {
            tooltip.dispose();
            this.tooltip = undefined;
        }
        this.setReference(undefined);
        this.debouncedShowTooltip();
    }
    disposed() {
        const { tooltip } = this;
        if (tooltip !== undefined) {
            tooltip.dispose();
            this.tooltip = undefined;
        }
        this.setReference(undefined);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/ui/position_drag_and_drop.ts":
/*!*******************************************************!*\
  !*** ./src/neuroglancer/ui/position_drag_and_drop.ts ***!
  \*******************************************************/
/*! exports provided: setupPositionDropHandlers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupPositionDropHandlers", function() { return setupPositionDropHandlers; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/widget/position_widget */ "./src/neuroglancer/widget/position_widget.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function setupPositionDropHandlers(target, position) {
    const dropDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(target, 'drop', (event) => {
        event.preventDefault();
        if (event.dataTransfer.types.indexOf(neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_1__["positionDragType"]) !== -1) {
            const positionState = JSON.parse(event.dataTransfer.getData(neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_1__["positionDragType"]));
            position.restoreState(positionState);
            event.stopPropagation();
        }
    });
    const dragoverDisposer = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(target, 'dragover', (event) => {
        if (event.dataTransfer.types.indexOf(neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_1__["positionDragType"]) !== -1) {
            // Permit drag.
            event.dataTransfer.dropEffect = 'link';
            event.preventDefault();
            event.stopPropagation();
        }
    });
    return () => {
        dragoverDisposer();
        dropDisposer();
    };
}


/***/ }),

/***/ "./src/neuroglancer/ui/state_editor.css":
/*!**********************************************!*\
  !*** ./src/neuroglancer/ui/state_editor.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/state_editor.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/ui/state_editor.ts ***!
  \*********************************************/
/*! exports provided: StateEditorDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateEditorDialog", function() { return StateEditorDialog; });
/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! codemirror/lib/codemirror.css */ "./node_modules/codemirror/lib/codemirror.css");
/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var codemirror_mode_javascript_javascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! codemirror/mode/javascript/javascript */ "./node_modules/codemirror/mode/javascript/javascript.js");
/* harmony import */ var codemirror_mode_javascript_javascript__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_javascript_javascript__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var codemirror_addon_fold_foldcode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! codemirror/addon/fold/foldcode */ "./node_modules/codemirror/addon/fold/foldcode.js");
/* harmony import */ var codemirror_addon_fold_foldcode__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_fold_foldcode__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var codemirror_addon_fold_foldgutter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! codemirror/addon/fold/foldgutter */ "./node_modules/codemirror/addon/fold/foldgutter.js");
/* harmony import */ var codemirror_addon_fold_foldgutter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_fold_foldgutter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var codemirror_addon_fold_brace_fold__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! codemirror/addon/fold/brace-fold */ "./node_modules/codemirror/addon/fold/brace-fold.js");
/* harmony import */ var codemirror_addon_fold_brace_fold__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_fold_brace_fold__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var codemirror_addon_fold_foldgutter_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! codemirror/addon/fold/foldgutter.css */ "./node_modules/codemirror/addon/fold/foldgutter.css");
/* harmony import */ var codemirror_addon_fold_foldgutter_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_fold_foldgutter_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var codemirror_addon_lint_lint_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! codemirror/addon/lint/lint.css */ "./node_modules/codemirror/addon/lint/lint.css");
/* harmony import */ var codemirror_addon_lint_lint_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_lint_lint_css__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _state_editor_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./state_editor.css */ "./src/neuroglancer/ui/state_editor.css");
/* harmony import */ var _state_editor_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_state_editor_css__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! codemirror */ "./node_modules/codemirror/lib/codemirror.js");
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(codemirror__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/overlay */ "./src/neuroglancer/overlay.ts");
/* harmony import */ var neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/trackable */ "./src/neuroglancer/util/trackable.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Support for editing Neuroglancer state as JSON directly within browser.
 */












const valueUpdateDelay = 100;
class StateEditorDialog extends neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_10__["Overlay"] {
    constructor(viewer) {
        super();
        this.viewer = viewer;
        this.parsedValue = null;
        this.debouncedValueUpdater = lodash_debounce__WEBPACK_IMPORTED_MODULE_9___default()(() => {
            const value = this.textEditor.getValue();
            try {
                const json = JSON.parse(value);
                this.parsedValue = json;
                this.applyButton.disabled = false;
                this.textEditor.setOption('lint', undefined);
            }
            catch (parseError) {
                this.parsedValue = null;
                this.applyButton.disabled = true;
                let line = 0, column = 0, message = 'Unknown parse error';
                if (parseError instanceof Error) {
                    const m = parseError.message.match(/^((?:.|\n)*) in JSON at position ([0-9]+)$/);
                    if (m !== null) {
                        message = m[1];
                        const offset = parseInt(m[2], 10);
                        const prefix = value.substring(0, offset);
                        const lines = prefix.split('\n');
                        line = lines.length - 1;
                        column = lines[lines.length - 1].length;
                    }
                    else {
                        message = parseError.message;
                    }
                }
                this.textEditor.setOption('lint', {
                    getAnnotations: () => {
                        return [{
                                message,
                                severity: 'error',
                                from: codemirror__WEBPACK_IMPORTED_MODULE_8___default.a.Pos(line, column),
                            }];
                    },
                });
            }
        }, valueUpdateDelay);
        this.content.classList.add('neuroglancer-state-editor');
        const button = this.applyButton = document.createElement('button');
        button.textContent = 'Apply changes';
        this.content.appendChild(button);
        button.addEventListener('click', () => this.applyChanges());
        button.disabled = true;
        this.textEditor = codemirror__WEBPACK_IMPORTED_MODULE_8___default()(_element => { }, {
            value: '',
            mode: { 'name': 'javascript', json: true },
            foldGutter: true,
            gutters: [
                'CodeMirror-lint-markers',
                'CodeMirror-foldgutter',
            ],
        });
        this.updateView();
        this.textEditor.on('change', () => {
            this.debouncedValueUpdater();
        });
        this.content.appendChild(this.textEditor.getWrapperElement());
        this.textEditor.refresh();
    }
    applyChanges() {
        if (this.parsedValue !== null) {
            this.viewer.state.reset();
            this.viewer.state.restoreState(this.parsedValue);
        }
        this.applyButton.disabled = true;
    }
    updateView() {
        this.textEditor.setValue(this.getJson());
        this.textEditor.execCommand('foldAll');
        this.textEditor.execCommand('unfold');
    }
    getJson() {
        return JSON.stringify(Object(neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_11__["getCachedJson"])(this.viewer.state).value, null, '  ');
    }
}


/***/ }),

/***/ "./src/neuroglancer/ui/statistics.css":
/*!********************************************!*\
  !*** ./src/neuroglancer/ui/statistics.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/ui/statistics.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/ui/statistics.ts ***!
  \*******************************************/
/*! exports provided: StatisticsDisplayState, StatisticsPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatisticsDisplayState", function() { return StatisticsDisplayState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatisticsPanel", function() { return StatisticsPanel; });
/* harmony import */ var neuroglancer_ui_statistics_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/ui/statistics.css */ "./src/neuroglancer/ui/statistics.css");
/* harmony import */ var neuroglancer_ui_statistics_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_ui_statistics_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/chunk_manager/base */ "./src/neuroglancer/chunk_manager/base.ts");
/* harmony import */ var neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/trackable_boolean */ "./src/neuroglancer/trackable_boolean.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/trackable */ "./src/neuroglancer/util/trackable.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









class StatisticsDisplayState {
    constructor() {
        this.tracker = new neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_8__["CompoundTrackable"]();
        this.visible = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_3__["TrackableBoolean"](false);
        this.size = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_4__["TrackableValue"](100, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_7__["verifyPositiveInt"]);
        this.tracker.add('visible', this.visible);
        this.tracker.add('size', this.size);
    }
    get changed() {
        return this.tracker.changed;
    }
    restoreState(obj) {
        this.tracker.restoreState(obj);
    }
    reset() {
        this.tracker.reset();
    }
    toJSON() {
        const obj = this.tracker.toJSON();
        for (const k of Object.keys(obj)) {
            if (obj[k] !== undefined)
                return obj;
        }
        return undefined;
    }
}
function getProperties(obj) {
    const map = new Map();
    function handleObject(o, prefix) {
        if (typeof o !== 'object') {
            map.set(prefix, '' + o);
            return;
        }
        for (const key of Object.keys(o)) {
            handleObject(o[key], prefix + '.' + key);
        }
    }
    handleObject(obj, '');
    return map;
}
function getDistinguishingProperties(properties) {
    const selected = new Set();
    selected.add('.type');
    const allProps = new Set();
    function areDistinguished(i, j) {
        for (const prop of selected) {
            if (properties[i].get(prop) !== properties[j].get(prop)) {
                return true;
            }
        }
        return false;
    }
    for (let i = 0, n = properties.length; i < n; ++i) {
        for (const prop of properties[i].keys()) {
            allProps.add(prop);
        }
        let matches = [];
        for (let j = 0; j < i; ++j) {
            if (!areDistinguished(i, j)) {
                matches.push(j);
            }
        }
        while (matches.length > 0) {
            let bestReducedMatches = matches;
            let bestProp = undefined;
            for (const prop of allProps) {
                if (selected.has(prop))
                    continue;
                const reducedMatches = [];
                for (const j of matches) {
                    if (properties[j].get(prop) === properties[i].get(prop)) {
                        reducedMatches.push(j);
                    }
                }
                if (reducedMatches.length < bestReducedMatches.length) {
                    bestReducedMatches = reducedMatches;
                    bestProp = prop;
                }
                if (reducedMatches.length === 0)
                    break;
            }
            // Prevent infinite loop if there are no distinguishing properties.
            if (bestProp === undefined)
                break;
            matches = bestReducedMatches;
            selected.add(bestProp);
        }
    }
    return Array.from(selected);
}
function getNameFromProps(properties, selected) {
    const result = {};
    for (const prop of selected) {
        const value = properties.get(prop);
        if (value === undefined)
            continue;
        if (prop === '')
            return value;
        result[prop] = value;
    }
    return JSON.stringify(result);
}
function getFormattedNames(objects) {
    const properties = objects.map(getProperties);
    const selectedProps = getDistinguishingProperties(properties);
    return properties.map(p => getNameFromProps(p, selectedProps));
}
/**
 * Interval in ms at which to request new statistics from the backend thread.
 */
const requestDataInterval = 1000;
class StatisticsPanel extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_5__["RefCounted"] {
    constructor(chunkQueueManager, displayState) {
        super();
        this.chunkQueueManager = chunkQueueManager;
        this.displayState = displayState;
        this.element = document.createElement('div');
        this.columns = new Map();
        this.data = undefined;
        this.requestDataTimerId = -1;
        this.dataRequested = false;
        this.debouncedUpdateView = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(() => this.updateView(), 0));
        const { element } = this;
        element.className = 'neuroglancer-statistics-panel';
        this.registerDisposer(this.displayState.changed.add(this.debouncedUpdateView));
        this.registerDisposer(this.displayState.visible.changed.add(() => this.requestData()));
        this.requestData();
        const { columns } = this;
        // Total number of visible-priority chunks
        //    number in downloading state
        //    number in other system memory state
        //    number in gpu memory state
        //    number in failed state
        columns.set('Visible chunks/T', (statistics) => {
            let sum = 0;
            for (let state = 0; state < neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["numChunkStates"]; ++state) {
                sum += statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkStateStatisticIndex"])(state, neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkPriorityTier"].VISIBLE) *
                    neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["numChunkMemoryStatistics"] + neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkMemoryStatistics"].numChunks];
            }
            return sum;
        });
        columns.set('Visible chunks/D', (statistics) => {
            return (statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkStateStatisticIndex"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkState"].DOWNLOADING, neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkPriorityTier"].VISIBLE) *
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["numChunkMemoryStatistics"] +
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkMemoryStatistics"].numChunks]);
        });
        columns.set('Visible chunks/M', (statistics) => {
            return (statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkStateStatisticIndex"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkState"].SYSTEM_MEMORY, neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkPriorityTier"].VISIBLE) *
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["numChunkMemoryStatistics"] +
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkMemoryStatistics"].numChunks] +
                statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkStateStatisticIndex"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkState"].SYSTEM_MEMORY_WORKER, neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkPriorityTier"].VISIBLE) *
                    neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["numChunkMemoryStatistics"] +
                    neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkMemoryStatistics"].numChunks]);
        });
        columns.set('Visible chunks/G', (statistics) => {
            return statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkStateStatisticIndex"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkState"].GPU_MEMORY, neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkPriorityTier"].VISIBLE) *
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["numChunkMemoryStatistics"] +
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkMemoryStatistics"].numChunks];
        });
        columns.set('Visible chunks/F', (statistics) => {
            return statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkStateStatisticIndex"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkState"].FAILED, neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkPriorityTier"].VISIBLE) *
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["numChunkMemoryStatistics"] +
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkMemoryStatistics"].numChunks];
        });
        columns.set('Visible memory', (statistics) => {
            return statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkStateStatisticIndex"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkState"].GPU_MEMORY, neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkPriorityTier"].VISIBLE) *
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["numChunkMemoryStatistics"] +
                neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkMemoryStatistics"].gpuMemoryBytes];
        });
        columns.set('Download latency', (statistics) => {
            return statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkDownloadStatisticIndex"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkDownloadStatistics"].totalTime)] /
                statistics[Object(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["getChunkDownloadStatisticIndex"])(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["ChunkDownloadStatistics"].totalChunks)];
        });
    }
    disposed() {
        clearTimeout(this.requestDataTimerId);
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_6__["removeFromParent"])(this.element);
        super.disposed();
    }
    requestData() {
        if (!this.displayState.visible.value)
            return;
        if (this.dataRequested)
            return;
        const { chunkQueueManager } = this;
        const rpc = chunkQueueManager.rpc;
        this.dataRequested = true;
        rpc.promiseInvoke(neuroglancer_chunk_manager_base__WEBPACK_IMPORTED_MODULE_2__["REQUEST_CHUNK_STATISTICS_RPC_ID"], { queue: chunkQueueManager.rpcId })
            .then(data => {
            this.dataRequested = false;
            this.data = data;
            this.debouncedUpdateView();
            this.requestDataTimerId = setTimeout(() => {
                this.requestDataTimerId = -1;
                this.requestData();
            }, requestDataInterval);
        });
    }
    updateView() {
        if (!this.displayState.visible.value)
            return;
        const { data } = this;
        if (data === undefined)
            return;
        const { columns } = this;
        const rpc = this.chunkQueueManager.rpc;
        const table = document.createElement('table');
        const rows = [];
        for (const [id, statistics] of data) {
            const source = rpc.get(id);
            if (source === undefined)
                continue;
            const row = [source];
            for (const column of columns.values()) {
                row.push(column(statistics));
            }
            rows.push(row);
        }
        const formattedNames = getFormattedNames(rows.map(x => Object.assign({ type: x[0].RPC_TYPE_ID }, x[0].key || {})));
        const sourceFormattedNames = new Map();
        formattedNames.forEach((name, i) => {
            sourceFormattedNames.set(rows[i][0], name);
        });
        {
            const thead = document.createElement('thead');
            let tr = document.createElement('tr');
            thead.appendChild(tr);
            const addHeaderColumn = (label) => {
                const td = document.createElement('td');
                td.textContent = label;
                tr.appendChild(td);
            };
            addHeaderColumn('Name');
            let prevPrefix = undefined;
            for (const column of columns.keys()) {
                const sepIndex = column.indexOf('/');
                let prefix = column;
                if (sepIndex !== -1) {
                    prefix = column.substring(0, sepIndex);
                    if (prefix === prevPrefix) {
                        ++tr.lastElementChild.colSpan;
                        continue;
                    }
                    prevPrefix = prefix;
                }
                addHeaderColumn(prefix);
            }
            tr = document.createElement('tr');
            thead.appendChild(tr);
            {
                const td = document.createElement('td');
                tr.appendChild(td);
            }
            for (const column of columns.keys()) {
                const sepIndex = column.indexOf('/');
                let suffix = '';
                if (sepIndex !== -1) {
                    suffix = column.substring(sepIndex + 1);
                }
                const td = document.createElement('td');
                td.textContent = suffix;
                tr.appendChild(td);
            }
            table.appendChild(thead);
        }
        const tbody = document.createElement('tbody');
        // TODO: sort rows
        for (const [source, ...values] of rows) {
            const tr = document.createElement('tr');
            const addColumn = (label) => {
                const td = document.createElement('td');
                td.textContent = label;
                tr.appendChild(td);
            };
            addColumn(sourceFormattedNames.get(source));
            for (const value of values) {
                addColumn('' + value);
            }
            tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_6__["removeChildren"])(this.element);
        this.element.appendChild(table);
    }
}


/***/ }),

/***/ "./src/neuroglancer/ui/tool.ts":
/*!*************************************!*\
  !*** ./src/neuroglancer/ui/tool.ts ***!
  \*************************************/
/*! exports provided: Tool, restoreTool, registerTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tool", function() { return Tool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "restoreTool", function() { return restoreTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerTool", function() { return registerTool; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class Tool extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    setActive(_value) { }
    deactivate() { }
}
function restoreTool(layer, obj) {
    if (obj === undefined) {
        return undefined;
    }
    if (typeof obj === 'string') {
        obj = { 'type': obj };
    }
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verifyObject"])(obj);
    const type = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verifyObjectProperty"])(obj, 'type', neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verifyString"]);
    const getter = tools.get(type);
    if (getter === undefined) {
        throw new Error(`Invalid tool type: ${JSON.stringify(obj)}.`);
    }
    return getter(layer, obj);
}
const tools = new Map();
function registerTool(type, getter) {
    tools.set(type, getter);
}


/***/ }),

/***/ "./src/neuroglancer/ui/url_hash_binding.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/ui/url_hash_binding.ts ***!
  \*************************************************/
/*! exports provided: UrlHashBinding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlHashBinding", function() { return UrlHashBinding; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/trackable */ "./src/neuroglancer/util/trackable.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @file Implements a binding between a Trackable value and the URL hash state.
 */
/**
 * Encodes a fragment string robustly.
 */
function encodeFragment(fragment) {
    return encodeURI(fragment).replace(/[!'()*;,]/g, function (c) {
        return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
/**
 * An instance of this class manages a binding between a Trackable value and the URL hash state.
 * The binding is initialized in the constructor, and is removed when dispose is called.
 */
class UrlHashBinding extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__["RefCounted"] {
    constructor(root, updateDelayMilliseconds = 200) {
        super();
        this.root = root;
        /**
         * Most recent error parsing URL hash.
         */
        this.parseError = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_1__["WatchableValue"](undefined);
        this.registerEventListener(window, 'hashchange', () => this.updateFromUrlHash());
        const throttledSetUrlHash = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => this.setUrlHash(), updateDelayMilliseconds);
        this.registerDisposer(root.changed.add(throttledSetUrlHash));
        this.registerDisposer(() => throttledSetUrlHash.cancel());
    }
    /**
     * Sets the URL hash to match the current state.
     */
    setUrlHash() {
        const cacheState = Object(neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_4__["getCachedJson"])(this.root);
        const { generation } = cacheState;
        if (generation !== this.prevStateGeneration) {
            this.prevStateGeneration = cacheState.generation;
            let stateString = encodeFragment(JSON.stringify(cacheState.value));
            if (stateString !== this.prevStateString) {
                this.prevStateString = stateString;
                if (decodeURIComponent(stateString) === '{}') {
                    history.replaceState(null, '', '#');
                }
                else {
                    history.replaceState(null, '', '#!' + stateString);
                }
            }
        }
    }
    /**
     * Sets the current state to match the URL hash.  If it is desired to initialize the state based
     * on the URL hash, then this should be called immediately after construction.
     */
    updateFromUrlHash() {
        try {
            let s = location.href.replace(/^[^#]+/, '');
            if (s === '' || s === '#' || s === '#!') {
                s = '#!{}';
            }
            if (s.startsWith('#!+')) {
                s = s.slice(3);
                // Firefox always %-encodes the URL even if it is not typed that way.
                s = decodeURIComponent(s);
                let state = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["urlSafeParse"])(s);
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyObject"])(state);
                this.root.restoreState(state);
                this.prevStateString = undefined;
            }
            else if (s.startsWith('#!')) {
                s = s.slice(2);
                s = decodeURIComponent(s);
                if (s === this.prevStateString) {
                    return;
                }
                this.prevStateString = s;
                this.root.reset();
                let state = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["urlSafeParse"])(s);
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyObject"])(state);
                this.root.restoreState(state);
            }
            else {
                throw new Error(`URL hash is expected to be of the form "#!{...}" or "#!+{...}".`);
            }
            this.parseError.value = undefined;
        }
        catch (parseError) {
            this.parseError.value = parseError;
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/uint64_map.ts":
/*!****************************************!*\
  !*** ./src/neuroglancer/uint64_map.ts ***!
  \****************************************/
/*! exports provided: Uint64Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64Map", function() { return Uint64Map; });
/* harmony import */ var neuroglancer_gpu_hash_hash_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/gpu_hash/hash_table */ "./src/neuroglancer/gpu_hash/hash_table.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * This work is a derivative of the Google Neuroglancer project,
 * Copyright 2016 Google Inc.
 * The Derivative Work is covered by
 * Copyright 2019 Howard Hughes Medical Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Uint64Map_1;



let Uint64Map = Uint64Map_1 = class Uint64Map extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["SharedObjectCounterpart"] {
    constructor() {
        super(...arguments);
        this.hashTable = new neuroglancer_gpu_hash_hash_table__WEBPACK_IMPORTED_MODULE_0__["HashMapUint64"]();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__["Signal"]();
    }
    get value() {
        return this;
    }
    static makeWithCounterpart(rpc) {
        let obj = new Uint64Map_1();
        obj.initializeCounterpart(rpc);
        return obj;
    }
    disposed() {
        super.disposed();
        this.hashTable = undefined;
        this.changed = undefined;
    }
    set_(key, value) {
        return this.hashTable.set(key, value);
    }
    set(key, value) {
        if (this.set_(key, value)) {
            let { rpc } = this;
            if (rpc) {
                rpc.invoke('Uint64Map.set', { 'id': this.rpcId, 'key': key, 'value': value });
            }
            this.changed.dispatch(key, true);
        }
    }
    has(key) {
        return this.hashTable.has(key);
    }
    get(key, value) {
        return this.hashTable.get(key, value);
    }
    [Symbol.iterator]() {
        return this.hashTable.entries();
    }
    delete_(key) {
        return this.hashTable.delete(key);
    }
    delete(key) {
        if (this.delete_(key)) {
            let { rpc } = this;
            if (rpc) {
                rpc.invoke('Uint64Map.delete', { 'id': this.rpcId, 'key': key });
            }
            this.changed.dispatch(key, false);
        }
    }
    get size() {
        return this.hashTable.size;
    }
    clear() {
        if (this.hashTable.clear()) {
            let { rpc } = this;
            if (rpc) {
                rpc.invoke('Uint64Map.clear', { 'id': this.rpcId });
            }
            this.changed.dispatch(null, false);
        }
    }
    toJSON() {
        let result = {};
        for (let [key, value] of this.hashTable.entries()) {
            result[key.toString()] = value.toString();
        }
        return result;
    }
};
Uint64Map = Uint64Map_1 = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["registerSharedObject"])('Uint64Map')
], Uint64Map);

Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["registerRPC"])('Uint64Map.set', function (x) {
    let obj = this.get(x['id']);
    if (obj.set_(x['key'], x['value'])) {
        obj.changed.dispatch();
    }
});
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["registerRPC"])('Uint64Map.delete', function (x) {
    let obj = this.get(x['id']);
    if (obj.delete_(x['key'])) {
        obj.changed.dispatch();
    }
});
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["registerRPC"])('Uint64Map.clear', function (x) {
    let obj = this.get(x['id']);
    if (obj.hashTable.clear()) {
        obj.changed.dispatch();
    }
});


/***/ }),

/***/ "./src/neuroglancer/uint64_set.ts":
/*!****************************************!*\
  !*** ./src/neuroglancer/uint64_set.ts ***!
  \****************************************/
/*! exports provided: Uint64Set */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64Set", function() { return Uint64Set; });
/* harmony import */ var neuroglancer_gpu_hash_hash_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/gpu_hash/hash_table */ "./src/neuroglancer/gpu_hash/hash_table.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Uint64Set_1;



let Uint64Set = Uint64Set_1 = class Uint64Set extends neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["SharedObjectCounterpart"] {
    constructor() {
        super(...arguments);
        this.hashTable = new neuroglancer_gpu_hash_hash_table__WEBPACK_IMPORTED_MODULE_0__["HashSetUint64"]();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__["Signal"]();
    }
    get value() {
        return this;
    }
    static makeWithCounterpart(rpc) {
        let obj = new Uint64Set_1();
        obj.initializeCounterpart(rpc);
        return obj;
    }
    disposed() {
        super.disposed();
        this.hashTable = undefined;
        this.changed = undefined;
    }
    add_(x) {
        return this.hashTable.add(x);
    }
    add(x) {
        if (this.add_(x)) {
            let { rpc } = this;
            if (rpc) {
                rpc.invoke('Uint64Set.add', { 'id': this.rpcId, 'value': x });
            }
            this.changed.dispatch(x, true);
        }
    }
    has(x) {
        return this.hashTable.has(x);
    }
    [Symbol.iterator]() {
        return this.hashTable.keys();
    }
    delete_(x) {
        return this.hashTable.delete(x);
    }
    delete(x) {
        if (this.delete_(x)) {
            let { rpc } = this;
            if (rpc) {
                rpc.invoke('Uint64Set.delete', { 'id': this.rpcId, 'value': x });
            }
            this.changed.dispatch(x, false);
        }
    }
    get size() {
        return this.hashTable.size;
    }
    clear() {
        if (this.hashTable.clear()) {
            let { rpc } = this;
            if (rpc) {
                rpc.invoke('Uint64Set.clear', { 'id': this.rpcId });
            }
            this.changed.dispatch(null, false);
        }
    }
    toJSON() {
        let result = new Array();
        for (let id of this) {
            result.push(id.toString());
        }
        // Need to sort entries, otherwise serialization changes every time.
        result.sort();
        return result;
    }
};
Uint64Set = Uint64Set_1 = __decorate([
    Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["registerSharedObject"])('Uint64Set')
], Uint64Set);

Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["registerRPC"])('Uint64Set.add', function (x) {
    let obj = this.get(x['id']);
    if (obj.add_(x['value'])) {
        obj.changed.dispatch();
    }
});
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["registerRPC"])('Uint64Set.delete', function (x) {
    let obj = this.get(x['id']);
    if (obj.delete_(x['value'])) {
        obj.changed.dispatch();
    }
});
Object(neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_2__["registerRPC"])('Uint64Set.clear', function (x) {
    let obj = this.get(x['id']);
    if (obj.hashTable.clear()) {
        obj.changed.dispatch();
    }
});


/***/ }),

/***/ "./src/neuroglancer/user_layer_with_coordinate_transform.ts":
/*!******************************************************************!*\
  !*** ./src/neuroglancer/user_layer_with_coordinate_transform.ts ***!
  \******************************************************************/
/*! exports provided: UserLayerWithCoordinateTransformMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserLayerWithCoordinateTransformMixin", function() { return UserLayerWithCoordinateTransformMixin; });
/* harmony import */ var neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/coordinate_transform */ "./src/neuroglancer/coordinate_transform.ts");
/* harmony import */ var neuroglancer_widget_coordinate_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/widget/coordinate_transform */ "./src/neuroglancer/widget/coordinate_transform.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const TRANSFORM_JSON_KEY = 'transform';
/**
 * Mixin that adds a `transform` property to a user layer.
 */
function UserLayerWithCoordinateTransformMixin(Base) {
    class C extends Base {
        constructor(...args) {
            super(...args);
            this.transform = new neuroglancer_coordinate_transform__WEBPACK_IMPORTED_MODULE_0__["CoordinateTransform"]();
            this.transform.changed.add(this.specificationChanged.dispatch);
            this.tabs.add('transform', {
                label: 'Transform',
                order: 100,
                getter: () => new neuroglancer_widget_coordinate_transform__WEBPACK_IMPORTED_MODULE_1__["CoordinateTransformTab"](this.transform)
            });
            const specification = args[1];
            this.transform.restoreState(specification[TRANSFORM_JSON_KEY]);
        }
        toJSON() {
            const x = super.toJSON();
            x[TRANSFORM_JSON_KEY] = this.transform.toJSON();
            return x;
        }
    }
    return C;
}


/***/ }),

/***/ "./src/neuroglancer/user_layer_with_volume_source.ts":
/*!***********************************************************!*\
  !*** ./src/neuroglancer/user_layer_with_volume_source.ts ***!
  \***********************************************************/
/*! exports provided: UserLayerWithVolumeSourceMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserLayerWithVolumeSourceMixin", function() { return UserLayerWithVolumeSourceMixin; });
/* harmony import */ var neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/annotation/frontend */ "./src/neuroglancer/annotation/frontend.ts");
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/render_scale_statistics */ "./src/neuroglancer/render_scale_statistics.ts");
/* harmony import */ var neuroglancer_ui_annotations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/ui/annotations */ "./src/neuroglancer/ui/annotations.ts");
/* harmony import */ var neuroglancer_user_layer_with_coordinate_transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/user_layer_with_coordinate_transform */ "./src/neuroglancer/user_layer_with_coordinate_transform.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







const SOURCE_JSON_KEY = 'source';
const CROSS_SECTION_RENDER_SCALE_JSON_KEY = 'crossSectionRenderScale';
function helper(Base) {
    class C extends Base {
        constructor() {
            super(...arguments);
            this.sliceViewRenderScaleHistogram = new neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["RenderScaleHistogram"]();
            this.sliceViewRenderScaleTarget = (() => {
                const target = Object(neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["trackableRenderScaleTarget"])(1);
                target.changed.add(this.specificationChanged.dispatch);
                return target;
            })();
        }
        restoreState(specification) {
            super.restoreState(specification);
            const volumePath = this.volumePath =
                Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_6__["verifyObjectProperty"])(specification, SOURCE_JSON_KEY, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_6__["verifyOptionalString"]);
            this.sliceViewRenderScaleTarget.restoreState(specification[CROSS_SECTION_RENDER_SCALE_JSON_KEY]);
            if (volumePath !== undefined) {
                const multiscaleSource = this.multiscaleSource = Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_2__["getVolumeWithStatusMessage"])(this.manager.dataSourceProvider, this.manager.chunkManager, volumePath, this.volumeOptions);
                multiscaleSource.then(volume => {
                    if (!this.wasDisposed) {
                        const staticAnnotations = volume.getStaticAnnotations && volume.getStaticAnnotations();
                        if (staticAnnotations !== undefined) {
                            this.annotationLayerState.value = new neuroglancer_annotation_frontend__WEBPACK_IMPORTED_MODULE_0__["AnnotationLayerState"](Object.assign({ transform: this.transform, source: staticAnnotations, role: neuroglancer_layer__WEBPACK_IMPORTED_MODULE_1__["RenderLayerRole"].DEFAULT_ANNOTATION }, Object(neuroglancer_ui_annotations__WEBPACK_IMPORTED_MODULE_4__["getAnnotationRenderOptions"])(this)));
                        }
                    }
                });
            }
        }
        toJSON() {
            const result = super.toJSON();
            result[SOURCE_JSON_KEY] = this.volumePath;
            result[CROSS_SECTION_RENDER_SCALE_JSON_KEY] = this.sliceViewRenderScaleTarget.toJSON();
            return result;
        }
    }
    return C;
}
/**
 * Mixin that adds a `source` property to a user layer.
 */
function UserLayerWithVolumeSourceMixin(Base) {
    return helper(Object(neuroglancer_ui_annotations__WEBPACK_IMPORTED_MODULE_4__["UserLayerWithAnnotationsMixin"])(Object(neuroglancer_user_layer_with_coordinate_transform__WEBPACK_IMPORTED_MODULE_5__["UserLayerWithCoordinateTransformMixin"])(Base)));
}


/***/ }),

/***/ "./src/neuroglancer/util/animation_frame_debounce.ts":
/*!***********************************************************!*\
  !*** ./src/neuroglancer/util/animation_frame_debounce.ts ***!
  \***********************************************************/
/*! exports provided: animationFrameDebounce */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animationFrameDebounce", function() { return animationFrameDebounce; });
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a function that, when called, ensures `callback` is invoked at the next animation frame.
 */
function animationFrameDebounce(callback) {
    let handle = -1;
    const cancel = () => {
        if (handle !== -1) {
            cancelAnimationFrame(handle);
            handle = -1;
        }
    };
    const flush = () => {
        if (handle !== -1) {
            handle = -1;
            callback();
        }
    };
    return Object.assign(() => {
        if (handle === -1) {
            handle = requestAnimationFrame(() => {
                handle = -1;
                callback();
            });
        }
    }, { flush, cancel });
}


/***/ }),

/***/ "./src/neuroglancer/util/array.ts":
/*!****************************************!*\
  !*** ./src/neuroglancer/util/array.ts ***!
  \****************************************/
/*! exports provided: partitionArray, maybePadArray, getFortranOrderStrides, transposeArray2d, tile2dArray, binarySearch, binarySearchLowerBound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partitionArray", function() { return partitionArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maybePadArray", function() { return maybePadArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFortranOrderStrides", function() { return getFortranOrderStrides; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transposeArray2d", function() { return transposeArray2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile2dArray", function() { return tile2dArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearch", function() { return binarySearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearchLowerBound", function() { return binarySearchLowerBound; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Partitions array[start:end] such that all elements for which predicate
 * returns true are before the elements for which predicate returns false.
 *
 * predicate will be called exactly once for each element in array[start:end],
 * in order.
 *
 * @returns {number} The index of the first element for which predicate returns
 * false, or end if there is no such element.
 */
function partitionArray(array, start, end, predicate) {
    while (start < end) {
        let x = array[start];
        if (predicate(x)) {
            ++start;
            continue;
        }
        --end;
        array[start] = array[end];
        array[end] = x;
    }
    return end;
}
/**
 * Returns an array of size newSize that starts with the contents of array.
 * Either returns array if it has the correct size, or a new array with zero
 * padding at the end.
 */
function maybePadArray(array, newSize) {
    if (array.length === newSize) {
        return array;
    }
    let newArray = new array.constructor(newSize);
    newArray.set(array);
    return newArray;
}
function getFortranOrderStrides(size, baseStride = 1) {
    let length = size.length;
    let strides = new Array(length);
    let stride = strides[0] = baseStride;
    for (let i = 1; i < length; ++i) {
        stride *= size[i - 1];
        strides[i] = stride;
    }
    return strides;
}
/**
 * Converts an array of shape [majorSize, minorSize] to
 * [minorSize, majorSize].
 */
function transposeArray2d(array, majorSize, minorSize) {
    let transpose = new array.constructor(array.length);
    for (let i = 0; i < majorSize * minorSize; i += minorSize) {
        for (let j = 0; j < minorSize; j++) {
            let index = i / minorSize;
            transpose[j * majorSize + index] = array[i + j];
        }
    }
    return transpose;
}
function tile2dArray(array, majorDimension, minorTiles, majorTiles) {
    const minorDimension = array.length / majorDimension;
    const length = array.length * minorTiles * majorTiles;
    const result = new array.constructor(length);
    const minorTileStride = array.length * majorTiles;
    const majorTileStride = majorDimension;
    const minorStride = majorDimension * majorTiles;
    for (let minor = 0; minor < minorDimension; ++minor) {
        for (let major = 0; major < majorDimension; ++major) {
            const inputValue = array[minor * majorDimension + major];
            const baseOffset = minor * minorStride + major;
            for (let minorTile = 0; minorTile < minorTiles; ++minorTile) {
                for (let majorTile = 0; majorTile < majorTiles; ++majorTile) {
                    result[minorTile * minorTileStride + majorTile * majorTileStride + baseOffset] =
                        inputValue;
                }
            }
        }
    }
    return result;
}
function binarySearch(haystack, needle, compare, low = 0, high = haystack.length) {
    while (low < high) {
        const mid = (low + high - 1) >> 1;
        const compareResult = compare(needle, haystack[mid]);
        if (compareResult > 0) {
            low = mid + 1;
        }
        else if (compareResult < 0) {
            high = mid;
        }
        else {
            return mid;
        }
    }
    return ~low;
}
/**
 * Returns the first index in `[begin, end)` for which `predicate` is `true`, or returns `end` if no
 * such index exists.
 *
 * For any index `i` in `(begin, end)`, it must be the case that `predicate(i) >= predicate(i - 1)`.
 */
function binarySearchLowerBound(begin, end, predicate) {
    let count = end - begin;
    while (count > 0) {
        let step = Math.floor(count / 2);
        let i = begin + step;
        if (predicate(i)) {
            count = step;
        }
        else {
            begin = i + 1;
            count -= step + 1;
        }
    }
    return begin;
}


/***/ }),

/***/ "./src/neuroglancer/util/automatic_focus.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/util/automatic_focus.ts ***!
  \**************************************************/
/*! exports provided: AutomaticallyFocusedElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutomaticallyFocusedElement", function() { return AutomaticallyFocusedElement; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_linked_list_0__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/linked_list.0 */ "./src/neuroglancer/util/linked_list.0.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class AutomaticFocusList {
    constructor() {
        neuroglancer_util_linked_list_0__WEBPACK_IMPORTED_MODULE_2__["default"].initializeHead(this);
    }
}
const automaticFocusList = new AutomaticFocusList();
const maybeUpdateFocus = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
    const { activeElement } = document;
    if (activeElement === null || activeElement === document.body) {
        const node = neuroglancer_util_linked_list_0__WEBPACK_IMPORTED_MODULE_2__["default"].front(automaticFocusList);
        if (node !== null) {
            node.element.focus();
        }
    }
});
window.addEventListener('focus', () => {
    maybeUpdateFocus();
}, true);
window.addEventListener('blur', () => {
    maybeUpdateFocus();
}, true);
class AutomaticallyFocusedElement extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(element) {
        super();
        this.element = element;
        this.prev0 = null;
        this.next0 = null;
        this.lastFocusedElement = null;
        this.scheduleUpdateFocus = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
            const { activeElement } = document;
            const { element } = this;
            if (element.contains(activeElement) || activeElement instanceof HTMLInputElement ||
                (activeElement instanceof HTMLElement && activeElement.isContentEditable) ||
                activeElement instanceof HTMLTextAreaElement) {
                // Never steal focus from descendant.
                return;
            }
            if (activeElement != null &&
                (activeElement === this.lastFocusedElement || activeElement.contains(element))) {
                this.element.focus();
            }
            this.lastFocusedElement = null;
        }, 0));
        element.tabIndex = -1;
        this.registerEventListener(element, 'pointerdown', event => {
            if (event.target !== element)
                return;
            this.lastFocusedElement = null;
            element.focus();
        });
        this.registerEventListener(element, 'mouseenter', () => {
            this.lastFocusedElement = document.activeElement;
            this.scheduleUpdateFocus();
        });
        this.registerEventListener(element, 'mouseleave', () => {
            this.scheduleUpdateFocus.cancel();
        });
        // Insert at the end of the list.
        neuroglancer_util_linked_list_0__WEBPACK_IMPORTED_MODULE_2__["default"].insertBefore(automaticFocusList, this);
        this.registerEventListener(element, 'focus', () => {
            // Move to the beginning of the list.
            neuroglancer_util_linked_list_0__WEBPACK_IMPORTED_MODULE_2__["default"].pop(this);
            neuroglancer_util_linked_list_0__WEBPACK_IMPORTED_MODULE_2__["default"].insertAfter(automaticFocusList, this);
        });
        maybeUpdateFocus();
    }
    disposed() {
        neuroglancer_util_linked_list_0__WEBPACK_IMPORTED_MODULE_2__["default"].pop(this);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/cancellation.ts":
/*!***********************************************!*\
  !*** ./src/neuroglancer/util/cancellation.ts ***!
  \***********************************************/
/*! exports provided: CANCELED, throwIfCanceled, uncancelableToken, CancellationTokenSource, MultipleConsumerCancellationTokenSource, makeCancelablePromise */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANCELED", function() { return CANCELED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwIfCanceled", function() { return throwIfCanceled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uncancelableToken", function() { return uncancelableToken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CancellationTokenSource", function() { return CancellationTokenSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultipleConsumerCancellationTokenSource", function() { return MultipleConsumerCancellationTokenSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCancelablePromise", function() { return makeCancelablePromise; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CancellationError {
    constructor() {
        this.name = 'CancellationError';
        this.message = 'CANCELED';
    }
    toString() {
        return 'CANCELED';
    }
}
/**
 * Singleton instance of CancellationError thrown to indicate cancellation.
 */
const CANCELED = new CancellationError();
/**
 * Throws CANCELED if token.isCanceled === true.
 */
function throwIfCanceled(token) {
    if (token.isCanceled === true) {
        throw CANCELED;
    }
}
const noopFunction = () => { };
/**
 * CancellationToken that cannot be canceled.  This can be passed to operations that require a
 * CancellationToken but will not need to be canceled.
 */
const uncancelableToken = {
    isCanceled: false,
    add: () => noopFunction,
    remove: noopFunction
};
/**
 * Class that can be used to trigger cancellation.
 */
class CancellationTokenSource {
    /**
     * Trigger cancellation.
     *
     * If this.isCanceled === false, then each registered cancellation handler is invoked
     * synchronously.
     */
    cancel() {
        const { handlers } = this;
        if (handlers !== null) {
            this.handlers = null;
            if (handlers !== undefined) {
                for (let handler of handlers) {
                    handler();
                }
            }
        }
    }
    get isCanceled() {
        return this.handlers === null;
    }
    add(handler) {
        let { handlers } = this;
        if (handlers === null) {
            handler();
            return noopFunction;
        }
        if (handlers === undefined) {
            handlers = this.handlers = new Set();
        }
        handlers.add(handler);
        return () => {
            this.remove(handler);
        };
    }
    remove(handler) {
        const { handlers } = this;
        if (handlers != null) {
            handlers.delete(handler);
        }
    }
}
/**
 * Creates a CancellationToken corresponding to an asynchronous process with multiple consumers.  It
 * is cancelled only when the cancellation tokens corresponding to all of the consumers have been
 * cancelled.
 */
class MultipleConsumerCancellationTokenSource extends CancellationTokenSource {
    constructor() {
        super(...arguments);
        this.consumers = new Set();
    }
    addConsumer(cancellationToken = uncancelableToken) {
        const { consumers } = this;
        if (consumers.has(cancellationToken) || cancellationToken.isCanceled) {
            return;
        }
        consumers.add(cancellationToken);
        cancellationToken.add(() => {
            consumers.delete(cancellationToken);
            if (consumers.size === 0) {
                this.cancel();
            }
        });
    }
}
/**
 * Creates a promise and a dependent cancellation token.
 *
 * The dependent cancellation token will be canceled if the specified `cancellationToken` is
 * canceled while the promise is pending.
 *
 * @param cancellationToken The token that provides notification of cancellation.
 * @param executor The executor passed the resolve and reject functions for the promise, as well as
 * the dependent cancellation token.  If cancellation occurs after either resolve or reject is
 * called, then the dependent token is not cancelled.
 *
 * @returns A new Promise.
 */
function makeCancelablePromise(cancellationToken, executor) {
    return new Promise((resolve, reject) => {
        if (cancellationToken === uncancelableToken) {
            executor(resolve, reject, uncancelableToken);
            return;
        }
        const scopedToken = new CancellationTokenSource();
        const unregister = cancellationToken.add(() => {
            scopedToken.cancel();
        });
        executor(value => {
            unregister();
            resolve(value);
        }, error => {
            unregister();
            reject(error);
        }, scopedToken);
    });
}


/***/ }),

/***/ "./src/neuroglancer/util/clipboard.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/util/clipboard.ts ***!
  \********************************************/
/*! exports provided: eventHasInputTextTarget, setClipboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eventHasInputTextTarget", function() { return eventHasInputTextTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setClipboard", function() { return setClipboard; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the event appears to be targetted on input text and should not be overridden by a
 * global handler.
 */
function eventHasInputTextTarget(event) {
    const selection = window.getSelection();
    if (selection !== null && !selection.isCollapsed) {
        return true;
    }
    const { tagName } = event.target;
    if (tagName === 'TEXTAREA' || tagName === 'INPUT') {
        return true;
    }
    return false;
}
function setClipboard(data, format = 'text/plain') {
    let success = false;
    const cleanup = Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(document, 'copy', (event) => {
        const { clipboardData } = event;
        if (clipboardData !== null) {
            clipboardData.setData(format, data);
            success = true;
        }
        event.stopPropagation();
        event.preventDefault();
    }, true);
    try {
        document.execCommand('copy');
    }
    finally {
        cleanup();
    }
    return success;
}


/***/ }),

/***/ "./src/neuroglancer/util/color.ts":
/*!****************************************!*\
  !*** ./src/neuroglancer/util/color.ts ***!
  \****************************************/
/*! exports provided: parseColorSerialization, parseRGBAColorSpecification, parseRGBColorSpecification, packColor, serializeColor, TrackableRGB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseColorSerialization", function() { return parseColorSerialization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseRGBAColorSpecification", function() { return parseRGBAColorSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseRGBColorSpecification", function() { return parseRGBColorSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "packColor", function() { return packColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serializeColor", function() { return serializeColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableRGB", function() { return TrackableRGB; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_float32_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/float32_to_string */ "./src/neuroglancer/util/float32_to_string.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_hex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/hex */ "./src/neuroglancer/util/hex.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for converting between strings and RGB/RGBA colors.
 */




/**
 * Parse the serialization of a color.
 *
 * This is based on the definition here:
 * https://html.spec.whatwg.org/multipage/canvas.html#serialisation-of-a-color
 */
function parseColorSerialization(x) {
    const rgbaPattern = /^rgba\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\.[0-9]+)?)\)$/;
    {
        const m = x.match(rgbaPattern);
        if (m !== null) {
            return [parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), parseFloat(m[4])];
        }
    }
    const hexPattern = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;
    {
        const m = x.match(hexPattern);
        if (m !== null) {
            return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1.0];
        }
    }
    throw new Error(`Invalid serialized color: ${JSON.stringify(x)}.`);
}
function parseRGBAColorSpecification(x) {
    try {
        if (typeof x !== 'string') {
            throw new Error(`Expected string, but received ${JSON.stringify(x)}.`);
        }
        const context = document.createElement('canvas').getContext('2d');
        context.fillStyle = x;
        const result = parseColorSerialization(context.fillStyle);
        return neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec4"].fromValues(result[0] / 255, result[1] / 255, result[2] / 255, result[3]);
    }
    catch (parseError) {
        throw new Error(`Failed to parse color specification: ${parseError.message}`);
    }
}
function parseRGBColorSpecification(x) {
    const result = parseRGBAColorSpecification(x);
    return result.subarray(0, 3);
}
/**
 * Returns an integer formed by concatenating the channels of the input color vector.
 * Each channel is clamped to the range [0.0, 1.0] before being converted to 8 bits.
 * An RGB color is packed into 24 bits, and a RGBA into 32 bits.
 */
function packColor(x) {
    const size = (x[3] === undefined) ? 3 : 4;
    let result = 0;
    for (let i = 0; i < size; i++) {
        // The ">>> 0" ensures an unsigned value.
        result = ((result << 8) >>> 0) + Math.min(255, Math.max(0, (Math.round(x[i] * 255))));
    }
    return result;
}
function serializeColor(x) {
    if (x[3] === undefined || x[3] === 1) {
        let result = '#';
        for (let i = 0; i < 3; ++i) {
            result += Object(neuroglancer_util_hex__WEBPACK_IMPORTED_MODULE_3__["hexEncodeByte"])(Math.min(255, Math.max(0, Math.round(x[i] * 255))));
        }
        return result;
    }
    else {
        let result = 'rgba(';
        for (let i = 0; i < 3; ++i) {
            if (i !== 0) {
                result += ', ';
            }
            result += Math.min(255, Math.max(0, Math.round(x[i] * 255)));
        }
        result += `, ${Object(neuroglancer_util_float32_to_string__WEBPACK_IMPORTED_MODULE_1__["float32ToString"])(x[3])})`;
        return result;
    }
}
class TrackableRGB extends neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["WatchableValue"] {
    constructor(defaultValue) {
        super(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].clone(defaultValue));
        this.defaultValue = defaultValue;
    }
    toString() {
        return serializeColor(this.value);
    }
    toJSON() {
        if (neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].equals(this.value, this.defaultValue)) {
            return undefined;
        }
        else {
            return serializeColor(this.value);
        }
    }
    reset() {
        this.value = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].clone(this.defaultValue);
    }
    restoreState(x) {
        if (x === undefined) {
            this.reset();
            return;
        }
        const { value } = this;
        const newValue = parseRGBColorSpecification(x);
        if (!neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_2__["vec3"].equals(value, newValue)) {
            this.value = newValue;
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/colorspace.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/util/colorspace.ts ***!
  \*********************************************/
/*! exports provided: hsvToRgb, rgbToHsv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsvToRgb", function() { return hsvToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbToHsv", function() { return rgbToHsv; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Converts an HSV color (with h, s, v in [0,1]) to RGB (in range [0,1]).
 *
 * Based on goog/color/color.js in the Google Closure library.
 */
function hsvToRgb(out, h, s, v) {
    h *= 6;
    let hueIndex = Math.floor(h);
    let remainder = h - hueIndex;
    let val1 = v * (1 - s);
    let val2 = v * (1 - (s * remainder));
    let val3 = v * (1 - (s * (1 - remainder)));
    switch (hueIndex % 6) {
        case 0:
            out[0] = v;
            out[1] = val3;
            out[2] = val1;
            break;
        case 1:
            out[0] = val2;
            out[1] = v;
            out[2] = val1;
            break;
        case 2:
            out[0] = val1;
            out[1] = v;
            out[2] = val3;
            break;
        case 3:
            out[0] = val1;
            out[1] = val2;
            out[2] = v;
            break;
        case 4:
            out[0] = val3;
            out[1] = val1;
            out[2] = v;
            break;
        case 5:
            out[0] = v;
            out[1] = val1;
            out[2] = val2;
            break;
    }
    return out;
}
/**
 * Converts from RGB values (with r,g,b in range [0,1]) to an array of HSV values (in range [0, 1])
 *
 * Based on goog/color/color.js in the Google Closure library.
 */
function rgbToHsv(out, r, g, b) {
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    out[2] = max;
    if (min === max) {
        out[0] = 0;
        out[1] = 0;
    }
    else {
        const delta = (max - min);
        out[1] = delta / max;
        if (r === max) {
            out[0] = (g - b) / delta;
        }
        else if (g === max) {
            out[0] = 2 + ((b - r) / delta);
        }
        else {
            out[0] = 4 + ((r - g) / delta);
        }
        out[0] /= 6.0;
        if (out[0] < 0.0) {
            out[0] += 1.0;
        }
        if (out[0] > 1.0) {
            out[0] -= 1.0;
        }
    }
    return out;
}
;


/***/ }),

/***/ "./src/neuroglancer/util/compare.ts":
/*!******************************************!*\
  !*** ./src/neuroglancer/util/compare.ts ***!
  \******************************************/
/*! exports provided: approxEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "approxEqual", function() { return approxEqual; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function approxEqual(a, b) {
    if (a === b) {
        return true;
    }
    return (Math.abs(a - b) / Math.min(Math.abs(a), Math.abs(b)) < 1e-6);
}


/***/ }),

/***/ "./src/neuroglancer/util/completion.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/util/completion.ts ***!
  \*********************************************/
/*! exports provided: applyCompletionOffset, getPrefixMatches, getPrefixMatchesWithDescriptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyCompletionOffset", function() { return applyCompletionOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrefixMatches", function() { return getPrefixMatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrefixMatchesWithDescriptions", function() { return getPrefixMatchesWithDescriptions; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function applyCompletionOffset(offset, completionResult) {
    completionResult.offset += offset;
    return completionResult;
}
function getPrefixMatches(prefix, options) {
    let result = [];
    for (let option of options) {
        if (option.startsWith(prefix)) {
            result.push({ value: option });
        }
    }
    return result;
}
function getPrefixMatchesWithDescriptions(prefix, options, getValue, getDescription) {
    let result = [];
    for (let option of options) {
        let key = getValue(option);
        if (key.startsWith(prefix)) {
            result.push({ value: key, description: getDescription(option) });
        }
    }
    return result;
}


/***/ }),

/***/ "./src/neuroglancer/util/data_type.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/util/data_type.ts ***!
  \********************************************/
/*! exports provided: DataType, DATA_TYPE_BYTES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataType", function() { return DataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA_TYPE_BYTES", function() { return DATA_TYPE_BYTES; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * If this is updated, DATA_TYPE_BYTES must also be updated.
 */
var DataType;
(function (DataType) {
    DataType[DataType["UINT8"] = 0] = "UINT8";
    DataType[DataType["UINT16"] = 1] = "UINT16";
    DataType[DataType["UINT32"] = 2] = "UINT32";
    DataType[DataType["UINT64"] = 3] = "UINT64";
    DataType[DataType["FLOAT32"] = 4] = "FLOAT32";
})(DataType || (DataType = {}));
const DATA_TYPE_BYTES = [];
DATA_TYPE_BYTES[DataType.UINT8] = 1;
DATA_TYPE_BYTES[DataType.UINT16] = 2;
DATA_TYPE_BYTES[DataType.UINT32] = 4;
DATA_TYPE_BYTES[DataType.UINT64] = 8;
DATA_TYPE_BYTES[DataType.FLOAT32] = 4;


/***/ }),

/***/ "./src/neuroglancer/util/disjoint_sets.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/util/disjoint_sets.ts ***!
  \************************************************/
/*! exports provided: DisjointUint64Sets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisjointUint64Sets", function() { return DisjointUint64Sets; });
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const rankSymbol = Symbol('disjoint_sets:rank');
const parentSymbol = Symbol('disjoint_sets:parent');
const nextSymbol = Symbol('disjoint_sets:next');
const prevSymbol = Symbol('disjoint_sets:prev');
function findRepresentative(v) {
    // First pass: find the root, which will be stored in ancestor.
    let old = v;
    let ancestor = v[parentSymbol];
    while (ancestor !== v) {
        v = ancestor;
        ancestor = v[parentSymbol];
    }
    // Second pass: set all of the parent pointers along the path from the
    // original element `old' to refer directly to the root `ancestor'.
    v = old[parentSymbol];
    while (ancestor !== v) {
        old[parentSymbol] = ancestor;
        old = v;
        v = old[parentSymbol];
    }
    return ancestor;
}
function linkUnequalSetRepresentatives(i, j) {
    let iRank = i[rankSymbol];
    let jRank = j[rankSymbol];
    if (iRank > jRank) {
        j[parentSymbol] = i;
        return i;
    }
    i[parentSymbol] = j;
    if (iRank === jRank) {
        j[rankSymbol] = jRank + 1;
    }
    return j;
}
function spliceCircularLists(i, j) {
    let iPrev = i[prevSymbol];
    let jPrev = j[prevSymbol];
    // Connect end of i to beginning of j.
    j[prevSymbol] = iPrev;
    iPrev[nextSymbol] = j;
    // Connect end of j to beginning of i.
    i[prevSymbol] = jPrev;
    jPrev[nextSymbol] = i;
}
function* setElementIterator(i) {
    let j = i;
    do {
        yield j;
        j = j[nextSymbol];
    } while (j !== i);
}
function initializeElement(v) {
    v[parentSymbol] = v;
    v[rankSymbol] = 0;
    v[nextSymbol] = v[prevSymbol] = v;
}
const minSymbol = Symbol('disjoint_sets:min');
function isRootElement(v) {
    return v[parentSymbol] === v;
}
/**
 * Represents a collection of disjoint sets of Uint64 values.
 *
 * Supports merging sets, retrieving the minimum Uint64 value contained in a set (the representative
 * value), and iterating over the elements contained in a set.
 */
class DisjointUint64Sets {
    constructor() {
        this.map = new Map();
        this.generation = 0;
    }
    get(x) {
        let key = x.toString();
        let element = this.map.get(key);
        if (element === undefined) {
            return x;
        }
        return findRepresentative(element)[minSymbol];
    }
    isMinElement(x) {
        let y = this.get(x);
        return (y === x || neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_0__["Uint64"].equal(y, x));
    }
    makeSet(x) {
        let key = x.toString();
        let { map } = this;
        let element = map.get(key);
        if (element === undefined) {
            element = x.clone();
            initializeElement(element);
            element[minSymbol] = element;
            map.set(key, element);
            return element;
        }
        return findRepresentative(element);
    }
    link(a, b) {
        a = this.makeSet(a);
        b = this.makeSet(b);
        if (a === b) {
            return false;
        }
        this.generation++;
        let newNode = linkUnequalSetRepresentatives(a, b);
        spliceCircularLists(a, b);
        let aMin = a[minSymbol];
        let bMin = b[minSymbol];
        newNode[minSymbol] = neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_0__["Uint64"].less(aMin, bMin) ? aMin : bMin;
        return true;
    }
    *setElements(a) {
        let key = a.toString();
        let element = this.map.get(key);
        if (element === undefined) {
            yield a;
        }
        else {
            yield* setElementIterator(element);
        }
    }
    clear() {
        let { map } = this;
        if (map.size === 0) {
            return false;
        }
        ++this.generation;
        map.clear();
        return true;
    }
    get size() {
        return this.map.size;
    }
    *mappings(temp = new Array(2)) {
        for (let element of this.map.values()) {
            temp[0] = element;
            temp[1] = findRepresentative(element)[minSymbol];
            yield temp;
        }
    }
    [Symbol.iterator]() {
        return this.mappings();
    }
    /**
     * Returns an array of arrays of strings, where the arrays contained in the outer array correspond
     * to the disjoint sets, and the strings are the base-10 string representations of the members of
     * each set.  The members are sorted in numerical order, and the sets are sorted in numerical
     * order of their smallest elements.
     */
    toJSON() {
        let sets = new Array();
        for (let element of this.map.values()) {
            if (isRootElement(element)) {
                let members = new Array();
                for (let member of setElementIterator(element)) {
                    members.push(member);
                }
                members.sort(neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_0__["Uint64"].compare);
                sets.push(members);
            }
        }
        sets.sort((a, b) => neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_0__["Uint64"].compare(a[0], b[0]));
        return sets.map(set => set.map(element => element.toString()));
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/disposable.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/util/disposable.ts ***!
  \*********************************************/
/*! exports provided: invokeDisposer, invokeDisposers, registerEventListener, RefCounted, RefCountedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invokeDisposer", function() { return invokeDisposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invokeDisposers", function() { return invokeDisposers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerEventListener", function() { return registerEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RefCounted", function() { return RefCounted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RefCountedValue", function() { return RefCountedValue; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function invokeDisposer(disposer) {
    if (typeof disposer === 'object') {
        disposer.dispose();
    }
    else {
        disposer();
    }
}
function invokeDisposers(disposers) {
    for (let i = disposers.length; i > 0; --i) {
        invokeDisposer(disposers[i - 1]);
    }
}
function registerEventListener(target, type, listener, options) {
    target.addEventListener(type, listener, options);
    return () => target.removeEventListener(type, listener, options);
}
class RefCounted {
    constructor() {
        this.refCount = 1;
    }
    addRef() {
        ++this.refCount;
        return this;
    }
    dispose() {
        if (--this.refCount !== 0) {
            return;
        }
        this.refCountReachedZero();
    }
    refCountReachedZero() {
        this.disposed();
        let { disposers } = this;
        if (disposers !== undefined) {
            invokeDisposers(disposers);
            this.disposers = undefined;
        }
        this.wasDisposed = true;
    }
    disposed() { }
    registerDisposer(f) {
        let { disposers } = this;
        if (disposers == null) {
            this.disposers = [f];
        }
        else {
            disposers.push(f);
        }
        return f;
    }
    unregisterDisposer(f) {
        let { disposers } = this;
        if (disposers != null) {
            let index = disposers.indexOf(f);
            if (index !== -1) {
                disposers.splice(index, 1);
            }
        }
        return f;
    }
    registerEventListener(target, type, listener, options) {
        this.registerDisposer(registerEventListener(target, type, listener, options));
    }
    registerCancellable(cancellable) {
        this.registerDisposer(() => {
            cancellable.cancel();
        });
        return cancellable;
    }
}
class RefCountedValue extends RefCounted {
    constructor(value) {
        super();
        this.value = value;
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/dom.ts":
/*!**************************************!*\
  !*** ./src/neuroglancer/util/dom.ts ***!
  \**************************************/
/*! exports provided: removeChildren, removeFromParent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChildren", function() { return removeChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromParent", function() { return removeFromParent; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function removeChildren(element) {
    while (true) {
        let child = element.firstElementChild;
        if (!child) {
            break;
        }
        element.removeChild(child);
    }
}
function removeFromParent(element) {
    let { parentElement } = element;
    if (parentElement) {
        parentElement.removeChild(element);
        return true;
    }
    return false;
}


/***/ }),

/***/ "./src/neuroglancer/util/drag_and_drop.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/util/drag_and_drop.ts ***!
  \************************************************/
/*! exports provided: encodeStringAsDragType, decodeStringFromDragType, encodeDragType, decodeParametersFromDragType, encodeParametersAsDragType, decodeParametersFromDragTypeList, setDropEffect, getDropEffect, preventDrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeStringAsDragType", function() { return encodeStringAsDragType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeStringFromDragType", function() { return decodeStringFromDragType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeDragType", function() { return encodeDragType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeParametersFromDragType", function() { return decodeParametersFromDragType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeParametersAsDragType", function() { return encodeParametersAsDragType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeParametersFromDragTypeList", function() { return decodeParametersFromDragTypeList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDropEffect", function() { return setDropEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDropEffect", function() { return getDropEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preventDrag", function() { return preventDrag; });
/* harmony import */ var neuroglancer_util_hex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/hex */ "./src/neuroglancer/util/hex.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for encoding arbitrary strings as HTML5 Drag-and-drop types.
 *
 * The HTML5 Drag and Drop mechanism provides a way of attaching a set of (string key -> string
 * value) mappings to a drag.  The keys can be retrieved by any target the drag passes over, while
 * the values can only be retrieved when the actual "drop" happens.  Therefore, any data that needs
 * to be available prior to the drop must be stored as a key.  Additionally, the key strings are
 * munged.  According to the spec
 * <https://dev.w3.org/html5/spec-preview/dnd.html#the-drag-data-store>, the keys are converted to
 * ASCII lowercase, which means that only ASCII uppercase letters are modified, and all other
 * Unicode characters are preserved.  However, Chrome 62 does not appear to follow the spec, and
 * munges other characters as well.  Therefore, we hex encode to be safe.
 */


function encodeStringAsDragType(s) {
    return Object(neuroglancer_util_hex__WEBPACK_IMPORTED_MODULE_0__["hexEncode"])(new TextEncoder().encode(s));
}
function decodeStringFromDragType(s) {
    return new TextDecoder().decode(Object(neuroglancer_util_hex__WEBPACK_IMPORTED_MODULE_0__["hexDecode"])(s));
}
function encodeDragType(prefix, parameters) {
    return prefix + encodeStringAsDragType(JSON.stringify(parameters));
}
function decodeParametersFromDragType(dragType, prefix) {
    if (!dragType.startsWith(prefix)) {
        return undefined;
    }
    try {
        const jsonString = decodeStringFromDragType(dragType.substring(prefix.length));
        return JSON.parse(jsonString);
    }
    catch (_a) {
        return undefined;
    }
}
function encodeParametersAsDragType(prefix, parameters) {
    return prefix + encodeStringAsDragType(JSON.stringify(parameters));
}
function decodeParametersFromDragTypeList(dragTypes, prefix) {
    for (const dragType of dragTypes) {
        const parameters = decodeParametersFromDragType(dragType, prefix);
        if (parameters !== undefined) {
            return { parameters, dragType };
        }
    }
    return undefined;
}
let savedDropEffect;
/**
 * On Chrome 62, the dataTransfer.dropEffect property is reset to 'none' when the 'drop' event is
 * dispatched.  As a workaround, we store it in a global variable.
 *
 * The alternative workaround of recomputing it in the 'drop' event handler is problematic for a
 * different reason: the computation may depend on the modifier key states, and on Firefox 52, these
 * key states are not set in the 'drop' event.
 */
function setDropEffect(event, dropEffect) {
    event.dataTransfer.dropEffect = dropEffect;
    savedDropEffect = dropEffect;
    return dropEffect;
}
function getDropEffect() {
    return savedDropEffect;
}
function preventDrag(element) {
    element.draggable = true;
    return Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["registerEventListener"])(element, 'dragstart', (event) => {
        event.stopPropagation();
        event.preventDefault();
    });
}


/***/ }),

/***/ "./src/neuroglancer/util/dropdown.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/util/dropdown.ts ***!
  \*******************************************/
/*! exports provided: positionDropdown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionDropdown", function() { return positionDropdown; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Utilities for positioning dropdown menus.
 */
function positionDropdown(dropdownElement, associatedElement, { horizontal = false, vertical = true, topMargin = 6, bottomMargin = 6, leftMargin = 6, rightMargin = 6, maxHeight = true, maxWidth = true } = {}) {
    let rect = associatedElement.getBoundingClientRect();
    if (horizontal) {
        let viewportWidth = dropdownElement.ownerDocument.documentElement.clientHeight;
        let distanceLeft = rect.right;
        let distanceRight = viewportWidth - rect.left;
        if (distanceLeft > distanceRight) {
            dropdownElement.style.left = '';
            dropdownElement.style.right = '0';
            if (maxWidth) {
                dropdownElement.style.maxWidth = (distanceLeft - leftMargin) + 'px';
            }
        }
        else {
            dropdownElement.style.right = '';
            dropdownElement.style.left = '0';
            if (maxWidth) {
                dropdownElement.style.maxWidth = (distanceRight - rightMargin) + 'px';
            }
        }
    }
    if (vertical) {
        let viewportHeight = dropdownElement.ownerDocument.documentElement.clientHeight;
        let distanceToTop = rect.top - topMargin;
        let distanceToBottom = viewportHeight - rect.bottom - bottomMargin;
        if (distanceToTop > distanceToBottom * 3) {
            dropdownElement.style.top = '';
            dropdownElement.style.bottom = '100%';
            if (maxHeight) {
                dropdownElement.style.maxHeight = distanceToTop + 'px';
            }
        }
        else {
            dropdownElement.style.top = '100%';
            dropdownElement.style.bottom = '';
            if (maxHeight) {
                dropdownElement.style.maxHeight = distanceToBottom + 'px';
            }
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/event_action_map.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/util/event_action_map.ts ***!
  \***************************************************/
/*! exports provided: Modifiers, getEventModifierMask, getStrokeIdentifier, normalizeEventAction, normalizeEventIdentifier, EventActionMap, dispatchEventAction, eventPhaseNames, dispatchEvent, dispatchEventWithModifiers, registerActionListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Modifiers", function() { return Modifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEventModifierMask", function() { return getEventModifierMask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStrokeIdentifier", function() { return getStrokeIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeEventAction", function() { return normalizeEventAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeEventIdentifier", function() { return normalizeEventIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventActionMap", function() { return EventActionMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatchEventAction", function() { return dispatchEventAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eventPhaseNames", function() { return eventPhaseNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatchEvent", function() { return dispatchEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispatchEventWithModifiers", function() { return dispatchEventWithModifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerActionListener", function() { return registerActionListener; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_hierarchical_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/hierarchical_map */ "./src/neuroglancer/util/hierarchical_map.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Modifiers;
(function (Modifiers) {
    Modifiers[Modifiers["CONTROL"] = 1] = "CONTROL";
    Modifiers[Modifiers["ALT"] = 2] = "ALT";
    Modifiers[Modifiers["META"] = 4] = "META";
    Modifiers[Modifiers["SHIFT"] = 8] = "SHIFT";
})(Modifiers || (Modifiers = {}));
function getEventModifierMask(event) {
    return (event.ctrlKey ? 1 /* CONTROL */ : 0) | (event.altKey ? 2 /* ALT */ : 0) |
        (event.metaKey ? 4 /* META */ : 0) | (event.shiftKey ? 8 /* SHIFT */ : 0);
}
function getStrokeIdentifier(keyName, modifiers) {
    let identifier = '';
    if (modifiers & 1 /* CONTROL */) {
        identifier += 'control+';
    }
    if (modifiers & 2 /* ALT */) {
        identifier += 'alt+';
    }
    if (modifiers & 4 /* META */) {
        identifier += 'meta+';
    }
    if (modifiers & 8 /* SHIFT */) {
        identifier += 'shift+';
    }
    identifier += keyName;
    return identifier;
}
function normalizeModifiersAndBaseIdentifier(identifier) {
    let parts = identifier.split('+');
    let keyName;
    let modifiers = 0;
    for (let part of parts) {
        switch (part) {
            case 'control':
                modifiers |= 1 /* CONTROL */;
                break;
            case 'alt':
                modifiers |= 2 /* ALT */;
                break;
            case 'meta':
                modifiers |= 4 /* META */;
                break;
            case 'shift':
                modifiers |= 8 /* SHIFT */;
                break;
            default:
                if (keyName === undefined) {
                    keyName = part;
                }
                else {
                    return undefined;
                }
        }
    }
    if (keyName === undefined) {
        return undefined;
    }
    return getStrokeIdentifier(keyName, modifiers);
}
/**
 * Normalizes an ActionOrEventAction into an EventAction.
 */
function normalizeEventAction(action) {
    if (typeof action === 'string') {
        return { action: action };
    }
    return action;
}
/**
 * Normalizes a user-specified EventIdentifier into a list of one or more corresponding
 * NormalizedEventIdentifier strings.
 */
function* normalizeEventIdentifier(identifier) {
    const firstColonOffset = identifier.indexOf(':');
    const suffix = normalizeModifiersAndBaseIdentifier(identifier.substring(firstColonOffset + 1));
    if (suffix === undefined) {
        throw new Error(`Invalid event identifier: ${JSON.stringify(identifier)}`);
    }
    if (firstColonOffset !== -1) {
        const prefix = identifier.substring(0, firstColonOffset);
        // TODO(jbms): Support capture phase.
        if (prefix !== 'at' && prefix !== 'bubble') {
            throw new Error(`Invalid event phase: ${JSON.stringify(prefix)}`);
        }
        yield `${prefix}:${suffix}`;
    }
    else {
        yield `at:${suffix}`;
        yield `bubble:${suffix}`;
    }
}
/**
 * Hierarchical map of `EventIdentifier` specifications to `EventAction` specifications.  These maps
 * are used by KeyboardEventBinder and MouseEventBinder to dispatch an ActionEvent in response to an
 * input event.
 */
class EventActionMap extends neuroglancer_util_hierarchical_map__WEBPACK_IMPORTED_MODULE_1__["HierarchicalMap"] {
    /**
     * Returns a new EventActionMap with the specified bindings.
     *
     * The keys of the `bindings` object specify unnormalized event identifiers to be mapped to their
     * corresponding `ActionOrEventAction` values.
     */
    static fromObject(bindings, options = {}) {
        const map = new EventActionMap();
        map.label = options.label;
        if (options.parents !== undefined) {
            for (const [parent, priority] of options.parents) {
                map.addParent(parent, priority);
            }
        }
        for (const key of Object.keys(bindings)) {
            map.set(key, normalizeEventAction(bindings[key]));
        }
        return map;
    }
    setFromObject(bindings) {
        for (const key of Object.keys(bindings)) {
            this.set(key, normalizeEventAction(bindings[key]));
        }
    }
    /**
     * Maps the specified event `identifier` to the specified `action`.
     *
     * The `identifier` may be unnormalized; the actual mapping is created for each corresponding
     * normalized identifier.
     */
    set(identifier, action) {
        const normalizedAction = normalizeEventAction(action);
        for (const normalizedIdentifier of normalizeEventIdentifier(identifier)) {
            super.set(normalizedIdentifier, normalizedAction);
        }
    }
    /**
     * Deletes the mapping for the specified `identifier`.
     *
     * The `identifier` may be unnormalized; the mapping is deleted for each corresponding normalized
     * identifier.
     */
    delete(identifier) {
        for (const normalizedIdentifier of normalizeEventIdentifier(identifier)) {
            super.delete(normalizedIdentifier);
        }
    }
    describe() {
        const bindings = [];
        const uniqueBindings = new Map();
        for (const [key, value] of this.entries()) {
            const split = key.indexOf(':');
            uniqueBindings.set(key.substring(split + 1), value.action);
        }
        for (const [key, value] of uniqueBindings) {
            bindings.push(`${key}${value}`);
        }
        return bindings.join(', ');
    }
}
function dispatchEventAction(originalEvent, detail, eventAction) {
    if (eventAction === undefined) {
        return;
    }
    if (eventAction.stopPropagation !== false) {
        originalEvent.stopPropagation();
    }
    const actionEvent = new CustomEvent('action:' + eventAction.action, { 'bubbles': true, detail: detail, cancelable: true });
    const cancelled = !originalEvent.target.dispatchEvent(actionEvent);
    if (eventAction.preventDefault !== false || cancelled) {
        originalEvent.preventDefault();
    }
}
const eventPhaseNames = [];
eventPhaseNames[Event.AT_TARGET] = 'at';
eventPhaseNames[Event.CAPTURING_PHASE] = 'capture';
eventPhaseNames[Event.BUBBLING_PHASE] = 'bubble';
function dispatchEvent(baseIdentifier, originalEvent, eventPhase, detail, eventMap) {
    const eventIdentifier = eventPhaseNames[eventPhase] + ':' + baseIdentifier;
    const eventAction = eventMap.get(eventIdentifier);
    dispatchEventAction(originalEvent, detail, eventAction);
}
function dispatchEventWithModifiers(baseIdentifier, originalEvent, detail, eventMap) {
    dispatchEvent(getStrokeIdentifier(baseIdentifier, getEventModifierMask(originalEvent)), originalEvent, originalEvent.eventPhase, detail, eventMap);
}
/**
 * Register an event listener for the specified `action`.
 *
 * There is no checking that the `TriggerEvent` type is suitable for use with the specified
 * `action`.
 *
 * @returns A nullary disposer function that unregisters the listener when called.
 */
function registerActionListener(target, action, listener, options) {
    return Object(neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["registerEventListener"])(target, `action:${action}`, listener, options);
}


/***/ }),

/***/ "./src/neuroglancer/util/float32_to_string.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/util/float32_to_string.ts ***!
  \****************************************************/
/*! exports provided: float32ToString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "float32ToString", function() { return float32ToString; });
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tempArray = new Float32Array(1);
/**
 * Converts `x` into its nearest single precision float representation and
 * returns a minimal string representation, with as many digits as necessary
 * to uniquely distinguish single precision `x` from its adjacent single
 * precision values.
 *
 * E.g.: 0.299999999000000017179701217174d  0.30000001192092896f  '0.3')
 */
function float32ToString(x) {
    tempArray[0] = x;
    x = tempArray[0];
    for (let digits = 1; digits < 21; ++digits) {
        let result = x.toPrecision(digits);
        tempArray[0] = parseFloat(result);
        if (tempArray[0] === x) {
            return result;
        }
    }
    return x.toString();
}


/***/ }),

/***/ "./src/neuroglancer/util/geom.ts":
/*!***************************************!*\
  !*** ./src/neuroglancer/util/geom.ts ***!
  \***************************************/
/*! exports provided: mat2, mat3, mat4, quat, vec2, vec3, vec4, identityMat4, AXES_NAMES, BoundingBox, kAxes, kZeroVec, kOneVec, kInfinityVec, kIdentityQuat, prod3, prod4, vec3Key, rectifyVec3IfAxisAligned, rectifyTransformMatrixIfAxisAligned, quatRotateX180, quatRotateY180, quatRotateZ180, transformVectorByMat4, effectiveScalingFactorFromMat4, translationRotationScaleZReflectionToMat4, findClosestParameterizedLinePosition, projectPointToLineSegment, mat3FromMat4, getFrustrumPlanes, isAABBVisible */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identityMat4", function() { return identityMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXES_NAMES", function() { return AXES_NAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return BoundingBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kAxes", function() { return kAxes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kZeroVec", function() { return kZeroVec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kOneVec", function() { return kOneVec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kInfinityVec", function() { return kInfinityVec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kIdentityQuat", function() { return kIdentityQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod3", function() { return prod3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod4", function() { return prod4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3Key", function() { return vec3Key; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rectifyVec3IfAxisAligned", function() { return rectifyVec3IfAxisAligned; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rectifyTransformMatrixIfAxisAligned", function() { return rectifyTransformMatrixIfAxisAligned; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quatRotateX180", function() { return quatRotateX180; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quatRotateY180", function() { return quatRotateY180; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quatRotateZ180", function() { return quatRotateZ180; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformVectorByMat4", function() { return transformVectorByMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "effectiveScalingFactorFromMat4", function() { return effectiveScalingFactorFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translationRotationScaleZReflectionToMat4", function() { return translationRotationScaleZReflectionToMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findClosestParameterizedLinePosition", function() { return findClosestParameterizedLinePosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectPointToLineSegment", function() { return projectPointToLineSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat3FromMat4", function() { return mat3FromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFrustrumPlanes", function() { return getFrustrumPlanes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAABBVisible", function() { return isAABBVisible; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"]; });

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const identityMat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
const AXES_NAMES = ['x', 'y', 'z'];
class BoundingBox {
    constructor(lower, upper) {
        this.lower = lower;
        this.upper = upper;
    }
}
const kAxes = [
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(1, 0, 0),
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0, 1, 0),
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0, 0, 1),
];
const kZeroVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0, 0, 0);
const kOneVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(1, 1, 1);
const kInfinityVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(Infinity, Infinity, Infinity);
const kIdentityQuat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
function prod3(x) {
    return x[0] * x[1] * x[2];
}
function prod4(x) {
    return x[0] * x[1] * x[2] * x[3];
}
/**
 * Implements a one-to-one conversion from Vec3 to string, suitable for use a Map key.
 *
 * Specifically, returns the string representation of the 3 values separated by commas.
 */
function vec3Key(x) {
    return `${x[0]},${x[1]},${x[2]}`;
}
const RECTIFY_EPSILON = 1e-4;
function rectifyVec3IfAxisAligned(v, offset) {
    let a0 = Math.abs(v[offset]), a1 = Math.abs(v[offset + 1]), a2 = Math.abs(v[offset + 2]);
    let max = Math.max(a0, a1, a2);
    if (a0 / max < RECTIFY_EPSILON) {
        v[offset] = 0;
    }
    if (a1 / max < RECTIFY_EPSILON) {
        v[offset + 1] = 0;
    }
    if (a2 / max < RECTIFY_EPSILON) {
        v[offset + 2] = 0;
    }
}
/**
 * Makes columns of m that are approximately axis-aligned exactly axis aligned.
 *
 * Note that mat is stored in Fortran order, and therefore the first column is m[0], m[1], m[2].
 */
function rectifyTransformMatrixIfAxisAligned(m) {
    rectifyVec3IfAxisAligned(m, 0);
    rectifyVec3IfAxisAligned(m, 4);
    rectifyVec3IfAxisAligned(m, 8);
}
/**
 * Transforms `a` by a 180-degree rotation about X, stores result in `out`.
 */
function quatRotateX180(out, a) {
    let x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = w;
    out[1] = z;
    out[2] = -y;
    out[3] = -x;
}
/**
 * Transforms `a` by a 180-degree rotation about Y, stores result in `out`.
 */
function quatRotateY180(out, a) {
    let x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = -z;
    out[1] = w;
    out[2] = x;
    out[3] = -y;
}
/**
 * Transforms `a` by a 180-degree rotation about Z, stores result in `out`.
 */
function quatRotateZ180(out, a) {
    let x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = y;
    out[1] = -x;
    out[2] = w;
    out[3] = -z;
}
/**
 * Transforms a vector `a` by a homogenous transformation matrix `m`.  The translation component of
 * `m` is ignored.
 */
function transformVectorByMat4(out, a, m) {
    let x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z;
    out[1] = m[1] * x + m[5] * y + m[9] * z;
    out[2] = m[2] * x + m[6] * y + m[10] * z;
    return out;
}
/**
 * Computes the effective scaling factor of each local spatial dimension by `m`, which is assumed to
 * transform local coordinates to global coordinates.
 */
function effectiveScalingFactorFromMat4(out, m) {
    const m0 = m[0], m1 = m[1], m2 = m[2], m4 = m[4], m5 = m[5], m6 = m[6], m8 = m[8], m9 = m[9], m10 = m[10];
    out[0] = Math.sqrt(m0 * m0 + m1 * m1 + m2 * m2);
    out[1] = Math.sqrt(m4 * m4 + m5 * m5 + m6 * m6);
    out[2] = Math.sqrt(m8 * m8 + m9 * m9 + m10 * m10);
    return out;
}
function translationRotationScaleZReflectionToMat4(out, translation, rotation, scale, zReflection) {
    const temp = out;
    out[0] = scale[0];
    out[1] = scale[1];
    out[2] = scale[2] * zReflection;
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromRotationTranslationScale(out, rotation, translation, temp);
}
/**
 * Returns the value of `t` that minimizes `(p - (a + t * (b - a)))`.
 */
function findClosestParameterizedLinePosition(a, b, p) {
    // http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
    // Compute t: -dot(a-p, b-a) / |b - a|^2
    const denominator = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].squaredDistance(a, b);
    let numerator = 0;
    for (let i = 0; i < 3; ++i) {
        const aValue = a[i];
        numerator -= (aValue - p[i]) * (b[i] - aValue);
    }
    return numerator / Math.max(denominator, 1e-6);
}
/**
 * Sets `out` to the position on the line segment `[a, b]` closest to `p`.
 */
function projectPointToLineSegment(out, a, b, p) {
    let t = findClosestParameterizedLinePosition(a, b, p);
    t = Math.max(0.0, Math.min(1.0, t));
    for (let i = 0; i < 3; ++i) {
        const aValue = a[i];
        out[i] = aValue + t * (b[i] - aValue);
    }
    return out;
}
function mat3FromMat4(out, m) {
    const m00 = m[0], m01 = m[1], m02 = m[2], m10 = m[4], m11 = m[5], m12 = m[6], m20 = m[8], m21 = m[9], m22 = m[10];
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
/**
 * Extracts the left, right, bottom, top, near, far clipping planes from `projectionMat`.
 * @param out Row-major array of shape `(6, 4)` specifying for each of the left, right, bottom, top,
 *     near, far clipping planes the `a`, `b`, `c`, `d` coefficients such that
 *     `0 < a * x + b * y + c * z + d` if the point `x, y, z` is inside the half-space of the
 * clipping plane.
 * @param m Projection matrix
 */
function getFrustrumPlanes(out, m) {
    // http://web.archive.org/web/20120531231005/http://crazyjoke.free.fr/doc/3D/plane%20extraction.pdf
    const m00 = m[0], m10 = m[1], m20 = m[2], m30 = m[3], m01 = m[4], m11 = m[5], m21 = m[6], m31 = m[7], m02 = m[8], m12 = m[9], m22 = m[10], m32 = m[11], m03 = m[12], m13 = m[13], m23 = m[14], m33 = m[15];
    out[0] = m30 + m00; // left: a
    out[1] = m31 + m01; // left: b
    out[2] = m32 + m02; // left: c
    out[3] = m33 + m03; // left: d
    out[4] = m30 - m00; // right: a
    out[5] = m31 - m01; // right: b
    out[6] = m32 - m02; // right: c
    out[7] = m33 - m03; // right: d
    out[8] = m30 + m10; // bottom: a
    out[9] = m31 + m11; // bottom: b
    out[10] = m32 + m12; // bottom: c
    out[11] = m33 + m13; // bottom: d
    out[12] = m30 - m10; // top: a
    out[13] = m31 - m11; // top: b
    out[14] = m32 - m12; // top: c
    out[15] = m33 - m13; // top: d
    const nearA = m30 + m20; // near: a
    const nearB = m31 + m21; // near: b
    const nearC = m32 + m22; // near: c
    const nearD = m33 + m23; // near: d
    // Normalize near plane
    const nearNorm = Math.sqrt(nearA ** 2 + nearB ** 2 + nearC ** 2);
    out[16] = nearA / nearNorm;
    out[17] = nearB / nearNorm;
    out[18] = nearC / nearNorm;
    out[19] = nearD / nearNorm;
    out[20] = m30 - m20; // far: a
    out[21] = m31 - m21; // far: b
    out[22] = m32 - m22; // far: c
    out[23] = m33 - m23; // far: d
    return out;
}
/**
 * Checks whether the specified axis-aligned bounding box (AABB) intersects the view frustrum.
 *
 * @param clippingPlanes Array of length 24 specifying the clipping planes of the view frustrum, as
 *     computed by `getFrustrumPlanes`
 */
function isAABBVisible(xLower, yLower, zLower, xUpper, yUpper, zUpper, clippingPlanes) {
    for (let i = 0; i < 6; ++i) {
        const a = clippingPlanes[i * 4], b = clippingPlanes[i * 4 + 1], c = clippingPlanes[i * 4 + 2], d = clippingPlanes[i * 4 + 3];
        const sum = Math.max(a * xLower, a * xUpper) + Math.max(b * yLower, b * yUpper) +
            Math.max(c * zLower, c * zUpper) + d;
        if (sum < 0) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./src/neuroglancer/util/google_oauth2.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/util/google_oauth2.ts ***!
  \************************************************/
/*! exports provided: AUTH_SERVER, embedRelayFrame, authenticateGoogleOAuth2, GoogleOAuth2CredentialsProvider, fetchWithGoogleCredentials */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTH_SERVER", function() { return AUTH_SERVER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "embedRelayFrame", function() { return embedRelayFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "authenticateGoogleOAuth2", function() { return authenticateGoogleOAuth2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GoogleOAuth2CredentialsProvider", function() { return GoogleOAuth2CredentialsProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchWithGoogleCredentials", function() { return fetchWithGoogleCredentials; });
/* harmony import */ var neuroglancer_credentials_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/credentials_provider */ "./src/neuroglancer/credentials_provider/index.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/random */ "./src/neuroglancer/util/random.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







const AUTH_SERVER = 'https://accounts.google.com/o/oauth2/auth';
const AUTH_ORIGIN = 'https://accounts.google.com';
function embedRelayFrame(proxyName, rpcToken) {
    let iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    iframe.id = proxyName;
    iframe.name = proxyName;
    const origin = location.origin;
    iframe.src = `https://accounts.google.com/o/oauth2/postmessageRelay?` +
        `parent=${encodeURIComponent(origin)}#rpctoken=${rpcToken}`;
    document.body.appendChild(iframe);
}
class PendingRequest {
    constructor() {
        this.finished = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_6__["Signal"]();
    }
}
class AuthHandler {
    constructor() {
        this.proxyName = `postmessageRelay${Object(neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_5__["getRandomHexString"])()}`;
        this.rpcToken = `${Object(neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_5__["getRandomHexString"])()}`;
        this.relayReadyService = `oauth2relayReady:${this.rpcToken}`;
        this.oauth2CallbackService = `oauth2callback:${this.rpcToken}`;
        this.pendingRequests = new Map();
        embedRelayFrame(this.proxyName, this.rpcToken);
        this.relayReadyPromise = new Promise((relayReadyPromiseResolve) => {
            addEventListener('message', (event) => {
                if (event.origin !== AUTH_ORIGIN) {
                    return;
                }
                try {
                    let data = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyObject"])(JSON.parse(event.data));
                    let service = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyString"])(data['s']);
                    if (service === this.relayReadyService) {
                        relayReadyPromiseResolve();
                    }
                    if (service === this.oauth2CallbackService) {
                        let args = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["parseArray"])(data['a'], x => x);
                        let arg = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_4__["verifyString"])(args[0]);
                        let origin = location.origin;
                        if (!arg.startsWith(origin + '#') && !arg.startsWith(origin + '?')) {
                            throw new Error(`oauth2callback: URL ${JSON.stringify(arg)} ` +
                                `does not match current origin ${origin}.`);
                        }
                        let hashPart = arg.substring(origin.length + 1);
                        let parts = hashPart.split('&');
                        let params = new Map();
                        for (let part of parts) {
                            let match = part.match('^([a-z_]+)=(.*)$');
                            if (match === null) {
                                throw new Error(`oauth2callback: URL part ${JSON.stringify(match)} ` +
                                    `does not match expected pattern.`);
                            }
                            params.set(match[1], match[2]);
                        }
                        let state = params.get('state');
                        if (state === undefined) {
                            throw new Error(`oauth2callback: State argument is missing.`);
                        }
                        let request = this.pendingRequests.get(state);
                        if (request === undefined) {
                            // Request may have been cancelled.
                            return;
                        }
                        let error = params.get('error');
                        if (error !== undefined) {
                            let errorSubtype = params.get('error_subtype');
                            let fullMessage = error;
                            if (errorSubtype !== undefined) {
                                fullMessage += ': ' + errorSubtype;
                            }
                            request.finished.dispatch(undefined, new Error(`Error obtaining Google OAuth2 token: ${fullMessage}`));
                            return;
                        }
                        let accessToken = params.get('access_token');
                        let tokenType = params.get('token_type');
                        let expiresIn = params.get('expires_in');
                        let scope = params.get('scope');
                        if (accessToken === undefined || tokenType === undefined || expiresIn === undefined ||
                            scope === undefined) {
                            throw new Error(`oauth2callback: URL lacks expected parameters.`);
                        }
                        request.finished.dispatch({
                            accessToken: accessToken,
                            tokenType: tokenType,
                            expiresIn: expiresIn,
                            scope: scope
                        });
                        return;
                    }
                }
                catch (parseError) {
                    throw new Error(`Invalid message received from ${AUTH_ORIGIN}: ${JSON.stringify(event.data)}: ` +
                        `${parseError.message}.`);
                }
            });
        });
    }
    addPendingRequest(state) {
        let request = new PendingRequest();
        this.pendingRequests.set(state, request);
        request.finished.add(() => {
            this.pendingRequests.delete(state);
        });
        return request;
    }
    makeAuthRequestUrl(options) {
        let url = `${AUTH_SERVER}?client_id=${encodeURIComponent(options.clientId)}`;
        url += `&redirect_uri=postmessage`;
        url += `&response_type=token`;
        let { origin = location.origin } = options;
        url += `&origin=${encodeURIComponent(origin)}`;
        url += `&proxy=${this.proxyName}`;
        url += `&include_granted_scopes=true`;
        url += `&scope=${encodeURIComponent(options.scopes.join(' '))}`;
        if (options.state) {
            url += `&state=${options.state}`;
        }
        if (options.approvalPrompt) {
            url += `&approval_prompt=${encodeURIComponent(options.approvalPrompt)}`;
        }
        if (options.loginHint) {
            url += `&login_hint=${encodeURIComponent(options.loginHint)}`;
        }
        if (options.immediate) {
            url += `&immediate=true`;
        }
        if (options.authUser !== undefined) {
            url += `&authuser=${options.authUser}`;
        }
        return url;
    }
}
let authHandlerInstance;
function authHandler() {
    if (authHandlerInstance === undefined) {
        authHandlerInstance = new AuthHandler();
    }
    return authHandlerInstance;
}
/**
 * Obtain a Google OAuth2 authentication token.
 * @return A Promise that resolves to an authentication token.
 */
function authenticateGoogleOAuth2(options, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__["uncancelableToken"]) {
    const state = Object(neuroglancer_util_random__WEBPACK_IMPORTED_MODULE_5__["getRandomHexString"])();
    const handler = authHandler();
    const url = handler.makeAuthRequestUrl({
        state,
        clientId: options.clientId,
        scopes: options.scopes,
        approvalPrompt: options.approvalPrompt,
        loginHint: options.loginHint,
        immediate: options.immediate,
        authUser: options.authUser,
    });
    const request = handler.addPendingRequest(state);
    const promise = new Promise((resolve, reject) => {
        request.finished.add((token, error) => {
            if (token !== undefined) {
                resolve(token);
            }
            else {
                reject(error);
            }
        });
    });
    request.finished.add(cancellationToken.add(() => {
        request.finished.dispatch(undefined, neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__["CANCELED"]);
    }));
    if (options.immediate) {
        // For immediate mode auth, we can wait until the relay is ready, since we aren't opening a new
        // window.
        handler.relayReadyPromise.then(() => {
            if (cancellationToken.isCanceled) {
                return;
            }
            const iframe = document.createElement('iframe');
            iframe.src = url;
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            request.finished.add(() => {
                Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_3__["removeFromParent"])(iframe);
            });
        });
    }
    else {
        if (!cancellationToken.isCanceled) {
            const newWindow = open(url);
            if (newWindow !== null) {
                request.finished.add(() => {
                    newWindow.close();
                });
            }
        }
    }
    return promise;
}
class GoogleOAuth2CredentialsProvider extends neuroglancer_credentials_provider__WEBPACK_IMPORTED_MODULE_0__["CredentialsProvider"] {
    constructor(options) {
        super();
        this.options = options;
        this.get = Object(neuroglancer_credentials_provider__WEBPACK_IMPORTED_MODULE_0__["makeCredentialsGetter"])(cancellationToken => {
            const { options } = this;
            const status = new neuroglancer_status__WEBPACK_IMPORTED_MODULE_1__["StatusMessage"](/*delay=*/ true);
            let cancellationSource;
            return new Promise((resolve, reject) => {
                const dispose = () => {
                    cancellationSource = undefined;
                    status.dispose();
                };
                cancellationToken.add(() => {
                    if (cancellationSource !== undefined) {
                        cancellationSource.cancel();
                        cancellationSource = undefined;
                        status.dispose();
                        reject(neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__["CANCELED"]);
                    }
                });
                function writeLoginStatus(msg = `${options.description} authorization required.`, linkMessage = 'Request authorization.') {
                    status.setText(msg + '  ');
                    let button = document.createElement('button');
                    button.textContent = linkMessage;
                    status.element.appendChild(button);
                    button.addEventListener('click', () => {
                        login(/*immediate=*/ false);
                    });
                    status.setVisible(true);
                }
                function login(immediate) {
                    if (cancellationSource !== undefined) {
                        cancellationSource.cancel();
                    }
                    cancellationSource = new neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_2__["CancellationTokenSource"]();
                    writeLoginStatus(`Waiting for ${options.description} authorization...`, 'Retry');
                    authenticateGoogleOAuth2({
                        clientId: options.clientId,
                        scopes: options.scopes,
                        immediate: immediate,
                        authUser: 0,
                    }, cancellationSource)
                        .then(token => {
                        if (cancellationSource !== undefined) {
                            dispose();
                            resolve(token);
                        }
                    }, reason => {
                        if (cancellationSource !== undefined) {
                            cancellationSource = undefined;
                            if (immediate) {
                                writeLoginStatus();
                            }
                            else {
                                writeLoginStatus(`${options.description} authorization failed: ${reason}.`, 'Retry');
                            }
                        }
                    });
                }
                login(/*immediate=*/ true);
            });
        });
    }
}
function fetchWithGoogleCredentials(credentialsProvider, input, init = {}) {
    function start(credentials) {
        const token = credentials.credentials;
        const headers = new Headers(init.headers);
        headers.append('Authorization', `${token.tokenType} ${token.accessToken}`);
        return fetch(input, Object.assign({}, init, { mode: 'cors', headers })).then(response => {
            if (response.status === 401) {
                // 401: Authorization needed.  OAuth2 token may have expired.
                return credentialsProvider.get(credentials).then(start);
            }
            return response;
        });
    }
    const promise = credentialsProvider.get(/*invalidToken=*/ undefined).then(start);
    const disposeRef = () => {
        credentialsProvider.dispose();
    };
    promise.then(disposeRef, disposeRef);
    return promise;
}


/***/ }),

/***/ "./src/neuroglancer/util/hex.ts":
/*!**************************************!*\
  !*** ./src/neuroglancer/util/hex.ts ***!
  \**************************************/
/*! exports provided: hexEncodeByte, hexEncode, hexDecode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexEncodeByte", function() { return hexEncodeByte; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexEncode", function() { return hexEncode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexDecode", function() { return hexDecode; });
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hexEncodeByte(x) {
    return ('0' + x.toString(16)).slice(-2);
}
function hexEncode(arr) {
    return Array.prototype.map.call(arr, hexEncodeByte).join('');
}
function hexDecode(x) {
    if (!/^(?:[0-9a-fA-F]{2})*$/.test(x)) {
        throw new Error('Invalid hex-encoded string');
    }
    const length = x.length / 2;
    const result = new Uint8Array(length);
    for (let i = 0; i < length; ++i) {
        result[i] = parseInt(x.substr(i * 2, 2), 16);
    }
    return result;
}


/***/ }),

/***/ "./src/neuroglancer/util/hierarchical_map.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/util/hierarchical_map.ts ***!
  \***************************************************/
/*! exports provided: HierarchicalMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HierarchicalMap", function() { return HierarchicalMap; });
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Maps string event identifiers to string action identifiers.
 *
 * When an event identifier is looked up in a given HierarchicalMap, it is resolved to a
 * corresponding action identifier in one of two ways:
 *
 * 1. via mappings defined directly on the HierarchicalMap.
 *
 * 2. via a recursive lookup on a "parent" HierarchicalMap that has been specified for the root
 *    HierarchicalMap on which the lookup was initiated.
 *
 * HierarchicalMap objects may be specified as "parents" of another HierarchicalMap along with a
 * specified numerical priority value, such that there is a directed graph of HierarchicalMap
 * objects.  Cycles in this graph may lead to infinite looping.
 *
 * Recursive lookups in parent HierarchicalMap objects are performed in order of decreasing
 * priority. The lookup stops as soon as a mapping is found.  Direct bindings have a priority of 0.
 * Therefore, parent maps with a priority higher than 0 take precedence over direct bindings.
 */
class HierarchicalMap {
    /**
     * If an existing HierarchicalMap is specified, a shallow copy is made.
     *
     * @param existing Existing map to make a shallow copy of.
     */
    constructor(existing) {
        this.parents = new Array();
        this.parentPriorities = new Array();
        this.bindings = new Map();
        if (existing !== undefined) {
            this.parents.push(...existing.parents);
            this.parentPriorities.push(...existing.parentPriorities);
            for (const [k, v] of existing.bindings) {
                this.bindings.set(k, v);
            }
        }
    }
    /**
     * Register `parent` as a parent map.  If `priority > 0`, this map will take precedence over
     * direct bindings.
     *
     * @returns A nullary function that unregisters the parent (and may be called at most once).
     */
    addParent(parent, priority) {
        const { parents, parentPriorities } = this;
        let index = 0;
        const { length } = parents;
        while (index < length && priority < parentPriorities[index]) {
            ++index;
        }
        parents.splice(index, 0, parent);
        parentPriorities.splice(index, 0, priority);
        return () => {
            this.removeParent(parent);
        };
    }
    /**
     * Unregisters `parent` as a parent.
     */
    removeParent(parent) {
        const index = this.parents.indexOf(parent);
        if (index === -1) {
            throw new Error(`Attempt to remove non-existent parent map.`);
        }
        this.parents.splice(index, 1);
        this.parentPriorities.splice(index, 1);
    }
    /**
     * Register a direct binding.
     */
    set(key, value) {
        this.bindings.set(key, value);
    }
    /**
     * Unregister a direct binding.
     */
    delete(key) {
        this.bindings.delete(key);
    }
    /**
     * Deletes all bindings, including parents.
     */
    clear() {
        this.bindings.clear();
        this.parents.length = 0;
        this.parentPriorities.length = 0;
    }
    /**
     * Lookup the highest priority value to which the specified key is mapped.
     */
    get(key) {
        const { parents, parentPriorities } = this;
        const numParents = parentPriorities.length;
        let parentIndex = 0;
        let value;
        for (; parentIndex < numParents && parentPriorities[parentIndex] > 0; ++parentIndex) {
            value = parents[parentIndex].get(key);
            if (value !== undefined) {
                return value;
            }
        }
        value = this.bindings.get(key);
        if (value !== undefined) {
            return value;
        }
        for (; parentIndex < numParents; ++parentIndex) {
            value = parents[parentIndex].get(key);
            if (value !== undefined) {
                return value;
            }
        }
        return undefined;
    }
    /**
     * Find all values to which the specified key is mapped.
     */
    *getAll(key) {
        const { parents, parentPriorities } = this;
        const numParents = parentPriorities.length;
        let parentIndex = 0;
        let value;
        while (parentIndex < numParents && parentPriorities[parentIndex] > 0) {
            value = parents[parentIndex].get(key);
            if (value !== undefined) {
                yield value;
            }
        }
        value = this.bindings.get(key);
        if (value !== undefined) {
            yield value;
        }
        while (parentIndex < numParents) {
            value = parents[parentIndex].get(key);
            if (value !== undefined) {
                yield value;
            }
        }
    }
    *entries() {
        const { parents, parentPriorities } = this;
        const numParents = parentPriorities.length;
        let parentIndex = 0;
        while (parentIndex < numParents && parentPriorities[parentIndex] > 0) {
            yield* parents[parentIndex].entries();
        }
        yield* this.bindings.entries();
        while (parentIndex < numParents) {
            yield* parents[parentIndex].entries();
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/http_request.ts":
/*!***********************************************!*\
  !*** ./src/neuroglancer/util/http_request.ts ***!
  \***********************************************/
/*! exports provided: HttpError, fetchOk, responseArrayBuffer, responseJson, cancellableFetchOk, getByteRangeHeader, parseSpecialUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpError", function() { return HttpError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchOk", function() { return fetchOk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "responseArrayBuffer", function() { return responseArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "responseJson", function() { return responseJson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancellableFetchOk", function() { return cancellableFetchOk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getByteRangeHeader", function() { return getByteRangeHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSpecialUrl", function() { return parseSpecialUrl; });
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class HttpError extends Error {
    constructor(url, status, statusText) {
        let message = `Fetching ${JSON.stringify(url)} resulted in HTTP error ${status}`;
        if (statusText) {
            message += `: ${statusText}`;
        }
        message += '.';
        super(message);
        this.name = 'HttpError';
        this.message = message;
        this.url = url;
        this.status = status;
        this.statusText = statusText;
    }
    static fromResponse(response) {
        return new HttpError(response.url, response.status, response.statusText);
    }
}
/**
 * Issues a `fetch` request.
 *
 * If the request fails due to an HTTP status outside `[200, 300)`, throws an `HttpError`.  If the
 * request fails due to a network or CORS restriction, throws an `HttpError` with a `status` of `0`.
 */
async function fetchOk(input, init) {
    let response;
    try {
        response = await fetch(input, init);
    }
    catch (error) {
        if (error instanceof TypeError) {
            throw new HttpError('', 0, '');
        }
        throw error;
    }
    if (!response.ok)
        throw HttpError.fromResponse(response);
    return response;
}
function responseArrayBuffer(response) {
    return response.arrayBuffer();
}
function responseJson(response) {
    return response.json();
}
/**
 * Issues a `fetch` request in the same way as `fetchOk`, and returns the result of the promise
 * returned by `transformResponse`.
 *
 * Additionally, the request may be cancelled through `cancellationToken`.
 *
 * The `transformResponse` function should not do anything with the `Response` object after its
 * result becomes ready; otherwise, cancellation may not work as expected.
 */
async function cancellableFetchOk(input, init, transformResponse, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"]) {
    if (cancellationToken === neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"]) {
        const response = await fetchOk(input, init);
        return await transformResponse(response);
    }
    const abortController = new AbortController();
    const unregisterCancellation = cancellationToken.add(() => abortController.abort());
    try {
        const response = await fetchOk(input, init);
        return await transformResponse(response);
    }
    finally {
        unregisterCancellation();
    }
}
const tempUint64 = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_1__["Uint64"]();
function getByteRangeHeader(startOffset, endOffset) {
    let endOffsetStr;
    if (typeof endOffset === 'number') {
        endOffsetStr = `${endOffset - 1}`;
    }
    else {
        neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_1__["Uint64"].decrement(tempUint64, endOffset);
        endOffsetStr = tempUint64.toString();
    }
    return { 'Range': `bytes=${startOffset}-${endOffsetStr}` };
}
/**
 * Parses a URL that may have a special protocol designation into a real URL.
 *
 * If the protocol is 'http' or 'https', the input string is returned as is.
 *
 * The special 'gs://bucket/path' syntax is supported for accessing Google Storage buckets.
 */
function parseSpecialUrl(url) {
    const urlProtocolPattern = /^([^:\/]+):\/\/([^\/]+)(\/.*)?$/;
    let match = url.match(urlProtocolPattern);
    if (match === null) {
        throw new Error(`Invalid URL: ${JSON.stringify(url)}`);
    }
    const protocol = match[1];
    if (protocol === 'gs') {
        const bucket = match[2];
        let path = match[3];
        if (path === undefined)
            path = '';
        return `https://storage.googleapis.com/${bucket}${path}`;
    }
    return url;
}


/***/ }),

/***/ "./src/neuroglancer/util/json.ts":
/*!***************************************!*\
  !*** ./src/neuroglancer/util/json.ts ***!
  \***************************************/
/*! exports provided: verifyFloat, verifyFiniteFloat, verifyFinitePositiveFloat, parseXYZ, parseFiniteVec, parseIntVec, stableStringify, urlSafeStringifyString, urlSafeStringify, normalizeStringLiteral, urlSafeToJSON, jsonToUrlSafe, urlSafeParse, pythonLiteralToJSON, pythonLiteralParse, parseArray, parseFixedLengthArray, verifyObject, verifyInt, verifyPositiveInt, verifyMapKey, verifyString, verifyOptionalString, verifyOptionalInt, verifyOptionalBoolean, valueOr, verifyObjectProperty, verifyObjectAsMap, verifyFloat01, parseQueryStringParameters, verifyEnumString, verify3dVec, verify3dScale, verify3dDimensions, verifyStringArray, verifyBoolean */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyFloat", function() { return verifyFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyFiniteFloat", function() { return verifyFiniteFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyFinitePositiveFloat", function() { return verifyFinitePositiveFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseXYZ", function() { return parseXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFiniteVec", function() { return parseFiniteVec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseIntVec", function() { return parseIntVec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stableStringify", function() { return stableStringify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlSafeStringifyString", function() { return urlSafeStringifyString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlSafeStringify", function() { return urlSafeStringify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeStringLiteral", function() { return normalizeStringLiteral; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlSafeToJSON", function() { return urlSafeToJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jsonToUrlSafe", function() { return jsonToUrlSafe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlSafeParse", function() { return urlSafeParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pythonLiteralToJSON", function() { return pythonLiteralToJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pythonLiteralParse", function() { return pythonLiteralParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseArray", function() { return parseArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFixedLengthArray", function() { return parseFixedLengthArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyObject", function() { return verifyObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyInt", function() { return verifyInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyPositiveInt", function() { return verifyPositiveInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyMapKey", function() { return verifyMapKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyString", function() { return verifyString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyOptionalString", function() { return verifyOptionalString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyOptionalInt", function() { return verifyOptionalInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyOptionalBoolean", function() { return verifyOptionalBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueOr", function() { return valueOr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyObjectProperty", function() { return verifyObjectProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyObjectAsMap", function() { return verifyObjectAsMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyFloat01", function() { return verifyFloat01; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseQueryStringParameters", function() { return parseQueryStringParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyEnumString", function() { return verifyEnumString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verify3dVec", function() { return verify3dVec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verify3dScale", function() { return verify3dScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verify3dDimensions", function() { return verify3dDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyStringArray", function() { return verifyStringArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyBoolean", function() { return verifyBoolean; });
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function verifyFloat(obj) {
    let t = typeof obj;
    if (t === 'number' || t === 'string') {
        let x = parseFloat('' + obj);
        if (!Number.isNaN(x)) {
            return x;
        }
    }
    throw new Error(`Expected floating-point number, but received: ${JSON.stringify(obj)}.`);
}
function verifyFiniteFloat(obj) {
    let x = verifyFloat(obj);
    if (Number.isFinite(x)) {
        return x;
    }
    throw new Error(`Expected finite floating-point number, but received: ${x}.`);
}
function verifyFinitePositiveFloat(obj) {
    let x = verifyFiniteFloat(obj);
    if (x > 0) {
        return x;
    }
    throw new Error(`Expected positive finite floating-point number, but received: ${x}.`);
}
function parseXYZ(out, obj, validator = verifyFloat) {
    verifyObject(obj);
    out[0] = out[1] = out[2] = 0;
    for (const key of Object.keys(obj)) {
        switch (key) {
            case 'x':
                out[0] = validator(obj[key]);
                break;
            case 'y':
                out[1] = validator(obj[key]);
                break;
            case 'z':
                out[2] = validator(obj[key]);
                break;
            default:
                throw new Error(`Expected object to have keys ['x', 'y', 'z'], but received: ${JSON.stringify(obj)}.`);
        }
    }
    return out;
}
function parseFiniteVec(out, obj) {
    let length = out.length;
    if (!Array.isArray(obj) || obj.length !== length) {
        throw new Error('Incompatible sizes');
    }
    for (let i = 0; i < length; ++i) {
        if (!Number.isFinite(parseFloat(obj[i]))) {
            throw new Error('Non-finite value.');
        }
    }
    for (let i = 0; i < length; ++i) {
        out[i] = parseFloat(obj[i]);
    }
    return out;
}
function parseIntVec(out, obj) {
    let length = out.length;
    if (!Array.isArray(obj) || obj.length !== length) {
        throw new Error('Incompatible sizes.');
    }
    for (let i = 0; i < length; ++i) {
        let val = parseInt(obj[i], undefined);
        if (!Number.isInteger(val)) {
            throw new Error('Non-integer value.');
        }
    }
    for (let i = 0; i < length; ++i) {
        out[i] = parseInt(obj[i], undefined);
    }
    return out;
}
/**
 * Returns a JSON representation of x, with object keys sorted to ensure a
 * consistent result.
 */
function stableStringify(x) {
    if (typeof x === 'object') {
        if (x === null) {
            return 'null';
        }
        if (Array.isArray(x)) {
            let s = '[';
            let size = x.length;
            let i = 0;
            if (i < size) {
                s += stableStringify(x[i]);
                while (++i < size) {
                    s += ',';
                    s += stableStringify(x[i]);
                }
            }
            s += ']';
            return s;
        }
        let s = '{';
        let keys = Object.keys(x).sort();
        let i = 0;
        let size = keys.length;
        if (i < size) {
            let key = keys[i];
            s += JSON.stringify(key);
            s += ':';
            s += stableStringify(x[key]);
            while (++i < size) {
                s += ',';
                key = keys[i];
                s += JSON.stringify(key);
                s += ':';
                s += stableStringify(x[key]);
            }
        }
        s += '}';
        return s;
    }
    return JSON.stringify(x);
}
function swapQuotes(x) {
    return x.replace(/['"]/g, s => {
        return (s === '"' ? '\'' : '"');
    });
}
function urlSafeStringifyString(x) {
    return swapQuotes(JSON.stringify(swapQuotes(x)));
}
const URL_SAFE_COMMA = '_';
function urlSafeStringify(x) {
    if (typeof x === 'object') {
        if (x === null) {
            return 'null';
        }
        let toJSON = x['toJSON'];
        if (typeof toJSON === 'function') {
            return urlSafeStringify(toJSON.call(x));
        }
        if (Array.isArray(x)) {
            let s = '[';
            let size = x.length;
            let i = 0;
            if (i < size) {
                s += urlSafeStringify(x[i]);
                while (++i < size) {
                    s += URL_SAFE_COMMA;
                    s += urlSafeStringify(x[i]);
                }
            }
            s += ']';
            return s;
        }
        let s = '{';
        let keys = Object.keys(x);
        let first = true;
        for (let key of keys) {
            let value = x[key];
            if (value === undefined) {
                continue;
            }
            let valueString = urlSafeStringify(value);
            if (!valueString) {
                continue;
            }
            if (!first) {
                s += URL_SAFE_COMMA;
            }
            else {
                first = false;
            }
            s += urlSafeStringifyString(key);
            s += ':';
            s += valueString;
        }
        s += '}';
        return s;
    }
    if (typeof x === 'string') {
        return urlSafeStringifyString(x);
    }
    return JSON.stringify(x);
}
const SINGLE_QUOTE_STRING_PATTERN = /('(?:[^'\\]|(?:\\.))*')/;
const DOUBLE_QUOTE_STRING_PATTERN = /("(?:[^'\\]|(?:\\.))*")/;
const SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN = new RegExp(`${SINGLE_QUOTE_STRING_PATTERN.source}|${DOUBLE_QUOTE_STRING_PATTERN.source}`);
const DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN = new RegExp(`${DOUBLE_QUOTE_STRING_PATTERN.source}|${SINGLE_QUOTE_STRING_PATTERN.source}`);
const DOUBLE_QUOTE_PATTERN = /^((?:[^"'\\]|(?:\\[^']))*)("|\\')/;
const SINGLE_QUOTE_PATTERN = /^((?:[^"'\\]|(?:\\.))*)'/;
function convertStringLiteral(x, quoteInitial, quoteReplace, quoteSearch) {
    if (x.length >= 2 && x.charAt(0) === quoteInitial && x.charAt(x.length - 1) === quoteInitial) {
        let inner = x.substr(1, x.length - 2);
        let s = quoteReplace;
        while (inner.length > 0) {
            let m = inner.match(quoteSearch);
            if (m === null) {
                s += inner;
                break;
            }
            s += m[1];
            if (m[2] === quoteReplace) {
                // We received a single unescaped quoteReplace character.
                s += '\\';
                s += quoteReplace;
            }
            else {
                // We received "\\" + quoteInitial.  We need to remove the escaping.
                s += quoteInitial;
            }
            inner = inner.substr(m.index + m[0].length);
        }
        s += quoteReplace;
        return s;
    }
    return x;
}
/**
 * Converts a string literal delimited by either single or double quotes into a string literal
 * delimited by double quotes.
 */
function normalizeStringLiteral(x) {
    return convertStringLiteral(x, '\'', '"', DOUBLE_QUOTE_PATTERN);
}
// quoteChar: des
function convertJsonHelper(x, desiredCommaChar, desiredQuoteChar) {
    const commaSearch = /[&_,]/g;
    let quoteInitial;
    let quoteSearch;
    let stringLiteralPattern;
    if (desiredQuoteChar === '"') {
        quoteInitial = '\'';
        quoteSearch = DOUBLE_QUOTE_PATTERN;
        stringLiteralPattern = SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN;
    }
    else {
        quoteInitial = '"';
        quoteSearch = SINGLE_QUOTE_PATTERN;
        stringLiteralPattern = DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN;
    }
    let s = '';
    while (x.length > 0) {
        let m = x.match(stringLiteralPattern);
        let before;
        let replacement;
        if (m === null) {
            before = x;
            x = '';
            replacement = '';
        }
        else {
            before = x.substr(0, m.index);
            x = x.substr(m.index + m[0].length);
            let originalString = m[1];
            if (originalString !== undefined) {
                replacement =
                    convertStringLiteral(originalString, quoteInitial, desiredQuoteChar, quoteSearch);
            }
            else {
                replacement = m[2];
            }
        }
        s += before.replace(commaSearch, desiredCommaChar);
        s += replacement;
    }
    return s;
}
function urlSafeToJSON(x) {
    return convertJsonHelper(x, ',', '"');
}
function jsonToUrlSafe(x) {
    return convertJsonHelper(x, '_', '\'');
}
function urlSafeParse(x) {
    return JSON.parse(urlSafeToJSON(x));
}
// Converts a string containing a Python literal into a string containing an equivalent JSON
// literal.
function pythonLiteralToJSON(x) {
    let s = '';
    while (x.length > 0) {
        let m = x.match(SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN);
        let before;
        let replacement;
        if (m === null) {
            before = x;
            x = '';
            replacement = '';
        }
        else {
            before = x.substr(0, m.index);
            x = x.substr(m.index + m[0].length);
            let singleQuoteString = m[1];
            if (singleQuoteString !== undefined) {
                replacement = normalizeStringLiteral(singleQuoteString);
            }
            else {
                replacement = m[2];
            }
        }
        s += before.replace(/\(/g, '[')
            .replace(/\)/g, ']')
            .replace('True', 'true')
            .replace('False', 'false')
            .replace(/,\s*([\}\]])/g, '$1');
        s += replacement;
    }
    return s;
}
// Converts a string containing a Python literal into an equivalent JavaScript value.
function pythonLiteralParse(x) {
    return JSON.parse(pythonLiteralToJSON(x));
}
// Checks that `x' is an array, maps each element by parseElement.
function parseArray(x, parseElement) {
    if (!Array.isArray(x)) {
        throw new Error(`Expected array, but received: ${JSON.stringify(x)}.`);
    }
    return x.map(parseElement);
}
function parseFixedLengthArray(out, obj, parseElement) {
    const length = out.length;
    if (!Array.isArray(obj) || obj.length !== length) {
        throw new Error(`Expected length ${length} array, but received: ${JSON.stringify(obj)}.`);
    }
    for (let i = 0; i < length; ++i) {
        out[i] = parseElement(obj[i], i);
    }
    return out;
}
function verifyObject(obj) {
    if (typeof obj !== 'object' || obj == null || Array.isArray(obj)) {
        throw new Error(`Expected JSON object, but received: ${JSON.stringify(obj)}.`);
    }
    return obj;
}
function verifyInt(obj) {
    let result = parseInt(obj, 10);
    if (!Number.isInteger(result)) {
        throw new Error(`Expected integer, but received: ${JSON.stringify(obj)}.`);
    }
    return result;
}
function verifyPositiveInt(obj) {
    let result = verifyInt(obj);
    if (result <= 0) {
        throw new Error(`Expected positive integer, but received: ${result}.`);
    }
    return result;
}
function verifyMapKey(obj, map) {
    let result = map.get(obj);
    if (result === undefined) {
        throw new Error(`Expected one of ${JSON.stringify(Array.from(map.keys()))}, ` +
            `but received: ${JSON.stringify(obj)}.`);
    }
    return result;
}
function verifyString(obj) {
    if (typeof obj !== 'string') {
        throw new Error(`Expected string, but received: ${JSON.stringify(obj)}.`);
    }
    return obj;
}
function verifyOptionalString(obj) {
    if (obj === undefined) {
        return undefined;
    }
    return verifyString(obj);
}
function verifyOptionalInt(obj) {
    if (obj === undefined) {
        return undefined;
    }
    return verifyInt(obj);
}
function verifyOptionalBoolean(obj) {
    if (obj === undefined) {
        return undefined;
    }
    if (typeof obj === 'boolean') {
        return obj;
    }
    else if (obj === 'true') {
        return true;
    }
    else if (obj === 'false') {
        return false;
    }
    else {
        throw new Error(`Expected string or boolean but received: ${JSON.stringify(obj)}`);
    }
}
function valueOr(value, defaultValue) {
    return value === undefined ? defaultValue : value;
}
function verifyObjectProperty(obj, propertyName, validator) {
    let value = obj.hasOwnProperty(propertyName) ? obj[propertyName] : undefined;
    try {
        return validator(value);
    }
    catch (parseError) {
        throw new Error(`Error parsing ${JSON.stringify(propertyName)} property: ${parseError.message}`);
    }
}
function verifyObjectAsMap(obj, validator) {
    verifyObject(obj);
    let map = new Map();
    for (let key of Object.keys(obj)) {
        try {
            map.set(key, validator(obj[key]));
        }
        catch (parseError) {
            throw new Error(`Error parsing value associated with key ${JSON.stringify(key)}: ${parseError.message}`);
        }
    }
    return map;
}
function verifyFloat01(obj) {
    if (typeof obj !== 'number' || !Number.isFinite(obj) || obj < 0 || obj > 1) {
        throw new Error(`Expected floating point number in [0,1], but received: ${JSON.stringify(obj)}.`);
    }
    return obj;
}
/**
 * The query string parameters may either be specified in the usual
 * 'name=value&otherName=otherValue' form or as (optionally urlSafe) JSON: '{"name":"value"}`.
 */
function parseQueryStringParameters(queryString) {
    if (queryString === '') {
        return {};
    }
    if (queryString.startsWith('{')) {
        return urlSafeParse(queryString);
    }
    else {
        let result = {};
        let parts = queryString.split(/[&;]/);
        for (let part of parts) {
            let m = part.match(/^([^=&;]+)=([^&;]*)$/);
            if (m === null) {
                throw new Error(`Invalid query string part: ${JSON.stringify(part)}.`);
            }
            result[m[1]] = decodeURIComponent(m[2]);
        }
        return result;
    }
}
/**
 * Verifies that `obj' is a string that, when converted to uppercase, matches a string property of
 * `enumType`.
 *
 * Note: TypeScript does not seem to allow better typing of the return type.
 *
 * @returns The corresponding numerical value.
 */
function verifyEnumString(obj, enumType) {
    if (typeof obj === 'string' && obj.match(/^[a-zA-Z]/) !== null) {
        obj = obj.toUpperCase();
        if (enumType.hasOwnProperty(obj)) {
            return enumType[obj];
        }
    }
    throw new Error(`Invalid enum value: ${JSON.stringify(obj)}.`);
}
function verify3dVec(obj) {
    return parseFixedLengthArray(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].create(), obj, verifyFiniteFloat);
}
function verify3dScale(obj) {
    return parseFixedLengthArray(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].create(), obj, verifyFinitePositiveFloat);
}
function verify3dDimensions(obj) {
    return parseFixedLengthArray(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].create(), obj, verifyPositiveInt);
}
function verifyStringArray(a) {
    if (!Array.isArray(a)) {
        throw new Error(`Expected array, received: ${JSON.stringify(a)}.`);
    }
    for (let x of a) {
        if (typeof x !== 'string') {
            throw new Error(`Expected string, received: ${JSON.stringify(x)}.`);
        }
    }
    return a;
}
function verifyBoolean(x) {
    if (typeof x !== 'boolean') {
        throw new Error(`Expected boolean, received: ${JSON.stringify(x)}`);
    }
    return x;
}


/***/ }),

/***/ "./src/neuroglancer/util/keyboard_bindings.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/util/keyboard_bindings.ts ***!
  \****************************************************/
/*! exports provided: KeyboardEventBinder, getEventKeyName, EventActionMap, registerActionListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyboardEventBinder", function() { return KeyboardEventBinder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEventKeyName", function() { return getEventKeyName; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventActionMap", function() { return neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_1__["EventActionMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerActionListener", function() { return neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_1__["registerActionListener"]; });

/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facility for triggering named actions in response to keyboard events.
 */
// This is based on goog/ui/keyboardshortcuthandler.js in the Google Closure library.


const globalKeys = new Set(['f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'escape', 'pause']);
const DEFAULT_TEXT_INPUTS = new Set([
    'color', 'date', 'datetime', 'datetime-local', 'email', 'month', 'number', 'password', 'search',
    'tel', 'text', 'time', 'url', 'week'
]);
class KeyboardEventBinder extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(target, eventMap) {
        super();
        this.target = target;
        this.eventMap = eventMap;
        this.modifierShortcutsAreGlobal = true;
        this.allShortcutsAreGlobal = false;
        this.allowSpaceKeyOnButtons = false;
        this.registerEventListener(target, 'keydown', this.handleKeyDown.bind(this), /*useCapture=*/ false);
    }
    shouldIgnoreEvent(key, event) {
        var el = event.target;
        let { tagName } = el;
        if (el === this.target) {
            // If the event is directly on the target element, we never ignore it.
            return false;
        }
        var isFormElement = tagName === 'TEXTAREA' || tagName === 'INPUT' || tagName === 'BUTTON' ||
            tagName === 'SELECT';
        var isContentEditable = !isFormElement &&
            (el.isContentEditable || (el.ownerDocument && el.ownerDocument.designMode === 'on'));
        if (!isFormElement && !isContentEditable) {
            return false;
        }
        // Always allow keys registered as global to be used (typically Esc, the
        // F-keys and other keys that are not typically used to manipulate text).
        if (this.allShortcutsAreGlobal || globalKeys.has(key)) {
            return false;
        }
        if (isContentEditable) {
            // For events originating from an element in editing mode we only let
            // global key codes through.
            return true;
        }
        // Event target is one of (TEXTAREA, INPUT, BUTTON, SELECT).
        // Allow modifier shortcuts, unless we shouldn't.
        if (this.modifierShortcutsAreGlobal && (event.altKey || event.ctrlKey || event.metaKey)) {
            return true;
        }
        // Allow ENTER to be used as shortcut for text inputs.
        if (tagName === 'INPUT' && DEFAULT_TEXT_INPUTS.has(el.type)) {
            return key !== 'enter';
        }
        // Checkboxes, radiobuttons and buttons. Allow all but SPACE as shortcut.
        if (tagName === 'INPUT' || tagName === 'BUTTON') {
            // TODO(gboyer): If more flexibility is needed, create protected helper
            // methods for each case (e.g. button, input, etc).
            if (this.allowSpaceKeyOnButtons) {
                return false;
            }
            else {
                return key === 'space';
            }
        }
        // Don't allow any additional shortcut keys for textareas or selects.
        return true;
    }
    handleKeyDown(event) {
        const key = getEventKeyName(event);
        if (this.shouldIgnoreEvent(key, event)) {
            return;
        }
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_1__["dispatchEventWithModifiers"])(key, event, event, this.eventMap);
    }
}
function getEventKeyName(event) {
    return event.code.toLowerCase();
}



/***/ }),

/***/ "./src/neuroglancer/util/linked_list.0.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/util/linked_list.0.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// DO NOT EDIT.  Generated from templates/neuroglancer/util/linked_list.template.ts.
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* harmony default export */ __webpack_exports__["default"] = (class {
    static insertAfter(head, x) {
        let next = head.next0;
        x.next0 = next;
        x.prev0 = head;
        head.next0 = x;
        next.prev0 = x;
    }
    static insertBefore(head, x) {
        let prev = head.prev0;
        x.prev0 = prev;
        x.next0 = head;
        head.prev0 = x;
        prev.next0 = x;
    }
    static front(head) {
        let next = head.next0;
        if (next === head) {
            return null;
        }
        return next;
    }
    static back(head) {
        let next = head.prev0;
        if (next === head) {
            return null;
        }
        return next;
    }
    static pop(x) {
        let next = x.next0;
        let prev = x.prev0;
        next.prev0 = prev;
        prev.next0 = next;
        x.next0 = null;
        x.prev0 = null;
        return x;
    }
    static *iterator(head) {
        for (let x = head.next0; x !== head; x = x.next0) {
            yield x;
        }
    }
    static *reverseIterator(head) {
        for (let x = head.prev0; x !== head; x = x.prev0) {
            yield x;
        }
    }
    static initializeHead(head) {
        head.next0 = head.prev0 = head;
    }
});


/***/ }),

/***/ "./src/neuroglancer/util/longest_common_prefix.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/util/longest_common_prefix.ts ***!
  \********************************************************/
/*! exports provided: longestCommonPrefix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "longestCommonPrefix", function() { return longestCommonPrefix; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the longest common prefix of a sequence of strings.
 *
 * Returns '' if the sequence of strings is empty.
 */
function longestCommonPrefix(strings) {
    let it = strings[Symbol.iterator]();
    let { value: firstValue, done: noValues } = it.next();
    if (noValues) {
        // The sequence of strings is empty.
        return '';
    }
    let commonPrefixLength = firstValue.length;
    while (commonPrefixLength > 0) {
        let { value, done } = it.next();
        if (done) {
            break;
        }
        let i = 0;
        for (; i < commonPrefixLength; ++i) {
            if (firstValue.charCodeAt(i) !== value.charCodeAt(i)) {
                break;
            }
        }
        commonPrefixLength = i;
    }
    return firstValue.substring(0, commonPrefixLength);
}


/***/ }),

/***/ "./src/neuroglancer/util/memoize.ts":
/*!******************************************!*\
  !*** ./src/neuroglancer/util/memoize.ts ***!
  \******************************************/
/*! exports provided: Memoize, StringMemoize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Memoize", function() { return Memoize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringMemoize", function() { return StringMemoize; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class Memoize {
    constructor() {
        this.map = new Map();
    }
    /**
     * If getter throws an exception, no value is added.
     */
    get(key, getter) {
        let { map } = this;
        let obj = map.get(key);
        if (obj === undefined) {
            obj = getter();
            obj.registerDisposer(() => {
                map.delete(key);
            });
            map.set(key, obj);
        }
        else {
            obj.addRef();
        }
        return obj;
    }
}
class StringMemoize extends Memoize {
    get(x, getter) {
        if (typeof x !== 'string') {
            x = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["stableStringify"])(x);
        }
        return super.get(x, getter);
    }
    getUncounted(x, getter) {
        return this.get(x, () => new neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCountedValue"](getter())).value;
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/mouse_bindings.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/util/mouse_bindings.ts ***!
  \*************************************************/
/*! exports provided: MouseEventBinder, EventActionMap, registerActionListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MouseEventBinder", function() { return MouseEventBinder; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventActionMap", function() { return neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_1__["EventActionMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerActionListener", function() { return neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_1__["registerActionListener"]; });

/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facility for triggering named actions in response to mouse events.
 */


class MouseEventBinder extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(target, eventMap) {
        super();
        this.target = target;
        this.eventMap = eventMap;
        this.registerEventListener(target, 'wheel', (event) => {
            this.dispatch('wheel', event);
        });
        this.registerEventListener(target, 'click', (event) => {
            this.dispatch(`click${event.button}`, event);
        });
        this.registerEventListener(target, 'dblclick', (event) => {
            this.dispatch(`dblclick${event.button}`, event);
        });
        this.registerEventListener(target, 'mousedown', (event) => {
            this.dispatch(`mousedown${event.button}`, event);
        });
        this.registerEventListener(target, 'mouseup', (event) => {
            this.dispatch(`mouseup${event.button}`, event);
        });
    }
    dispatch(baseIdentifier, event) {
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_1__["dispatchEventWithModifiers"])(baseIdentifier, event, event, this.eventMap);
    }
}



/***/ }),

/***/ "./src/neuroglancer/util/mouse_drag.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/util/mouse_drag.ts ***!
  \*********************************************/
/*! exports provided: startRelativeMouseDrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startRelativeMouseDrag", function() { return startRelativeMouseDrag; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startRelativeMouseDrag(initialEvent, handler, finishDragHandler) {
    let { document } = initialEvent.view;
    let prevClientX = initialEvent.clientX, prevClientY = initialEvent.clientY;
    const mouseMoveHandler = (e) => {
        const deltaX = e.clientX - prevClientX;
        const deltaY = e.clientY - prevClientY;
        prevClientX = e.clientX;
        prevClientY = e.clientY;
        handler(e, deltaX, deltaY);
    };
    const button = initialEvent.button;
    const cancel = (e) => {
        document.removeEventListener('pointermove', mouseMoveHandler, true);
        document.removeEventListener('pointerup', mouseUpHandler, false);
        if (finishDragHandler !== undefined) {
            finishDragHandler(e, e.clientX - prevClientX, e.clientY - prevClientY);
        }
    };
    const mouseUpHandler = (e) => {
        if (e.button === button) {
            cancel(e);
        }
    };
    document.addEventListener('pointermove', mouseMoveHandler, true);
    document.addEventListener('pointerup', mouseUpHandler, false);
    document.addEventListener('pointercancel', cancel, false);
}


/***/ }),

/***/ "./src/neuroglancer/util/number_to_string.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/util/number_to_string.ts ***!
  \***************************************************/
/*! exports provided: numberToStringFixed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberToStringFixed", function() { return numberToStringFixed; });
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function numberToStringFixed(v, maxDigits) {
    let s = '';
    for (let digits = 0; digits <= maxDigits; ++digits) {
        s = v.toFixed(digits);
        if (parseFloat(s) === v) {
            break;
        }
    }
    return s;
}


/***/ }),

/***/ "./src/neuroglancer/util/object_id.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/util/object_id.ts ***!
  \********************************************/
/*! exports provided: getObjectId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getObjectId", function() { return getObjectId; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OBJECT_ID_SYMBOL = Symbol('objectId');
let nextObjectId = 0;
/**
 * Returns a string that uniquely identifies a particular primitive value or object instance.
 */
function getObjectId(x) {
    if (x instanceof Object) {
        let id = x[OBJECT_ID_SYMBOL];
        if (id === undefined) {
            id = x[OBJECT_ID_SYMBOL] = nextObjectId++;
        }
        return `o${id}`;
    }
    else {
        return '' + JSON.stringify(x);
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/random.ts":
/*!*****************************************!*\
  !*** ./src/neuroglancer/util/random.ts ***!
  \*****************************************/
/*! exports provided: getRandomHexString, getRandomValues, getRandomUint32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomHexString", function() { return getRandomHexString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomValues", function() { return getRandomValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomUint32", function() { return getRandomUint32; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getRandomHexString(numBits = 128) {
    const numValues = Math.ceil(numBits / 32);
    const data = new Uint32Array(numValues);
    crypto.getRandomValues(data);
    let s = '';
    for (let i = 0; i < numValues; ++i) {
        s += ('00000000' + data[i].toString(16)).slice(-8);
    }
    return s;
}
/**
 * Calls crypto.getRandomValues as many times as needed to fill array.
 */
function getRandomValues(array) {
    let byteArray = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
    const blockSize = 65536;
    for (let i = 0, length = byteArray.length; i < length; i += blockSize) {
        crypto.getRandomValues(byteArray.subarray(i, Math.min(length, i + blockSize)));
    }
    return array;
}
function getRandomUint32() {
    const data = new Uint32Array(1);
    crypto.getRandomValues(data);
    return data[0];
}


/***/ }),

/***/ "./src/neuroglancer/util/scroll_into_view.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/util/scroll_into_view.ts ***!
  \***************************************************/
/*! exports provided: scrollIntoViewIfNeeded */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scrollIntoViewIfNeeded", function() { return scrollIntoViewIfNeeded; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function scrollIntoViewIfNeeded(element) {
    const parent = element.parentElement;
    const elementLeft = element.offsetLeft - parent.clientLeft;
    const elementTop = element.offsetTop - parent.clientTop;
    const elementRight = elementLeft + element.offsetWidth;
    const elementBottom = elementTop + element.offsetHeight;
    const parentWidth = parent.clientWidth;
    const parentHeight = parent.clientHeight;
    const viewportLeft = parent.scrollLeft;
    const viewportRight = viewportLeft + parentWidth;
    const viewportTop = parent.scrollTop;
    const viewportBottom = viewportTop + parentHeight;
    const scrollLeftDelta = Math.max(0.0, elementRight - viewportRight) || Math.min(0.0, elementLeft - viewportLeft);
    const scrollTopDelta = Math.max(0.0, elementBottom - viewportBottom) || Math.min(0.0, elementTop - viewportTop);
    parent.scrollLeft += scrollLeftDelta;
    parent.scrollTop += scrollTopDelta;
}


/***/ }),

/***/ "./src/neuroglancer/util/signal.ts":
/*!*****************************************!*\
  !*** ./src/neuroglancer/util/signal.ts ***!
  \*****************************************/
/*! exports provided: Signal, NullarySignal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Signal", function() { return Signal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NullarySignal", function() { return NullarySignal; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Simple signal dispatch mechanism.
 */
/**
 * This class provides a simple signal dispatch mechanism.  Handlers can be added, and then the
 * `dispatch` method calls all of them.
 *
 * If specified, Callable should be an interface containing only a callable signature returning
 * void.  Due to limitations in TypeScript, any interface containing a callable signature will be
 * accepted by the compiler, but the resultant signature of `dispatch` will not be correct.
 */
class Signal {
    constructor() {
        this.handlers = new Set();
        /**
         * Count of number of times this signal has been dispatched.  This is incremented each time
         * `dispatch` is called prior to invoking the handlers.
         */
        this.count = 0;
        const obj = this;
        this.dispatch = function () {
            ++obj.count;
            obj.handlers.forEach(handler => {
                handler.apply(this, arguments);
            });
        };
    }
    /**
     * Add a handler function.  If `dispatch` is currently be called, then the new handler will be
     * called before `dispatch` returns.
     *
     * @param handler The handler function to add.
     *
     * @return A function that unregisters the handler.
     */
    add(handler) {
        this.handlers.add(handler);
        return () => {
            return this.remove(handler);
        };
    }
    /**
     * Remove a handler function.  If `dispatch` is currently be called and the new handler has not
     * yet been called, then it will not be called.
     *
     * @param handler Handler to remove.
     * @return `true` if the handler was present, `false` otherwise.
     */
    remove(handler) {
        return this.handlers.delete(handler);
    }
    /**
     * Disposes of resources.  No methods, including `dispatch`, may be invoked afterwards.
     */
    dispose() {
        this.handlers = undefined;
    }
}
/**
 * Simple specialization of Signal for the common case of a nullary handler signature.
 */
class NullarySignal extends Signal {
}


/***/ }),

/***/ "./src/neuroglancer/util/signal_binding_updater.ts":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/util/signal_binding_updater.ts ***!
  \*********************************************************/
/*! exports provided: removeSignalBinding, addSignalBinding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeSignalBinding", function() { return removeSignalBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSignalBinding", function() { return addSignalBinding; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function removeSignalBinding(signal, handler) {
    signal.remove(handler);
}
function addSignalBinding(signal, handler) {
    signal.add(handler);
}


/***/ }),

/***/ "./src/neuroglancer/util/spatial_units.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/util/spatial_units.ts ***!
  \************************************************/
/*! exports provided: formatIntegerPoint, formatIntegerBounds, formatLength, formatVolume, formatBoundingBoxVolume */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatIntegerPoint", function() { return formatIntegerPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatIntegerBounds", function() { return formatIntegerBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatLength", function() { return formatLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatVolume", function() { return formatVolume; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatBoundingBoxVolume", function() { return formatBoundingBoxVolume; });
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/widget/scale_bar */ "./src/neuroglancer/widget/scale_bar.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function formatIntegerPoint(point) {
    return `(${Math.floor(point[0])}, ${Math.floor(point[1])}, ${Math.floor(point[2])})`;
}
function formatIntegerBounds(bounds) {
    let result = '';
    for (let i = 0; i < 3; ++i) {
        if (i !== 0) {
            result += '  ';
        }
        result += Math.round(Math.abs(bounds[i]));
    }
    return result;
}
function formatLength(lengthInNanometers) {
    const unit = Object(neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_1__["pickLengthUnit"])(lengthInNanometers);
    const value = lengthInNanometers / unit.lengthInNanometers;
    return `${value.toPrecision(3)}\u202f${unit.unit}`;
}
function formatVolume(volumeInCubicNanometers) {
    const unit = Object(neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_1__["pickVolumeUnit"])(volumeInCubicNanometers);
    const value = volumeInCubicNanometers / Math.pow(unit.lengthInNanometers, 3);
    return `${value.toPrecision(6)}\u202f${unit.unit}`;
}
function formatBoundingBoxVolume(pointA, pointB, transform) {
    let dimensionText = '';
    const vector = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    for (let axis = 0; axis < 3; ++axis) {
        neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(vector, 0, 0, 0);
        vector[axis] = pointB[axis] - pointA[axis];
        const spatialVector = Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["transformVectorByMat4"])(vector, vector, transform);
        const length = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].length(spatialVector);
        if (axis !== 0) {
            dimensionText += '  ';
        }
        dimensionText += formatLength(length);
    }
    const preTransformVolume = Math.abs(Object(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["prod3"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec3"].subtract(vector, pointB, pointA)));
    const det = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat3"].determinant(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat3"].fromMat4(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["mat3"].create(), transform));
    const postTransformVolume = det * preTransformVolume;
    return `${dimensionText}  [${formatVolume(postTransformVolume)}]`;
}


/***/ }),

/***/ "./src/neuroglancer/util/touch_bindings.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/util/touch_bindings.ts ***!
  \*************************************************/
/*! exports provided: TouchEventBinder, EventActionMap, registerActionListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TouchEventBinder", function() { return TouchEventBinder; });
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/throttle */ "./node_modules/lodash/throttle.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventActionMap", function() { return neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_2__["EventActionMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerActionListener", function() { return neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_2__["registerActionListener"]; });

/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facility for triggering named actions in response to touch events.
 */



/**
 * Minimum number of pixels in x and y that a touch point must move to trigger a
 * translate/rotate/pinch action.  This helps filter out spurious tiny movements that are hard to
 * avoid, especially with one finger touches.
 **/
const moveThreshold = 10;
/**
 * Number of milliseconds that a set of touch points must be held without moving (per moveThreshold)
 * to trigger a touchhold action.
 **/
const holdThreshold = 1000;
/**
 * Maximum duration of a tap.
 */
const maxTapDuration = 400;
/**
 * Maximum number of milliseconds delay between two taps to trigger a multitap action.
 */
const multiTapMaxInterval = 500;
const rotateThreshold = Math.PI / 20;
const pinchThreshold = 20;
const translateThreshold = 10;
function norm2(deltaX, deltaY) {
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}
function getTwoFingerDistanceAndAngle(touches) {
    let [t0, t1] = touches;
    if (t0.identifier > t1.identifier) {
        [t1, t0] = [t0, t1];
    }
    const offsetX = t0.clientX - t1.clientX;
    const offsetY = t0.clientY - t1.clientY;
    const distance = norm2(offsetX, offsetY);
    const angle = Math.atan2(offsetX, offsetY);
    return { distance, angle };
}
function getAngleDifference(x, y) {
    const TAU = Math.PI * 2;
    const d = Math.abs(x - y) % TAU;
    return Math.min(d, TAU - d);
}
class TouchEventBinder extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(target, eventMap) {
        super();
        this.target = target;
        this.eventMap = eventMap;
        this.prevTouches = new Map();
        this.moved = false;
        /**
         * Initial angle for two-finger touch.  Once the difference between this ange the current angle
         * exceeds `rotateThreshold`, `touchrotate` events are dispatched.
         **/
        this.prevAngle = 0;
        this.rotated = false;
        /**
         * Initial distance for two-finger touch.  Once the difference between this ange the current
         * distance exceeds `pinchThreshold`, `touchpinich` events are dispatched.
         **/
        this.prevDistance = 0;
        this.pinched = false;
        this.prevCenterX = 0;
        this.prevCenterY = 0;
        this.translated = false;
        this.startHold = this.registerCancellable(lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default()((event, eventPhase, centerX, centerY) => {
            const info = { event, centerX, centerY };
            this.dispatch(`touchhold${event.targetTouches.length}`, event, info, eventPhase);
        }, holdThreshold, { leading: false, trailing: true }));
        this.numPriorTaps = 0;
        this.priorTapNumTouches = 0;
        this.tapStartTime = 0;
        this.tapEndTime = 0;
        this.curTapNumTouches = 0;
        this.registerEventListener(target, 'touchstart', (event) => {
            this.handleTouchEvent(event);
        });
        this.registerEventListener(target, 'touchmove', (event) => {
            this.handleTouchEvent(event);
        });
        this.registerEventListener(target, 'touchend', (event) => {
            this.handleTouchEvent(event);
        });
    }
    dispatch(eventIdentifier, event, detail, eventPhase = event.eventPhase) {
        Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_2__["dispatchEvent"])(eventIdentifier, event, eventPhase, detail, this.eventMap);
    }
    handleTouchEvent(event) {
        if (event.target === this.target) {
            event.preventDefault();
        }
        else {
            return;
        }
        const newTouches = new Map();
        const { prevTouches, prevEvent } = this;
        // Compute average movement.
        let centerX = 0, centerY = 0;
        for (const touch of event.targetTouches) {
            newTouches.set(touch.identifier, touch);
            centerX += touch.clientX;
            centerY += touch.clientY;
        }
        centerX /= newTouches.size;
        centerY /= newTouches.size;
        // Remove touches that are no longer matched.
        for (const [key, touch] of prevTouches.entries()) {
            const newTouch = newTouches.get(key);
            if (newTouch === undefined) {
                prevTouches.delete(key);
            }
            else {
                const deltaX = newTouch.clientX - touch.clientX;
                const deltaY = newTouch.clientY - touch.clientY;
                if (Math.abs(deltaX) >= moveThreshold || Math.abs(deltaY) >= moveThreshold) {
                    this.moved = true;
                }
            }
        }
        if (prevEvent === undefined || prevEvent.targetTouches.length !== newTouches.size ||
            newTouches.size == 0) {
            this.moved = false;
            if (event.type === 'touchstart') {
                this.startHold(event, event.eventPhase, centerX, centerY);
                if (prevEvent === undefined || prevEvent.targetTouches.length === 0) {
                    this.tapStartTime = Date.now();
                    this.curTapNumTouches = 0;
                }
                this.curTapNumTouches = Math.max(this.curTapNumTouches, event.targetTouches.length);
            }
            else {
                if (event.type == 'touchend') {
                    const now = Date.now();
                    if (event.targetTouches.length === 0 && now - this.tapStartTime < maxTapDuration) {
                        if (this.curTapNumTouches !== this.priorTapNumTouches ||
                            now - this.tapEndTime >= multiTapMaxInterval) {
                            this.numPriorTaps = 0;
                        }
                        ++this.numPriorTaps;
                        this.tapEndTime = now;
                        this.priorTapNumTouches = this.curTapNumTouches;
                        const info = { event, centerX, centerY };
                        this.dispatch(`touchtap${this.curTapNumTouches}x${this.numPriorTaps}`, event, info);
                    }
                }
                this.startHold.cancel();
            }
            // Number of touches has changed.  Don't dispatch any events.
            // TODO: handle tap events
            this.prevTouches = newTouches;
            this.prevEvent = event;
            this.prevCenterX = centerX;
            this.prevCenterY = centerY;
            this.translated = false;
            if (newTouches.size === 2) {
                const { distance, angle } = getTwoFingerDistanceAndAngle(newTouches.values());
                this.prevDistance = distance;
                this.prevAngle = angle;
                this.rotated = false;
                this.pinched = false;
            }
            return;
        }
        if (!this.moved) {
            return;
        }
        this.tapStartTime = 0;
        this.startHold.cancel();
        this.prevTouches = newTouches;
        this.prevEvent = event;
        let { prevCenterX, prevCenterY, translated } = this;
        const deltaX = centerX - prevCenterX;
        const deltaY = centerY - prevCenterY;
        if (translated === false && norm2(deltaX, deltaY) >= translateThreshold) {
            translated = this.translated = true;
        }
        if (translated === true && (deltaX !== 0 || deltaY !== 0)) {
            this.prevCenterX = centerX;
            this.prevCenterY = centerY;
            const info = { event, deltaX, deltaY, centerX, centerY };
            this.dispatch(`touchtranslate${newTouches.size}`, event, info);
        }
        if (newTouches.size === 2) {
            const { distance, angle } = getTwoFingerDistanceAndAngle(newTouches.values());
            let { pinched, rotated, prevDistance, prevAngle } = this;
            if (pinched === false && Math.abs(distance - prevDistance) >= pinchThreshold) {
                this.pinched = pinched = true;
            }
            const angleDiff = getAngleDifference(angle, prevAngle);
            if (rotated === false && angleDiff >= rotateThreshold) {
                this.rotated = rotated = true;
            }
            if (pinched === true && distance != prevDistance) {
                this.prevDistance = distance;
                const info = { event, distance, prevDistance, centerX, centerY };
                this.dispatch(`touchpinch`, event, info);
            }
            if (rotated === true && angle !== prevAngle) {
                this.prevAngle = angle;
                this.dispatch(`touchrotate`, event, { event, centerX, centerY, angle, prevAngle });
            }
        }
    }
}



/***/ }),

/***/ "./src/neuroglancer/util/trackable.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/util/trackable.ts ***!
  \********************************************/
/*! exports provided: CompoundTrackable, PersistentCompoundTrackable, getCachedJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompoundTrackable", function() { return CompoundTrackable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PersistentCompoundTrackable", function() { return PersistentCompoundTrackable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCachedJson", function() { return getCachedJson; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Defines a generic interface for a simple state tracking mechanism.
 */



class CompoundTrackable extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor() {
        super(...arguments);
        this.children = new Map();
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["NullarySignal"]();
    }
    add(key, value) {
        const { children } = this;
        if (children.has(key)) {
            throw new Error(`Key ${JSON.stringify(key)} already registered.`);
        }
        this.children.set(key, value);
        value.changed.add(this.changed.dispatch);
        this.changed.dispatch();
        return () => {
            this.remove(key);
        };
    }
    remove(key) {
        const { children } = this;
        if (children.has(key)) {
            throw new Error(`Key ${JSON.stringify(key)} not registered.`);
        }
        const value = children.get(key);
        this.children.delete(key);
        value.changed.remove(this.changed.dispatch);
        this.changed.dispatch();
    }
    disposed() {
        const { changed } = this;
        for (let value of this.children.values()) {
            value.changed.remove(changed.dispatch);
        }
        this.children = undefined;
        super.disposed();
    }
    toJSON() {
        const result = this.baseJSON();
        for (let [key, value] of this.children) {
            result[key] = value.toJSON();
        }
        return result;
    }
    baseJSON() {
        return {};
    }
    reset() {
        for (let value of this.children.values()) {
            value.reset();
        }
    }
    restoreState(x) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verifyObject"])(x);
        for (let [key, value] of this.children) {
            try {
                if (x.hasOwnProperty(key)) {
                    const subValue = x[key];
                    if (subValue === undefined) {
                        continue;
                    }
                    value.restoreState(subValue);
                }
            }
            catch (restoreError) {
                throw new Error(`Error restoring property ${JSON.stringify(key)}: ${restoreError.message}`);
            }
        }
    }
}
class PersistentCompoundTrackable extends CompoundTrackable {
    constructor() {
        super(...arguments);
        this.lastState = {};
    }
    restoreState(x) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["verifyObject"])(x);
        this.lastState = x;
        super.restoreState(x);
    }
    reset() {
        this.lastState = {};
        super.reset();
    }
    baseJSON() {
        const result = Object.assign(super.baseJSON(), this.lastState);
        for (const key of this.children.keys()) {
            delete result[key];
        }
        return result;
    }
    toJSON() {
        const result = super.toJSON();
        this.lastState = result;
        return result;
    }
    add(key, value) {
        const result = super.add(key, value);
        const existingValue = this.lastState[key];
        if (existingValue !== undefined) {
            value.reset();
            value.restoreState(existingValue);
        }
        return result;
    }
}
/**
 * Cache used by getCachedJson.
 */
const jsonCache = new WeakMap();
/**
 * Returns a JSON representation of a Trackable object.
 *
 * Recursively caches the result, such that it is only necessary to traverse the changed portions of
 * the object.
 *
 * The returned value must not be modified.
 */
function getCachedJson(root) {
    let cacheState = jsonCache.get(root);
    const generation = root.changed.count;
    if (cacheState !== undefined) {
        if (cacheState.generation === generation) {
            return cacheState;
        }
    }
    let value;
    if (root instanceof CompoundTrackable) {
        value = root.baseJSON();
        for (let [k, v] of root.children) {
            value[k] = getCachedJson(v).value;
        }
    }
    else {
        value = root.toJSON();
    }
    if (cacheState === undefined) {
        cacheState = { generation, value };
        jsonCache.set(root, cacheState);
    }
    else {
        cacheState.generation = generation;
        cacheState.value = value;
    }
    return cacheState;
}


/***/ }),

/***/ "./src/neuroglancer/util/trackable_enum.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/util/trackable_enum.ts ***!
  \*************************************************/
/*! exports provided: TrackableEnum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableEnum", function() { return TrackableEnum; });
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class TrackableEnum {
    constructor(enumType, value_, defaultValue = value_) {
        this.enumType = enumType;
        this.value_ = value_;
        this.defaultValue = defaultValue;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__["NullarySignal"]();
    }
    set value(value) {
        if (this.value_ !== value) {
            this.value_ = value;
            this.changed.dispatch();
        }
    }
    get value() {
        return this.value_;
    }
    reset() {
        this.value = this.defaultValue;
    }
    restoreState(obj) {
        this.value = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_0__["verifyEnumString"])(obj, this.enumType);
    }
    toJSON() {
        return this.enumType[this.value_].toLowerCase();
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/uint64.ts":
/*!*****************************************!*\
  !*** ./src/neuroglancer/util/uint64.ts ***!
  \*****************************************/
/*! exports provided: Uint64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64", function() { return Uint64; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const randomTempBuffer = new Uint32Array(2);
const trueBase = 0x100000000;
let stringConversionData = [];
for (let base = 2; base <= 36; ++base) {
    let lowDigits = Math.floor(32 / Math.log2(base));
    let lowBase = Math.pow(base, lowDigits);
    let patternString = `^[0-${String.fromCharCode('0'.charCodeAt(0) + Math.min(9, base - 1))}`;
    if (base > 10) {
        patternString += `a-${String.fromCharCode('a'.charCodeAt(0) + base - 11)}`;
        patternString += `A-${String.fromCharCode('A'.charCodeAt(0) + base - 11)}`;
    }
    let maxDigits = Math.ceil(64 / Math.log2(base));
    patternString += `]{1,${maxDigits}}$`;
    let pattern = new RegExp(patternString);
    stringConversionData[base] = { lowDigits, lowBase, pattern };
}
/**
 * Returns the high 32 bits of the result of the 32-bit integer multiply `a` and `b`.
 *
 * The low 32-bits can be obtained using the built-in `Math.imul` function.
 */
function uint32MultiplyHigh(a, b) {
    a >>>= 0;
    b >>>= 0;
    const a00 = a & 0xFFFF, a16 = a >>> 16;
    const b00 = b & 0xFFFF, b16 = b >>> 16;
    let c00 = a00 * b00;
    let c16 = (c00 >>> 16) + (a16 * b00);
    let c32 = c16 >>> 16;
    c16 = (c16 & 0xFFFF) + (a00 * b16);
    c32 += c16 >>> 16;
    let c48 = c32 >>> 16;
    c32 = (c32 & 0xFFFF) + (a16 * b16);
    c48 += c32 >>> 16;
    return (((c48 & 0xFFFF) << 16) | (c32 & 0xFFFF)) >>> 0;
}
class Uint64 {
    constructor(low = 0, high = 0) {
        this.low = low;
        this.high = high;
    }
    clone() {
        return new Uint64(this.low, this.high);
    }
    assign(x) {
        this.low = x.low;
        this.high = x.high;
    }
    toString(base = 10) {
        let vLow = this.low, vHigh = this.high;
        if (vHigh === 0) {
            return vLow.toString(base);
        }
        vHigh *= trueBase;
        let { lowBase, lowDigits } = stringConversionData[base];
        let vHighExtra = vHigh % lowBase;
        vHigh = Math.floor(vHigh / lowBase);
        vLow += vHighExtra;
        vHigh += Math.floor(vLow / lowBase);
        vLow = vLow % lowBase;
        let vLowStr = vLow.toString(base);
        return vHigh.toString(base) + '0'.repeat(lowDigits - vLowStr.length) + vLowStr;
    }
    /**
     * Returns true if a is strictly less than b.
     */
    static less(a, b) {
        return a.high < b.high || (a.high === b.high && a.low < b.low);
    }
    /**
     * Returns a negative number if a is strictly less than b, 0 if a is equal to b, or a positive
     * number if a is strictly greater than b.
     */
    static compare(a, b) {
        return (a.high - b.high) || (a.low - b.low);
    }
    static equal(a, b) {
        return a.low === b.low && a.high === b.high;
    }
    static min(a, b) {
        return Uint64.less(a, b) ? a : b;
    }
    static max(a, b) {
        return Uint64.less(a, b) ? b : a;
    }
    static random() {
        crypto.getRandomValues(randomTempBuffer);
        return new Uint64(randomTempBuffer[0], randomTempBuffer[1]);
    }
    tryParseString(s, base = 10) {
        const { lowDigits, lowBase, pattern } = stringConversionData[base];
        if (!pattern.test(s)) {
            return false;
        }
        if (s.length <= lowDigits) {
            this.low = parseInt(s, base);
            this.high = 0;
            return true;
        }
        const splitPoint = s.length - lowDigits;
        const lowPrime = parseInt(s.substr(splitPoint), base);
        const highPrime = parseInt(s.substr(0, splitPoint), base);
        let high, low;
        if (lowBase === trueBase) {
            high = highPrime;
            low = lowPrime;
        }
        else {
            const highRemainder = Math.imul(highPrime, lowBase) >>> 0;
            high = uint32MultiplyHigh(highPrime, lowBase) +
                (Math.imul(Math.floor(highPrime / trueBase), lowBase) >>> 0);
            low = lowPrime + highRemainder;
            if (low >= trueBase) {
                ++high;
                low -= trueBase;
            }
        }
        if ((low >>> 0) !== low || ((high >>> 0) !== high)) {
            return false;
        }
        this.low = low;
        this.high = high;
        return true;
    }
    parseString(s, base = 10) {
        if (!this.tryParseString(s, base)) {
            throw new Error(`Failed to parse string as uint64 value: ${JSON.stringify(s)}.`);
        }
        return this;
    }
    static parseString(s, base = 10) {
        let x = new Uint64();
        return x.parseString(s, base);
    }
    valid() {
        let { low, high } = this;
        return ((low >>> 0) === low) && ((high >>> 0) === high);
    }
    toJSON() {
        return this.toString();
    }
    static lshift(out, input, bits) {
        const { low, high } = input;
        if (bits === 0) {
            out.low = low;
            out.high = high;
        }
        else if (bits < 32) {
            out.low = low << bits;
            out.high = (high << bits) | (low >>> (32 - bits));
        }
        else {
            out.low = 0;
            out.high = low << (bits - 32);
        }
        return out;
    }
    static rshift(out, input, bits) {
        const { low, high } = input;
        if (bits === 0) {
            out.low = low;
            out.high = high;
        }
        else if (bits < 32) {
            out.low = (low >>> bits) | (high << (32 - bits));
            out.high = high >>> bits;
        }
        else {
            out.low = high >>> (bits - 32);
            out.high = 0;
        }
        return out;
    }
    static or(out, a, b) {
        out.low = a.low | b.low;
        out.high = a.high | b.high;
        return out;
    }
    static xor(out, a, b) {
        out.low = a.low ^ b.low;
        out.high = a.high ^ b.high;
        return out;
    }
    static and(out, a, b) {
        out.low = a.low & b.low;
        out.high = a.high & b.high;
        return out;
    }
    static add(out, a, b) {
        let lowSum = a.low + b.low;
        let highSum = a.high + b.high;
        const low = lowSum >>> 0;
        if (low !== lowSum)
            highSum += 1;
        out.low = low;
        out.high = highSum >>> 0;
        return out;
    }
    static addUint32(out, a, b) {
        let lowSum = a.low + b;
        let highSum = a.high;
        const low = lowSum >>> 0;
        if (low !== lowSum)
            highSum += 1;
        out.low = low;
        out.high = highSum >>> 0;
        return out;
    }
    static decrement(out, input) {
        let { low, high } = input;
        if (low === 0) {
            high -= 1;
        }
        out.low = (low - 1) >>> 0;
        out.high = high >>> 0;
        return out;
    }
    static increment(out, input) {
        let { low, high } = input;
        if (low === 0xFFFFFFFF)
            high += 1;
        out.low = (low + 1) >>> 0;
        out.high = high >>> 0;
        return out;
    }
    static subtract(out, a, b) {
        let lowSum = a.low - b.low;
        let highSum = a.high - b.high;
        const low = lowSum >>> 0;
        if (low !== lowSum)
            highSum -= 1;
        out.low = low;
        out.high = highSum >>> 0;
        return out;
    }
    static multiplyUint32(out, a, b) {
        const { low, high } = a;
        out.low = Math.imul(low, b) >>> 0;
        out.high = (Math.imul(high, b) + uint32MultiplyHigh(low, b)) >>> 0;
        return out;
    }
    static lowMask(out, bits) {
        if (bits <= 32) {
            out.high = 0;
            out.low = 0xffffffff >>> (32 - bits);
        }
        else {
            out.high = 0xffffffff >>> (bits - 32);
            out.low = 0xffffffff;
        }
        return out;
    }
}
Uint64.ZERO = new Uint64(0, 0);
Uint64.ONE = new Uint64(1, 0);


/***/ }),

/***/ "./src/neuroglancer/util/watchable_map.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/util/watchable_map.ts ***!
  \************************************************/
/*! exports provided: WatchableMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WatchableMap", function() { return WatchableMap; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class WatchableMap extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(register, unregister, values) {
        super();
        this.register = register;
        this.unregister = unregister;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_1__["NullarySignal"]();
        if (values === undefined) {
            this.map = new Map();
        }
        else {
            this.map = new Map(values);
            this.map.forEach(this.register);
        }
    }
    set(key, value) {
        const { map } = this;
        const existing = map.get(key);
        if (existing !== undefined) {
            this.unregister(existing, key);
        }
        map.set(key, value);
        this.register(value, key);
        this.changed.dispatch();
        return this;
    }
    delete(key) {
        const { map } = this;
        const existing = map.get(key);
        if (existing !== undefined) {
            this.unregister(existing, key);
            this.changed.dispatch();
            return true;
        }
        return false;
    }
    has(key) {
        return this.map.has(key);
    }
    get size() {
        return this.map.size;
    }
    [Symbol.iterator]() {
        return this.map[Symbol.iterator]();
    }
    clear() {
        const { map } = this;
        if (map.size > 0) {
            map.forEach(this.unregister);
            map.clear();
            this.changed.dispatch();
        }
    }
    values() {
        return this.map.values();
    }
    keys() {
        return this.map.keys();
    }
    disposed() {
        const { map } = this;
        map.forEach(this.unregister);
        this.map.clear();
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/util/wheel_zoom.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/util/wheel_zoom.ts ***!
  \*********************************************/
/*! exports provided: getWheelZoomAmount */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWheelZoomAmount", function() { return getWheelZoomAmount; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DOM_DELTA_PIXEL = 0;
const DOM_DELTA_LINE = 1;
const DOM_DELTA_PAGE = 2;
function getWheelZoomAmount(event) {
    let multiplier = 0;
    let { deltaMode } = event;
    switch (deltaMode) {
        case DOM_DELTA_PIXEL:
            multiplier = 1 / 200.0;
            break;
        case DOM_DELTA_LINE:
            multiplier = 1 / 10.0;
            break;
        case DOM_DELTA_PAGE:
            multiplier = 2;
            break;
    }
    return Math.exp(event.deltaY * multiplier);
}


/***/ }),

/***/ "./src/neuroglancer/util/zorder.ts":
/*!*****************************************!*\
  !*** ./src/neuroglancer/util/zorder.ts ***!
  \*****************************************/
/*! exports provided: getOctreeChildIndex, decodeZIndexCompressed, encodeZIndexCompressed, zorder3LessThan */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOctreeChildIndex", function() { return getOctreeChildIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeZIndexCompressed", function() { return decodeZIndexCompressed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeZIndexCompressed", function() { return encodeZIndexCompressed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zorder3LessThan", function() { return zorder3LessThan; });
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getOctreeChildIndex(x, y, z) {
    return (x & 1) | ((y << 1) & 2) | ((z << 2) & 4);
}
/**
 * Decodes a "compressed" 3-d morton index.
 *
 * Decoded bit `i` of `x`, `y`, and `z` is at bit `i + min(i, yBits) + min(i, zBits)`, `i + min(i +
 * 1, xBits) + min(i, zBits)`, and `i + min(i + 1, xBits) + min(i + 1, zBits)` of `zindex`,
 * respectively, for `i` in `[0, xBits)`, `[0, yBits)`, `[0, zBits)`, respectively.
 */
function decodeZIndexCompressed(zindex, xBits, yBits, zBits) {
    const maxCoordBits = Math.max(xBits, yBits, zBits);
    let inputBit = 0;
    let inputValue = zindex.low;
    let x = 0, y = 0, z = 0;
    for (let coordBit = 0; coordBit < maxCoordBits; ++coordBit) {
        if (coordBit < xBits) {
            const bit = (inputValue >>> inputBit) & 1;
            x |= (bit << coordBit);
            if (inputBit === 31) {
                inputBit = 0;
                inputValue = zindex.high;
            }
            else {
                ++inputBit;
            }
        }
        if (coordBit < yBits) {
            const bit = (inputValue >>> inputBit) & 1;
            y |= (bit << coordBit);
            if (inputBit === 31) {
                inputBit = 0;
                inputValue = zindex.high;
            }
            else {
                ++inputBit;
            }
        }
        if (coordBit < zBits) {
            const bit = (inputValue >>> inputBit) & 1;
            z |= (bit << coordBit);
            if (inputBit === 31) {
                inputBit = 0;
                inputValue = zindex.high;
            }
            else {
                ++inputBit;
            }
        }
    }
    return Uint32Array.of(x, y, z);
}
function encodeZIndexCompressed(zindex, xBits, yBits, zBits, x, y, z) {
    const maxBits = Math.max(xBits, yBits, zBits);
    let outputBit = 0;
    let outputNum = 0;
    let isHigh = false;
    function writeBit(b) {
        outputNum |= (b & 1) << outputBit;
        if (++outputBit === 32) {
            zindex.low = outputNum;
            outputNum = 0;
            outputBit = 0;
            isHigh = true;
        }
    }
    for (let bit = 0; bit < maxBits; ++bit) {
        if (bit < xBits) {
            writeBit((x >> bit) & 1);
        }
        if (bit < yBits) {
            writeBit((y >> bit) & 1);
        }
        if (bit < zBits) {
            writeBit((z >> bit) & 1);
        }
    }
    if (isHigh) {
        zindex.high = outputNum;
    }
    else {
        zindex.high = 0;
        zindex.low = outputNum;
    }
    return zindex;
}
function lessMsb(a, b) {
    return a < b && a < (a ^ b);
}
/**
 * Returns `true` if `(x0, y0, z0)` occurs before `(x1, y1, z1)` in Z-curve order.
 */
function zorder3LessThan(x0, y0, z0, x1, y1, z1) {
    let mostSignificant0 = z0, mostSignificant1 = z1;
    if (lessMsb(mostSignificant0 ^ mostSignificant1, y0 ^ y1)) {
        mostSignificant0 = y0;
        mostSignificant1 = y1;
    }
    if (lessMsb(mostSignificant0 ^ mostSignificant1, x0 ^ x1)) {
        mostSignificant0 = x0;
        mostSignificant1 = x1;
    }
    return mostSignificant0 < mostSignificant1;
}


/***/ }),

/***/ "./src/neuroglancer/vector_graphics_user_layer.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/vector_graphics_user_layer.ts ***!
  \********************************************************/
/*! exports provided: VectorGraphicsUserLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorGraphicsUserLayer", function() { return VectorGraphicsUserLayer; });
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_sliceview_vector_graphics_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/sliceview/vector_graphics/base */ "./src/neuroglancer/sliceview/vector_graphics/base.ts");
/* harmony import */ var neuroglancer_sliceview_vector_graphics_vector_graphics_line_renderlayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/sliceview/vector_graphics/vector_graphics_line_renderlayer */ "./src/neuroglancer/sliceview/vector_graphics/vector_graphics_line_renderlayer.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/trackable_alpha */ "./src/neuroglancer/trackable_alpha.ts");
/* harmony import */ var neuroglancer_trackable_finite_float__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/trackable_finite_float */ "./src/neuroglancer/trackable_finite_float.ts");
/* harmony import */ var neuroglancer_trackable_vec3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/trackable_vec3 */ "./src/neuroglancer/trackable_vec3.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/widget/range */ "./src/neuroglancer/widget/range.ts");
/* harmony import */ var neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/widget/tab_view */ "./src/neuroglancer/widget/tab_view.ts");
/* harmony import */ var neuroglancer_widget_vec3_entry_widget__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/widget/vec3_entry_widget */ "./src/neuroglancer/widget/vec3_entry_widget.ts");
/* harmony import */ var _image_user_layer_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./image_user_layer.css */ "./src/neuroglancer/image_user_layer.css");
/* harmony import */ var _image_user_layer_css__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_image_user_layer_css__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var neuroglancer_maximize_button_css__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/maximize_button.css */ "./src/neuroglancer/maximize_button.css");
/* harmony import */ var neuroglancer_maximize_button_css__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_maximize_button_css__WEBPACK_IMPORTED_MODULE_14__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















function getVectorGraphicsWithStatusMessage(dataSourceProvider, chunkManager, x, options = {}) {
    return neuroglancer_status__WEBPACK_IMPORTED_MODULE_4__["StatusMessage"].forPromise(new Promise(function (resolve) {
        resolve(dataSourceProvider.getVectorGraphicsSource(chunkManager, x, options));
    }), {
        initialMessage: `Retrieving metadata for vector graphics source ${x}.`,
        delay: true,
        errorPrefix: `Error retrieving metadata for vector graphics source ${x}: `,
    });
}
class VectorGraphicsUserLayer extends neuroglancer_layer__WEBPACK_IMPORTED_MODULE_0__["UserLayer"] {
    constructor(manager, x) {
        super(manager, x);
        this.opacity = Object(neuroglancer_trackable_alpha__WEBPACK_IMPORTED_MODULE_5__["trackableAlphaValue"])(0.5);
        this.lineWidth = Object(neuroglancer_trackable_finite_float__WEBPACK_IMPORTED_MODULE_6__["trackableFiniteFloat"])(10.0);
        this.color = Object(neuroglancer_trackable_vec3__WEBPACK_IMPORTED_MODULE_7__["trackableVec3"])(neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_8__["vec3"].fromValues(1.0, 1.0, 1.0));
        this.opacity.restoreState(x['opacity']);
        this.lineWidth.restoreState(x['linewidth']);
        this.color.restoreState(x['color']);
        this.lineWidth.changed.add(() => {
            this.specificationChanged.dispatch();
        });
        this.color.changed.add(() => {
            this.specificationChanged.dispatch();
        });
        this.vectorGraphicsLayerType = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_9__["verifyEnumString"])(x['type'], neuroglancer_sliceview_vector_graphics_base__WEBPACK_IMPORTED_MODULE_2__["VectorGraphicsType"]);
        let vectorGraphicsPath = this.vectorGraphicsPath = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_9__["verifyOptionalString"])(x['source']);
        let remaining = 0;
        if (vectorGraphicsPath !== undefined) {
            ++remaining;
            if (this.vectorGraphicsLayerType === neuroglancer_sliceview_vector_graphics_base__WEBPACK_IMPORTED_MODULE_2__["VectorGraphicsType"].LINE) {
                getVectorGraphicsWithStatusMessage(manager.dataSourceProvider, manager.chunkManager, vectorGraphicsPath)
                    .then(vectorGraphics => {
                    if (!this.wasDisposed) {
                        let renderLayer = this.renderLayer =
                            new neuroglancer_sliceview_vector_graphics_vector_graphics_line_renderlayer__WEBPACK_IMPORTED_MODULE_3__["VectorGraphicsLineRenderLayer"](vectorGraphics, {
                                opacity: this.opacity,
                                lineWidth: this.lineWidth,
                                color: this.color,
                                sourceOptions: {}
                            });
                        this.addRenderLayer(renderLayer);
                        if (--remaining === 0) {
                            this.isReady = true;
                        }
                    }
                });
            }
        }
        this.tabs.add('rendering', { label: 'Rendering', order: -100, getter: () => new DisplayOptionsTab(this) });
        this.tabs.default = 'rendering';
    }
    toJSON() {
        const x = super.toJSON();
        x['type'] = this.getLayerType();
        x['source'] = this.vectorGraphicsPath;
        x['opacity'] = this.opacity.toJSON();
        x['linewidth'] = this.lineWidth.toJSON();
        x['color'] = this.color.toJSON();
        return x;
    }
    getLayerType() {
        let typeStr = neuroglancer_sliceview_vector_graphics_base__WEBPACK_IMPORTED_MODULE_2__["VectorGraphicsType"][this.vectorGraphicsLayerType];
        return typeStr.toLowerCase();
    }
}
class DisplayOptionsTab extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_11__["Tab"] {
    constructor(layer) {
        super();
        this.layer = layer;
        this.opacityWidget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_10__["RangeWidget"](this.layer.opacity));
        this.lineWidthWidget = this.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_10__["RangeWidget"](this.layer.lineWidth, { min: 0, max: 50, step: 1 }));
        this.colorWidget = this.registerDisposer(new VectorGraphicsColorWidget(this.layer.color));
        const { element } = this;
        element.classList.add('image-dropdown');
        let { opacityWidget, lineWidthWidget, colorWidget } = this;
        let topRow = document.createElement('div');
        topRow.className = 'image-dropdown-top-row';
        opacityWidget.promptElement.textContent = 'Opacity';
        lineWidthWidget.promptElement.textContent = 'Line Width';
        colorWidget.promptElement.textContent = 'Color';
        let spacer = document.createElement('div');
        spacer.style.flex = '1';
        let helpLink = document.createElement('a');
        let helpButton = document.createElement('button');
        helpButton.type = 'button';
        helpButton.textContent = '?';
        helpButton.className = 'help-link';
        helpLink.appendChild(helpButton);
        helpLink.title = 'Documentation on vector graphics layer rendering';
        helpLink.target = '_blank';
        helpLink.href =
            'https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/vectorgraphics_layer_rendering.md';
        topRow.appendChild(spacer);
        topRow.appendChild(helpLink);
        element.appendChild(topRow);
        element.appendChild(this.opacityWidget.element);
        element.appendChild(this.lineWidthWidget.element);
        element.appendChild(this.colorWidget.element);
    }
}
class VectorGraphicsColorWidget extends neuroglancer_widget_vec3_entry_widget__WEBPACK_IMPORTED_MODULE_12__["Vec3Widget"] {
    constructor(model) {
        super(model);
    }
    verifyValue(value) {
        let num = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_9__["verifyFiniteFloat"])(value);
        // Scale from [0,255] to [0,1]
        num = num / 255.0;
        if (num < 0.) {
            return 0.;
        }
        if (num > 1.) {
            return 1.;
        }
        return num;
    }
    updateInput() {
        this.inputx.valueAsNumber = Math.round(this.model.value[0] * 255.);
        this.inputy.valueAsNumber = Math.round(this.model.value[1] * 255.);
        this.inputz.valueAsNumber = Math.round(this.model.value[2] * 255.);
    }
}
Object(neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_1__["registerLayerType"])('line', VectorGraphicsUserLayer);
// registerLayerType('point', VectorGraphicsUserLayer);


/***/ }),

/***/ "./src/neuroglancer/viewer.css":
/*!*************************************!*\
  !*** ./src/neuroglancer/viewer.css ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/viewer.ts":
/*!************************************!*\
  !*** ./src/neuroglancer/viewer.ts ***!
  \************************************/
/*! exports provided: DataManagementContext, InputEventBindings, ViewerUIControlConfiguration, ViewerUIConfiguration, Viewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataManagementContext", function() { return DataManagementContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputEventBindings", function() { return InputEventBindings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewerUIControlConfiguration", function() { return ViewerUIControlConfiguration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewerUIConfiguration", function() { return ViewerUIConfiguration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Viewer", function() { return Viewer; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/chunk_manager/frontend */ "./src/neuroglancer/chunk_manager/frontend.ts");
/* harmony import */ var neuroglancer_credentials_provider_default_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/credentials_provider/default_manager */ "./src/neuroglancer/credentials_provider/default_manager.ts");
/* harmony import */ var neuroglancer_data_panel_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/data_panel_layout */ "./src/neuroglancer/data_panel_layout.ts");
/* harmony import */ var neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/datasource/default_provider */ "./src/neuroglancer/datasource/default_provider.ts");
/* harmony import */ var neuroglancer_help_input_event_bindings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/help/input_event_bindings */ "./src/neuroglancer/help/input_event_bindings.ts");
/* harmony import */ var neuroglancer_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/layer */ "./src/neuroglancer/layer.ts");
/* harmony import */ var neuroglancer_layer_dialog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/layer_dialog */ "./src/neuroglancer/layer_dialog.ts");
/* harmony import */ var neuroglancer_layer_groups_layout__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/layer_groups_layout */ "./src/neuroglancer/layer_groups_layout.ts");
/* harmony import */ var neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/layer_specification */ "./src/neuroglancer/layer_specification.ts");
/* harmony import */ var neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/navigation_state */ "./src/neuroglancer/navigation_state.ts");
/* harmony import */ var neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/overlay */ "./src/neuroglancer/overlay.ts");
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! neuroglancer/trackable_boolean */ "./src/neuroglancer/trackable_boolean.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_ui_context_menu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! neuroglancer/ui/context_menu */ "./src/neuroglancer/ui/context_menu.ts");
/* harmony import */ var neuroglancer_ui_drag_resize__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! neuroglancer/ui/drag_resize */ "./src/neuroglancer/ui/drag_resize.ts");
/* harmony import */ var neuroglancer_ui_layer_side_panel__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! neuroglancer/ui/layer_side_panel */ "./src/neuroglancer/ui/layer_side_panel.ts");
/* harmony import */ var neuroglancer_ui_mouse_selection_state_tooltip__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! neuroglancer/ui/mouse_selection_state_tooltip */ "./src/neuroglancer/ui/mouse_selection_state_tooltip.ts");
/* harmony import */ var neuroglancer_ui_position_drag_and_drop__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! neuroglancer/ui/position_drag_and_drop */ "./src/neuroglancer/ui/position_drag_and_drop.ts");
/* harmony import */ var neuroglancer_ui_state_editor__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! neuroglancer/ui/state_editor */ "./src/neuroglancer/ui/state_editor.ts");
/* harmony import */ var neuroglancer_ui_statistics__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! neuroglancer/ui/statistics */ "./src/neuroglancer/ui/statistics.ts");
/* harmony import */ var neuroglancer_util_automatic_focus__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! neuroglancer/util/automatic_focus */ "./src/neuroglancer/util/automatic_focus.ts");
/* harmony import */ var neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! neuroglancer/util/color */ "./src/neuroglancer/util/color.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! neuroglancer/util/keyboard_bindings */ "./src/neuroglancer/util/keyboard_bindings.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! neuroglancer/util/trackable */ "./src/neuroglancer/util/trackable.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/* harmony import */ var neuroglancer_widget_annotation_tool_status__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! neuroglancer/widget/annotation_tool_status */ "./src/neuroglancer/widget/annotation_tool_status.ts");
/* harmony import */ var neuroglancer_widget_number_input_widget__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! neuroglancer/widget/number_input_widget */ "./src/neuroglancer/widget/number_input_widget.ts");
/* harmony import */ var neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! neuroglancer/widget/position_widget */ "./src/neuroglancer/widget/position_widget.ts");
/* harmony import */ var neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! neuroglancer/widget/scale_bar */ "./src/neuroglancer/widget/scale_bar.ts");
/* harmony import */ var neuroglancer_widget_text_icon_button__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! neuroglancer/widget/text_icon_button */ "./src/neuroglancer/widget/text_icon_button.ts");
/* harmony import */ var neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! neuroglancer/worker_rpc */ "./src/neuroglancer/worker_rpc.ts");
/* harmony import */ var _viewer_css__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./viewer.css */ "./src/neuroglancer/viewer.css");
/* harmony import */ var _viewer_css__WEBPACK_IMPORTED_MODULE_38___default = /*#__PURE__*/__webpack_require__.n(_viewer_css__WEBPACK_IMPORTED_MODULE_38__);
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! neuroglancer/noselect.css */ "./src/neuroglancer/noselect.css");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_39___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_39__);
/* harmony import */ var neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! neuroglancer/ui/button.css */ "./src/neuroglancer/ui/button.css");
/* harmony import */ var neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_40___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_40__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









































class DataManagementContext extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_24__["RefCounted"] {
    constructor(gl, frameNumberCounter, bundleRoot = '') {
        super();
        this.gl = gl;
        this.frameNumberCounter = frameNumberCounter;
        const chunk_worker_url = bundleRoot + 'chunk_worker.bundle.js';
        this.worker = new Worker(chunk_worker_url);
        this.chunkQueueManager = this.registerDisposer(new neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["ChunkQueueManager"](new neuroglancer_worker_rpc__WEBPACK_IMPORTED_MODULE_37__["RPC"](this.worker), this.gl, this.frameNumberCounter, {
            gpuMemory: new neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["CapacitySpecification"]({ defaultItemLimit: 1e6, defaultSizeLimit: 1e9 }),
            systemMemory: new neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["CapacitySpecification"]({ defaultItemLimit: 1e7, defaultSizeLimit: 2e9 }),
            download: new neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["CapacitySpecification"]({ defaultItemLimit: 32, defaultSizeLimit: Number.POSITIVE_INFINITY }),
            compute: new neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["CapacitySpecification"]({ defaultItemLimit: 128, defaultSizeLimit: 5e8 }),
        }));
        this.chunkQueueManager.registerDisposer(() => this.worker.terminate());
        this.chunkManager = this.registerDisposer(new neuroglancer_chunk_manager_frontend__WEBPACK_IMPORTED_MODULE_1__["ChunkManager"](this.chunkQueueManager));
    }
    get rpc() {
        return this.chunkQueueManager.rpc;
    }
}
class InputEventBindings extends neuroglancer_data_panel_layout__WEBPACK_IMPORTED_MODULE_3__["InputEventBindings"] {
    constructor() {
        super(...arguments);
        this.global = new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_28__["EventActionMap"]();
    }
}
const viewerUiControlOptionKeys = [
    'showHelpButton',
    'showEditStateButton',
    'showLayerPanel',
    'showLocation',
    'showAnnotationToolStatus',
];
const viewerOptionKeys = ['showUIControls', 'showPanelBorders', ...viewerUiControlOptionKeys];
class ViewerUIControlConfiguration {
    constructor() {
        this.showHelpButton = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true);
        this.showEditStateButton = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true);
        this.showLayerPanel = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true);
        this.showLocation = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true);
        this.showAnnotationToolStatus = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true);
    }
}
class ViewerUIConfiguration extends ViewerUIControlConfiguration {
    constructor() {
        super(...arguments);
        /**
         * If set to false, all UI controls (controlled individually by the options below) are disabled.
         */
        this.showUIControls = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true);
        this.showPanelBorders = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true);
    }
}
function setViewerUiConfiguration(config, options) {
    for (const key of viewerOptionKeys) {
        const value = options[key];
        if (value !== undefined) {
            config[key].value = value;
        }
    }
}
const defaultViewerOptions = "undefined" !== typeof NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS ?
    NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS : {
    showLayerDialog: true,
    resetStateWhenEmpty: true,
};
function makeViewerContextMenu(viewer) {
    const menu = new neuroglancer_ui_context_menu__WEBPACK_IMPORTED_MODULE_15__["ContextMenu"]();
    const { element } = menu;
    element.classList.add('neuroglancer-viewer-context-menu');
    const addLimitWidget = (label, limit) => {
        const widget = menu.registerDisposer(new neuroglancer_widget_number_input_widget__WEBPACK_IMPORTED_MODULE_33__["NumberInputWidget"](limit, { label }));
        widget.element.classList.add('neuroglancer-viewer-context-menu-limit-widget');
        element.appendChild(widget.element);
    };
    addLimitWidget('GPU memory limit', viewer.chunkQueueManager.capacities.gpuMemory.sizeLimit);
    addLimitWidget('System memory limit', viewer.chunkQueueManager.capacities.systemMemory.sizeLimit);
    addLimitWidget('Concurrent chunk requests', viewer.chunkQueueManager.capacities.download.itemLimit);
    const addCheckbox = (label, value) => {
        const labelElement = document.createElement('label');
        labelElement.textContent = label;
        const checkbox = menu.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBooleanCheckbox"](value));
        labelElement.appendChild(checkbox.element);
        element.appendChild(labelElement);
    };
    addCheckbox('Show axis lines', viewer.showAxisLines);
    addCheckbox('Show scale bar', viewer.showScaleBar);
    addCheckbox('Show cross sections in 3-d', viewer.showPerspectiveSliceViews);
    addCheckbox('Show default annotations', viewer.showDefaultAnnotations);
    addCheckbox('Show chunk statistics', viewer.statisticsDisplayState.visible);
    return menu;
}
class Viewer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_24__["RefCounted"] {
    constructor(display, options = {}) {
        super();
        this.display = display;
        this.navigationState = this.registerDisposer(new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_10__["NavigationState"]());
        this.perspectiveNavigationState = new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_10__["NavigationState"](new neuroglancer_navigation_state__WEBPACK_IMPORTED_MODULE_10__["Pose"](this.navigationState.position), 1);
        this.mouseState = new neuroglancer_layer__WEBPACK_IMPORTED_MODULE_6__["MouseSelectionState"]();
        this.layerManager = this.registerDisposer(new neuroglancer_layer__WEBPACK_IMPORTED_MODULE_6__["LayerManager"]());
        this.selectedLayer = this.registerDisposer(new neuroglancer_layer__WEBPACK_IMPORTED_MODULE_6__["SelectedLayerState"](this.layerManager.addRef()));
        this.showAxisLines = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true, true);
        this.showScaleBar = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true, true);
        this.showPerspectiveSliceViews = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true, true);
        this.visibleLayerRoles = Object(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_6__["allRenderLayerRoles"])();
        this.showDefaultAnnotations = new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["TrackableBoolean"](true, true);
        this.crossSectionBackgroundColor = new neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_23__["TrackableRGB"](neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_27__["vec3"].fromValues(0.5, 0.5, 0.5));
        this.perspectiveViewBackgroundColor = new neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_23__["TrackableRGB"](neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_27__["vec3"].fromValues(0, 0, 0));
        this.scaleBarOptions = new neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_35__["TrackableScaleBarOptions"]();
        this.statisticsDisplayState = new neuroglancer_ui_statistics__WEBPACK_IMPORTED_MODULE_21__["StatisticsDisplayState"]();
        this.layerSelectedValues = this.registerDisposer(new neuroglancer_layer__WEBPACK_IMPORTED_MODULE_6__["LayerSelectedValues"](this.layerManager, this.mouseState));
        this.resetInitiated = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_29__["NullarySignal"]();
        this.state = new neuroglancer_util_trackable__WEBPACK_IMPORTED_MODULE_30__["CompoundTrackable"]();
        /**
         * Logical and of each of the above values with the value of showUIControls.
         */
        this.uiControlVisibility = {};
        this.visible = true;
        const { dataContext = new DataManagementContext(display.gl, display, options.bundleRoot), visibility = new neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_31__["WatchableVisibilityPriority"](neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_31__["WatchableVisibilityPriority"].VISIBLE), inputEventBindings = {
            global: new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_28__["EventActionMap"](),
            sliceView: new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_28__["EventActionMap"](),
            perspectiveView: new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_28__["EventActionMap"](),
        }, element = display.makeCanvasOverlayElement(), dataSourceProvider = Object(neuroglancer_datasource_default_provider__WEBPACK_IMPORTED_MODULE_4__["getDefaultDataSourceProvider"])({ credentialsManager: neuroglancer_credentials_provider_default_manager__WEBPACK_IMPORTED_MODULE_2__["defaultCredentialsManager"] }), uiConfiguration = new ViewerUIConfiguration(), } = options;
        this.visibility = visibility;
        this.inputEventBindings = inputEventBindings;
        this.element = element;
        this.dataSourceProvider = dataSourceProvider;
        this.uiConfiguration = uiConfiguration;
        this.registerDisposer(() => Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_25__["removeFromParent"])(this.element));
        this.dataContext = this.registerDisposer(dataContext);
        setViewerUiConfiguration(uiConfiguration, options);
        const optionsWithDefaults = Object.assign({}, defaultViewerOptions, options);
        const { resetStateWhenEmpty, showLayerDialog, } = optionsWithDefaults;
        for (const key of viewerUiControlOptionKeys) {
            this.uiControlVisibility[key] = this.makeUiControlVisibilityState(key);
        }
        this.registerDisposer(this.uiConfiguration.showPanelBorders.changed.add(() => {
            this.updateShowBorders();
        }));
        this.showLayerDialog = showLayerDialog;
        this.resetStateWhenEmpty = resetStateWhenEmpty;
        this.layerSpecification = new neuroglancer_layer_specification__WEBPACK_IMPORTED_MODULE_9__["TopLevelLayerListSpecification"](this.dataSourceProvider, this.layerManager, this.chunkManager, this.layerSelectedValues, this.navigationState.voxelSize);
        this.registerDisposer(display.updateStarted.add(() => {
            this.onUpdateDisplay();
        }));
        this.showDefaultAnnotations.changed.add(() => {
            if (this.showDefaultAnnotations.value) {
                this.visibleLayerRoles.add(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_6__["RenderLayerRole"].DEFAULT_ANNOTATION);
            }
            else {
                this.visibleLayerRoles.delete(neuroglancer_layer__WEBPACK_IMPORTED_MODULE_6__["RenderLayerRole"].DEFAULT_ANNOTATION);
            }
        });
        const { state } = this;
        state.add('layers', this.layerSpecification);
        state.add('navigation', this.navigationState);
        state.add('showAxisLines', this.showAxisLines);
        state.add('showScaleBar', this.showScaleBar);
        state.add('showDefaultAnnotations', this.showDefaultAnnotations);
        state.add('perspectiveOrientation', this.perspectiveNavigationState.pose.orientation);
        state.add('perspectiveZoom', this.perspectiveNavigationState.zoomFactor);
        state.add('showSlices', this.showPerspectiveSliceViews);
        state.add('gpuMemoryLimit', this.dataContext.chunkQueueManager.capacities.gpuMemory.sizeLimit);
        state.add('systemMemoryLimit', this.dataContext.chunkQueueManager.capacities.systemMemory.sizeLimit);
        state.add('concurrentDownloads', this.dataContext.chunkQueueManager.capacities.download.itemLimit);
        state.add('selectedLayer', this.selectedLayer);
        state.add('crossSectionBackgroundColor', this.crossSectionBackgroundColor);
        state.add('perspectiveViewBackgroundColor', this.perspectiveViewBackgroundColor);
        this.registerDisposer(this.navigationState.changed.add(() => {
            this.handleNavigationStateChanged();
        }));
        this.layerManager.initializePosition(this.navigationState.position);
        this.registerDisposer(this.layerSpecification.voxelCoordinatesSet.add((voxelCoordinates) => {
            this.navigationState.position.setVoxelCoordinates(voxelCoordinates);
        }));
        this.registerDisposer(this.layerSpecification.spatialCoordinatesSet.add((spatialCoordinates) => {
            const { position } = this.navigationState;
            neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_27__["vec3"].copy(position.spatialCoordinates, spatialCoordinates);
            position.markSpatialCoordinatesChanged();
        }));
        // Debounce this call to ensure that a transient state does not result in the layer dialog being
        // shown.
        const maybeResetState = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
            if (!this.wasDisposed && this.layerManager.managedLayers.length === 0 &&
                this.resetStateWhenEmpty) {
                // No layers, reset state.
                this.navigationState.reset();
                this.perspectiveNavigationState.pose.orientation.reset();
                this.perspectiveNavigationState.zoomFactor.reset();
                this.resetInitiated.dispatch();
                if (!neuroglancer_overlay__WEBPACK_IMPORTED_MODULE_11__["overlaysOpen"] && this.showLayerDialog && this.visibility.visible) {
                    new neuroglancer_layer_dialog__WEBPACK_IMPORTED_MODULE_7__["LayerDialog"](this.layerSpecification);
                }
            }
        }));
        this.layerManager.layersChanged.add(maybeResetState);
        maybeResetState();
        this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
            this.layerSelectedValues.handleLayerChange();
        }));
        this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
            if (this.visible) {
                display.scheduleRedraw();
            }
        }));
        this.makeUI();
        this.updateShowBorders();
        state.add('layout', this.layout);
        state.add('statistics', this.statisticsDisplayState);
        this.registerActionListeners();
        this.registerEventActionBindings();
        this.registerDisposer(Object(neuroglancer_ui_position_drag_and_drop__WEBPACK_IMPORTED_MODULE_19__["setupPositionDropHandlers"])(element, this.navigationState.position));
        this.registerDisposer(new neuroglancer_ui_mouse_selection_state_tooltip__WEBPACK_IMPORTED_MODULE_18__["MouseSelectionStateTooltipManager"](this.mouseState, this.layerManager, this.navigationState.voxelSize));
    }
    get chunkManager() {
        return this.dataContext.chunkManager;
    }
    get chunkQueueManager() {
        return this.dataContext.chunkQueueManager;
    }
    makeUiControlVisibilityState(key) {
        const showUIControls = this.uiConfiguration.showUIControls;
        const option = this.uiConfiguration[key];
        return this.registerDisposer(Object(neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_14__["makeDerivedWatchableValue"])((a, b) => a && b, showUIControls, option));
    }
    get inputEventMap() {
        return this.inputEventBindings.global;
    }
    updateShowBorders() {
        const { element } = this;
        const className = 'neuroglancer-show-panel-borders';
        if (this.uiConfiguration.showPanelBorders.value) {
            element.classList.add(className);
        }
        else {
            element.classList.remove(className);
        }
    }
    makeUI() {
        const gridContainer = this.element;
        gridContainer.classList.add('neuroglancer-viewer');
        gridContainer.classList.add('neuroglancer-noselect');
        gridContainer.style.display = 'flex';
        gridContainer.style.flexDirection = 'column';
        const topRow = document.createElement('div');
        topRow.title = 'Right click for settings';
        topRow.classList.add('neuroglancer-viewer-top-row');
        const contextMenu = this.contextMenu = this.registerDisposer(makeViewerContextMenu(this));
        contextMenu.registerParent(topRow);
        topRow.style.display = 'flex';
        topRow.style.flexDirection = 'row';
        topRow.style.alignItems = 'stretch';
        const voxelSizeWidget = this.registerDisposer(new neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_34__["VoxelSizeWidget"](document.createElement('div'), this.navigationState.voxelSize));
        this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["ElementVisibilityFromTrackableBoolean"](this.uiControlVisibility.showLocation, voxelSizeWidget.element));
        topRow.appendChild(voxelSizeWidget.element);
        const positionWidget = this.registerDisposer(new neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_34__["PositionWidget"](this.navigationState.position));
        this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["ElementVisibilityFromTrackableBoolean"](this.uiControlVisibility.showLocation, positionWidget.element));
        topRow.appendChild(positionWidget.element);
        const mousePositionWidget = this.registerDisposer(new neuroglancer_widget_position_widget__WEBPACK_IMPORTED_MODULE_34__["MousePositionWidget"](document.createElement('div'), this.mouseState, this.navigationState.voxelSize));
        mousePositionWidget.element.style.flex = '1';
        mousePositionWidget.element.style.alignSelf = 'center';
        this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["ElementVisibilityFromTrackableBoolean"](this.uiControlVisibility.showLocation, mousePositionWidget.element));
        topRow.appendChild(mousePositionWidget.element);
        const annotationToolStatus = this.registerDisposer(new neuroglancer_widget_annotation_tool_status__WEBPACK_IMPORTED_MODULE_32__["AnnotationToolStatusWidget"](this.selectedLayer));
        topRow.appendChild(annotationToolStatus.element);
        this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["ElementVisibilityFromTrackableBoolean"](this.uiControlVisibility.showAnnotationToolStatus, annotationToolStatus.element));
        {
            const button = Object(neuroglancer_widget_text_icon_button__WEBPACK_IMPORTED_MODULE_36__["makeTextIconButton"])('{}', 'Edit JSON state');
            this.registerEventListener(button, 'click', () => {
                this.editJsonState();
            });
            this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["ElementVisibilityFromTrackableBoolean"](this.uiControlVisibility.showEditStateButton, button));
            topRow.appendChild(button);
        }
        {
            const button = Object(neuroglancer_widget_text_icon_button__WEBPACK_IMPORTED_MODULE_36__["makeTextIconButton"])('?', 'Help');
            this.registerEventListener(button, 'click', () => {
                this.showHelpDialog();
            });
            this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["ElementVisibilityFromTrackableBoolean"](this.uiControlVisibility.showHelpButton, button));
            topRow.appendChild(button);
        }
        this.registerDisposer(new neuroglancer_trackable_boolean__WEBPACK_IMPORTED_MODULE_13__["ElementVisibilityFromTrackableBoolean"](Object(neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_14__["makeDerivedWatchableValue"])((...values) => values.reduce((a, b) => a || b, false), this.uiControlVisibility.showHelpButton, this.uiControlVisibility.showEditStateButton, this.uiControlVisibility.showLocation, this.uiControlVisibility.showAnnotationToolStatus), topRow));
        gridContainer.appendChild(topRow);
        const layoutAndSidePanel = document.createElement('div');
        layoutAndSidePanel.style.display = 'flex';
        layoutAndSidePanel.style.flex = '1';
        layoutAndSidePanel.style.flexDirection = 'row';
        this.layout = this.registerDisposer(new neuroglancer_layer_groups_layout__WEBPACK_IMPORTED_MODULE_8__["RootLayoutContainer"](this, '4panel'));
        layoutAndSidePanel.appendChild(this.layout.element);
        const layerInfoPanel = this.registerDisposer(new neuroglancer_ui_layer_side_panel__WEBPACK_IMPORTED_MODULE_17__["LayerInfoPanelContainer"](this.selectedLayer.addRef()));
        layoutAndSidePanel.appendChild(layerInfoPanel.element);
        const self = this;
        layerInfoPanel.registerDisposer(new neuroglancer_ui_drag_resize__WEBPACK_IMPORTED_MODULE_16__["DragResizablePanel"](layerInfoPanel.element, {
            changed: self.selectedLayer.changed,
            get value() {
                return self.selectedLayer.visible;
            },
            set value(visible) {
                self.selectedLayer.visible = visible;
            }
        }, this.selectedLayer.size, 'horizontal', 290));
        gridContainer.appendChild(layoutAndSidePanel);
        const statisticsPanel = this.registerDisposer(new neuroglancer_ui_statistics__WEBPACK_IMPORTED_MODULE_21__["StatisticsPanel"](this.chunkQueueManager, this.statisticsDisplayState));
        gridContainer.appendChild(statisticsPanel.element);
        statisticsPanel.registerDisposer(new neuroglancer_ui_drag_resize__WEBPACK_IMPORTED_MODULE_16__["DragResizablePanel"](statisticsPanel.element, this.statisticsDisplayState.visible, this.statisticsDisplayState.size, 'vertical'));
        const updateVisibility = () => {
            const shouldBeVisible = this.visibility.visible;
            if (shouldBeVisible !== this.visible) {
                gridContainer.style.visibility = shouldBeVisible ? 'inherit' : 'hidden';
                this.visible = shouldBeVisible;
            }
        };
        updateVisibility();
        this.registerDisposer(this.visibility.changed.add(updateVisibility));
    }
    /**
     * Called once by the constructor to set up event handlers.
     */
    registerEventActionBindings() {
        const { element } = this;
        this.registerDisposer(new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_28__["KeyboardEventBinder"](element, this.inputEventMap));
        this.registerDisposer(new neuroglancer_util_automatic_focus__WEBPACK_IMPORTED_MODULE_22__["AutomaticallyFocusedElement"](element));
    }
    bindAction(action, handler) {
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_26__["registerActionListener"])(this.element, action, handler));
    }
    /**
     * Called once by the constructor to register the action listeners.
     */
    registerActionListeners() {
        for (const action of ['recolor', 'clear-segments',]) {
            this.bindAction(action, () => {
                this.layerManager.invokeAction(action);
            });
        }
        for (const action of ['select']) {
            this.bindAction(action, () => {
                this.mouseState.updateUnconditionally();
                this.layerManager.invokeAction(action);
            });
        }
        this.bindAction('help', () => this.showHelpDialog());
        for (let i = 1; i <= 9; ++i) {
            this.bindAction(`toggle-layer-${i}`, () => {
                const layerIndex = i - 1;
                const layers = this.layerManager.managedLayers;
                if (layerIndex < layers.length) {
                    let layer = layers[layerIndex];
                    layer.setVisible(!layer.visible);
                }
            });
            this.bindAction(`select-layer-${i}`, () => {
                const layerIndex = i - 1;
                const layers = this.layerManager.managedLayers;
                if (layerIndex < layers.length) {
                    const layer = layers[layerIndex];
                    this.selectedLayer.layer = layer;
                    this.selectedLayer.visible = true;
                }
            });
        }
        this.bindAction('annotate', () => {
            const selectedLayer = this.selectedLayer.layer;
            if (selectedLayer === undefined) {
                neuroglancer_status__WEBPACK_IMPORTED_MODULE_12__["StatusMessage"].showTemporaryMessage('The annotate command requires a layer to be selected.');
                return;
            }
            const userLayer = selectedLayer.layer;
            if (userLayer === null || userLayer.tool.value === undefined) {
                neuroglancer_status__WEBPACK_IMPORTED_MODULE_12__["StatusMessage"].showTemporaryMessage(`The selected layer (${JSON.stringify(selectedLayer.name)}) does not have an active annotation tool.`);
                return;
            }
            userLayer.tool.value.trigger(this.mouseState);
        });
        this.bindAction('toggle-axis-lines', () => this.showAxisLines.toggle());
        this.bindAction('toggle-scale-bar', () => this.showScaleBar.toggle());
        this.bindAction('toggle-default-annotations', () => this.showDefaultAnnotations.toggle());
        this.bindAction('toggle-show-slices', () => this.showPerspectiveSliceViews.toggle());
        this.bindAction('toggle-show-statistics', () => this.showStatistics());
    }
    showHelpDialog() {
        const { inputEventBindings } = this;
        new neuroglancer_help_input_event_bindings__WEBPACK_IMPORTED_MODULE_5__["InputEventBindingHelpDialog"]([
            ['Global', inputEventBindings.global],
            ['Slice View', inputEventBindings.sliceView],
            ['Perspective View', inputEventBindings.perspectiveView],
        ]);
    }
    editJsonState() {
        new neuroglancer_ui_state_editor__WEBPACK_IMPORTED_MODULE_20__["StateEditorDialog"](this);
    }
    showStatistics(value = undefined) {
        if (value === undefined) {
            value = !this.statisticsDisplayState.visible.value;
        }
        this.statisticsDisplayState.visible.value = value;
    }
    get gl() {
        return this.display.gl;
    }
    onUpdateDisplay() {
        if (this.visible) {
            this.dataContext.chunkQueueManager.chunkUpdateDeadline = null;
        }
    }
    handleNavigationStateChanged() {
        if (this.visible) {
            let { chunkQueueManager } = this.dataContext;
            if (chunkQueueManager.chunkUpdateDeadline === null) {
                chunkQueueManager.chunkUpdateDeadline = Date.now() + 10;
            }
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/visibility_priority/frontend.ts":
/*!**********************************************************!*\
  !*** ./src/neuroglancer/visibility_priority/frontend.ts ***!
  \**********************************************************/
/*! exports provided: WatchableVisibilityPriority, VisibilityPriorityAggregator, withSharedVisibility */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WatchableVisibilityPriority", function() { return WatchableVisibilityPriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VisibilityPriorityAggregator", function() { return VisibilityPriorityAggregator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withSharedVisibility", function() { return withSharedVisibility; });
/* harmony import */ var neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/shared_watchable_value */ "./src/neuroglancer/shared_watchable_value.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class WatchableVisibilityPriority extends neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_1__["WatchableValue"] {
    constructor(value = Number.NEGATIVE_INFINITY) {
        super(value);
    }
    get visible() {
        return this.value === Number.POSITIVE_INFINITY;
    }
    get ignored() {
        return this.value === Number.NEGATIVE_INFINITY;
    }
}
WatchableVisibilityPriority.VISIBLE = Number.POSITIVE_INFINITY;
WatchableVisibilityPriority.IGNORED = Number.NEGATIVE_INFINITY;
/**
 * Maintains the maximum value of multiple WatchableVisibilityPriority values.
 */
class VisibilityPriorityAggregator extends WatchableVisibilityPriority {
    constructor() {
        super(...arguments);
        this.contributors = new Map();
    }
    /**
     * Registers `x` to be included in the set of values to be aggregated.
     *
     * @returns A disposer function that unregisters the specified value.
     */
    add(x) {
        const { contributors } = this;
        const changedDisposer = x.changed.add(() => {
            this.update();
        });
        const disposer = () => {
            contributors.delete(disposer);
            changedDisposer();
            this.update();
        };
        contributors.set(disposer, x);
        this.update();
        return disposer;
    }
    update() {
        let priority = Number.NEGATIVE_INFINITY;
        for (const x of this.contributors.values()) {
            priority = Math.max(priority, x.value);
        }
        this.value = priority;
    }
}
/**
 * Mixin that adds a `visibility` property which is shared with the counterpart.
 */
function withSharedVisibility(Base) {
    return class extends Base {
        constructor() {
            super(...arguments);
            this.visibility = new VisibilityPriorityAggregator();
        }
        initializeCounterpart(rpc, options = {}) {
            // Backend doesn't need to own a reference to SharedWatchableValue because frontend, which is
            // the owner of this SharedObject, owns a reference.
            options['visibility'] =
                this.registerDisposer(neuroglancer_shared_watchable_value__WEBPACK_IMPORTED_MODULE_0__["SharedWatchableValue"].makeFromExisting(rpc, this.visibility)).rpcId;
            super.initializeCounterpart(rpc, options);
        }
    };
}


/***/ }),

/***/ "./src/neuroglancer/webgl/buffer.ts":
/*!******************************************!*\
  !*** ./src/neuroglancer/webgl/buffer.ts ***!
  \******************************************/
/*! exports provided: Buffer, getMemoizedBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Buffer", function() { return Buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMemoizedBuffer", function() { return getMemoizedBuffer; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Buffer {
    constructor(gl, bufferType = WebGL2RenderingContext.ARRAY_BUFFER) {
        this.gl = gl;
        this.bufferType = bufferType;
        this.gl = gl;
        // This should never return null.
        this.buffer = gl.createBuffer();
    }
    bind() {
        this.gl.bindBuffer(this.bufferType, this.buffer);
    }
    bindToVertexAttrib(location, componentsPerVertexAttribute, attributeType = WebGL2RenderingContext.FLOAT, normalized = false, stride = 0, offset = 0) {
        this.bind();
        this.gl.enableVertexAttribArray(location);
        this.gl.vertexAttribPointer(location, componentsPerVertexAttribute, attributeType, normalized, stride, offset);
    }
    bindToVertexAttribI(location, componentsPerVertexAttribute, attributeType = WebGL2RenderingContext.UNSIGNED_INT, stride = 0, offset = 0) {
        this.bind();
        this.gl.enableVertexAttribArray(location);
        this.gl.vertexAttribIPointer(location, componentsPerVertexAttribute, attributeType, stride, offset);
    }
    setData(data, usage = WebGL2RenderingContext.STATIC_DRAW) {
        let gl = this.gl;
        this.bind();
        gl.bufferData(this.bufferType, data, usage);
    }
    dispose() {
        this.gl.deleteBuffer(this.buffer);
        this.buffer = undefined;
        this.gl = undefined;
    }
    static fromData(gl, data, bufferType, usage) {
        let buffer = new Buffer(gl, bufferType);
        buffer.setData(data, usage);
        return buffer;
    }
}
function getMemoizedBuffer(gl, bufferType, getter, ...args) {
    return gl.memoize.get(Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_1__["stableStringify"])({ id: 'getMemoizedBuffer', getter: Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_2__["getObjectId"])(getter), args }), () => {
        const result = new neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCountedValue"](Buffer.fromData(gl, getter(...args), bufferType, WebGL2RenderingContext.STATIC_DRAW));
        result.registerDisposer(result.value);
        return result;
    });
}


/***/ }),

/***/ "./src/neuroglancer/webgl/circles.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/webgl/circles.ts ***!
  \*******************************************/
/*! exports provided: VERTICES_PER_CIRCLE, CircleShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICES_PER_CIRCLE", function() { return VERTICES_PER_CIRCLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleShader", function() { return CircleShader; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_webgl_quad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/webgl/quad */ "./src/neuroglancer/webgl/quad.ts");
/* harmony import */ var neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/square_corners_buffer */ "./src/neuroglancer/webgl/square_corners_buffer.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for drawing circles in WebGL as quads (triangle fan).
 */



const VERTICES_PER_CIRCLE = 4;
class CircleShader extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl, circlesPerInstance = 1) {
        super();
        this.circlesPerInstance = circlesPerInstance;
        this.squareCornersBuffer = Object(neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_2__["getSquareCornersBuffer"])(gl, -1, -1, 1, 1, /*minorTiles=*/ circlesPerInstance, /*majorTiles=*/ 1);
        this.quadHelper = this.registerDisposer(new neuroglancer_webgl_quad__WEBPACK_IMPORTED_MODULE_1__["QuadRenderHelper"](gl, circlesPerInstance));
    }
    defineShader(builder, crossSectionFade) {
        // XY corners of square ranging from [-1, -1] to [1, 1].
        builder.addAttribute('highp vec2', 'aCircleCornerOffset');
        // x and y components: The x and y radii of the point in normalized device coordinates.
        // z component: Starting point of border from [0, 1]..
        // w component: Fraction of total radius that is feathered.
        builder.addUniform('highp vec4', 'uCircleParams');
        // 2-D position within circle quad, ranging from [-1, -1] to [1, 1].
        builder.addVarying('highp vec2', 'vCircleCoord');
        builder.addVertexCode(`
void emitCircle(vec4 position) {
  gl_Position = position;
  gl_Position.xy += aCircleCornerOffset * uCircleParams.xy * gl_Position.w;
  vCircleCoord = aCircleCornerOffset;
}
`);
        if (crossSectionFade) {
            builder.addFragmentCode(`
float getCircleAlphaMultiplier() {
  return 1.0 - 2.0 * abs(0.5 - gl_FragCoord.z);
}
`);
        }
        else {
            builder.addFragmentCode(`
float getCircleAlphaMultiplier() {
  return 1.0;
}
`);
        }
        builder.addFragmentCode(`
vec4 getCircleColor(vec4 interiorColor, vec4 borderColor) {
  float radius = length(vCircleCoord);
  if (radius > 1.0) {
    discard;
  }

  float borderColorFraction = clamp((radius - uCircleParams.z) / uCircleParams.w, 0.0, 1.0);
  float feather = clamp((1.0 - radius) / uCircleParams.w, 0.0, 1.0);
  vec4 color = mix(interiorColor, borderColor, borderColorFraction);

  return vec4(color.rgb, color.a * feather * getCircleAlphaMultiplier());
}
`);
    }
    draw(shader, renderContext, options, count) {
        const { gl } = shader;
        const aCircleCornerOffset = shader.attribute('aCircleCornerOffset');
        this.squareCornersBuffer.bindToVertexAttrib(aCircleCornerOffset, /*components=*/ 2);
        const totalRadius = options.interiorRadiusInPixels + options.borderWidthInPixels + options.featherWidthInPixels;
        gl.uniform4f(shader.uniform('uCircleParams'), totalRadius / renderContext.viewportWidth, totalRadius / renderContext.viewportHeight, options.interiorRadiusInPixels / totalRadius, options.featherWidthInPixels === 0 ? 1e-6 : options.featherWidthInPixels / totalRadius);
        this.quadHelper.draw(gl, count);
        shader.gl.disableVertexAttribArray(aCircleCornerOffset);
    }
}


/***/ }),

/***/ "./src/neuroglancer/webgl/colormaps.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/webgl/colormaps.ts ***!
  \*********************************************/
/*! exports provided: glsl_COLORMAPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_COLORMAPS", function() { return glsl_COLORMAPS; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const glsl_COLORMAPS = (`vec3 colormapJet(float x) {
  vec3 result;
  result.r = x < 0.89 ? ((x - 0.35) / 0.31) : (1.0 - (x - 0.89) / 0.11 * 0.5);
  result.g = x < 0.64 ? ((x - 0.125) * 4.0) : (1.0 - (x - 0.64) / 0.27);
  result.b = x < 0.34 ? (0.5 + x * 0.5 / 0.11) : (1.0 - (x - 0.34) / 0.31);
  return clamp(result, 0.0, 1.0);
}
` +
    /*
     * Adapted from http://www.mrao.cam.ac.uk/~dag/CUBEHELIX/CubeHelix.m
     * which is licensed under http://unlicense.org/
     */
    `vec3 colormapCubehelix(float x) {
  float xclamp = clamp(x, 0.0, 1.0);
  float angle = 2.0 * 3.1415926 * (4.0 / 3.0 + xclamp);
  float amp = xclamp * (1.0 - xclamp) / 2.0;
  vec3 result;
  float cosangle = cos(angle);
  float sinangle = sin(angle);
  result.r = -0.14861 * cosangle + 1.78277 * sinangle;
  result.g = -0.29227 * cosangle + -0.90649 * sinangle;
  result.b = 1.97294 * cosangle;
  result = clamp(xclamp + amp * result, 0.0, 1.0);
  return result;
}
`);


/***/ }),

/***/ "./src/neuroglancer/webgl/context.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/webgl/context.ts ***!
  \*******************************************/
/*! exports provided: DEBUG_SHADERS, initializeWebGL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUG_SHADERS", function() { return DEBUG_SHADERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeWebGL", function() { return initializeWebGL; });
/* harmony import */ var neuroglancer_util_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/memoize */ "./src/neuroglancer/util/memoize.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const DEBUG_SHADERS = false;
function initializeWebGL(canvas) {
    let options = {
        'antialias': false,
        'stencil': true,
    };
    if (DEBUG_SHADERS) {
        console.log('DEBUGGING via preserveDrawingBuffer');
        options['preserveDrawingBuffer'] = true;
    }
    let gl = canvas.getContext('webgl2', options);
    if (gl == null) {
        throw new Error('WebGL not supported.');
    }
    gl.memoize = new neuroglancer_util_memoize__WEBPACK_IMPORTED_MODULE_0__["Memoize"]();
    gl.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    gl.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    gl.tempTextureUnit = gl.maxTextureImageUnits - 1;
    // FIXME: verify that we received a stencil buffer
    // var contextAttributes = gl.getContextAttributes();
    // var haveStencilBuffer = contextAttributes.stencil;
    for (const extension of ['EXT_color_buffer_float']) {
        if (!gl.getExtension(extension)) {
            throw new Error(`${extension} extension not available`);
        }
    }
    // Extensions to attempt to add but not fail if they are not available.
    for (const extension of [
        // Some versions of Firefox 67.0 seem to require this extension being added in addition
        // to EXT_color_buffer_float, despite the note here indicating it is unnecessary:
        // https://developer.mozilla.org/en-US/docs/Web/API/EXT_float_blend
        //
        // See https://github.com/google/neuroglancer/issues/140
        'EXT_float_blend',
    ]) {
        gl.getExtension(extension);
    }
    return gl;
}


/***/ }),

/***/ "./src/neuroglancer/webgl/dynamic_shader.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/webgl/dynamic_shader.ts ***!
  \**************************************************/
/*! exports provided: makeWatchableShaderError, makeTrackableFragmentMain, ShaderGetter, parameterizedContextDependentShaderGetter, parameterizedEmitterDependentShaderGetter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeWatchableShaderError", function() { return makeWatchableShaderError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTrackableFragmentMain", function() { return makeTrackableFragmentMain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderGetter", function() { return ShaderGetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parameterizedContextDependentShaderGetter", function() { return parameterizedContextDependentShaderGetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parameterizedEmitterDependentShaderGetter", function() { return parameterizedEmitterDependentShaderGetter; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






function makeWatchableShaderError() {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["WatchableValue"](undefined);
}
function makeTrackableFragmentMain(value) {
    return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["TrackableValue"](value, neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyString"]);
}
class ShaderGetter extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(gl, defineShader, getShaderKey, shaderError = makeWatchableShaderError()) {
        super();
        this.gl = gl;
        this.defineShader = defineShader;
        this.getShaderKey = getShaderKey;
        this.shaderError = shaderError;
        this.shaderUpdated = true;
        this.shader = undefined;
        shaderError.value = undefined;
    }
    invalidateShader() {
        this.shaderUpdated = true;
    }
    get() {
        if (!this.shaderUpdated) {
            return this.shader;
        }
        this.shaderUpdated = false;
        try {
            let newShader = this.getShader();
            this.disposeShader();
            this.shader = newShader;
            this.shaderError.value = null;
        }
        catch (shaderError) {
            this.shaderError.value = shaderError;
        }
        return this.shader;
    }
    getShader() {
        let key = this.getShaderKey();
        return this.gl.memoize.get(key, () => this.buildShader());
    }
    buildShader() {
        let builder = new neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_4__["ShaderBuilder"](this.gl);
        this.defineShader(builder);
        return builder.build();
    }
    disposed() {
        super.disposed();
        this.disposeShader();
    }
    disposeShader() {
        if (this.shader) {
            this.shader.dispose();
            this.shader = undefined;
        }
    }
}
function parameterizedContextDependentShaderGetter(refCounted, gl, options) {
    const shaders = new Map();
    const { parameters, fallbackParameters, shaderError, encodeParameters = (p) => p, getContextKey, defineShader } = options;
    const { encodeContext = getContextKey } = options;
    const stringMemoizeKey = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["stableStringify"])(options.memoizeKey);
    function getNewShader(parameters, context) {
        const key = JSON.stringify({
            id: stringMemoizeKey,
            context: encodeContext(context),
            parameters: encodeParameters(parameters)
        });
        return gl.memoize.get(key, () => {
            const builder = new neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_4__["ShaderBuilder"](gl);
            defineShader(builder, parameters, context);
            return builder.build();
        });
    }
    function getter(context) {
        const contextKey = encodeContext(context);
        let entry = shaders.get(contextKey);
        if (entry === undefined) {
            entry = { generation: -1, shader: null, fallback: false, parameters: parameters.value };
            shaders.set(contextKey, entry);
        }
        const generation = parameters.changed.count;
        if (generation === entry.generation) {
            return entry;
        }
        const parametersValue = entry.parameters = parameters.value;
        const oldShader = entry.shader;
        entry.generation = generation;
        let newShader = null;
        try {
            newShader = getNewShader(parametersValue, context);
            entry.fallback = false;
            if (fallbackParameters !== undefined) {
                fallbackParameters.value = parametersValue;
            }
            shaderError.value = null;
        }
        catch (e) {
            shaderError.value = e;
            if (fallbackParameters !== undefined) {
                try {
                    const fallbackParametersValue = fallbackParameters.value;
                    newShader = getNewShader(fallbackParametersValue, context);
                    entry.parameters = fallbackParametersValue;
                    entry.fallback = true;
                }
                catch (_a) {
                }
            }
        }
        if (oldShader !== null) {
            oldShader.dispose();
        }
        entry.shader = newShader;
        return entry;
    }
    refCounted.registerDisposer(() => {
        for (const entry of shaders.values()) {
            const { shader } = entry;
            if (shader !== null) {
                shader.dispose();
            }
        }
    });
    return getter;
}
function parameterizedEmitterDependentShaderGetter(refCounted, gl, memoizeKey, fallbackParameters, parameters, shaderError, defineShader) {
    const getter = parameterizedContextDependentShaderGetter(refCounted, gl, {
        memoizeKey,
        fallbackParameters,
        parameters,
        getContextKey: (emitter) => emitter,
        encodeContext: (emitter) => Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_3__["getObjectId"])(emitter),
        shaderError,
        defineShader: (builder, parameters, emitter) => {
            builder.require(emitter);
            return defineShader(builder, parameters);
        },
    });
    return (emitter) => getter(emitter).shader;
}


/***/ }),

/***/ "./src/neuroglancer/webgl/ellipse.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/webgl/ellipse.ts ***!
  \*******************************************/
/*! exports provided: glsl_EllipseQuadraticForm, glsl_computeCrossSectionEllipse, computeCrossSectionEllipseDebug, glsl_CenterOrientEllipse, glsl_computeCenterOrientEllipse, computeCenterOrientEllipseDebug */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_EllipseQuadraticForm", function() { return glsl_EllipseQuadraticForm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_computeCrossSectionEllipse", function() { return glsl_computeCrossSectionEllipse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeCrossSectionEllipseDebug", function() { return computeCrossSectionEllipseDebug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_CenterOrientEllipse", function() { return glsl_CenterOrientEllipse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_computeCenterOrientEllipse", function() { return glsl_computeCenterOrientEllipse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeCenterOrientEllipseDebug", function() { return computeCenterOrientEllipseDebug; });
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Ellipse-related shader functions.
 */

/**
 * Specifies the parameters of an ellipse in quadratic form.
 */
const glsl_EllipseQuadraticForm = `
struct EllipseQuadraticForm {
  highp float A;  // x*x coefficient
  highp float B;  // x*y coefficient
  highp float C;  // y*y coefficient
  highp float D;  // x coefficient
  highp float E;  // y coefficient
  highp float F;  // 1 coefficient
};
`;
/**
 * Given a 3-d ellipsoid, finds the ellipse corresponding to the z=0 cross-section.
 * @param A The positive semi-definite matrix defining the ellipsoid shape.
 * @param c The centroid.
 */
const glsl_computeCrossSectionEllipse = [glsl_EllipseQuadraticForm, `
EllipseQuadraticForm computeCrossSectionEllipse(mat3 A, vec3 c) {
  EllipseQuadraticForm p;
  p.A = A[0][0];
  p.B = A[0][1] + A[1][0];
  p.C = A[1][1];
  p.D = -2.0 * c[0] * A[0][0] - c[1] * (A[0][1] + A[1][0]) +
        c[2] * (A[0][2] + A[2][0]);
  p.E = -c[0] * (A[0][1] + A[1][0]) - 2.0 * c[1] * A[1][1] +
        c[2] * (A[1][2] + A[2][1]);
  p.F = c[0] * c[0] * A[0][0] + c[0] * c[1] * (A[0][1] + A[1][0]) -
        c[0] * c[2] * (A[0][2] + A[2][0]) + c[1] * c[1] * A[1][1] -
        c[1] * c[2] * (A[1][2] + A[2][1]) + c[2] * c[2] * A[2][2] - 1.0;
  return p;
}
`];
function computeCrossSectionEllipseDebug(Ao, c) {
    const A = [[Ao[0], Ao[1], Ao[2]], [Ao[3], Ao[4], Ao[5]], [Ao[6], Ao[7], Ao[8]]];
    return {
        A: A[0][0],
        B: A[0][1] + A[1][0],
        C: A[1][1],
        D: -2.0 * c[0] * A[0][0] - c[1] * (A[0][1] + A[1][0]) + c[2] * (A[0][2] + A[2][0]),
        E: -c[0] * (A[0][1] + A[1][0]) - 2.0 * c[1] * A[1][1] + c[2] * (A[1][2] + A[2][1]),
        F: c[0] * c[0] * A[0][0] + c[0] * c[1] * (A[0][1] + A[1][0]) -
            c[0] * c[2] * (A[0][2] + A[2][0]) + c[1] * c[1] * A[1][1] -
            c[1] * c[2] * (A[1][2] + A[2][1]) + c[2] * c[2] * A[2][2] - 1.0,
    };
}
const glsl_CenterOrientEllipse = `
struct CenterOrientEllipse {
  vec2 k;   // center
  vec2 u1;  // minor axis direction
  vec2 u2;  // major axis direction
  float a;  // semimajor axis
  float b;  // semiminor axis
  bool valid; // indicates if the ellipse is valid
};
`;
/**
 * Compute the center-orient parameterization of an ellipse from the quadratic parameterization.
 *
 * See: https://www.geometrictools.com/Documentation/InformationAboutEllipses.pdf
 */
const glsl_computeCenterOrientEllipse = [
    glsl_EllipseQuadraticForm, glsl_CenterOrientEllipse, `
CenterOrientEllipse computeCenterOrientEllipse(EllipseQuadraticForm p) {
  CenterOrientEllipse r;
  float a11 = p.A;
  float a12 = p.B / 2.0;
  float a22 = p.C;
  float b1 = p.D;
  float b2 = p.E;
  float c = p.F;
  float kdenom = 2.0 * (a12 * a12 - a11 * a22);
  float k1 = r.k.x = (a22 * b1 - a12 * b2) / kdenom;
  float k2 = r.k.y = (a11 * b2 - a12 * b1) / kdenom;
  float mu = 1.0 / (a11 * k1 * k1 + 2.0 * a12 * k1 * k2 + a22 * k2 * k2 - c);
  float m11 = mu * a11;
  float m12 = mu * a12;
  float m22 = mu * a22;
  float lambdaTerm1 = m11 + m22;
  float lambdaTerm2 = sqrt((m11 - m22) * (m11 - m22) + 4.0 * m12 * m12);
  float lambda1 = ((lambdaTerm1 + lambdaTerm2) / 2.0);
  float lambda2 = ((lambdaTerm1 - lambdaTerm2) / 2.0);
  r.a = 1.0 / sqrt(lambda1);
  r.b = 1.0 / sqrt(lambda2);
  r.valid = lambda1 > 0.0 && lambda2 > 0.0;
  if (abs(m12) < 1e-10) {
    r.u1 = vec2(1.0, 0.0);
  } else if (m11 >= m22) {
    r.u1 = normalize(vec2(lambda1 - m22, m12));
  } else {
    r.u1 = normalize(vec2(m12, lambda1 - m11));
  }
  r.u2 = vec2(-r.u1.y, r.u1.x);
  return r;
}
`
];
function computeCenterOrientEllipseDebug(p) {
    const a11 = p.A;
    const a12 = p.B / 2.0;
    const a22 = p.C;
    const b1 = p.D;
    const b2 = p.E;
    const c = p.F;
    const kdenom = 2.0 * (a12 * a12 - a11 * a22);
    const k1 = (a22 * b1 - a12 * b2) / kdenom;
    const k2 = (a11 * b2 - a12 * b1) / kdenom;
    const mu = 1.0 / (a11 * k1 * k1 + 2.0 * a12 * k1 * k2 + a22 * k2 * k2 - c);
    const m11 = mu * a11;
    const m12 = mu * a12;
    const m22 = mu * a22;
    const lambdaTerm1 = m11 + m22;
    const lambdaTerm2 = Math.sqrt((m11 - m22) * (m11 - m22) + 4.0 * m12 * m12);
    const lambda1 = ((lambdaTerm1 + lambdaTerm2) / 2.0);
    const lambda2 = ((lambdaTerm1 - lambdaTerm2) / 2.0);
    const a = 1.0 / Math.sqrt(lambda1);
    const b = 1.0 / Math.sqrt(lambda2);
    let u1;
    if (Math.abs(m12) < 1e-10) {
        u1 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec2"].fromValues(1, 0);
    }
    else if (m11 >= m22) {
        u1 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec2"].fromValues(lambda1 - m22, m12);
    }
    else {
        u1 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec2"].fromValues(m12, lambda1 - m11);
    }
    neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec2"].normalize(u1, u1);
    const u2 = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec2"].fromValues(-u1[1], u1[0]);
    return { k: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_0__["vec2"].fromValues(k1, k2), u1, u2, a, b, lambda1, lambda2, m11, m12, m22 };
}


/***/ }),

/***/ "./src/neuroglancer/webgl/index_emulation.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/webgl/index_emulation.ts ***!
  \***************************************************/
/*! exports provided: CountingBuffer, disableCountingBuffer, getCountingBuffer, countingBufferShaderModule, IndexBufferAttributeHelper, makeIndexBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CountingBuffer", function() { return CountingBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableCountingBuffer", function() { return disableCountingBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCountingBuffer", function() { return getCountingBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countingBufferShaderModule", function() { return countingBufferShaderModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IndexBufferAttributeHelper", function() { return IndexBufferAttributeHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeIndexBuffer", function() { return makeIndexBuffer; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/* harmony import */ var neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/shader_lib */ "./src/neuroglancer/webgl/shader_lib.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class CountingBuffer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl) {
        super();
        this.gl = gl;
        this.buffer = this.registerDisposer(new neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__["Buffer"](gl));
    }
    resize(length) {
        let bufferData;
        if (length < 256) {
            let data = bufferData = new Uint8Array(length);
            for (let i = 0; i < length; ++i) {
                data[i] = i;
            }
            this.webglType = WebGL2RenderingContext.UNSIGNED_BYTE;
        }
        else if (length < 65536) {
            const data = bufferData = new Uint16Array(length);
            for (let i = 0; i < length; ++i) {
                data[i] = i;
            }
            this.webglType = WebGL2RenderingContext.UNSIGNED_SHORT;
        }
        else {
            const data = bufferData = new Uint32Array(length);
            for (let i = 0; i < length; ++i) {
                data[i] = i;
            }
            this.webglType = WebGL2RenderingContext.UNSIGNED_INT;
        }
        this.buffer.setData(bufferData);
        this.length = length;
    }
    ensure(length) {
        if (this.length === undefined || this.length < length) {
            this.resize(length);
        }
        return this;
    }
    bindToVertexAttrib(location) {
        this.buffer.bindToVertexAttribI(location, 1, this.webglType);
    }
    bind(shader, divisor = 0) {
        const location = shader.attribute('aIndexRaw');
        if (location >= 0) {
            this.bindToVertexAttrib(location);
            if (divisor !== 0) {
                this.gl.vertexAttribDivisor(location, divisor);
            }
        }
    }
}
function disableCountingBuffer(gl, shader, instanced = false) {
    const location = shader.attribute('aIndexRaw');
    if (location >= 0) {
        if (instanced) {
            gl.vertexAttribDivisor(location, 0);
        }
        gl.disableVertexAttribArray(location);
    }
}
function getCountingBuffer(gl) {
    return gl.memoize.get('IndexBuffer', () => new CountingBuffer(gl));
}
function countingBufferShaderModule(builder) {
    builder.addAttribute('highp uint', 'aIndexRaw');
    builder.addVertexCode(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_uint32"]);
    builder.addVertexCode(`
uint getPrimitiveIndex() {
  return aIndexRaw;
}
`);
}
/**
 * Helper class for using a buffer containing uint32 index values as a vertex attribute.
 */
class IndexBufferAttributeHelper {
    constructor(name) {
        this.name = name;
    }
    defineShader(builder) {
        builder.addAttribute('highp uint', this.name);
    }
    bind(buffer, shader) {
        const attrib = shader.attribute(this.name);
        buffer.bindToVertexAttribI(attrib, /*components=*/ 1, WebGL2RenderingContext.UNSIGNED_INT);
    }
    disable(shader) {
        shader.gl.disableVertexAttribArray(shader.attribute(this.name));
    }
}
function makeIndexBuffer(gl, data) {
    return neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__["Buffer"].fromData(gl, data, WebGL2RenderingContext.ARRAY_BUFFER, WebGL2RenderingContext.STATIC_DRAW);
}


/***/ }),

/***/ "./src/neuroglancer/webgl/lines.ts":
/*!*****************************************!*\
  !*** ./src/neuroglancer/webgl/lines.ts ***!
  \*****************************************/
/*! exports provided: VERTICES_PER_LINE, LineShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICES_PER_LINE", function() { return VERTICES_PER_LINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineShader", function() { return LineShader; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_webgl_quad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/webgl/quad */ "./src/neuroglancer/webgl/quad.ts");
/* harmony import */ var neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/square_corners_buffer */ "./src/neuroglancer/webgl/square_corners_buffer.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for drawing anti-aliased lines in WebGL as quads.
 */



const VERTICES_PER_LINE = neuroglancer_webgl_quad__WEBPACK_IMPORTED_MODULE_1__["VERTICES_PER_QUAD"];
class LineShader extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl, linesPerInstance = 1) {
        super();
        this.linesPerInstance = linesPerInstance;
        this.lineOffsetsBuffer =
            Object(neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_2__["getSquareCornersBuffer"])(gl, 0, -1, 1, 1, /*minorTiles=*/ linesPerInstance, /*majorTiles=*/ 1);
        this.quadHelper = this.registerDisposer(new neuroglancer_webgl_quad__WEBPACK_IMPORTED_MODULE_1__["QuadRenderHelper"](gl, linesPerInstance));
    }
    defineShader(builder) {
        builder.addAttribute('highp vec2', 'aLineOffset');
        // x: line width in normalized device x coordinates
        // y: line height in normalized device y coordinates
        // z: Fraction of line width that is feathered
        builder.addUniform('highp vec3', 'uLineParams');
        builder.addVarying('highp float', 'vLineCoord');
        builder.addVertexCode(`
uint getLineEndpointIndex() { return uint(aLineOffset.x); }
`);
        builder.addVertexCode(`
void emitLine(mat4 projection, vec3 vertexA, vec3 vertexB) {
  vec3 vertexPosition = mix(vertexA, vertexB, aLineOffset.x);
  vec3 otherVertexPosition = mix(vertexB, vertexA, aLineOffset.x);

  vec4 vertexPositionClip = projection * vec4(vertexPosition, 1.0);
  vec4 otherVertexPositionClip = projection * vec4(otherVertexPosition, 1.0);

  vec3 vertexPositionDevice = vertexPositionClip.xyz / vertexPositionClip.w;
  vec3 otherVertexPositionDevice = otherVertexPositionClip.xyz / otherVertexPositionClip.w;

  vec2 lineDirection = normalize(otherVertexPositionDevice.xy - vertexPositionDevice.xy);
  vec2 lineNormal = vec2(lineDirection.y, -lineDirection.x);

  gl_Position = vertexPositionClip;
  gl_Position.xy += aLineOffset.y * (2.0 * aLineOffset.x - 1.0) * lineNormal * uLineParams.xy * 0.5 * gl_Position.w;
  vLineCoord = aLineOffset.y;
}
`);
        builder.addFragmentCode(`
float getLineAlpha() {
  return clamp((1.0 - abs(vLineCoord)) / uLineParams.z, 0.0, 1.0);
}
`);
    }
    draw(shader, renderContext, lineWidthInPixels, featherWidthInPixels, numInstances) {
        const aLineOffset = shader.attribute('aLineOffset');
        this.lineOffsetsBuffer.bindToVertexAttrib(aLineOffset, /*components=*/ 2);
        const lineWidthIncludingFeather = lineWidthInPixels + featherWidthInPixels;
        const { gl } = shader;
        gl.uniform3f(shader.uniform('uLineParams'), lineWidthIncludingFeather / renderContext.viewportWidth, lineWidthIncludingFeather / renderContext.viewportHeight, featherWidthInPixels === 0 ? 1e-6 : featherWidthInPixels / lineWidthIncludingFeather);
        this.quadHelper.draw(gl, numInstances);
        gl.disableVertexAttribArray(aLineOffset);
    }
}


/***/ }),

/***/ "./src/neuroglancer/webgl/offscreen.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/webgl/offscreen.ts ***!
  \*********************************************/
/*! exports provided: SizeManaged, Renderbuffer, DepthBuffer, DepthStencilBuffer, StencilBuffer, Framebuffer, TextureBuffer, makeTextureBuffers, FramebufferConfiguration, OffscreenCopyHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SizeManaged", function() { return SizeManaged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Renderbuffer", function() { return Renderbuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthBuffer", function() { return DepthBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilBuffer", function() { return DepthStencilBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StencilBuffer", function() { return StencilBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Framebuffer", function() { return Framebuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureBuffer", function() { return TextureBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTextureBuffers", function() { return makeTextureBuffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FramebufferConfiguration", function() { return FramebufferConfiguration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffscreenCopyHelper", function() { return OffscreenCopyHelper; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/* harmony import */ var neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/webgl/square_corners_buffer */ "./src/neuroglancer/webgl/square_corners_buffer.ts");
/* harmony import */ var neuroglancer_webgl_texture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/webgl/texture */ "./src/neuroglancer/webgl/texture.ts");
/* harmony import */ var neuroglancer_webgl_trivial_shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/webgl/trivial_shaders */ "./src/neuroglancer/webgl/trivial_shaders.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class SizeManaged extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor() {
        super(...arguments);
        this.width = Number.NaN;
        this.height = Number.NaN;
    }
    hasSize(width, height) {
        return this.width === width && this.height === height;
    }
    resize(width, height) {
        if (this.hasSize(width, height)) {
            return;
        }
        this.width = width;
        this.height = height;
        this.performResize();
    }
}
class Renderbuffer extends SizeManaged {
    constructor(gl, internalformat) {
        super();
        this.gl = gl;
        this.internalformat = internalformat;
        this.renderbuffer = null;
        this.renderbuffer = gl.createRenderbuffer();
    }
    performResize() {
        let { gl } = this;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, this.internalformat, this.width, this.height);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
    disposed() {
        this.gl.deleteRenderbuffer(this.renderbuffer);
    }
    attachToFramebuffer(attachment) {
        let { gl } = this;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, this.renderbuffer);
    }
}
class DepthBuffer extends Renderbuffer {
    constructor(gl, includeStencilBuffer = false) {
        super(gl, includeStencilBuffer ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT16);
        this.gl = gl;
        this.includeStencilBuffer = includeStencilBuffer;
    }
    attachToFramebuffer() {
        let { gl } = this;
        super.attachToFramebuffer(this.includeStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
    }
}
class DepthStencilBuffer extends DepthBuffer {
    constructor(gl) {
        super(gl, /*includeStencilBuffer=*/ true);
    }
}
const StencilBuffer = DepthStencilBuffer;
class Framebuffer extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl) {
        super();
        this.gl = gl;
        this.framebuffer = this.gl.createFramebuffer();
    }
    disposed() {
        let { gl } = this;
        gl.deleteFramebuffer(this.framebuffer);
    }
    bind() {
        let { gl } = this;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    }
    unbind() {
        let { gl } = this;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
}
class TextureBuffer extends SizeManaged {
    constructor(gl, internalFormat, format, dataType) {
        super();
        this.gl = gl;
        this.internalFormat = internalFormat;
        this.format = format;
        this.dataType = dataType;
        this.texture = gl.createTexture();
    }
    performResize() {
        Object(neuroglancer_webgl_texture__WEBPACK_IMPORTED_MODULE_4__["resizeTexture"])(this.gl, this.texture, this.width, this.height, this.internalFormat, this.format, this.dataType);
    }
    disposed() {
        this.gl.deleteTexture(this.texture);
    }
    attachToFramebuffer(attachment) {
        let { gl } = this;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, this.texture, /*level=*/ 0);
    }
}
function makeTextureBuffers(gl, count, internalFormat = WebGL2RenderingContext.RGBA8, format = WebGL2RenderingContext.RGBA, dataType = WebGL2RenderingContext.UNSIGNED_BYTE) {
    let result = new Array();
    for (let i = 0; i < count; ++i) {
        result[i] = new TextureBuffer(gl, internalFormat, format, dataType);
    }
    return result;
}
const tempPixel = new Uint8Array(4);
const tempPixelUint32 = new Uint32Array(1);
const tempPixelFloat32 = new Float32Array(4);
class FramebufferConfiguration extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl, configuration) {
        super();
        this.gl = gl;
        this.width = Number.NaN;
        this.height = Number.NaN;
        this.fullAttachmentList = new Array();
        this.attachmentVerified = false;
        this.singleAttachmentList = [this.gl.COLOR_ATTACHMENT0];
        let { framebuffer = new Framebuffer(gl), colorBuffers, depthBuffer } = configuration;
        this.framebuffer = this.registerDisposer(framebuffer);
        this.colorBuffers = colorBuffers;
        this.depthBuffer = depthBuffer;
        if (depthBuffer !== undefined) {
            this.registerDisposer(depthBuffer);
        }
        let { fullAttachmentList } = this;
        colorBuffers.forEach((buffer, i) => {
            this.registerDisposer(buffer);
            fullAttachmentList[i] = gl.COLOR_ATTACHMENT0 + i;
        });
    }
    hasSize(width, height) {
        return this.width === width && this.height === height;
    }
    bind(width, height) {
        this.width = width;
        this.height = height;
        this.framebuffer.bind();
        let { gl, depthBuffer } = this;
        if (depthBuffer !== undefined) {
            depthBuffer.resize(width, height);
            depthBuffer.attachToFramebuffer();
        }
        this.colorBuffers.forEach((buffer, i) => {
            buffer.resize(width, height);
            buffer.attachToFramebuffer(gl.COLOR_ATTACHMENT0 + i);
        });
        gl.drawBuffers(this.fullAttachmentList);
        this.verifyAttachment();
        gl.viewport(0, 0, width, height);
    }
    bindSingle(textureIndex) {
        let { gl } = this;
        this.framebuffer.bind();
        // If this texture is still be bound to color attachment textureIndex, the attachment will fail
        // (at least on some browsers).  Therefore, if textureIndex is not 0, we clear the attachment.
        // In the case that textureIndex is 0, the attachment will be overridden anyway.
        if (textureIndex !== 0) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + textureIndex, gl.TEXTURE_2D, null, /*level=*/ 0);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        this.colorBuffers[textureIndex].attachToFramebuffer(gl.COLOR_ATTACHMENT0);
        gl.drawBuffers(this.singleAttachmentList);
    }
    unbind() {
        this.framebuffer.unbind();
    }
    /**
     * Only supports UNSIGNED_BYTE RGBA textures.
     */
    readPixel(textureIndex, glWindowX, glWindowY) {
        let { gl } = this;
        try {
            this.bindSingle(textureIndex);
            gl.readPixels(glWindowX, glWindowY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, tempPixel);
        }
        finally {
            this.framebuffer.unbind();
        }
        return tempPixel;
    }
    readPixelUint32(textureIndex, glWindowX, glWindowY) {
        let { gl } = this;
        try {
            this.bindSingle(textureIndex);
            gl.readPixels(glWindowX, glWindowY, 1, 1, WebGL2RenderingContext.RED_INTEGER, WebGL2RenderingContext.UNSIGNED_INT, tempPixelUint32);
        }
        finally {
            this.framebuffer.unbind();
        }
        return tempPixelUint32[0];
    }
    readPixelFloat32(textureIndex, glWindowX, glWindowY) {
        let { gl } = this;
        try {
            this.bindSingle(textureIndex);
            // Reading just the red channel using a format of RED fails with certain WebGL
            // implementations.  Using RGBA seems to have better compatibility.
            gl.readPixels(glWindowX, glWindowY, 1, 1, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, tempPixelFloat32);
        }
        finally {
            this.framebuffer.unbind();
        }
        return tempPixelFloat32[0];
    }
    readPixelFloat32IntoBuffer(textureIndex, glWindowX, glWindowY, offset, width = 1, height = 1) {
        let { gl } = this;
        try {
            this.bindSingle(textureIndex);
            // Reading just the red channel using a format of RED fails with certain WebGL
            // implementations.  Using RGBA seems to have better compatibility.
            gl.readPixels(glWindowX, glWindowY, width, height, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, offset);
        }
        finally {
            this.framebuffer.unbind();
        }
    }
    verifyAttachment() {
        if (this.attachmentVerified) {
            return;
        }
        let { gl } = this;
        let framebufferStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (framebufferStatus !== gl.FRAMEBUFFER_COMPLETE) {
            throw new Error(`Framebuffer configuration not supported`);
        }
        this.attachmentVerified = true;
    }
}
class OffscreenCopyHelper extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl, shader) {
        super();
        this.gl = gl;
        this.shader = shader;
        this.copyVertexPositionsBuffer = Object(neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_3__["getSquareCornersBuffer"])(this.gl);
        this.copyTexCoordsBuffer = Object(neuroglancer_webgl_square_corners_buffer__WEBPACK_IMPORTED_MODULE_3__["getSquareCornersBuffer"])(this.gl, 0, 0, 1, 1);
        this.registerDisposer(shader);
    }
    draw(...textures) {
        let { gl, shader } = this;
        shader.bind();
        let numTextures = textures.length;
        for (let i = 0; i < numTextures; ++i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, textures[i]);
        }
        gl.uniformMatrix4fv(shader.uniform('uProjectionMatrix'), false, neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["identityMat4"]);
        let aVertexPosition = shader.attribute('aVertexPosition');
        this.copyVertexPositionsBuffer.bindToVertexAttrib(aVertexPosition, /*components=*/ 2);
        let aTexCoord = shader.attribute('aTexCoord');
        this.copyTexCoordsBuffer.bindToVertexAttrib(aTexCoord, /*components=*/ 2);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        gl.disableVertexAttribArray(aVertexPosition);
        gl.disableVertexAttribArray(aTexCoord);
        for (let i = 0; i < numTextures; ++i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }
    static get(gl, shaderModule = neuroglancer_webgl_trivial_shaders__WEBPACK_IMPORTED_MODULE_5__["defineCopyFragmentShader"], numTextures = 1) {
        return gl.memoize.get(`OffscreenCopyHelper:${numTextures}:${Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_2__["getObjectId"])(shaderModule)}`, () => new OffscreenCopyHelper(gl, Object(neuroglancer_webgl_trivial_shaders__WEBPACK_IMPORTED_MODULE_5__["elementWiseTextureShader"])(gl, shaderModule, numTextures)));
    }
}


/***/ }),

/***/ "./src/neuroglancer/webgl/quad.ts":
/*!****************************************!*\
  !*** ./src/neuroglancer/webgl/quad.ts ***!
  \****************************************/
/*! exports provided: VERTICES_PER_QUAD, TRIANGLES_PER_QUAD, INDICES_PER_QUAD, QuadRenderHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICES_PER_QUAD", function() { return VERTICES_PER_QUAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLES_PER_QUAD", function() { return TRIANGLES_PER_QUAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INDICES_PER_QUAD", function() { return INDICES_PER_QUAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadRenderHelper", function() { return QuadRenderHelper; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for drawing quads in WebGL as two triangles.
 */


const VERTICES_PER_QUAD = 4;
const TRIANGLES_PER_QUAD = 2;
const INDICES_PER_QUAD = TRIANGLES_PER_QUAD * 3;
/**
 * Returns a WebGL2RenderingContext.TRIANGLES index array for drawing an instance containing
 * `quadsPerInstance` quads.
 */
function getQuadIndexArray(quadsPerInstance) {
    const result = new Uint16Array(quadsPerInstance * INDICES_PER_QUAD);
    for (let quad = 0; quad < quadsPerInstance; ++quad) {
        const v = quad * VERTICES_PER_QUAD;
        let i = quad * INDICES_PER_QUAD;
        result[i] = v;
        result[i + 1] = v + 1;
        result[i + 2] = v + 2;
        result[i + 3] = v + 2;
        result[i + 4] = v + 3;
        result[i + 5] = v;
    }
    return result;
}
class QuadRenderHelper extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl, quadsPerInstance) {
        super();
        this.quadsPerInstance = quadsPerInstance;
        if (quadsPerInstance !== 1) {
            this.quadIndexBuffer =
                this.registerDisposer(Object(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__["getMemoizedBuffer"])(gl, WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, getQuadIndexArray, quadsPerInstance))
                    .value;
        }
    }
    draw(gl, numInstances) {
        if (this.quadsPerInstance === 1) {
            gl.drawArraysInstanced(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4, numInstances);
        }
        else {
            this.quadIndexBuffer.bind();
            gl.drawElementsInstanced(WebGL2RenderingContext.TRIANGLES, INDICES_PER_QUAD * this.quadsPerInstance, WebGL2RenderingContext.UNSIGNED_SHORT, /*offset=*/ 0, numInstances);
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/webgl/shader.ts":
/*!******************************************!*\
  !*** ./src/neuroglancer/webgl/shader.ts ***!
  \******************************************/
/*! exports provided: ShaderType, parseShaderErrors, ShaderCompilationError, ShaderLinkError, getShader, ShaderProgram, ShaderCode, textureTargetForSamplerType, ShaderBuilder, shaderContainsIdentifiers, emitterDependentShaderGetter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderType", function() { return ShaderType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseShaderErrors", function() { return parseShaderErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderCompilationError", function() { return ShaderCompilationError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLinkError", function() { return ShaderLinkError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getShader", function() { return getShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderProgram", function() { return ShaderProgram; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderCode", function() { return ShaderCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textureTargetForSamplerType", function() { return textureTargetForSamplerType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderBuilder", function() { return ShaderBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shaderContainsIdentifiers", function() { return shaderContainsIdentifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "emitterDependentShaderGetter", function() { return emitterDependentShaderGetter; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const DEBUG_SHADER = false;
var ShaderType;
(function (ShaderType) {
    ShaderType[ShaderType["VERTEX"] = WebGL2RenderingContext.VERTEX_SHADER] = "VERTEX";
    ShaderType[ShaderType["FRAGMENT"] = WebGL2RenderingContext.FRAGMENT_SHADER] = "FRAGMENT";
})(ShaderType || (ShaderType = {}));
/**
 * Parses the output of getShaderInfoLog into a list of messages.
 */
function parseShaderErrors(log) {
    log = log.replace('\0', '');
    let result = [];
    for (let line of log.split('\n')) {
        let m = line.match(/^ERROR:\s*(\d+):(\d+)\s*(.+)$/);
        if (m !== null) {
            result.push({ message: m[3].trim(), file: parseInt(m[1], 10), line: parseInt(m[2], 10) });
        }
        else {
            m = line.match(/^ERROR:\s*(.+)$/);
            if (m !== null) {
                result.push({ message: m[1] });
            }
            else {
                line = line.trim();
                if (line) {
                    result.push({ message: line });
                }
            }
        }
    }
    return result;
}
class ShaderCompilationError extends Error {
    constructor(shaderType, source, log, errorMessages) {
        const message = `Error compiling ${ShaderType[shaderType].toLowerCase()} shader: ${log}`;
        super(message);
        this.name = 'ShaderCompilationError';
        this.log = log;
        this.message = message;
        this.shaderType = shaderType;
        this.source = source;
        this.errorMessages = errorMessages;
    }
}
class ShaderLinkError extends Error {
    constructor(vertexSource, fragmentSource, log) {
        const message = `Error linking shader: ${log}`;
        super(message);
        this.name = 'ShaderLinkError';
        this.log = log;
        this.message = message;
        this.vertexSource = vertexSource;
        this.fragmentSource = fragmentSource;
    }
}
function getShader(gl, source, shaderType) {
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        let log = gl.getShaderInfoLog(shader) || '';
        if (DEBUG_SHADER) {
            let lines = source.replace('<', '&lt;').replace('>', '&gt;').split('\n');
            let s = '<pre>';
            s += log.replace('<', '&lt;').replace('>', '&gt;') + '\n';
            lines.forEach((line, i) => {
                s += `${i + 1}: ${line}\n`;
            });
            s += `\n</pre>`;
            let w = window.open('about:blank', '_blank');
            if (w !== null) {
                try {
                    w.document.write(s);
                }
                catch (writeError) {
                }
            }
        }
        throw new ShaderCompilationError(shaderType, source, log, parseShaderErrors(log));
    }
    return shader;
}
class ShaderProgram extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl, vertexSource, fragmentSource, uniformNames, attributeNames) {
        super();
        this.gl = gl;
        this.vertexSource = vertexSource;
        this.fragmentSource = fragmentSource;
        this.attributes = new Map();
        this.uniforms = new Map();
        let vertexShader = this.vertexShader = getShader(gl, vertexSource, gl.VERTEX_SHADER);
        let fragmentShader = this.fragmentShader = getShader(gl, fragmentSource, gl.FRAGMENT_SHADER);
        let shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            let log = gl.getProgramInfoLog(shaderProgram) || '';
            // DEBUG
            // {
            //   let combinedSource = 'VERTEX SHADER\n\n' + vertexSource + '\n\n\nFRAGMENT SHADER\n\n' +
            //   fragmentSource + '\n';
            //   let w = window.open("about:blank", "_blank");
            //   w.document.write('<pre>' + combinedSource.replace('<', '&lt;').replace('>', '&gt;') +
            //   '</pre>');
            // }
            throw new ShaderLinkError(vertexSource, fragmentSource, log);
        }
        this.program = shaderProgram;
        let { uniforms, attributes } = this;
        if (uniformNames) {
            for (let name of uniformNames) {
                uniforms.set(name, gl.getUniformLocation(shaderProgram, name));
            }
        }
        if (attributeNames) {
            for (let name of attributeNames) {
                attributes.set(name, gl.getAttribLocation(shaderProgram, name));
            }
        }
    }
    uniform(name) {
        return this.uniforms.get(name);
    }
    attribute(name) {
        return this.attributes.get(name);
    }
    textureUnit(symbol) {
        return this.textureUnits.get(symbol);
    }
    bind() {
        this.gl.useProgram(this.program);
    }
    disposed() {
        let { gl } = this;
        gl.deleteShader(this.vertexShader);
        this.vertexShader = undefined;
        gl.deleteShader(this.fragmentShader);
        this.fragmentShader = undefined;
        gl.deleteProgram(this.program);
        this.program = undefined;
        this.gl = undefined;
        this.attributes = undefined;
        this.uniforms = undefined;
    }
}
class ShaderCode {
    constructor() {
        this.code = '';
        this.parts = new Set();
    }
    add(x) {
        if (this.parts.has(x)) {
            return;
        }
        this.parts.add(x);
        switch (typeof x) {
            case 'string':
                this.code += x;
                break;
            case 'function':
                this.add(x());
                break;
            default:
                if (Array.isArray(x)) {
                    for (let y of x) {
                        this.add(y);
                    }
                }
                else {
                    console.log('Invalid code type', x);
                    throw new Error('Invalid code type');
                }
        }
    }
    toString() {
        return this.code;
    }
}
const textureTargetForSamplerType = {
    'sampler2D': WebGL2RenderingContext.TEXTURE_2D,
    'isampler2D': WebGL2RenderingContext.TEXTURE_2D,
    'usampler2D': WebGL2RenderingContext.TEXTURE_2D,
    'sampler3D': WebGL2RenderingContext.TEXTURE_3D,
    'isampler3D': WebGL2RenderingContext.TEXTURE_3D,
    'usampler3D': WebGL2RenderingContext.TEXTURE_3D,
};
class ShaderBuilder {
    constructor(gl) {
        this.gl = gl;
        this.nextSymbolID = 0;
        this.nextTextureUnit = 0;
        this.uniformsCode = '';
        this.attributesCode = '';
        this.varyingsCodeVS = '';
        this.varyingsCodeFS = '';
        this.fragmentExtensionsSet = new Set();
        this.fragmentExtensions = '';
        this.vertexCode = new ShaderCode();
        this.vertexMain = '';
        this.fragmentCode = new ShaderCode();
        this.outputBufferCode = '';
        this.fragmentMain = '';
        this.required = new Set();
        this.uniforms = new Array();
        this.attributes = new Array();
        this.initializers = [];
        this.textureUnits = new Map();
    }
    allocateTextureUnit(symbol, count = 1) {
        if (this.textureUnits.has(symbol)) {
            throw new Error('Duplicate texture unit symbol: ' + symbol);
        }
        let old = this.nextTextureUnit;
        this.nextTextureUnit += count;
        this.textureUnits.set(symbol, old);
        return old;
    }
    addTextureSampler(samplerType, name, symbol, extent) {
        let textureUnit = this.allocateTextureUnit(symbol, extent);
        this.addUniform(`highp ${samplerType}`, name, extent);
        this.addInitializer(shader => {
            if (extent) {
                let textureUnits = new Int32Array(extent);
                for (let i = 0; i < extent; ++i) {
                    textureUnits[i] = i + textureUnit;
                }
                shader.gl.uniform1iv(shader.uniform(name), textureUnits);
            }
            else {
                shader.gl.uniform1i(shader.uniform(name), textureUnit);
            }
        });
        return textureUnit;
    }
    symbol(name) {
        return name + (this.nextSymbolID++);
    }
    addAttribute(typeName, name) {
        this.attributes.push(name);
        this.attributesCode += `in ${typeName} ${name};\n`;
        return name;
    }
    addVarying(typeName, name, interpolationMode = '') {
        this.varyingsCodeVS += `${interpolationMode} out ${typeName} ${name};\n`;
        this.varyingsCodeFS += `${interpolationMode} in ${typeName} ${name};\n`;
    }
    addOutputBuffer(typeName, name, location) {
        if (location !== null) {
            this.outputBufferCode += `layout(location = ${location}) `;
        }
        this.outputBufferCode += `out ${typeName} ${name};\n`;
    }
    addUniform(typeName, name, extent) {
        this.uniforms.push(name);
        if (extent != null) {
            this.uniformsCode += `uniform ${typeName} ${name}[${extent}];\n`;
        }
        else {
            this.uniformsCode += `uniform ${typeName} ${name};\n`;
        }
        return name;
    }
    addFragmentExtension(name) {
        if (this.fragmentExtensionsSet.has(name)) {
            return;
        }
        this.fragmentExtensionsSet.add(name);
        this.fragmentExtensions += `#extension ${name} : require\n`;
    }
    addVertexCode(code) {
        this.vertexCode.add(code);
    }
    addFragmentCode(code) {
        this.fragmentCode.add(code);
    }
    setVertexMain(code) {
        this.vertexMain = code;
    }
    addVertexMain(code) {
        this.vertexMain = (this.vertexMain || '') + code;
    }
    setFragmentMain(code) {
        this.fragmentMain = `void main() {
${code}
}
`;
    }
    setFragmentMainFunction(code) {
        this.fragmentMain = code;
    }
    addInitializer(f) {
        this.initializers.push(f);
    }
    require(f) {
        if (this.required.has(f)) {
            return;
        }
        this.required.add(f);
        f(this);
    }
    build() {
        let vertexSource = `#version 300 es
precision highp float;
precision highp int;
${this.uniformsCode}
${this.attributesCode}
${this.varyingsCodeVS}
${this.vertexCode}
void main() {
${this.vertexMain}
}
`;
        let fragmentSource = `#version 300 es
${this.fragmentExtensions}
precision highp float;
precision highp int;
${this.uniformsCode}
${this.varyingsCodeFS}
${this.outputBufferCode}
${this.fragmentCode}
${this.fragmentMain}
`;
        let shader = new ShaderProgram(this.gl, vertexSource, fragmentSource, this.uniforms, this.attributes);
        shader.textureUnits = this.textureUnits;
        let { initializers } = this;
        if (initializers.length > 0) {
            shader.bind();
            for (let initializer of initializers) {
                initializer(shader);
            }
        }
        return shader;
    }
}
function shaderContainsIdentifiers(code, identifiers) {
    let found = new Set();
    for (let identifier of identifiers) {
        let pattern = new RegExp(`(?:^|[^a-zA-Z0-9_])${identifier}[^a-zA-Z0-9_])`);
        if (code.match(pattern) !== null) {
            found.add(identifier);
        }
    }
    return found;
}
function emitterDependentShaderGetter(refCounted, gl, defineShader) {
    const shaders = new Map();
    function getter(emitter) {
        let shader = shaders.get(emitter);
        if (shader === undefined) {
            const builder = new ShaderBuilder(gl);
            builder.require(emitter);
            defineShader(builder);
            shader = refCounted.registerDisposer(builder.build());
            shaders.set(emitter, shader);
        }
        return shader;
    }
    return getter;
}


/***/ }),

/***/ "./src/neuroglancer/webgl/shader_lib.ts":
/*!**********************************************!*\
  !*** ./src/neuroglancer/webgl/shader_lib.ts ***!
  \**********************************************/
/*! exports provided: glsl_hsvToRgb, glsl_uint64, glsl_unpackUint64leFromUint32, glsl_equalUint64, glsl_uint8, glsl_float, glsl_uint16, glsl_uint32, glsl_getFortranOrderIndex, getShaderType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_hsvToRgb", function() { return glsl_hsvToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_uint64", function() { return glsl_uint64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_unpackUint64leFromUint32", function() { return glsl_unpackUint64leFromUint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_equalUint64", function() { return glsl_equalUint64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_uint8", function() { return glsl_uint8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_float", function() { return glsl_float; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_uint16", function() { return glsl_uint16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_uint32", function() { return glsl_uint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glsl_getFortranOrderIndex", function() { return glsl_getFortranOrderIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getShaderType", function() { return getShaderType; });
/* harmony import */ var neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/data_type */ "./src/neuroglancer/util/data_type.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Hue, saturation, and value are in [0, 1] range.
var glsl_hsvToRgb = `
vec3 hueToRgb(float hue) {
  float hue6 = hue * 6.0;
  float r = abs(hue6 - 3.0) - 1.0;
  float g = 2.0 - abs(hue6 - 2.0);
  float b = 2.0 - abs(hue6 - 4.0);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}
vec3 hsvToRgb(vec3 c) {
  vec3 hueRgb = hueToRgb(c.x);
  return c.z * ((hueRgb - 1.0) * c.y + 1.0);
}
`;
const glsl_uint64 = `
struct uint64_t {
  highp uvec2 value;
};
struct uint64x2_t {
  highp uvec4 value;
};
uint64_t toUint64(uint64_t x) { return x; }
`;
const glsl_unpackUint64leFromUint32 = [
    glsl_uint64, `
uint64_t unpackUint64leFromUint32(highp uvec2 x) {
  uint64_t result;
  result.value = x;
  return result;
}
uint64x2_t unpackUint64leFromUint32(highp uvec4 x) {
  uint64x2_t result;
  result.value = x;
  return result;
}
`
];
const glsl_equalUint64 = [
    glsl_uint64, `
bool equals(uint64_t a, uint64_t b) {
  return a.value == b.value;
}
`
];
const glsl_uint8 = [
    glsl_uint64, `
struct uint8_t {
  highp uint value;
};
struct uint8x2_t {
  highp uvec2 value;
};
struct uint8x3_t {
  highp uvec3 value;
};
struct uint8x4_t {
  highp uvec4 value;
};
highp uint toRaw(uint8_t x) { return x.value; }
highp float toNormalized(uint8_t x) { return float(x.value) / 255.0; }
highp uvec2 toRaw(uint8x2_t x) { return x.value; }
highp vec2 toNormalized(uint8x2_t x) { return vec2(x.value) / 255.0; }
highp uvec3 toRaw(uint8x3_t x) { return x.value; }
vec3 toNormalized(uint8x3_t x) { return vec3(x.value) / 255.0; }
highp uvec4 toRaw(uint8x4_t x) { return x.value; }
vec4 toNormalized(uint8x4_t x) { return vec4(x.value) / 255.0; }
uint64_t toUint64(uint8_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
`
];
const glsl_float = `
float toRaw(float x) { return x; }
float toNormalized(float x) { return x; }
vec2 toRaw(vec2 x) { return x; }
vec2 toNormalized(vec2 x) { return x; }
vec3 toRaw(vec3 x) { return x; }
vec3 toNormalized(vec3 x) { return x; }
vec4 toRaw(vec4 x) { return x; }
vec4 toNormalized(vec4 x) { return x; }
`;
const glsl_uint16 = [
    glsl_uint64, `
struct uint16_t {
  highp uint value;
};
struct uint16x2_t {
  highp uvec2 value;
};
highp uint toRaw(uint16_t x) { return x.value; }
highp float toNormalized(uint16_t x) { return float(toRaw(x)) / 65535.0; }
highp uvec2 toRaw(uint16x2_t x) { return x.value; }
highp vec2 toNormalized(uint16x2_t x) { return vec2(toRaw(x)) / 65535.0; }
uint64_t toUint64(uint16_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
`
];
const glsl_uint32 = [
    glsl_uint64, `
struct uint32_t {
  highp uint value;
};
highp float toNormalized(uint32_t x) { return float(x.value) / 4294967295.0; }
highp uint toRaw(uint32_t x) { return x.value; }
uint64_t toUint64(uint32_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
`
];
var glsl_getFortranOrderIndex = `
highp int getFortranOrderIndex(ivec3 subscripts, ivec3 size) {
  return subscripts.x + size.x * (subscripts.y + size.y * subscripts.z);
}
`;
function getShaderType(dataType, numComponents = 1) {
    switch (dataType) {
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].FLOAT32:
            if (numComponents === 1) {
                return 'float';
            }
            if (numComponents > 1 && numComponents <= 4) {
                return `vec${numComponents}`;
            }
            break;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].UINT8:
            if (numComponents === 1) {
                return 'uint8_t';
            }
            if (numComponents > 1 && numComponents <= 4) {
                return `uint8x${numComponents}_t`;
            }
            break;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].UINT16:
            if (numComponents === 1) {
                return 'uint16_t';
            }
            if (numComponents === 2) {
                return `uint16x2_t`;
            }
            break;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].UINT32:
            if (numComponents === 1) {
                return 'uint32_t';
            }
            break;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"].UINT64:
            if (numComponents === 1) {
                return 'uint64_t';
            }
            break;
    }
    throw new Error(`No shader type for ${neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_0__["DataType"][dataType]}[${numComponents}].`);
}


/***/ }),

/***/ "./src/neuroglancer/webgl/shader_ui_controls.ts":
/*!******************************************************!*\
  !*** ./src/neuroglancer/webgl/shader_ui_controls.ts ***!
  \******************************************************/
/*! exports provided: stripComments, parseDirectiveParameters, parseShaderUiControls, addControlsToBuilder, WatchableShaderUiControls, ShaderControlState, setControlsInShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripComments", function() { return stripComments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirectiveParameters", function() { return parseDirectiveParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseShaderUiControls", function() { return parseShaderUiControls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addControlsToBuilder", function() { return addControlsToBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WatchableShaderUiControls", function() { return WatchableShaderUiControls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderControlState", function() { return ShaderControlState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setControlsInShader", function() { return setControlsInShader; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/color */ "./src/neuroglancer/util/color.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





// Strips comments from GLSL code.  Also handles string literals since they are used in ui control
// directives.
function stripComments(code) {
    // https://stackoverflow.com/a/241506
    const commentPattern = /\/\/.*?$|\/\*(?:.|\n)*?\*\/|'(?:\\.|[^\\'])*'|"(?:\\.|[^\\"])*"/mg;
    return code.replace(commentPattern, m => {
        if (m.startsWith('/')) {
            return m.replace(/[^\s]/g, ' ');
        }
        return m;
    });
}
function parseDirectiveParameters(input) {
    let errors = [];
    let parameters = new Map();
    if (input === undefined) {
        return { errors, parameters };
    }
    const pattern = /^[ \t]*([_a-z][_a-zA-Z0-9]*)[ \t]*=[ \t]*(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?|"(?:\\.|[^\\"])*")[ \t]*/;
    while (true) {
        input = input.trim();
        if (input.length == 0)
            break;
        const m = input.match(pattern);
        if (m === null) {
            errors.push('Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...');
            break;
        }
        const name = m[1];
        let value;
        try {
            value = JSON.parse(m[2]);
        }
        catch (_a) {
            errors.push(`Invalid #uicontrol parameter value: ${value}`);
            break;
        }
        if (parameters.has(name)) {
            errors.push(`Duplicate #uicontrol parameter: ${name}`);
        }
        else {
            parameters.set(name, value);
        }
        input = input.substring(m[0].length);
        if (input.length > 0 && !input.startsWith(',')) {
            errors.push('Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...');
        }
        input = input.substring(1);
    }
    return { parameters, errors };
}
function parseSliderDirective(valueType, parameters) {
    let min;
    let max;
    let step;
    let defaultValue;
    let errors = [];
    if (valueType !== 'float' && valueType !== 'uint' && valueType !== 'int') {
        errors.push('type must be float, int, or uint');
    }
    for (const [key, value] of parameters) {
        const getValue = () => {
            if (typeof value !== 'number') {
                errors.push(`Expected ${key} argument to be a number`);
                return undefined;
            }
            if (valueType === 'int' || valueType === 'uint') {
                if (!Number.isInteger(value)) {
                    errors.push(`Expected ${key} argument to be an integer`);
                }
                if (valueType === 'uint' && value < 0) {
                    errors.push(`Expected ${key} argument to be an unsigned integer`);
                }
            }
            return value;
        };
        if (key === 'min') {
            min = getValue();
        }
        else if (key === 'max') {
            max = getValue();
        }
        else if (key === 'default') {
            defaultValue = getValue();
        }
        else if (key === 'step') {
            step = getValue();
        }
        else {
            errors.push(`Invalid parameter: ${key}`);
        }
    }
    if (min === undefined) {
        errors.push('min must be specified');
    }
    if (max === undefined) {
        errors.push('max must be specified');
    }
    if (min !== undefined && max !== undefined) {
        if (min > max) {
            errors.push('min must be less than max');
        }
        if (step === undefined) {
            if (valueType === 'float') {
                step = (max - min) / 100;
            }
            else {
                step = 1;
            }
        }
        if (defaultValue !== undefined) {
            if (defaultValue < min || defaultValue > max) {
                errors.push('default must be within valid range');
            }
        }
        else {
            if (valueType === 'float') {
                defaultValue = (min + max) / 2;
            }
            else {
                defaultValue = min;
            }
        }
    }
    if (errors.length > 0) {
        return { errors };
    }
    else {
        return {
            control: { type: 'slider', valueType, min, max, step, default: defaultValue },
            errors: undefined,
        };
    }
}
function parseColorDirective(valueType, parameters) {
    let defaultColor = 'white';
    let errors = [];
    if (valueType !== 'vec3') {
        errors.push('type must be vec3');
    }
    for (const [key, value] of parameters) {
        if (key === 'default') {
            if (typeof value !== 'string') {
                errors.push(`Expected default argument to be a string`);
            }
            else {
                defaultColor = value;
            }
        }
        else {
            errors.push(`Invalid parameter: ${key}`);
        }
    }
    if (errors.length > 0) {
        return { errors };
    }
    return {
        control: {
            type: 'color',
            valueType,
            defaultString: defaultColor,
            default: Object(neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_1__["parseRGBColorSpecification"])(defaultColor)
        },
        errors: undefined
    };
}
const controlParsers = new Map([['slider', parseSliderDirective], ['color', parseColorDirective]]);
function parseShaderUiControls(code) {
    code = stripComments(code);
    // Matches any #uicontrols directive.  Syntax errors in the directive are handled later.
    const directivePattern = /^[ \t]*#[ \t]*uicontrol[ \t]+(.*)$/mg;
    const innerPattern = /^([_a-zA-Z][_a-zA-Z0-9]*)[ \t]+([a-z][a-zA-Z0-9]*)[ \t]+([a-z]+)[ \t]*(?:\([ \t]*(.*)\)[ \t]*)?/;
    let errors = [];
    const controls = new Map();
    const newCode = code.replace(directivePattern, (_match, innerPart, offset) => {
        const m = innerPart.match(innerPattern);
        const getLineNumber = () => {
            return Math.max(0, code.substring(0, offset).split('\n').length - 1);
        };
        if (m === null) {
            errors.push({
                line: getLineNumber(),
                message: 'Invalid #uicontrol syntax, expected: #uicontrol <type> <name> <control>(<param>=<value>, ...)'
            });
            return '';
        }
        const typeName = m[1];
        const variableName = m[2];
        const controlName = m[3];
        const parameterText = m[4];
        const { parameters, errors: innerErrors } = parseDirectiveParameters(parameterText);
        for (const error of innerErrors) {
            errors.push({ line: getLineNumber(), message: error });
        }
        if (controls.has(variableName)) {
            errors.push({ line: getLineNumber(), message: `Duplicate definition for control ${variableName}` });
        }
        if (innerErrors.length > 0) {
            return '';
        }
        const parser = controlParsers.get(controlName);
        if (parser === undefined) {
            errors.push({ line: getLineNumber(), message: `Invalid control type ${controlName}` });
            return '';
        }
        const result = parser(typeName, parameters);
        if (result.errors !== undefined) {
            for (const error of result.errors) {
                errors.push({ line: getLineNumber(), message: error });
            }
            return '';
        }
        controls.set(variableName, result.control);
        return '';
    });
    return { source: code, code: newCode, errors, controls };
}
function uniformName(controlName) {
    return `u_shaderControl_${controlName}`;
}
function addControlsToBuilder(controls, builder) {
    for (const [name, control] of controls) {
        builder.addUniform(`highp ${control.valueType}`, uniformName(name));
        builder.addFragmentCode(`#define ${name} ${uniformName(name)}\n`);
    }
}
function objectFromEntries(entries) {
    const obj = {};
    for (const [key, value] of entries) {
        obj[key] = value;
    }
    return obj;
}
function encodeControls(controls) {
    if (controls === undefined)
        return undefined;
    return JSON.stringify(objectFromEntries(controls));
}
class WatchableShaderUiControls {
    constructor() {
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__["NullarySignal"]();
        this.controls = undefined;
    }
    get value() {
        return this.controls;
    }
    set value(newControls) {
        if (encodeControls(newControls) === encodeControls(this.controls)) {
            return;
        }
        this.controls = newControls;
        this.changed.dispatch();
    }
}
function getControlTrackable(control) {
    switch (control.type) {
        case 'slider':
            return new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["TrackableValue"](control.default, x => {
                let v;
                if (control.valueType === 'float') {
                    v = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyFiniteFloat"])(x);
                }
                else {
                    v = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyInt"])(x);
                }
                if (v < control.min || v > control.max) {
                    throw new Error(`${JSON.stringify(x)} is outside valid range [${control.min}, ${control.max}]`);
                }
                return v;
            });
        case 'color':
            return new neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_1__["TrackableRGB"](control.default);
    }
}
class ShaderControlState extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__["RefCounted"] {
    constructor(fragmentMain) {
        super();
        this.fragmentMain = fragmentMain;
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_4__["NullarySignal"]();
        this.controls = new WatchableShaderUiControls();
        this.fragmentMainGeneration = -1;
        this.parseErrors_ = [];
        this.processedFragmentMain_ = '';
        this.controlsGeneration = -1;
        this.state_ = new Map();
        this.unparsedJson = undefined;
        this.registerDisposer(fragmentMain.changed.add(() => this.handleFragmentMainChanged()));
        this.registerDisposer(this.controls.changed.add(() => this.handleControlsChanged()));
        this.handleFragmentMainChanged();
        const self = this;
        this.parseErrors = {
            changed: fragmentMain.changed,
            get value() {
                self.handleFragmentMainChanged();
                return self.parseErrors_;
            }
        };
        this.processedFragmentMain = {
            changed: fragmentMain.changed,
            get value() {
                self.handleFragmentMainChanged();
                return self.processedFragmentMain_;
            }
        };
        this.parseResult = {
            changed: fragmentMain.changed,
            get value() {
                return self.parseResult_;
            }
        };
    }
    handleFragmentMainChanged() {
        const generation = this.fragmentMain.changed.count;
        if (generation === this.fragmentMainGeneration)
            return;
        this.fragmentMainGeneration = generation;
        const result = this.parseResult_ = parseShaderUiControls(this.fragmentMain.value);
        this.parseErrors_ = result.errors;
        this.processedFragmentMain_ = result.code;
        if (result.errors.length === 0) {
            this.controls.value = result.controls;
        }
    }
    handleControlsChanged() {
        const generation = this.controls.changed.count;
        if (generation === this.controlsGeneration) {
            return;
        }
        this.controlsGeneration = generation;
        const controls = this.controls.value;
        if (controls === undefined) {
            return;
        }
        let changed = false;
        const { state_, unparsedJson } = this;
        // Remove values in `state` not in `controls`.
        for (const [name, controlState] of state_) {
            const control = controls.get(name);
            if (control === undefined) {
                controlState.trackable.changed.remove(this.changed.dispatch);
                state_.delete(name);
                changed = true;
                continue;
            }
        }
        for (const [name, control] of controls) {
            let controlState = state_.get(name);
            if (controlState !== undefined &&
                JSON.stringify(controlState.control) !== JSON.stringify(control)) {
                controlState.trackable.changed.remove(this.changed.dispatch);
                controlState = undefined;
            }
            if (controlState === undefined) {
                controlState = { control, trackable: getControlTrackable(control) };
                controlState.trackable.changed.add(this.changed.dispatch);
                state_.set(name, controlState);
                changed = true;
            }
            if (unparsedJson !== undefined && unparsedJson.hasOwnProperty(name)) {
                changed = true;
                try {
                    controlState.trackable.restoreState(unparsedJson[name]);
                }
                catch (_a) {
                    // Ignore error
                }
            }
        }
        if (unparsedJson !== undefined) {
            changed = true;
        }
        this.unparsedJson = undefined;
        if (changed) {
            this.changed.dispatch();
        }
    }
    get state() {
        if (this.controls.changed.count !== this.controlsGeneration) {
            this.handleControlsChanged();
        }
        return this.state_;
    }
    restoreState(value) {
        if (value === undefined)
            return;
        const { state } = this;
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_3__["verifyObject"])(value);
        const controls = this.controls.value;
        if (controls === undefined) {
            this.unparsedJson = value;
            this.changed.dispatch();
            return;
        }
        for (const [key, controlState] of state) {
            const { trackable } = controlState;
            trackable.reset();
            if (value.hasOwnProperty(key)) {
                try {
                    trackable.restoreState(value[key]);
                }
                catch (_a) {
                    // Ignore error
                }
            }
        }
        this.unparsedJson = undefined;
    }
    reset() {
        for (const controlState of this.state.values()) {
            controlState.trackable.reset();
        }
        if (this.unparsedJson !== undefined) {
            this.unparsedJson = undefined;
            this.changed.dispatch();
        }
    }
    toJSON() {
        const { state } = this;
        const { unparsedJson } = this;
        if (unparsedJson !== undefined)
            return unparsedJson;
        const obj = {};
        let empty = true;
        for (const [key, value] of state) {
            const valueJson = value.trackable.toJSON();
            ;
            if (valueJson !== undefined) {
                obj[key] = valueJson;
                empty = false;
            }
        }
        if (empty)
            return undefined;
        return obj;
    }
}
function setControlInShader(gl, shader, name, control, value) {
    const uniform = shader.uniform(uniformName(name));
    switch (control.type) {
        case 'slider':
            switch (control.valueType) {
                case 'int':
                case 'uint':
                    gl.uniform1i(uniform, value);
                    break;
                case 'float':
                    gl.uniform1f(uniform, value);
            }
            break;
        case 'color':
            gl.uniform3fv(uniform, value);
            break;
    }
}
function setControlsInShader(gl, shader, shaderControlState, controls) {
    const { state } = shaderControlState;
    if (shaderControlState.controls.value === controls) {
        // Case when shader doesn't have any errors.
        for (const [name, controlState] of state) {
            setControlInShader(gl, shader, name, controlState.control, controlState.trackable.value);
        }
    }
    else {
        // Case when shader does have errors and we are using the fallback shader, which may have a
        // different/incompatible set of controls.
        for (const [name, control] of controls) {
            const controlState = state.get(name);
            const value = (controlState !== undefined &&
                JSON.stringify(controlState.control) === JSON.stringify(control)) ?
                controlState.trackable.value :
                control.default;
            setControlInShader(gl, shader, name, control, value);
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/webgl/spheres.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/webgl/spheres.ts ***!
  \*******************************************/
/*! exports provided: getSphereVertexArray, getSphereIndexArray, SphereRenderHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSphereVertexArray", function() { return getSphereVertexArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSphereIndexArray", function() { return getSphereIndexArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereRenderHelper", function() { return SphereRenderHelper; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for drawing spheres in WebGL
 */


function getSphereVertexArray(latitudeBands, longitudeBands) {
    const result = new Float32Array((latitudeBands + 1) * (longitudeBands + 1) * 3);
    let i = 0;
    for (let latIndex = 0; latIndex <= latitudeBands; ++latIndex) {
        const theta = latIndex * Math.PI / latitudeBands;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        for (let lonIndex = 0; lonIndex <= longitudeBands; ++lonIndex) {
            const phi = lonIndex * 2 * Math.PI / longitudeBands;
            const sinPhi = Math.sin(phi);
            const cosPhi = Math.cos(phi);
            result[i++] = cosPhi * sinTheta; // x
            result[i++] = cosTheta; // y
            result[i++] = sinPhi * sinTheta; // z
        }
    }
    return result;
}
function getSphereIndexArray(latitudeBands, longitudeBands) {
    const result = new Uint16Array(latitudeBands * longitudeBands * 6);
    let i = 0;
    for (let latIndex = 0; latIndex < latitudeBands; latIndex++) {
        for (let lonIndex = 0; lonIndex < longitudeBands; lonIndex++) {
            const first = (latIndex * (longitudeBands + 1)) + lonIndex;
            const second = first + longitudeBands + 1;
            result[i++] = first;
            result[i++] = second;
            result[i++] = first + 1;
            result[i++] = second;
            result[i++] = second + 1;
            result[i++] = first + 1;
        }
    }
    return result;
}
class SphereRenderHelper extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(gl, latitudeBands, longitudeBands) {
        super();
        this.vertexBuffer =
            this.registerDisposer(Object(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__["getMemoizedBuffer"])(gl, WebGL2RenderingContext.ARRAY_BUFFER, getSphereVertexArray, latitudeBands, longitudeBands))
                .value;
        this.indexBuffer =
            this.registerDisposer(Object(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__["getMemoizedBuffer"])(gl, WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, getSphereIndexArray, latitudeBands, longitudeBands))
                .value;
        this.numIndices = latitudeBands * longitudeBands * 6;
    }
    defineShader(builder) {
        builder.addAttribute('highp vec3', 'aSphereVertex');
        builder.addVarying('highp float', 'vLightingFactor');
        // projectionMatrix = cameraMatrix * modelViewMat
        // normalTransformMatrix = (modelViewMat^{-1})^T
        // eff modelViewMat = modelViewMat * scalMat(radii)
        // normalTransformMatrix =  (modelViewMat * scalMat)^{-1}^T
        // =   (scalMat^{-1} * modelViewMat^{-1})^T
        // =   modelViewMat^{-1}^T * (scalMat^{-1})^T
        builder.addVertexCode(`
void emitSphere(mat4 projectionMatrix, mat4 normalTransformMatrix, vec3 centerPosition, vec3 radii, vec4 lightDirection) {
  vec3 vertexPosition = aSphereVertex * radii + centerPosition;
  gl_Position = projectionMatrix * vec4(vertexPosition, 1.0);
  vec3 normal = normalize((normalTransformMatrix * vec4(aSphereVertex / radii, 0.0)).xyz);
  vLightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;
}
`);
    }
    draw(shader, numInstances) {
        const aSphereVertex = shader.attribute('aSphereVertex');
        this.vertexBuffer.bindToVertexAttrib(aSphereVertex, /*components=*/ 3, /*attributeType=*/ WebGL2RenderingContext.FLOAT, 
        /*normalized=*/ false);
        this.indexBuffer.bind();
        shader.gl.drawElementsInstanced(WebGL2RenderingContext.TRIANGLES, this.numIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 
        /*offset=*/ 0, numInstances);
        shader.gl.disableVertexAttribArray(aSphereVertex);
    }
}


/***/ }),

/***/ "./src/neuroglancer/webgl/square_corners_buffer.ts":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/webgl/square_corners_buffer.ts ***!
  \*********************************************************/
/*! exports provided: getSquareCornersArray, getCubeCornersArray, getSquareCornersBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSquareCornersArray", function() { return getSquareCornersArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCubeCornersArray", function() { return getCubeCornersArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSquareCornersBuffer", function() { return getSquareCornersBuffer; });
/* harmony import */ var neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/array */ "./src/neuroglancer/util/array.ts");
/* harmony import */ var neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/webgl/buffer */ "./src/neuroglancer/webgl/buffer.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function getSquareCornersArray(startX = -1, startY = -1, endX = 1, endY = 1, minorTiles = 1, majorTiles = 1) {
    return Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_0__["tile2dArray"])(new Float32Array([
        startX, startY,
        startX, endY,
        endX, endY,
        endX, startY,
    ]), 
    /*majorDimension=*/ 2, minorTiles, majorTiles);
}
function getCubeCornersArray(startX = -1, startY = -1, startZ = -1, endX = 1, endY = 1, endZ = 1, minorTiles = 1, majorTiles = 1) {
    return Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_0__["tile2dArray"])(new Float32Array([
        startX, startY, startZ,
        endX, startY, startZ,
        startX, endY, startZ,
        endX, endY, startZ,
        startX, startY, endZ,
        endX, startY, endZ,
        startX, endY, endZ,
        endX, endY, endZ,
    ]), 
    /*majorDimension=*/ 3, minorTiles, majorTiles);
}
function getSquareCornersBuffer(gl, startX = -1, startY = -1, endX = 1, endY = 1, minorTiles = 1, majorTiles = 1) {
    return Object(neuroglancer_webgl_buffer__WEBPACK_IMPORTED_MODULE_1__["getMemoizedBuffer"])(gl, WebGL2RenderingContext.ARRAY_BUFFER, getSquareCornersArray, startX, startY, endX, endY, minorTiles, majorTiles)
        .value;
}


/***/ }),

/***/ "./src/neuroglancer/webgl/texture.ts":
/*!*******************************************!*\
  !*** ./src/neuroglancer/webgl/texture.ts ***!
  \*******************************************/
/*! exports provided: setRawTextureParameters, setRawTexture3DParameters, resizeTexture, setTextureFromCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setRawTextureParameters", function() { return setRawTextureParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setRawTexture3DParameters", function() { return setRawTexture3DParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeTexture", function() { return resizeTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTextureFromCanvas", function() { return setTextureFromCanvas; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Sets parameters to make a texture suitable for use as a raw array: NEAREST
 * filtering, clamping.
 */
function setRawTextureParameters(gl) {
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
    // Prevents s-coordinate wrapping (repeating).  Repeating not
    // permitted for non-power-of-2 textures.
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
    // Prevents t-coordinate wrapping (repeating).  Repeating not
    // permitted for non-power-of-2 textures.
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
}
function setRawTexture3DParameters(gl) {
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
    // Prevents s-coordinate wrapping (repeating).  Repeating not
    // permitted for non-power-of-2 textures.
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
    // Prevents t-coordinate wrapping (repeating).  Repeating not
    // permitted for non-power-of-2 textures.
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_R, WebGL2RenderingContext.CLAMP_TO_EDGE);
}
function resizeTexture(gl, texture, width, height, internalFormat = WebGL2RenderingContext.RGBA8, format = WebGL2RenderingContext.RGBA, dataType = WebGL2RenderingContext.UNSIGNED_BYTE) {
    gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + gl.tempTextureUnit);
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
    setRawTextureParameters(gl);
    gl.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, 
    /*internalformat=*/ internalFormat, 
    /*width=*/ width, 
    /*height=*/ height, 
    /*border=*/ 0, 
    /*format=*/ format, dataType, null);
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
}
function setTextureFromCanvas(gl, texture, canvas) {
    gl.activeTexture(WebGL2RenderingContext.TEXTURE0 + gl.tempTextureUnit);
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
    // Prevents s-coordinate wrapping (repeating).  Repeating not permitted for non-power-of-2
    // textures.
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
    // Prevents t-coordinate wrapping (repeating).  Repeating not permitted for non-power-of-2
    // textures.
    gl.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
    gl.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 1);
    gl.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 4);
    gl.texImage2D(WebGL2RenderingContext.TEXTURE_2D, /*level=*/ 0, 
    /*internalformat=*/ WebGL2RenderingContext.RGBA8, 
    /*format=*/ WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, canvas);
    gl.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 0);
    gl.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
}


/***/ }),

/***/ "./src/neuroglancer/webgl/texture_access.ts":
/*!**************************************************!*\
  !*** ./src/neuroglancer/webgl/texture_access.ts ***!
  \**************************************************/
/*! exports provided: OneDimensionalTextureLayout, TextureFormat, integerTextureFormatForNumComponents, floatTextureFormatForNumComponents, textureSelectorForNumComponents, internalUint8FormatForNumComponents, internalUint16FormatForNumComponents, internalUint32FormatForNumComponents, internalFloatFormatForNumComponents, getSamplerPrefixForDataType, computeTextureFormat, compute1dTextureLayout, setOneDimensionalTextureData, setThreeDimensionalTextureData, OneDimensionalTextureAccessHelper, ThreeDimensionalTextureAccessHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneDimensionalTextureLayout", function() { return OneDimensionalTextureLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureFormat", function() { return TextureFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "integerTextureFormatForNumComponents", function() { return integerTextureFormatForNumComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatTextureFormatForNumComponents", function() { return floatTextureFormatForNumComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textureSelectorForNumComponents", function() { return textureSelectorForNumComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "internalUint8FormatForNumComponents", function() { return internalUint8FormatForNumComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "internalUint16FormatForNumComponents", function() { return internalUint16FormatForNumComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "internalUint32FormatForNumComponents", function() { return internalUint32FormatForNumComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "internalFloatFormatForNumComponents", function() { return internalFloatFormatForNumComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSamplerPrefixForDataType", function() { return getSamplerPrefixForDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeTextureFormat", function() { return computeTextureFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compute1dTextureLayout", function() { return compute1dTextureLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOneDimensionalTextureData", function() { return setOneDimensionalTextureData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setThreeDimensionalTextureData", function() { return setThreeDimensionalTextureData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneDimensionalTextureAccessHelper", function() { return OneDimensionalTextureAccessHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThreeDimensionalTextureAccessHelper", function() { return ThreeDimensionalTextureAccessHelper; });
/* harmony import */ var neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/array */ "./src/neuroglancer/util/array.ts");
/* harmony import */ var neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/data_type */ "./src/neuroglancer/util/data_type.ts");
/* harmony import */ var neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/webgl/shader_lib */ "./src/neuroglancer/webgl/shader_lib.ts");
/* harmony import */ var neuroglancer_webgl_texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/webgl/texture */ "./src/neuroglancer/webgl/texture.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file
 * Facilities for reading various data types from 2-D and 3-D WebGL textures.
 *
 * WebGL2 only supports 2-D and 3-D textures, and because implementations typically limit the size
 * of each dimension, a large 1-D array has to be fit to a rectangular 2-D texture, which may
 * require padding.
 */




class OneDimensionalTextureLayout {
}
class TextureFormat {
}
const integerTextureFormatForNumComponents = [
    -1,
    WebGL2RenderingContext.RED_INTEGER,
    WebGL2RenderingContext.RG_INTEGER,
    WebGL2RenderingContext.RGB_INTEGER,
    WebGL2RenderingContext.RGBA_INTEGER
];
const floatTextureFormatForNumComponents = [
    -1,
    WebGL2RenderingContext.RED,
    WebGL2RenderingContext.RG,
    WebGL2RenderingContext.RGB,
    WebGL2RenderingContext.RGBA
];
const textureSelectorForNumComponents = ['', 'r', 'rg', 'rgb', 'rgba'];
const internalUint8FormatForNumComponents = [
    -1,
    WebGL2RenderingContext.R8UI,
    WebGL2RenderingContext.RG8UI,
    WebGL2RenderingContext.RGB8UI,
    WebGL2RenderingContext.RGBA8UI
];
const internalUint16FormatForNumComponents = [
    -1,
    WebGL2RenderingContext.R16UI,
    WebGL2RenderingContext.RG16UI,
    WebGL2RenderingContext.RGB16UI,
    WebGL2RenderingContext.RGBA16UI
];
const internalUint32FormatForNumComponents = [
    -1,
    WebGL2RenderingContext.R32UI,
    WebGL2RenderingContext.RG32UI,
    WebGL2RenderingContext.RGB32UI,
    WebGL2RenderingContext.RGBA32UI
];
const internalFloatFormatForNumComponents = [
    -1,
    WebGL2RenderingContext.R32F,
    WebGL2RenderingContext.RG32F,
    WebGL2RenderingContext.RGB32F,
    WebGL2RenderingContext.RGBA32F
];
function getSamplerPrefixForDataType(dataType) {
    return dataType === neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].FLOAT32 ? '' : 'u';
}
/**
 * Fills in a OneDimensionalTextureFormat object with the suitable texture format for the specified
 * DataType and number of components.
 */
function computeTextureFormat(format, dataType, numComponents = 1) {
    switch (dataType) {
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT8:
            if (numComponents < 1 || numComponents > 4) {
                break;
            }
            format.texelsPerElement = 1;
            format.textureInternalFormat = internalUint8FormatForNumComponents[numComponents];
            format.textureFormat = integerTextureFormatForNumComponents[numComponents];
            format.texelType = WebGL2RenderingContext.UNSIGNED_BYTE;
            format.arrayElementsPerTexel = numComponents;
            format.arrayConstructor = Uint8Array;
            format.samplerPrefix = 'u';
            return format;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT16:
            if (numComponents < 1 || numComponents > 4) {
                break;
            }
            format.texelsPerElement = 1;
            format.textureInternalFormat = internalUint16FormatForNumComponents[numComponents];
            format.textureFormat = integerTextureFormatForNumComponents[numComponents];
            format.texelType = WebGL2RenderingContext.UNSIGNED_SHORT;
            format.arrayElementsPerTexel = numComponents;
            format.arrayConstructor = Uint16Array;
            format.samplerPrefix = 'u';
            return format;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT64:
            if (numComponents < 1 || numComponents > 2) {
                break;
            }
            format.texelsPerElement = 1;
            format.textureInternalFormat = internalUint32FormatForNumComponents[numComponents * 2];
            format.textureFormat = integerTextureFormatForNumComponents[numComponents * 2];
            format.texelType = WebGL2RenderingContext.UNSIGNED_INT;
            format.arrayElementsPerTexel = 2 * numComponents;
            format.arrayConstructor = Uint32Array;
            format.samplerPrefix = 'u';
            return format;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT32:
            if (numComponents < 1 || numComponents > 4) {
                break;
            }
            format.texelsPerElement = 1;
            format.textureInternalFormat = internalUint32FormatForNumComponents[numComponents];
            format.textureFormat = integerTextureFormatForNumComponents[numComponents];
            format.texelType = WebGL2RenderingContext.UNSIGNED_INT;
            format.arrayElementsPerTexel = 1;
            format.arrayConstructor = Uint32Array;
            format.samplerPrefix = 'u';
            return format;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].FLOAT32:
            if (numComponents < 1 || numComponents > 4) {
                break;
            }
            format.texelsPerElement = 1;
            format.textureInternalFormat = internalFloatFormatForNumComponents[numComponents];
            format.textureFormat = floatTextureFormatForNumComponents[numComponents];
            format.texelType = WebGL2RenderingContext.FLOAT;
            format.arrayElementsPerTexel = numComponents;
            format.arrayConstructor = Float32Array;
            format.samplerPrefix = '';
            return format;
    }
    throw new Error(`No supported texture format for ${neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"][dataType]}[${numComponents}].`);
}
function compute1dTextureLayout(layout, gl, texelsPerElement, numElements) {
    const { maxTextureSize } = gl;
    if (numElements * texelsPerElement > maxTextureSize * maxTextureSize) {
        throw new Error('Number of elements exceeds maximum texture size: ' + texelsPerElement + ' * ' +
            numElements);
    }
    const minX = Math.ceil(numElements / maxTextureSize);
    const textureXBits = layout.textureXBits = Math.ceil(Math.log2(minX));
    layout.textureWidth = (1 << textureXBits) * texelsPerElement;
    layout.textureHeight = Math.ceil(numElements / (1 << textureXBits));
}
function setOneDimensionalTextureData(gl, textureLayout, format, data) {
    const { arrayConstructor, arrayElementsPerTexel, textureInternalFormat, textureFormat, } = format;
    const { textureWidth, textureHeight } = textureLayout;
    const requiredSize = textureWidth * textureHeight * arrayElementsPerTexel;
    if (data.constructor !== arrayConstructor) {
        data = new arrayConstructor(data.buffer, data.byteOffset, data.byteLength / arrayConstructor.BYTES_PER_ELEMENT);
    }
    let padded = Object(neuroglancer_util_array__WEBPACK_IMPORTED_MODULE_0__["maybePadArray"])(data, requiredSize);
    gl.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1);
    Object(neuroglancer_webgl_texture__WEBPACK_IMPORTED_MODULE_3__["setRawTextureParameters"])(gl);
    gl.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 
    /*level=*/ 0, textureInternalFormat, 
    /*width=*/ textureWidth, 
    /*height=*/ textureHeight, 
    /*border=*/ 0, textureFormat, format.texelType, padded);
}
function setThreeDimensionalTextureData(gl, format, data, width, height, depth) {
    const { arrayConstructor, textureInternalFormat, textureFormat, texelsPerElement, } = format;
    if (data.constructor !== arrayConstructor) {
        data = new arrayConstructor(data.buffer, data.byteOffset, data.byteLength / arrayConstructor.BYTES_PER_ELEMENT);
    }
    gl.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1);
    Object(neuroglancer_webgl_texture__WEBPACK_IMPORTED_MODULE_3__["setRawTexture3DParameters"])(gl);
    gl.texImage3D(WebGL2RenderingContext.TEXTURE_3D, 
    /*level=*/ 0, textureInternalFormat, 
    /*width=*/ width * texelsPerElement, 
    /*height=*/ height, 
    /*depth=*/ depth, 
    /*border=*/ 0, textureFormat, format.texelType, data);
}
function getShaderCodeForDataType(dataType) {
    switch (dataType) {
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT8:
            return neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_uint8"];
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT16:
            return neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_uint16"];
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT32:
            return neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_uint32"];
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT64:
            return neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_uint64"];
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].FLOAT32:
            return neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_float"];
    }
}
function getAccessorFunction(functionName, readTextureValue, samplerName, indexType, dataType, numComponents) {
    const shaderType = Object(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["getShaderType"])(dataType, numComponents);
    let parts = [getShaderCodeForDataType(dataType)];
    let code = `
${shaderType} ${functionName}(${indexType} index) {
`;
    switch (dataType) {
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT8:
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT16:
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT32:
            code += `
  ${shaderType} result;
  highp uvec4 temp;
  ${readTextureValue}(${samplerName}, index, temp);
  result.value = temp.${textureSelectorForNumComponents[numComponents]};
  return result;
`;
            break;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].UINT64:
            parts.push(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_unpackUint64leFromUint32"]);
            code += `
  highp uvec4 temp;
  ${readTextureValue}(${samplerName}, index, temp);
  return unpackUint64leFromUint32(temp.${textureSelectorForNumComponents[numComponents * 2]});
`;
            break;
        case neuroglancer_util_data_type__WEBPACK_IMPORTED_MODULE_1__["DataType"].FLOAT32:
            parts.push(neuroglancer_webgl_shader_lib__WEBPACK_IMPORTED_MODULE_2__["glsl_float"]);
            code += `
  highp vec4 temp;
  ${readTextureValue}(${samplerName}, index, temp);
  return temp.${textureSelectorForNumComponents[numComponents]};
`;
            break;
    }
    code += `
}
`;
    parts.push(code);
    return parts;
}
class OneDimensionalTextureAccessHelper {
    constructor(key) {
        this.key = key;
        this.uniformName = `uTextureXBits_${this.key}`;
        this.readTextureValue = `readTextureValue_${this.key}`;
    }
    defineShader(builder) {
        let { uniformName } = this;
        builder.addUniform('highp uint', uniformName);
    }
    getReadTextureValueCode(texelsPerElement, samplerPrefix) {
        let { uniformName } = this;
        let code = `
void ${this.readTextureValue}(highp ${samplerPrefix}sampler2D sampler, highp uint index`;
        for (let i = 0; i < texelsPerElement; ++i) {
            code += `, out ${samplerPrefix}vec4 output${i}`;
        }
        code += `) {

  highp int y = int(index >> ${uniformName});
  highp int x = int((index - (uint(y) << ${uniformName})) * ${texelsPerElement}u);
`;
        for (let i = 0; i < texelsPerElement; ++i) {
            code += `
  output${i} = texelFetch(sampler, ivec2(x + ${i}, y), 0);
`;
        }
        code += `
}
`;
        return code;
    }
    getAccessor(functionName, samplerName, dataType, numComponents = 1) {
        const samplerPrefix = getSamplerPrefixForDataType(dataType);
        return [
            this.getReadTextureValueCode(1, samplerPrefix),
            ...getAccessorFunction(functionName, this.readTextureValue, samplerName, 'highp uint', dataType, numComponents)
        ];
    }
    setupTextureLayout(gl, shader, textureLayout) {
        gl.uniform1ui(shader.uniform(this.uniformName), textureLayout.textureXBits);
    }
}
class ThreeDimensionalTextureAccessHelper {
    constructor(key) {
        this.key = key;
        this.readTextureValue = `readTextureValue_${this.key}`;
    }
    getReadTextureValueCode(texelsPerElement, samplerPrefix) {
        let code = `
void ${this.readTextureValue}(highp ${samplerPrefix}sampler3D sampler, highp ivec3 p`;
        for (let i = 0; i < texelsPerElement; ++i) {
            code += `, out ${samplerPrefix}vec4 output${i}`;
        }
        code += `) {
`;
        for (let i = 0; i < texelsPerElement; ++i) {
            code += `
  output${i} = texelFetch(sampler, ivec3(p.x * ${texelsPerElement} + ${i}, p.y, p.z), 0);
`;
        }
        code += `
}
`;
        return code;
    }
    getAccessor(functionName, samplerName, dataType, numComponents = 1) {
        const samplerPrefix = getSamplerPrefixForDataType(dataType);
        return [
            this.getReadTextureValueCode(1, samplerPrefix),
            ...getAccessorFunction(functionName, this.readTextureValue, samplerName, 'highp ivec3', dataType, numComponents)
        ];
    }
}


/***/ }),

/***/ "./src/neuroglancer/webgl/trivial_shaders.ts":
/*!***************************************************!*\
  !*** ./src/neuroglancer/webgl/trivial_shaders.ts ***!
  \***************************************************/
/*! exports provided: defineCopyFragmentShader, elementWiseTextureShader, trivialTextureShader, trivialColorShader, trivialUniformColorShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defineCopyFragmentShader", function() { return defineCopyFragmentShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elementWiseTextureShader", function() { return elementWiseTextureShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trivialTextureShader", function() { return trivialTextureShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trivialColorShader", function() { return trivialColorShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trivialUniformColorShader", function() { return trivialUniformColorShader; });
/* harmony import */ var neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/object_id */ "./src/neuroglancer/util/object_id.ts");
/* harmony import */ var neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/webgl/shader */ "./src/neuroglancer/webgl/shader.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function defineCopyFragmentShader(builder) {
    builder.addOutputBuffer('vec4', 'v4f_fragColor', null);
    builder.setFragmentMain('v4f_fragColor = getValue0();');
}
function elementWiseTextureShader(gl, shaderModule = defineCopyFragmentShader, numTextures = 1) {
    return gl.memoize.get(`elementWiseTextureShader:${numTextures}:${Object(neuroglancer_util_object_id__WEBPACK_IMPORTED_MODULE_0__["getObjectId"])(shaderModule)}`, () => {
        let builder = new neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_1__["ShaderBuilder"](gl);
        builder.addVarying('vec2', 'vTexCoord');
        builder.addUniform('sampler2D', 'uSampler', numTextures);
        builder.addInitializer(shader => {
            let textureIndices = [];
            for (let i = 0; i < numTextures; ++i) {
                textureIndices[i] = i;
            }
            gl.uniform1iv(shader.uniform('uSampler'), textureIndices);
        });
        for (let i = 0; i < numTextures; ++i) {
            builder.addFragmentCode(`
vec4 getValue${i}() {
  return texture(uSampler[${i}], vTexCoord);
}
`);
        }
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.require(shaderModule);
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.addAttribute('vec2', 'aTexCoord');
        builder.setVertexMain('vTexCoord = aTexCoord; gl_Position = uProjectionMatrix * aVertexPosition;');
        return builder.build();
    });
}
function trivialTextureShader(gl) {
    return elementWiseTextureShader(gl, defineCopyFragmentShader, 1);
}
function trivialColorShader(gl) {
    return gl.memoize.get('trivialColorShader', () => {
        let builder = new neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_1__["ShaderBuilder"](gl);
        builder.addVarying('vec4', 'vColor');
        builder.addOutputBuffer('vec4', 'v4f_fragColor', null);
        builder.setFragmentMain('v4f_fragColor = vColor;');
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.addAttribute('vec4', 'aColor');
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.setVertexMain('vColor = aColor; gl_Position = uProjectionMatrix * aVertexPosition;');
        return builder.build();
    });
}
function trivialUniformColorShader(gl) {
    return gl.memoize.get('trivialUniformColorShader', () => {
        let builder = new neuroglancer_webgl_shader__WEBPACK_IMPORTED_MODULE_1__["ShaderBuilder"](gl);
        builder.addUniform('mat4', 'uProjectionMatrix');
        builder.addAttribute('vec4', 'aVertexPosition');
        builder.addUniform('vec4', 'uColor');
        builder.addOutputBuffer('vec4', 'v4f_fragColor', null);
        builder.setFragmentMain('v4f_fragColor = uColor;');
        builder.setVertexMain('gl_Position = uProjectionMatrix * aVertexPosition;');
        return builder.build();
    });
}


/***/ }),

/***/ "./src/neuroglancer/widget/annotation_tool_status.css":
/*!************************************************************!*\
  !*** ./src/neuroglancer/widget/annotation_tool_status.css ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/annotation_tool_status.ts":
/*!***********************************************************!*\
  !*** ./src/neuroglancer/widget/annotation_tool_status.ts ***!
  \***********************************************************/
/*! exports provided: AnnotationToolStatusWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationToolStatusWidget", function() { return AnnotationToolStatusWidget; });
/* harmony import */ var _annotation_tool_status_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotation_tool_status.css */ "./src/neuroglancer/widget/annotation_tool_status.css");
/* harmony import */ var _annotation_tool_status_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_annotation_tool_status_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class AnnotationToolStatusWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(selectedLayer) {
        super();
        this.selectedLayer = selectedLayer;
        this.element = document.createElement('div');
        const { element } = this;
        element.className = 'neuroglancer-annotation-tool-status-widget';
        this.registerDisposer(selectedLayer.changed.add(() => this.selectedLayerChanged()));
        this.selectedLayerChanged();
    }
    selectedLayerChanged() {
        let { unbindPreviousLayer } = this;
        if (unbindPreviousLayer !== undefined) {
            unbindPreviousLayer();
        }
        const layer = this.selectedLayer.layer;
        if (layer !== undefined) {
            this.unbindPreviousLayer = layer.specificationChanged.add(() => {
                this.updateView();
            });
        }
        this.updateView();
    }
    disposed() {
        const { unbindPreviousLayer } = this;
        if (unbindPreviousLayer !== undefined) {
            unbindPreviousLayer();
        }
        this.unbindPreviousLayer = undefined;
    }
    getDescriptionText() {
        const layer = this.selectedLayer.layer;
        if (layer === undefined) {
            return undefined;
        }
        const userLayer = layer.layer;
        if (userLayer === null) {
            return undefined;
        }
        const tool = userLayer.tool.value;
        if (tool === undefined) {
            return undefined;
        }
        return tool.description;
    }
    updateView() {
        this.element.textContent = this.getDescriptionText() || '';
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/associate_label.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/widget/associate_label.ts ***!
  \****************************************************/
/*! exports provided: associateLabelWithElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "associateLabelWithElement", function() { return associateLabelWithElement; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let nextElementId = 0;
function associateLabelWithElement(label, element) {
    if (element.id === '') {
        element.id = `unique-id-for-association-${nextElementId++}`;
    }
    label.setAttribute('for', element.id);
}


/***/ }),

/***/ "./src/neuroglancer/widget/autocomplete.css":
/*!**************************************************!*\
  !*** ./src/neuroglancer/widget/autocomplete.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/autocomplete.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/widget/autocomplete.ts ***!
  \*************************************************/
/*! exports provided: makeDefaultCompletionElement, makeCompletionElementWithDescription, AutocompleteTextInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDefaultCompletionElement", function() { return makeDefaultCompletionElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCompletionElementWithDescription", function() { return makeCompletionElementWithDescription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocompleteTextInput", function() { return AutocompleteTextInput; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_dropdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/dropdown */ "./src/neuroglancer/util/dropdown.ts");
/* harmony import */ var neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/keyboard_bindings */ "./src/neuroglancer/util/keyboard_bindings.ts");
/* harmony import */ var neuroglancer_util_longest_common_prefix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/longest_common_prefix */ "./src/neuroglancer/util/longest_common_prefix.ts");
/* harmony import */ var neuroglancer_util_scroll_into_view__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/scroll_into_view */ "./src/neuroglancer/util/scroll_into_view.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_widget_associate_label__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/widget/associate_label */ "./src/neuroglancer/widget/associate_label.ts");
/* harmony import */ var _autocomplete_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./autocomplete.css */ "./src/neuroglancer/widget/autocomplete.css");
/* harmony import */ var _autocomplete_css__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_autocomplete_css__WEBPACK_IMPORTED_MODULE_10__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











const ACTIVE_COMPLETION_CLASS_NAME = 'autocomplete-completion-active';
const AUTOCOMPLETE_INDEX_SYMBOL = Symbol('autocompleteIndex');
function makeDefaultCompletionElement(completion) {
    let element = document.createElement('div');
    element.textContent = completion.value;
    return element;
}
function makeCompletionElementWithDescription(completion) {
    let element = document.createElement('div');
    element.className = 'autocomplete-completion-with-description';
    element.textContent = completion.value;
    let descriptionElement = document.createElement('div');
    descriptionElement.className = 'autocomplete-completion-description';
    descriptionElement.textContent = completion.description || '';
    element.appendChild(descriptionElement);
    return element;
}
const keyMap = neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_5__["EventActionMap"].fromObject({
    'arrowdown': { action: 'cycle-next-active-completion' },
    'arrowup': { action: 'cycle-prev-active-completion' },
    'tab': { action: 'choose-active-completion-or-prefix', preventDefault: false },
    'enter': { action: 'choose-active-completion', preventDefault: false },
    'escape': { action: 'cancel', preventDefault: false, stopPropagation: false },
});
const DEFAULT_COMPLETION_DELAY = 200; // milliseconds
class AutocompleteTextInput extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_2__["RefCounted"] {
    constructor(options) {
        super();
        this.inputChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_8__["Signal"]();
        this.prevInputValue = '';
        this.completionsVisible = false;
        this.activeCompletionPromise = null;
        this.activeCompletionCancellationToken = undefined;
        this.hasFocus = false;
        this.completionResult = null;
        this.dropdownContentsStale = true;
        this.updateHintScrollPositionTimer = null;
        this.completionElements = null;
        this.hasResultForDropdown = false;
        this.commonPrefix = '';
        /**
         * Index of the active completion.  The active completion is displayed as the hint text and is
         * highlighted in the dropdown.
         */
        this.activeIndex = -1;
        this.dropdownStyleStale = true;
        this.completer = options.completer;
        let { delay = DEFAULT_COMPLETION_DELAY } = options;
        let debouncedCompleter = this.scheduleUpdateCompletions = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => {
            const cancellationToken = this.activeCompletionCancellationToken =
                new neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_1__["CancellationTokenSource"]();
            let activeCompletionPromise = this.activeCompletionPromise =
                this.completer(this.value, cancellationToken);
            if (activeCompletionPromise !== null) {
                activeCompletionPromise.then(completionResult => {
                    if (this.activeCompletionPromise === activeCompletionPromise) {
                        this.setCompletions(completionResult);
                        this.activeCompletionPromise = null;
                    }
                });
            }
        }, delay);
        this.registerDisposer(() => {
            debouncedCompleter.cancel();
        });
        let element = this.element = document.createElement('div');
        element.className = 'autocomplete';
        let dropdownAndInputWrapper = document.createElement('div');
        dropdownAndInputWrapper.className = 'autocomplete-dropdown-wrapper';
        let dropdownElement = this.dropdownElement = document.createElement('div');
        dropdownElement.className = 'autocomplete-dropdown';
        let promptElement = this.promptElement = document.createElement('label');
        promptElement.className = 'autocomplete-prompt';
        let inputWrapperElement = this.inputWrapperElement = document.createElement('div');
        inputWrapperElement.className = 'autocomplete-input-wrapper';
        element.appendChild(promptElement);
        let inputElement = this.inputElement = document.createElement('input');
        inputElement.type = 'text';
        inputElement.autocomplete = 'off';
        inputElement.spellcheck = false;
        inputElement.className = 'autocomplete-input';
        Object(neuroglancer_widget_associate_label__WEBPACK_IMPORTED_MODULE_9__["associateLabelWithElement"])(promptElement, inputElement);
        let hintElement = this.hintElement = document.createElement('input');
        hintElement.type = 'text';
        hintElement.spellcheck = false;
        hintElement.className = 'autocomplete-hint';
        hintElement.disabled = true;
        inputWrapperElement.appendChild(hintElement);
        inputWrapperElement.appendChild(inputElement);
        dropdownAndInputWrapper.appendChild(inputWrapperElement);
        dropdownAndInputWrapper.appendChild(dropdownElement);
        element.appendChild(dropdownAndInputWrapper);
        this.registerInputHandler();
        this.handleInputChanged('');
        this.registerEventListener(this.inputElement, 'focus', () => {
            if (!this.hasFocus) {
                this.hasFocus = true;
                this.dropdownStyleStale = true;
                this.updateDropdown();
            }
        });
        this.registerEventListener(this.inputElement, 'blur', () => {
            if (this.hasFocus) {
                this.hasFocus = false;
                this.updateDropdown();
            }
        });
        this.registerEventListener(element.ownerDocument.defaultView, 'resize', () => {
            this.dropdownStyleStale = true;
        });
        this.registerEventListener(element.ownerDocument.defaultView, 'scroll', () => {
            this.dropdownStyleStale = true;
        });
        this.registerEventListener(this.dropdownElement, 'mousedown', this.handleDropdownMousedown.bind(this));
        this.registerEventListener(this.inputElement, 'keydown', () => {
            // User may have used a keyboard shortcut to scroll the input.
            this.hintScrollPositionMayBeStale();
        });
        this.registerEventListener(this.inputElement, 'mousemove', (event) => {
            if (event.buttons !== 0) {
                // May be dragging the text, which could cause scrolling.  This is not perfect, because we
                // don't detect mouse movements outside of the input box.
                this.hintScrollPositionMayBeStale();
            }
        });
        const keyboardHandler = this.registerDisposer(new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_5__["KeyboardEventBinder"](inputElement, keyMap));
        keyboardHandler.allShortcutsAreGlobal = true;
        Object(neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'cycle-next-active-completion', () => {
            this.cycleActiveCompletion(+1);
        });
        Object(neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'cycle-prev-active-completion', () => {
            this.cycleActiveCompletion(-1);
        });
        Object(neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'choose-active-completion-or-prefix', (event) => {
            if (this.selectActiveCompletion(/*allowPrefix=*/ true)) {
                event.preventDefault();
            }
        });
        Object(neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'choose-active-completion', (event) => {
            if (this.selectActiveCompletion(/*allowPrefix=*/ false)) {
                event.preventDefault();
            }
        });
        Object(neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'cancel', (event) => {
            event.stopPropagation();
            if (this.cancel()) {
                event.detail.preventDefault();
                event.detail.stopPropagation();
            }
        });
    }
    hintScrollPositionMayBeStale() {
        if (this.hintElement.value !== '') {
            this.scheduleUpdateHintScrollPosition();
        }
    }
    get disabled() {
        return this.inputElement.readOnly;
    }
    set disabled(value) {
        this.inputElement.readOnly = value;
    }
    handleDropdownMousedown(event) {
        this.inputElement.focus();
        let { dropdownElement } = this;
        for (let target = event.target; target instanceof HTMLElement; target = target.parentElement) {
            let index = target[AUTOCOMPLETE_INDEX_SYMBOL];
            if (index !== undefined) {
                this.selectCompletion(index);
                break;
            }
            if (target === dropdownElement) {
                break;
            }
        }
        event.preventDefault();
    }
    cycleActiveCompletion(delta) {
        if (this.completionResult === null) {
            return;
        }
        let { activeIndex } = this;
        let numCompletions = this.completionResult.completions.length;
        if (activeIndex === -1) {
            if (delta > 0) {
                activeIndex = 0;
            }
            else {
                activeIndex = numCompletions - 1;
            }
        }
        else {
            activeIndex = (activeIndex + delta + numCompletions) % numCompletions;
        }
        this.setActiveIndex(activeIndex);
    }
    registerInputHandler() {
        const handler = (_event) => {
            let value = this.inputElement.value;
            if (value !== this.prevInputValue) {
                this.prevInputValue = value;
                this.handleInputChanged(value);
            }
        };
        for (let eventType of ['input']) {
            this.registerEventListener(this.inputElement, eventType, handler, /*useCapture=*/ false);
        }
    }
    shouldShowDropdown() {
        let { completionResult } = this;
        if (completionResult === null || !this.hasFocus) {
            return false;
        }
        return this.hasResultForDropdown;
    }
    updateDropdownStyle() {
        let { dropdownElement, inputElement } = this;
        Object(neuroglancer_util_dropdown__WEBPACK_IMPORTED_MODULE_4__["positionDropdown"])(dropdownElement, inputElement, { horizontal: false });
        this.dropdownStyleStale = false;
    }
    updateDropdown() {
        if (this.shouldShowDropdown()) {
            let { dropdownElement } = this;
            let { activeIndex } = this;
            if (this.dropdownContentsStale) {
                let completionResult = this.completionResult;
                let { makeElement = makeDefaultCompletionElement } = completionResult;
                this.completionElements = completionResult.completions.map((completion, index) => {
                    let completionElement = makeElement.call(completionResult, completion);
                    completionElement[AUTOCOMPLETE_INDEX_SYMBOL] = index;
                    completionElement.classList.add('autocomplete-completion');
                    if (activeIndex === index) {
                        completionElement.classList.add(ACTIVE_COMPLETION_CLASS_NAME);
                    }
                    dropdownElement.appendChild(completionElement);
                    return completionElement;
                });
                this.dropdownContentsStale = false;
            }
            if (this.dropdownStyleStale) {
                this.updateDropdownStyle();
            }
            if (!this.completionsVisible) {
                dropdownElement.style.display = 'block';
                this.completionsVisible = true;
            }
            if (activeIndex !== -1) {
                let completionElement = this.completionElements[activeIndex];
                Object(neuroglancer_util_scroll_into_view__WEBPACK_IMPORTED_MODULE_7__["scrollIntoViewIfNeeded"])(completionElement);
            }
        }
        else if (this.completionsVisible) {
            this.dropdownElement.style.display = 'none';
            this.completionsVisible = false;
        }
    }
    setCompletions(completionResult) {
        this.clearCompletions();
        let { completions } = completionResult;
        if (completions.length === 0) {
            return;
        }
        this.completionResult = completionResult;
        if (completions.length === 1) {
            let completion = completions[0];
            if (completionResult.showSingleResult) {
                this.hasResultForDropdown = true;
            }
            else {
                let value = this.prevInputValue;
                if (!completion.value.startsWith(value)) {
                    this.hasResultForDropdown = true;
                }
                else {
                    this.hasResultForDropdown = false;
                }
            }
            if (completionResult.selectSingleResult) {
                this.setActiveIndex(0);
            }
            else {
                this.setHintValue(this.getCompletedValueByIndex(0));
            }
        }
        else {
            this.hasResultForDropdown = true;
            // Check for a common prefix.
            let commonResultPrefix = Object(neuroglancer_util_longest_common_prefix__WEBPACK_IMPORTED_MODULE_6__["longestCommonPrefix"])(function* () {
                for (let completion of completionResult.completions) {
                    yield completion.value;
                }
            }());
            let commonPrefix = this.getCompletedValue(commonResultPrefix);
            let value = this.prevInputValue;
            if (commonPrefix.startsWith(value)) {
                this.commonPrefix = commonPrefix;
                this.setHintValue(commonPrefix);
            }
        }
        this.updateDropdown();
    }
    scheduleUpdateHintScrollPosition() {
        if (this.updateHintScrollPositionTimer === null) {
            this.updateHintScrollPositionTimer = setTimeout(() => {
                this.updateHintScrollPosition();
            }, 0);
        }
    }
    setHintValue(hintValue) {
        let value = this.prevInputValue;
        if (hintValue === value || !hintValue.startsWith(value)) {
            // If the hint value is identical to the current value, there is no need to show it.  Also,
            // if it is not a prefix of the current value, then we cannot show it either.
            hintValue = '';
        }
        this.hintElement.value = hintValue;
        this.scheduleUpdateHintScrollPosition();
    }
    /**
     * This sets the active completion, which causes it to be highlighted and displayed as the hint.
     * Additionally, if the user hits tab then it is chosen.
     */
    setActiveIndex(index) {
        if (!this.dropdownContentsStale) {
            let { activeIndex } = this;
            if (activeIndex !== -1) {
                this.completionElements[activeIndex].classList.remove(ACTIVE_COMPLETION_CLASS_NAME);
            }
            if (index !== -1) {
                let completionElement = this.completionElements[index];
                completionElement.classList.add(ACTIVE_COMPLETION_CLASS_NAME);
                Object(neuroglancer_util_scroll_into_view__WEBPACK_IMPORTED_MODULE_7__["scrollIntoViewIfNeeded"])(completionElement);
            }
        }
        if (index !== -1) {
            this.setHintValue(this.getCompletedValueByIndex(index));
        }
        this.activeIndex = index;
    }
    getCompletedValueByIndex(index) {
        return this.getCompletedValue(this.completionResult.completions[index].value);
    }
    getCompletedValue(completionValue) {
        let completionResult = this.completionResult;
        let value = this.prevInputValue;
        return value.substring(0, completionResult.offset) + completionValue;
    }
    selectActiveCompletion(allowPrefix) {
        let { activeIndex } = this;
        if (activeIndex === -1) {
            if (!allowPrefix) {
                return false;
            }
            let { completionResult } = this;
            if (completionResult !== null && completionResult.completions.length === 1) {
                activeIndex = 0;
            }
            else {
                let { commonPrefix } = this;
                if (commonPrefix.length > this.value.length) {
                    this.value = commonPrefix;
                    return true;
                }
                return false;
            }
        }
        let newValue = this.getCompletedValueByIndex(activeIndex);
        if (this.value === newValue) {
            return false;
        }
        this.value = newValue;
        return true;
    }
    selectCompletion(index) {
        this.value = this.getCompletedValueByIndex(index);
    }
    /**
     * Called when user presses escape.  Does nothing here, but may be overridden in a subclass.
     */
    cancel() {
        return false;
    }
    /**
     * Updates the hintElement scroll position to match the scroll position of inputElement.
     *
     * This is called asynchronously after the input changes because automatic scrolling appears to
     * take place after the 'input' event fires.
     */
    updateHintScrollPosition() {
        this.updateHintScrollPositionTimer = null;
        this.hintElement.scrollLeft = this.inputElement.scrollLeft;
    }
    cancelActiveCompletion() {
        const token = this.activeCompletionCancellationToken;
        if (token !== undefined) {
            token.cancel();
        }
        this.activeCompletionCancellationToken = undefined;
        this.activeCompletionPromise = null;
    }
    handleInputChanged(value) {
        this.cancelActiveCompletion();
        this.hintElement.value = '';
        this.clearCompletions();
        this.inputChanged.dispatch(value);
        this.scheduleUpdateCompletions();
    }
    clearCompletions() {
        if (this.completionResult !== null) {
            this.activeIndex = -1;
            this.completionResult = null;
            this.completionElements = null;
            this.dropdownContentsStale = true;
            this.dropdownStyleStale = true;
            this.commonPrefix = '';
            Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_3__["removeChildren"])(this.dropdownElement);
            this.updateDropdown();
        }
    }
    get value() {
        return this.prevInputValue;
    }
    set value(value) {
        if (value !== this.prevInputValue) {
            this.inputElement.value = value;
            this.prevInputValue = value;
            this.handleInputChanged(value);
        }
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_3__["removeFromParent"])(this.element);
        this.cancelActiveCompletion();
        if (this.updateHintScrollPositionTimer !== null) {
            clearTimeout(this.updateHintScrollPositionTimer);
            this.updateHintScrollPositionTimer = null;
        }
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/close_button.ts":
/*!*************************************************!*\
  !*** ./src/neuroglancer/widget/close_button.ts ***!
  \*************************************************/
/*! exports provided: makeCloseButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCloseButton", function() { return makeCloseButton; });
/* harmony import */ var neuroglancer_widget_text_icon_button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/widget/text_icon_button */ "./src/neuroglancer/widget/text_icon_button.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function makeCloseButton() {
    return Object(neuroglancer_widget_text_icon_button__WEBPACK_IMPORTED_MODULE_0__["makeTextIconButton"])('');
}


/***/ }),

/***/ "./src/neuroglancer/widget/color.ts":
/*!******************************************!*\
  !*** ./src/neuroglancer/widget/color.ts ***!
  \******************************************/
/*! exports provided: ColorWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorWidget", function() { return ColorWidget; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class ColorWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(model) {
        super();
        this.model = model;
        this.element = document.createElement('input');
        const { element } = this;
        element.classList.add('neuroglancer-color-widget');
        element.type = 'color';
        element.addEventListener('change', () => this.updateModel());
        this.registerDisposer(model.changed.add(() => this.updateView()));
        this.updateView();
    }
    updateView() {
        this.element.value = this.model.toString();
    }
    updateModel() {
        this.model.restoreState(this.element.value);
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_1__["removeFromParent"])(this.element);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/coordinate_transform.css":
/*!**********************************************************!*\
  !*** ./src/neuroglancer/widget/coordinate_transform.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/coordinate_transform.ts":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/widget/coordinate_transform.ts ***!
  \*********************************************************/
/*! exports provided: CoordinateTransformTab */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CoordinateTransformTab", function() { return CoordinateTransformTab; });
/* harmony import */ var _coordinate_transform_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coordinate_transform.css */ "./src/neuroglancer/widget/coordinate_transform.css");
/* harmony import */ var _coordinate_transform_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_coordinate_transform_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_float32_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/float32_to_string */ "./src/neuroglancer/util/float32_to_string.ts");
/* harmony import */ var neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/widget/tab_view */ "./src/neuroglancer/widget/tab_view.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Tab for updating a coordinate transform.
 */



class CoordinateTransformTab extends neuroglancer_widget_tab_view__WEBPACK_IMPORTED_MODULE_2__["Tab"] {
    constructor(transform) {
        super();
        this.transform = transform;
        this.textArea = document.createElement('textarea');
        this.modelGeneration = -1;
        const { element } = this;
        element.classList.add('neuroglancer-coordinate-transform-widget');
        const { textArea } = this;
        const textAreaLabel = document.createElement('label');
        textAreaLabel.className = 'neuroglancer-coordinate-transform-widget-homogeneous';
        textAreaLabel.textContent = '34 Homogeneous transformation matrix';
        textAreaLabel.appendChild(textArea);
        element.appendChild(textAreaLabel);
        this.registerDisposer(transform.changed.add(() => this.updateView()));
        this.registerDisposer(this.visibility.changed.add(() => this.updateView()));
        textArea.addEventListener('change', () => this.updateModel());
        textArea.addEventListener('blur', () => this.updateModel());
        textArea.title = 'Homogeneous transformation matrix';
        textArea.rows = 3;
        const resetButton = document.createElement('button');
        resetButton.textContent = 'Reset to identity';
        resetButton.addEventListener('click', () => this.transform.reset());
        element.appendChild(resetButton);
        this.updateView();
    }
    updateView() {
        if (!this.visible) {
            return;
        }
        const generation = this.transform.changed.count;
        if (this.modelGeneration !== generation) {
            let value = '';
            const { transform } = this.transform;
            for (let i = 0; i < 3; ++i) {
                if (i !== 0) {
                    value += '\n';
                }
                for (let j = 0; j < 4; ++j) {
                    const x = transform[j * 4 + i];
                    if (j !== 0) {
                        value += ' ';
                    }
                    value += Object(neuroglancer_util_float32_to_string__WEBPACK_IMPORTED_MODULE_1__["float32ToString"])(x);
                }
            }
            this.textArea.value = value;
            this.modelGeneration = generation;
        }
    }
    updateModel() {
        const parts = this.textArea.value.split(/[\s,\[\]\(\)\{\}]/).filter(x => x.length > 0);
        if (parts.length === 12) {
            const numbers = [];
            for (let i = 0; i < 12; ++i) {
                const n = parseFloat(parts[i]);
                if (Number.isNaN(n)) {
                    return false;
                }
                numbers[i] = n;
            }
            const { transform } = this.transform;
            transform[3] = transform[7] = transform[10] = 0;
            transform[15] = 1;
            for (let i = 0; i < 4; ++i) {
                for (let j = 0; j < 3; ++j) {
                    transform[i * 4 + j] = numbers[i + j * 4];
                }
            }
            this.transform.changed.dispatch();
            return true;
        }
        return false;
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/enum_widget.ts":
/*!************************************************!*\
  !*** ./src/neuroglancer/widget/enum_widget.ts ***!
  \************************************************/
/*! exports provided: EnumSelectWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnumSelectWidget", function() { return EnumSelectWidget; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class EnumSelectWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(model) {
        super();
        this.model = model;
        this.element = document.createElement('select');
        this.valueIndexMap = new Map();
        const { element, valueIndexMap } = this;
        let index = 0;
        for (const key of Object.keys(model.enumType)) {
            if (isNaN(Number(key))) {
                const option = document.createElement('option');
                option.textContent = option.value = key.toLowerCase();
                element.appendChild(option);
                valueIndexMap.set(model.enumType[key], index);
                ++index;
            }
        }
        this.registerDisposer(model.changed.add(() => this.updateView()));
        this.registerEventListener(element, 'change', () => this.updateModel());
        this.registerEventListener(element, 'wheel', (event) => {
            let { deltaY } = event;
            if (deltaY > 0) {
                element.selectedIndex =
                    (element.options.length + element.selectedIndex - 1) % element.options.length;
                this.updateModel();
            }
            else if (deltaY < 0) {
                element.selectedIndex =
                    (element.options.length + element.selectedIndex + 1) % element.options.length;
                this.updateModel();
            }
        });
        this.updateView();
    }
    updateView() {
        const { element } = this;
        element.selectedIndex = this.valueIndexMap.get(this.model.value);
    }
    updateModel() {
        this.model.restoreState(this.element.value);
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/hidden_submit_button.ts":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/widget/hidden_submit_button.ts ***!
  \*********************************************************/
/*! exports provided: makeHiddenSubmitButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeHiddenSubmitButton", function() { return makeHiddenSubmitButton; });
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This creates a form submit button that is not displayed, in order that the form may be submitted
 * using the enter key.
 */
function makeHiddenSubmitButton() {
    let element = document.createElement('button');
    element.type = 'submit';
    element.className = 'hidden-submit-button';
    // We apply these styles directly to the element rather than by styling the class in order to
    // avoid them being overridden accidentally.
    element.style.margin = '0';
    element.style.border = '0';
    element.style.padding = '0';
    element.style.width = '0';
    element.style.height = '0';
    element.style.overflow = 'hidden';
    element.tabIndex = -1;
    return element;
}


/***/ }),

/***/ "./src/neuroglancer/widget/layer_reference.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/widget/layer_reference.ts ***!
  \****************************************************/
/*! exports provided: LayerReferenceWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerReferenceWidget", function() { return LayerReferenceWidget; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class LayerReferenceWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(ref) {
        super();
        this.ref = ref;
        this.element = document.createElement('label');
        this.selectElement = document.createElement('select');
        this.registerDisposer(ref);
        const { element, selectElement } = this;
        element.appendChild(selectElement);
        this.updateView();
        this.registerEventListener(selectElement, 'change', () => this.updateModel());
        this.registerDisposer(this.ref.changed.add(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => this.updateView(), 0)));
    }
    updateModel() {
        this.ref.layerName = this.selectElement.value || undefined;
    }
    updateView() {
        const { selectElement, ref } = this;
        const { filter } = ref;
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeChildren"])(selectElement);
        const emptyOption = document.createElement('option');
        selectElement.appendChild(emptyOption);
        for (const layer of this.ref.layerManager.managedLayers) {
            if (filter(layer)) {
                const option = document.createElement('option');
                const { name } = layer;
                option.textContent = name;
                option.value = name;
                selectElement.appendChild(option);
            }
        }
        selectElement.value = ref.layerName || '';
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/number_input_widget.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/widget/number_input_widget.ts ***!
  \********************************************************/
/*! exports provided: NumberInputWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberInputWidget", function() { return NumberInputWidget; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class NumberInputWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(model, options = {}) {
        super();
        this.model = model;
        this.element = document.createElement('label');
        this.inputElement = document.createElement('input');
        let { validator, label } = options;
        const { element, inputElement } = this;
        if (validator === undefined) {
            if (model instanceof neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["TrackableValue"]) {
                validator = model.validator;
            }
            else {
                validator = x => x;
            }
        }
        this.validator = validator;
        if (label !== undefined) {
            element.textContent = label;
        }
        element.appendChild(inputElement);
        element.className = 'neuroglancer-number-input';
        inputElement.type = 'input';
        this.registerDisposer(this.model.changed.add(() => this.updateView()));
        this.registerEventListener(inputElement, 'change', () => this.updateModel());
        this.updateView();
    }
    updateView() {
        this.inputElement.value = '' + this.model.value;
    }
    updateModel() {
        let value = parseFloat(this.inputElement.value.trim());
        if (Number.isNaN(value)) {
            this.updateView();
            return;
        }
        try {
            value = this.validator(value);
            this.model.value = value;
        }
        catch (_a) {
            this.updateView();
        }
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeFromParent"])(this.element);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/position_widget.css":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/widget/position_widget.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/position_widget.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/widget/position_widget.ts ***!
  \****************************************************/
/*! exports provided: positionDragType, PositionWidget, VoxelSizeWidget, MousePositionWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionDragType", function() { return positionDragType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionWidget", function() { return PositionWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoxelSizeWidget", function() { return VoxelSizeWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MousePositionWidget", function() { return MousePositionWidget; });
/* harmony import */ var neuroglancer_status__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/status */ "./src/neuroglancer/status.ts");
/* harmony import */ var neuroglancer_util_animation_frame_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/animation_frame_debounce */ "./src/neuroglancer/util/animation_frame_debounce.ts");
/* harmony import */ var neuroglancer_util_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/clipboard */ "./src/neuroglancer/util/clipboard.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/keyboard_bindings */ "./src/neuroglancer/util/keyboard_bindings.ts");
/* harmony import */ var neuroglancer_util_mouse_bindings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/mouse_bindings */ "./src/neuroglancer/util/mouse_bindings.ts");
/* harmony import */ var neuroglancer_util_number_to_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/number_to_string */ "./src/neuroglancer/util/number_to_string.ts");
/* harmony import */ var neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/widget/scale_bar */ "./src/neuroglancer/widget/scale_bar.ts");
/* harmony import */ var _position_widget_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./position_widget.css */ "./src/neuroglancer/widget/position_widget.css");
/* harmony import */ var _position_widget_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_position_widget_css__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/ui/button.css */ "./src/neuroglancer/ui/button.css");
/* harmony import */ var neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_ui_button_css__WEBPACK_IMPORTED_MODULE_12__);
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













const positionDragType = 'neuroglancer-position';
const inputEventMap = neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["EventActionMap"].fromObject({
    'tab': { action: 'tab-forward', preventDefault: false },
    'arrowup': { action: 'adjust-up' },
    'arrowdown': { action: 'adjust-down' },
    'wheel': { action: 'adjust-via-wheel' },
    'shift+tab': { action: 'tab-backward', preventDefault: false },
    'backspace': { action: 'delete-backward', preventDefault: false },
    'escape': { action: 'cancel' },
    'mouseup0': { action: 'select-all-if-was-not-focused', preventDefault: false },
});
const normalizedPrefixString = '  ';
const normalizedSeparatorString = ',   ';
class PositionWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(position, maxNumberWidth = 6) {
        super();
        this.position = position;
        this.maxNumberWidth = maxNumberWidth;
        this.element = document.createElement('div');
        this.inputContainer = document.createElement('div');
        this.inputElement = document.createElement('input');
        this.hintElement = document.createElement('input');
        this.tempPosition = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create();
        this.updateHintScrollPosition = this.registerCancellable(Object(neuroglancer_util_animation_frame_debounce__WEBPACK_IMPORTED_MODULE_1__["animationFrameDebounce"])(() => {
            this.hintElement.scrollLeft = this.inputElement.scrollLeft;
        }));
        const { element, inputElement, hintElement, inputContainer } = this;
        inputContainer.className = 'neuroglancer-position-widget-input-container';
        inputElement.className = 'neuroglancer-position-widget-input';
        hintElement.className = 'neuroglancer-position-widget-hint';
        this.inputFieldWidth =
            maxNumberWidth * 3 + normalizedPrefixString.length + normalizedSeparatorString.length * 2 + 1;
        for (const x of [inputElement, hintElement]) {
            x.spellcheck = false;
            x.autocomplete = 'off';
            x.type = 'text';
            x.style.width = this.inputFieldWidth + 'ch';
        }
        hintElement.disabled = true;
        const copyButton = document.createElement('div');
        copyButton.textContent = '';
        copyButton.className = 'neuroglancer-copy-button neuroglancer-button';
        copyButton.title = 'Copy position to clipboard';
        copyButton.addEventListener('click', () => {
            const result = Object(neuroglancer_util_clipboard__WEBPACK_IMPORTED_MODULE_2__["setClipboard"])(this.getPositionText());
            neuroglancer_status__WEBPACK_IMPORTED_MODULE_0__["StatusMessage"].showTemporaryMessage(result ? 'Position copied to clipboard' : 'Failed to copy position to clipboard');
        });
        copyButton.addEventListener('dragstart', event => {
            event.dataTransfer.setData(positionDragType, JSON.stringify(position.toJSON()));
            event.dataTransfer.setData('text', this.getPositionText());
            event.stopPropagation();
        });
        copyButton.draggable = true;
        element.appendChild(copyButton);
        element.appendChild(inputContainer);
        inputContainer.appendChild(inputElement);
        inputContainer.appendChild(hintElement);
        element.className = 'neuroglancer-position-widget';
        this.registerDisposer(position.changed.add(this.registerCancellable(Object(neuroglancer_util_animation_frame_debounce__WEBPACK_IMPORTED_MODULE_1__["animationFrameDebounce"])(() => this.updateView()))));
        const keyboardHandler = this.registerDisposer(new neuroglancer_util_keyboard_bindings__WEBPACK_IMPORTED_MODULE_7__["KeyboardEventBinder"](inputElement, inputEventMap));
        keyboardHandler.allShortcutsAreGlobal = true;
        this.registerDisposer(new neuroglancer_util_mouse_bindings__WEBPACK_IMPORTED_MODULE_8__["MouseEventBinder"](inputElement, inputEventMap));
        this.registerEventListener(inputElement, 'change', () => this.updatePosition());
        this.registerEventListener(inputElement, 'blur', () => this.updatePosition());
        this.registerEventListener(inputElement, 'input', () => this.cleanInput());
        this.registerEventListener(inputElement, 'keydown', this.updateHintScrollPosition);
        this.registerEventListener(inputElement, 'copy', (event) => {
            const { selectionStart, selectionEnd } = inputElement;
            let selection = inputElement.value.substring(selectionStart || 0, selectionEnd || 0);
            selection = selection.trim().replace(/\s+/g, ' ');
            const { clipboardData } = event;
            if (clipboardData !== null) {
                clipboardData.setData('text/plain', selection);
            }
            event.stopPropagation();
            event.preventDefault();
        });
        let wasFocused = false;
        this.registerEventListener(inputElement, 'mousedown', () => {
            wasFocused = document.activeElement === inputElement;
        });
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'select-all-if-was-not-focused', event => {
            if (wasFocused) {
                return;
            }
            inputElement.selectionStart = 0;
            inputElement.selectionEnd = inputElement.value.length;
            inputElement.selectionDirection = 'forward';
            event.preventDefault();
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'tab-forward', event => {
            const selectionStart = Math.min(inputElement.selectionStart || 0, inputElement.selectionEnd || 0);
            const valueSubstring = inputElement.value.substring(selectionStart);
            const match = valueSubstring.match(/^([^,\s]*)((?:\s+)|(?:\s*,\s*))?([^,\s]*)/);
            if (match !== null) {
                // Already on a field.  Pick the next field.
                if (match[2] !== undefined) {
                    inputElement.selectionStart = selectionStart + match[1].length + match[2].length;
                    inputElement.selectionEnd = inputElement.selectionStart + match[3].length;
                    inputElement.selectionDirection = 'forward';
                    event.preventDefault();
                    return;
                }
            }
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'tab-backward', event => {
            const selectionEnd = Math.max(inputElement.selectionStart || 0, inputElement.selectionEnd || 0);
            const valueSubstring = inputElement.value.substring(0, selectionEnd);
            const match = valueSubstring.match(/([^,\s]*)((?:\s+)|(?:\s*,\s*))?([^,\s]*)$/);
            if (match !== null) {
                // Already on a field.  Pick the previous field.
                if (match[2] !== undefined) {
                    inputElement.selectionStart = match.index;
                    inputElement.selectionEnd = inputElement.selectionStart + match[1].length;
                    inputElement.selectionDirection = 'forward';
                    event.preventDefault();
                    return;
                }
            }
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'delete-backward', event => {
            if (inputElement.selectionStart === inputElement.selectionEnd &&
                inputElement.selectionStart === inputElement.value.length) {
                const match = inputElement.value.match(/^(.*)(?![\s])(?:(?:\s+)|(?:\s*,\s*))$/);
                if (match !== null) {
                    inputElement.value = match[1];
                    this.cleanInput();
                    event.preventDefault();
                    return;
                }
            }
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'cancel', () => {
            this.updateView();
            this.inputElement.blur();
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'adjust-via-wheel', actionEvent => {
            const event = actionEvent.detail;
            const { deltaY } = event;
            if (deltaY === 0) {
                return;
            }
            const mouseCursorPosition = Math.ceil((inputElement.scrollLeft + event.offsetX - inputElement.clientLeft) /
                (inputElement.scrollWidth / this.inputFieldWidth));
            this.adjustFromCursor(mouseCursorPosition, -Math.sign(deltaY));
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'adjust-up', () => {
            this.adjustFromCursor(undefined, 1);
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_5__["registerActionListener"])(inputElement, 'adjust-down', () => {
            this.adjustFromCursor(undefined, -1);
        }));
        this.updateView();
    }
    adjustFromCursor(cursorPosition, adjustment) {
        const { inputElement } = this;
        if (cursorPosition === undefined) {
            cursorPosition =
                (inputElement.selectionDirection === 'forward' ? inputElement.selectionEnd :
                    inputElement.selectionStart) ||
                    0;
        }
        if (this.cleanInput() === undefined) {
            return;
        }
        const substring = inputElement.value.substring(0, cursorPosition);
        const axisIndex = substring.split(',').length - 1;
        this.updatePosition();
        const voxelCoordinates = this.tempPosition;
        if (this.position.getVoxelCoordinates(voxelCoordinates)) {
            voxelCoordinates[axisIndex] += adjustment;
            this.position.setVoxelCoordinates(voxelCoordinates);
            this.updateView();
        }
    }
    cleanInput() {
        const s = this.inputElement.value;
        const cursorPosition = this.inputElement.selectionStart || 0;
        const numberPattern = /(-?\d+(?:\.(?:\d+)?)?)/.source;
        const separatorPattern = /((?:\s+(?![\s,]))|(?:\s*,\s*))/.source;
        const startAndEndPattern = /([\[\]{}()\s]*)/.source;
        const pattern = new RegExp(`^${startAndEndPattern}(?![\\s])${numberPattern}?` +
            `(?:${separatorPattern}${numberPattern}?(?:${separatorPattern}${numberPattern}?)?)?` +
            `${startAndEndPattern}$`);
        const match = s.match(pattern);
        if (match !== null) {
            let cleanInput = normalizedPrefixString;
            let hint = 'x ';
            let cleanCursor = 2;
            let curFieldStart = match[1].length;
            const processField = (matchText, replacementText = undefined, hintText = undefined) => {
                if (matchText === undefined) {
                    return;
                }
                let curFieldEnd = curFieldStart + matchText.length;
                if (replacementText === undefined) {
                    replacementText = matchText;
                    hintText = ' '.repeat(replacementText.length);
                }
                if (cursorPosition >= curFieldStart) {
                    if (cursorPosition === curFieldEnd) {
                        cleanCursor = cleanInput.length + replacementText.length;
                    }
                    else {
                        cleanCursor = cleanInput.length +
                            Math.min(replacementText.length, cursorPosition - curFieldStart);
                    }
                }
                cleanInput += replacementText;
                hint += hintText;
                curFieldStart = curFieldEnd;
            };
            processField(match[2]);
            processField(match[3], normalizedSeparatorString, '  y ');
            processField(match[4]);
            processField(match[5], normalizedSeparatorString, '  z ');
            processField(match[6]);
            this.hintElement.value = hint;
            if (this.inputElement.value !== cleanInput) {
                this.inputElement.value = cleanInput;
                this.inputElement.selectionEnd = cleanCursor;
                this.inputElement.selectionStart = cleanCursor;
            }
            this.updateHintScrollPosition();
            if (match[2] !== undefined && match[4] !== undefined && match[6] !== undefined) {
                return {
                    position: neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].set(this.tempPosition, parseFloat(match[2]), parseFloat(match[4]), parseFloat(match[6]))
                };
            }
            return {};
        }
        else {
            this.hintElement.value = '';
        }
        return undefined;
    }
    updatePosition() {
        const cleanResult = this.cleanInput();
        if (cleanResult !== undefined && cleanResult.position !== undefined) {
            this.position.setVoxelCoordinates(cleanResult.position);
        }
    }
    getPositionText() {
        const { position } = this;
        const voxelPosition = this.tempPosition;
        if (position.getVoxelCoordinates(voxelPosition)) {
            return `${Math.floor(voxelPosition[0])}, ${Math.floor(voxelPosition[1])}, ${Math.floor(voxelPosition[2])}`;
        }
        else {
            return '<unspecified position>';
        }
    }
    updateView() {
        const { position } = this;
        const voxelPosition = this.tempPosition;
        if (position.getVoxelCoordinates(voxelPosition)) {
            const { inputElement } = this;
            const inputText = `  ${Math.floor(voxelPosition[0])},   ${Math.floor(voxelPosition[1])},   ${Math.floor(voxelPosition[2])}`;
            const firstComma = inputText.indexOf(',');
            const secondComma = inputText.indexOf(',', firstComma + 1);
            const xLen = firstComma - 2;
            const yLen = secondComma - firstComma - 4;
            let hintText = `x ${' '.repeat(xLen)}  y ${' '.repeat(yLen)}  z`;
            const prevSelectionStart = inputElement.selectionStart || 0;
            const prevSelectionEnd = inputElement.selectionEnd || 0;
            const prevSelectionDirection = inputElement.selectionDirection || undefined;
            inputElement.value = inputText;
            inputElement.setSelectionRange(prevSelectionStart, prevSelectionEnd, prevSelectionDirection);
            this.hintElement.value = hintText + ' '.repeat(inputText.length - hintText.length);
            this.updateHintScrollPosition();
        }
        else {
            this.inputElement.value = '';
            this.hintElement.value = '';
        }
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_4__["removeFromParent"])(this.element);
        super.disposed();
    }
}
class VoxelSizeWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(element, voxelSize) {
        super();
        this.element = element;
        this.voxelSize = voxelSize;
        this.dimensionsContainer = document.createElement('span');
        this.unitsElement = document.createElement('span');
        const { dimensionsContainer, unitsElement } = this;
        element.className = 'neuroglancer-voxel-size-widget';
        element.title = 'Voxel size';
        dimensionsContainer.className = 'neuroglancer-voxel-size-dimensions-container';
        element.appendChild(dimensionsContainer);
        element.appendChild(unitsElement);
        unitsElement.className = 'neuroglancer-voxel-size-units';
        this.registerDisposer(voxelSize.changed.add(this.registerCancellable(Object(neuroglancer_util_animation_frame_debounce__WEBPACK_IMPORTED_MODULE_1__["animationFrameDebounce"])(() => this.updateView()))));
        this.updateView();
    }
    updateView() {
        const { dimensionsContainer, unitsElement } = this;
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_4__["removeChildren"])(dimensionsContainer);
        if (!this.voxelSize.valid) {
            this.element.style.display = 'none';
        }
        else {
            this.element.style.display = null;
        }
        const { size } = this.voxelSize;
        const minVoxelSize = Math.min(size[0], size[1], size[2]);
        const unit = Object(neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_10__["pickLengthUnit"])(minVoxelSize);
        unitsElement.textContent = unit.unit;
        for (let i = 0; i < 3; ++i) {
            const s = Object(neuroglancer_util_number_to_string__WEBPACK_IMPORTED_MODULE_9__["numberToStringFixed"])(size[i] / unit.lengthInNanometers, 2);
            const dimElement = document.createElement('span');
            dimElement.className = 'neuroglancer-voxel-size-dimension';
            dimElement.textContent = s;
            dimensionsContainer.appendChild(dimElement);
        }
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_4__["removeFromParent"])(this.element);
        super.disposed();
    }
}
class MousePositionWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_3__["RefCounted"] {
    constructor(element, mouseState, voxelSize) {
        super();
        this.element = element;
        this.mouseState = mouseState;
        this.voxelSize = voxelSize;
        this.tempPosition = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_6__["vec3"].create();
        element.className = 'neuroglancer-mouse-position-widget';
        const updateViewFunction = this.registerCancellable(Object(neuroglancer_util_animation_frame_debounce__WEBPACK_IMPORTED_MODULE_1__["animationFrameDebounce"])(() => this.updateView()));
        this.registerDisposer(mouseState.changed.add(updateViewFunction));
        this.registerDisposer(voxelSize.changed.add(updateViewFunction));
    }
    updateView() {
        let text = '';
        const { mouseState, voxelSize } = this;
        if (mouseState.active && voxelSize.valid) {
            const p = this.tempPosition;
            voxelSize.voxelFromSpatial(p, mouseState.position);
            text = `x ${Math.floor(p[0])},  y ${Math.floor(p[1])},  z ${Math.floor(p[2])}`;
        }
        this.element.textContent = text;
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_4__["removeFromParent"])(this.element);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/range.css":
/*!*******************************************!*\
  !*** ./src/neuroglancer/widget/range.css ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/range.ts":
/*!******************************************!*\
  !*** ./src/neuroglancer/widget/range.ts ***!
  \******************************************/
/*! exports provided: RangeWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RangeWidget", function() { return RangeWidget; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var _range_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./range.css */ "./src/neuroglancer/widget/range.css");
/* harmony import */ var _range_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_range_css__WEBPACK_IMPORTED_MODULE_2__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class RangeWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(value, { min = 0, max = 1, step = 0.01 } = {}) {
        super();
        this.value = value;
        this.element = document.createElement('label');
        this.promptElement = document.createElement('span');
        this.inputElement = document.createElement('input');
        this.numericInputElement = document.createElement('input');
        let { element, promptElement, inputElement, numericInputElement } = this;
        element.className = 'range-slider';
        promptElement.className = 'range-prompt';
        const initInputElement = (el) => {
            el.min = '' + min;
            el.max = '' + max;
            el.step = '' + step;
            el.valueAsNumber = this.value.value;
            const inputValueChanged = () => {
                this.value.value = el.valueAsNumber;
            };
            this.registerEventListener(el, 'change', inputValueChanged);
            this.registerEventListener(el, 'input', inputValueChanged);
            this.registerEventListener(el, 'wheel', (event) => {
                let { deltaY } = event;
                if (deltaY > 0) {
                    el.stepUp();
                    inputValueChanged();
                }
                else if (deltaY < 0) {
                    el.stepDown();
                    inputValueChanged();
                }
            });
        };
        inputElement.type = 'range';
        initInputElement(inputElement);
        numericInputElement.type = 'number';
        const maxNumberWidth = Math.max(min.toString().length, max.toString().length, Math.min(max, min + step).toString().length, Math.max(min, max - step).toString().length);
        numericInputElement.style.width = (maxNumberWidth + 2) + 'ch';
        initInputElement(numericInputElement);
        element.appendChild(promptElement);
        element.appendChild(inputElement);
        element.appendChild(numericInputElement);
        value.changed.add(() => {
            this.inputElement.valueAsNumber = this.value.value;
            this.numericInputElement.valueAsNumber = this.value.value;
        });
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_1__["removeFromParent"])(this.element);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/render_scale_widget.css":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/widget/render_scale_widget.css ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/render_scale_widget.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/widget/render_scale_widget.ts ***!
  \********************************************************/
/*! exports provided: RenderScaleWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderScaleWidget", function() { return RenderScaleWidget; });
/* harmony import */ var neuroglancer_widget_render_scale_widget_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/widget/render_scale_widget.css */ "./src/neuroglancer/widget/render_scale_widget.css");
/* harmony import */ var neuroglancer_widget_render_scale_widget_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_widget_render_scale_widget_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ "./node_modules/lodash/throttle.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/render_scale_statistics */ "./src/neuroglancer/render_scale_statistics.ts");
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! neuroglancer/util/color */ "./src/neuroglancer/util/color.ts");
/* harmony import */ var neuroglancer_util_colorspace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/colorspace */ "./src/neuroglancer/util/colorspace.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! neuroglancer/util/event_action_map */ "./src/neuroglancer/util/event_action_map.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_mouse_bindings__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! neuroglancer/util/mouse_bindings */ "./src/neuroglancer/util/mouse_bindings.ts");
/* harmony import */ var neuroglancer_util_number_to_string__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! neuroglancer/util/number_to_string */ "./src/neuroglancer/util/number_to_string.ts");
/* harmony import */ var neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! neuroglancer/widget/scale_bar */ "./src/neuroglancer/widget/scale_bar.ts");
/* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! resize-observer-polyfill */ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














const updateInterval = 200;
const inputEventMap = neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__["EventActionMap"].fromObject({
    'mousedown0': { action: 'set' },
    'wheel': { action: 'adjust-via-wheel' },
    'dblclick0': { action: 'reset' },
});
function formatPixelNumber(x) {
    if (x < 1 || x > 1024) {
        const exponent = Math.log2(x) | 0;
        const coeff = x / 2 ** exponent;
        return `${Object(neuroglancer_util_number_to_string__WEBPACK_IMPORTED_MODULE_11__["numberToStringFixed"])(coeff, 1)}p${exponent}`;
    }
    return Math.round(x) + '';
}
class RenderScaleWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_7__["RefCounted"] {
    constructor(histogram, target) {
        super();
        this.histogram = histogram;
        this.target = target;
        this.label = document.createElement('div');
        this.element = document.createElement('div');
        this.canvas = document.createElement('canvas');
        this.legend = document.createElement('div');
        this.legendRenderScale = document.createElement('div');
        this.legendSpatialScale = document.createElement('div');
        this.legendChunks = document.createElement('div');
        this.ctx = this.canvas.getContext('2d');
        this.hoverTarget = new neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_4__["WatchableValue"](undefined);
        this.throttledUpdateView = this.registerCancellable(lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(() => this.debouncedUpdateView(), updateInterval, { leading: true, trailing: true }));
        this.debouncedUpdateView = this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(() => this.updateView(), 0));
        const { canvas, label, element, legend, legendRenderScale, legendSpatialScale, legendChunks } = this;
        label.className = 'neuroglancer-render-scale-widget-prompt';
        element.className = 'neuroglancer-render-scale-widget';
        element.title = inputEventMap.describe();
        legend.className = 'neuroglancer-render-scale-widget-legend';
        element.appendChild(label);
        element.appendChild(canvas);
        element.appendChild(legend);
        legendRenderScale.title = 'Target resolution of data in screen pixels';
        legendChunks.title = 'Number of chunks rendered';
        legend.appendChild(legendRenderScale);
        legend.appendChild(legendChunks);
        legend.appendChild(legendSpatialScale);
        this.registerDisposer(histogram.changed.add(this.throttledUpdateView));
        this.registerDisposer(histogram.visibility.changed.add(this.debouncedUpdateView));
        this.registerDisposer(target.changed.add(this.debouncedUpdateView));
        this.registerDisposer(new neuroglancer_util_mouse_bindings__WEBPACK_IMPORTED_MODULE_10__["MouseEventBinder"](canvas, inputEventMap));
        this.registerDisposer(target.changed.add(this.debouncedUpdateView));
        this.registerDisposer(this.hoverTarget.changed.add(this.debouncedUpdateView));
        const getTargetValue = (event) => {
            const position = event.offsetX / canvas.width * neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"];
            return Object(neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["getRenderScaleFromHistogramOffset"])(position);
        };
        this.registerEventListener(canvas, 'pointermove', (event) => {
            this.hoverTarget.value = [getTargetValue(event), event.offsetY];
        });
        this.registerEventListener(canvas, 'pointerleave', () => {
            this.hoverTarget.value = undefined;
        });
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__["registerActionListener"])(canvas, 'set', actionEvent => {
            this.target.value = getTargetValue(actionEvent.detail);
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__["registerActionListener"])(canvas, 'adjust-via-wheel', actionEvent => {
            const event = actionEvent.detail;
            const { deltaY } = event;
            if (deltaY === 0) {
                return;
            }
            this.hoverTarget.value = undefined;
            this.target.value *= 2 ** Math.sign(deltaY);
            event.preventDefault();
        }));
        this.registerDisposer(Object(neuroglancer_util_event_action_map__WEBPACK_IMPORTED_MODULE_8__["registerActionListener"])(canvas, 'reset', event => {
            this.hoverTarget.value = undefined;
            this.target.reset();
            event.preventDefault();
        }));
        const resizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_13__["default"](() => this.debouncedUpdateView());
        resizeObserver.observe(canvas);
        this.registerDisposer(() => resizeObserver.disconnect());
        this.updateView();
    }
    updateView() {
        const { ctx } = this;
        const { canvas } = this;
        const width = canvas.width = canvas.offsetWidth;
        const height = canvas.height = canvas.offsetHeight;
        const targetValue = this.target.value;
        const hoverValue = this.hoverTarget.value;
        {
            const { legendRenderScale } = this;
            const value = hoverValue === undefined ? targetValue : hoverValue[0];
            const valueString = formatPixelNumber(value);
            legendRenderScale.textContent = valueString + ' px';
        }
        function binToCanvasX(bin) {
            return bin * width / neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"];
        }
        ctx.clearRect(0, 0, width, height);
        const { histogram } = this;
        // histogram.begin(this.frameNumberCounter.frameNumber);
        const { value: histogramData, spatialScales } = histogram;
        if (!histogram.visibility.visible) {
            histogramData.fill(0);
        }
        const sortedSpatialScales = Array.from(spatialScales.keys());
        sortedSpatialScales.sort();
        const tempColor = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_9__["vec3"].create();
        let maxCount = 1;
        const numRows = spatialScales.size;
        let totalPresent = 0, totalNotPresent = 0;
        for (let bin = 0; bin < neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"]; ++bin) {
            let count = 0;
            for (let row = 0; row < numRows; ++row) {
                const index = row * neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"] * 2 + bin;
                const presentCount = histogramData[index];
                const notPresentCount = histogramData[index + neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"]];
                totalPresent += presentCount;
                totalNotPresent += notPresentCount;
                count += presentCount + notPresentCount;
            }
            maxCount = Math.max(count, maxCount);
        }
        const maxBarHeight = height;
        const yScale = maxBarHeight / Math.log(1 + maxCount);
        function countToCanvasY(count) {
            return height - Math.log(1 + count) * yScale;
        }
        let hoverSpatialScale = undefined;
        if (hoverValue !== undefined) {
            const i = Math.floor(Object(neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["getRenderScaleHistogramOffset"])(hoverValue[0]));
            if (i >= 0 && i < neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"]) {
                let sum = 0;
                const hoverY = hoverValue[1];
                for (let spatialScaleIndex = numRows - 1; spatialScaleIndex >= 0; --spatialScaleIndex) {
                    const spatialScale = sortedSpatialScales[spatialScaleIndex];
                    const row = spatialScales.get(spatialScale);
                    const index = 2 * row * neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"] + i;
                    const count = histogramData[index] + histogramData[index + neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"]];
                    if (count === 0)
                        continue;
                    const yStart = Math.round(countToCanvasY(sum));
                    sum += count;
                    const yEnd = Math.round(countToCanvasY(sum));
                    if (yEnd <= hoverY && hoverY <= yStart) {
                        hoverSpatialScale = spatialScale;
                        break;
                    }
                }
            }
        }
        if (hoverSpatialScale !== undefined) {
            totalPresent = 0;
            totalNotPresent = 0;
            const row = spatialScales.get(hoverSpatialScale);
            const baseIndex = 2 * row * neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"];
            for (let bin = 0; bin < neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"]; ++bin) {
                const index = baseIndex + bin;
                totalPresent += histogramData[index];
                totalNotPresent += histogramData[index + neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"]];
            }
            if (Number.isFinite(hoverSpatialScale)) {
                const unit = Object(neuroglancer_widget_scale_bar__WEBPACK_IMPORTED_MODULE_12__["pickLengthUnit"])(hoverSpatialScale);
                this.legendSpatialScale.textContent =
                    Object(neuroglancer_util_number_to_string__WEBPACK_IMPORTED_MODULE_11__["numberToStringFixed"])(hoverSpatialScale / unit.lengthInNanometers, 2) + ' ' + unit.unit;
            }
            else {
                this.legendSpatialScale.textContent = 'unknown';
            }
        }
        else {
            this.legendSpatialScale.textContent = '';
        }
        this.legendChunks.textContent = `${totalPresent}/${totalPresent + totalNotPresent}`;
        const spatialScaleColors = sortedSpatialScales.map(spatialScale => {
            const saturation = spatialScale === hoverSpatialScale ? 0.5 : 1;
            let hue;
            if (Number.isFinite(spatialScale)) {
                hue = (((Math.log2(spatialScale) * 0.1) % 1) + 1) % 1;
            }
            else {
                hue = 0;
            }
            Object(neuroglancer_util_colorspace__WEBPACK_IMPORTED_MODULE_6__["hsvToRgb"])(tempColor, hue, saturation, 1);
            const presentColor = Object(neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_5__["serializeColor"])(tempColor);
            Object(neuroglancer_util_colorspace__WEBPACK_IMPORTED_MODULE_6__["hsvToRgb"])(tempColor, hue, saturation, 0.5);
            const notPresentColor = Object(neuroglancer_util_color__WEBPACK_IMPORTED_MODULE_5__["serializeColor"])(tempColor);
            return [presentColor, notPresentColor];
        });
        for (let i = 0; i < neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"]; ++i) {
            let sum = 0;
            for (let spatialScaleIndex = numRows - 1; spatialScaleIndex >= 0; --spatialScaleIndex) {
                const spatialScale = sortedSpatialScales[spatialScaleIndex];
                const row = spatialScales.get(spatialScale);
                const index = row * neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"] * 2 + i;
                const presentCount = histogramData[index];
                const notPresentCount = histogramData[index + neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["numRenderScaleHistogramBins"]];
                const count = presentCount + notPresentCount;
                if (count === 0)
                    continue;
                const xStart = Math.round(binToCanvasX(i));
                const xEnd = Math.round(binToCanvasX(i + 1));
                const yStart = Math.round(countToCanvasY(sum));
                sum += count;
                const yEnd = Math.round(countToCanvasY(sum));
                const ySplit = (presentCount * yEnd + notPresentCount * yStart) / count;
                ctx.fillStyle = spatialScaleColors[spatialScaleIndex][1];
                ctx.fillRect(xStart, yEnd, xEnd - xStart, ySplit - yEnd);
                ctx.fillStyle = spatialScaleColors[spatialScaleIndex][0];
                ctx.fillRect(xStart, ySplit, xEnd - xStart, yStart - ySplit);
            }
        }
        {
            const value = targetValue;
            ctx.fillStyle = '#fff';
            const startOffset = binToCanvasX(Object(neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["getRenderScaleHistogramOffset"])(value));
            const lineWidth = 1;
            ctx.fillRect(Math.floor(startOffset), 0, lineWidth, height);
        }
        if (hoverValue !== undefined) {
            const value = hoverValue[0];
            ctx.fillStyle = '#888';
            const startOffset = binToCanvasX(Object(neuroglancer_render_scale_statistics__WEBPACK_IMPORTED_MODULE_3__["getRenderScaleHistogramOffset"])(value));
            const lineWidth = 1;
            ctx.fillRect(Math.floor(startOffset), 0, lineWidth, height);
        }
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/scale_bar.ts":
/*!**********************************************!*\
  !*** ./src/neuroglancer/widget/scale_bar.ts ***!
  \**********************************************/
/*! exports provided: ALLOWED_UNITS, pickLengthUnit, pickVolumeUnit, ScaleBarDimensions, ScaleBarTexture, defaultScaleBarTextureOptions, defaultScaleBarOptions, TrackableScaleBarOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALLOWED_UNITS", function() { return ALLOWED_UNITS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pickLengthUnit", function() { return pickLengthUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pickVolumeUnit", function() { return pickVolumeUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScaleBarDimensions", function() { return ScaleBarDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScaleBarTexture", function() { return ScaleBarTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultScaleBarTextureOptions", function() { return defaultScaleBarTextureOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultScaleBarOptions", function() { return defaultScaleBarOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrackableScaleBarOptions", function() { return TrackableScaleBarOptions; });
/* harmony import */ var neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/trackable_value */ "./src/neuroglancer/trackable_value.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_webgl_texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/webgl/texture */ "./src/neuroglancer/webgl/texture.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Facility for drawing a scale bar to indicate pixel size in physical length
 * units.
 *
 * The physical length with which the scale bar is labeled will be of the form:
 *
 *   significand * 10^exponent
 *
 * Any exponent may be used, but the significand in the range [1, 10] will be
 * equal to one of a
 * discrete set of allowed significand values, in order to ensure that the scale
 * bar is easy to
 * understand.
 */




/**
 * Default set of allowed significand values.  1 is implicitly part of the set.
 */
const DEFAULT_ALLOWED_SIGNIFICANDS = [
    1.5,
    2,
    3,
    5,
    7.5,
    10,
];
const ALLOWED_UNITS = [
    { unit: 'km', lengthInNanometers: 1e12 },
    { unit: 'm', lengthInNanometers: 1e9 },
    { unit: 'mm', lengthInNanometers: 1e6 },
    { unit: 'm', lengthInNanometers: 1e3 },
    { unit: 'nm', lengthInNanometers: 1 },
    { unit: 'pm', lengthInNanometers: 1e-3 },
];
function pickLengthUnit(lengthInNanometers) {
    const numAllowedUnits = ALLOWED_UNITS.length;
    let unit = ALLOWED_UNITS[numAllowedUnits - 1];
    for (let i = 0; i < numAllowedUnits; ++i) {
        const allowedUnit = ALLOWED_UNITS[i];
        if (lengthInNanometers >= allowedUnit.lengthInNanometers) {
            unit = allowedUnit;
            break;
        }
    }
    return unit;
}
function pickVolumeUnit(volumeInCubicNanometers) {
    const numAllowedUnits = ALLOWED_UNITS.length;
    let unit = ALLOWED_UNITS[numAllowedUnits - 1];
    for (let i = 0; i < numAllowedUnits; ++i) {
        const allowedUnit = ALLOWED_UNITS[i];
        if (volumeInCubicNanometers >= Math.pow(allowedUnit.lengthInNanometers, 3)) {
            unit = allowedUnit;
            break;
        }
    }
    return unit;
}
class ScaleBarDimensions {
    constructor() {
        /**
         * Allowed significand values.  1 is not included, but is always considered
         * part of the set.
         */
        this.allowedSignificands = DEFAULT_ALLOWED_SIGNIFICANDS;
        /**
         * The target length in pixels.  The closest
         */
        this.targetLengthInPixels = 0;
        /**
         * Pixel size in nanometers.
         */
        this.nanometersPerPixel = 0;
        this.prevNanometersPerPixel = 0;
        this.prevTargetLengthInPixels = 0;
    }
    /**
     * Updates physicalLength, physicalUnit, and lengthInPixels to be the optimal
     * values corresponding
     * to targetLengthInPixels and nanometersPerPixel.
     *
     * @returns true if the scale bar has changed, false if it is unchanged.
     */
    update() {
        let { nanometersPerPixel, targetLengthInPixels } = this;
        if (this.prevNanometersPerPixel === nanometersPerPixel &&
            this.prevTargetLengthInPixels === targetLengthInPixels) {
            return false;
        }
        this.prevNanometersPerPixel = nanometersPerPixel;
        this.prevTargetLengthInPixels = targetLengthInPixels;
        const targetNanometers = targetLengthInPixels * nanometersPerPixel;
        const exponent = Math.floor(Math.log(targetNanometers) / Math.LN10);
        const tenToThePowerExponent = Math.pow(10, exponent);
        const targetSignificand = targetNanometers / tenToThePowerExponent;
        // Determine significand value in this.allowedSignificands that is closest
        // to targetSignificand.
        let bestSignificand = 1;
        for (let allowedSignificand of this.allowedSignificands) {
            if (Math.abs(allowedSignificand - targetSignificand) <
                Math.abs(bestSignificand - targetSignificand)) {
                bestSignificand = allowedSignificand;
            }
            else {
                // If distance did not decrease, then it can only increase from here.
                break;
            }
        }
        const physicalNanometers = bestSignificand * tenToThePowerExponent;
        const unit = pickLengthUnit(physicalNanometers);
        this.lengthInPixels = Math.round(physicalNanometers / nanometersPerPixel);
        this.physicalUnit = unit.unit;
        this.physicalLength = physicalNanometers / unit.lengthInNanometers;
        return true;
    }
}
function makeScaleBarTexture(dimensions, gl, texture, options = defaultScaleBarTextureOptions) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const textHeight = options.textHeightInPixels * options.scaleFactor;
    const font = `bold ${textHeight}px ${options.fontName}`;
    ctx.font = font;
    ctx.fillStyle = 'white';
    const text = `${dimensions.physicalLength} ${dimensions.physicalUnit}`;
    const textMetrics = ctx.measureText(text);
    const innerWidth = Math.max(dimensions.lengthInPixels, textMetrics.width);
    const barHeight = options.barHeightInPixels * options.scaleFactor;
    const barTopMargin = options.barTopMarginInPixels * options.scaleFactor;
    const innerHeight = barHeight + barTopMargin + textHeight;
    const padding = options.paddingInPixels * options.scaleFactor;
    const totalHeight = innerHeight + 2 * padding;
    const totalWidth = innerWidth + 2 * padding;
    canvas.width = totalWidth;
    canvas.height = totalHeight;
    ctx.font = font;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(0, 0, totalWidth, totalHeight);
    ctx.fillStyle = 'white';
    ctx.fillText(text, totalWidth / 2, totalHeight - padding - barHeight - barTopMargin);
    ctx.fillRect(padding, totalHeight - padding - barHeight, dimensions.lengthInPixels, barHeight);
    Object(neuroglancer_webgl_texture__WEBPACK_IMPORTED_MODULE_3__["setTextureFromCanvas"])(gl, texture, canvas);
    return { width: totalWidth, height: totalHeight };
}
class ScaleBarTexture extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(gl, dimensions = new ScaleBarDimensions()) {
        super();
        this.gl = gl;
        this.dimensions = dimensions;
        this.texture = null;
        this.width = 0;
        this.height = 0;
        this.priorOptions = undefined;
    }
    update(options) {
        let { dimensions } = this;
        let { texture } = this;
        if (!dimensions.update() && texture !== null && options === this.priorOptions) {
            return;
        }
        if (texture === null) {
            texture = this.texture = this.gl.createTexture();
        }
        const { width, height } = makeScaleBarTexture(dimensions, this.gl, texture, options);
        this.priorOptions = options;
        this.width = width;
        this.height = height;
    }
    disposed() {
        this.gl.deleteTexture(this.texture);
        this.texture = null;
        super.disposed();
    }
}
const defaultScaleBarTextureOptions = {
    scaleFactor: 1,
    textHeightInPixels: 15,
    barHeightInPixels: 8,
    barTopMarginInPixels: 5,
    fontName: 'sans-serif',
    paddingInPixels: 2,
};
const defaultScaleBarOptions = Object.assign({}, defaultScaleBarTextureOptions, { maxWidthInPixels: 100, maxWidthFraction: 0.25, leftPixelOffset: 10, bottomPixelOffset: 10 });
function parseScaleBarOptions(obj) {
    const result = Object.assign({}, defaultScaleBarOptions);
    for (const k of [
        'textHeightInPixels', 'barTopMarginInPixels', 'barHeightInPixels', 'paddingInPixels',
        'scaleFactor', 'maxWidthInPixels', 'maxWidthFraction', 'leftPixelOffset',
        'bottomPixelOffset'
    ]) {
        Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, k, x => {
            if (x !== undefined) {
                result[k] = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyFloat"])(x);
            }
        });
    }
    Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyObjectProperty"])(obj, 'fontName', x => {
        if (x !== undefined) {
            result.fontName = Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyString"])(x);
        }
    });
    return result;
}
class TrackableScaleBarOptions extends neuroglancer_trackable_value__WEBPACK_IMPORTED_MODULE_0__["TrackableValue"] {
    constructor() {
        super(defaultScaleBarOptions, parseScaleBarOptions);
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/segment_set_widget.css":
/*!********************************************************!*\
  !*** ./src/neuroglancer/widget/segment_set_widget.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/segment_set_widget.ts":
/*!*******************************************************!*\
  !*** ./src/neuroglancer/widget/segment_set_widget.ts ***!
  \*******************************************************/
/*! exports provided: SegmentSetWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentSetWidget", function() { return SegmentSetWidget; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/noselect.css */ "./src/neuroglancer/noselect.css");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _segment_set_widget_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./segment_set_widget.css */ "./src/neuroglancer/widget/segment_set_widget.css");
/* harmony import */ var _segment_set_widget_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_segment_set_widget_css__WEBPACK_IMPORTED_MODULE_3__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let temp = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_1__["Uint64"]();
class SegmentSetWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(displayState) {
        super();
        this.displayState = displayState;
        this.element = document.createElement('div');
        this.clearButton = document.createElement('button');
        this.itemContainer = document.createElement('span');
        this.items = new Map();
        let { element, clearButton, itemContainer } = this;
        element.className = 'segment-set-widget neuroglancer-noselect';
        clearButton.className = 'clear-button';
        clearButton.title = 'Remove all segment IDs';
        this.registerEventListener(clearButton, 'click', () => {
            this.visibleSegments.clear();
        });
        itemContainer.className = 'item-container';
        element.appendChild(itemContainer);
        itemContainer.appendChild(clearButton);
        this.registerDisposer(displayState.visibleSegments.changed.add((x, add) => {
            this.handleSetChanged(x, add);
        }));
        this.registerDisposer(displayState.segmentColorHash.changed.add(() => {
            this.handleColorChanged();
        }));
        for (let x of displayState.visibleSegments) {
            this.addElement(x.toString());
        }
        this.updateClearButtonVisibility();
    }
    get visibleSegments() {
        return this.displayState.visibleSegments;
    }
    get segmentColorHash() {
        return this.displayState.segmentColorHash;
    }
    get segmentSelectionState() {
        return this.displayState.segmentSelectionState;
    }
    updateClearButtonVisibility() {
        let { clearButton } = this;
        clearButton.style.display = (this.displayState.visibleSegments.size > 0) ? '' : 'none';
    }
    handleSetChanged(x, added) {
        this.updateClearButtonVisibility();
        let { items } = this;
        if (x === null) {
            // Cleared.
            let { itemContainer, clearButton } = this;
            while (true) {
                let lastElement = itemContainer.lastElementChild;
                if (lastElement === clearButton) {
                    break;
                }
                itemContainer.removeChild(lastElement);
            }
            items.clear();
        }
        else if (added) {
            this.addElement(x.toString());
        }
        else {
            let s = x.toString();
            let itemElement = items.get(s);
            itemElement.parentElement.removeChild(itemElement);
            items.delete(s);
        }
    }
    addElement(s) {
        let itemElement = document.createElement('button');
        itemElement.className = 'segment-button';
        itemElement.textContent = s;
        itemElement.title = `Remove segment ID ${s}`;
        let widget = this;
        itemElement.addEventListener('click', function () {
            temp.tryParseString(this.textContent);
            widget.visibleSegments.delete(temp);
        });
        itemElement.addEventListener('mouseenter', function () {
            temp.tryParseString(this.textContent);
            widget.segmentSelectionState.set(temp);
        });
        itemElement.addEventListener('mouseleave', function () {
            temp.tryParseString(this.textContent);
            widget.segmentSelectionState.set(null);
        });
        this.setItemColor(itemElement);
        this.itemContainer.appendChild(itemElement);
        this.items.set(s, itemElement);
    }
    setItemColor(itemElement) {
        temp.tryParseString(itemElement.textContent);
        itemElement.style.backgroundColor = this.segmentColorHash.computeCssColor(temp);
    }
    handleColorChanged() {
        this.items.forEach(itemElement => {
            this.setItemColor(itemElement);
        });
    }
    disposed() {
        let { element } = this;
        let { parentElement } = element;
        if (parentElement) {
            parentElement.removeChild(element);
        }
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/shader_code_widget.css":
/*!********************************************************!*\
  !*** ./src/neuroglancer/widget/shader_code_widget.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/shader_code_widget.ts":
/*!*******************************************************!*\
  !*** ./src/neuroglancer/widget/shader_code_widget.ts ***!
  \*******************************************************/
/*! exports provided: ShaderCodeWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderCodeWidget", function() { return ShaderCodeWidget; });
/* harmony import */ var codemirror_addon_lint_lint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! codemirror/addon/lint/lint.js */ "./node_modules/codemirror/addon/lint/lint.js");
/* harmony import */ var codemirror_addon_lint_lint_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_lint_lint_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_code_widget_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader_code_widget.css */ "./src/neuroglancer/widget/shader_code_widget.css");
/* harmony import */ var _shader_code_widget_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_code_widget_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! codemirror/lib/codemirror.css */ "./node_modules/codemirror/lib/codemirror.css");
/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var codemirror_addon_lint_lint_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! codemirror/addon/lint/lint.css */ "./node_modules/codemirror/addon/lint/lint.css");
/* harmony import */ var codemirror_addon_lint_lint_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_lint_lint_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! codemirror */ "./node_modules/codemirror/lib/codemirror.js");
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(codemirror__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








__webpack_require__(/*! glsl-editor/glsl */ "./node_modules/glsl-editor/glsl.js")(codemirror__WEBPACK_IMPORTED_MODULE_4___default.a);
/**
 * Time in milliseconds during which the input field must not be modified before the shader is
 * recompiled.
 */
const SHADER_UPDATE_DELAY = 500;
class ShaderCodeWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_6__["RefCounted"] {
    constructor(state) {
        super();
        this.state = state;
        this.changingValue = false;
        this.debouncedValueUpdater = lodash_debounce__WEBPACK_IMPORTED_MODULE_5___default()(() => {
            this.changingValue = true;
            try {
                this.state.fragmentMain.value = this.textEditor.getValue();
            }
            finally {
                this.changingValue = false;
            }
        }, SHADER_UPDATE_DELAY);
        this.textEditor = codemirror__WEBPACK_IMPORTED_MODULE_4___default()(_element => { }, {
            value: this.state.fragmentMain.value,
            mode: 'glsl',
            gutters: ['CodeMirror-lint-markers'],
        });
        this.textEditor.on('change', () => {
            this.setValidState(undefined);
            this.debouncedValueUpdater();
        });
        this.registerDisposer(this.state.fragmentMain.changed.add(() => {
            if (!this.changingValue) {
                this.textEditor.setValue(this.state.fragmentMain.value);
            }
        }));
        this.element.classList.add('neuroglancer-shader-code-widget');
        this.registerDisposer(this.state.shaderError.changed.add(() => {
            this.updateErrorState();
        }));
        const { shaderControlState } = this.state;
        if (shaderControlState !== undefined) {
            this.registerDisposer(shaderControlState.parseErrors.changed.add(() => {
                this.updateErrorState();
            }));
        }
        this.updateErrorState();
    }
    get element() {
        return this.textEditor.getWrapperElement();
    }
    updateErrorState() {
        const error = this.state.shaderError.value;
        let controlParseErrors;
        const { shaderControlState } = this.state;
        if (shaderControlState !== undefined) {
            controlParseErrors = shaderControlState.parseErrors.value;
        }
        else {
            controlParseErrors = [];
        }
        if (error === undefined && controlParseErrors.length === 0) {
            this.setValidState(undefined);
        }
        else if (error != null || controlParseErrors.length !== 0) {
            this.textEditor.setOption('lint', {
                getAnnotations: () => {
                    const annotations = [];
                    for (const e of controlParseErrors) {
                        annotations.push({
                            message: e.message,
                            severity: 'error',
                            from: codemirror__WEBPACK_IMPORTED_MODULE_4___default.a.Pos(e.line),
                        });
                    }
                    if (error != null) {
                        if (error.name === 'ShaderCompilationError') {
                            const fragmentMainStartLineNumber = error
                                .source.split('\n')
                                .indexOf(this.state.fragmentMainStartLine) +
                                2;
                            for (const e of error.errorMessages) {
                                annotations.push({
                                    message: e.message,
                                    severity: 'error',
                                    from: codemirror__WEBPACK_IMPORTED_MODULE_4___default.a.Pos(e.line === undefined ? 0 : e.line - fragmentMainStartLineNumber),
                                });
                            }
                        }
                        else if (error.name === 'ShaderLinkError') {
                            annotations.push({
                                message: error.log,
                                severity: 'error',
                                from: codemirror__WEBPACK_IMPORTED_MODULE_4___default.a.Pos(0),
                            });
                        }
                        else {
                            annotations.push({
                                message: error.message,
                                severity: 'error',
                                from: codemirror__WEBPACK_IMPORTED_MODULE_4___default.a.Pos(0),
                            });
                        }
                    }
                    return annotations;
                },
            });
            this.setValidState(false);
        }
        else {
            this.textEditor.setOption('lint', undefined);
            this.setValidState(true);
        }
    }
    setValidState(valid) {
        let { element } = this;
        element.classList.remove('invalid-input');
        element.classList.remove('valid-input');
        if (valid === true) {
            element.classList.add('valid-input');
        }
        else if (valid === false) {
            element.classList.add('invalid-input');
        }
    }
    disposed() {
        this.debouncedValueUpdater.flush();
        this.debouncedValueUpdater = undefined;
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_7__["removeFromParent"])(this.element);
        this.textEditor = undefined;
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/shader_controls.ts":
/*!****************************************************!*\
  !*** ./src/neuroglancer/widget/shader_controls.ts ***!
  \****************************************************/
/*! exports provided: ShaderControls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderControls", function() { return ShaderControls; });
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_widget_color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/widget/color */ "./src/neuroglancer/widget/color.ts");
/* harmony import */ var neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/widget/range */ "./src/neuroglancer/widget/range.ts");
/**
 * @license
 * Copyright 2019 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class ShaderControls extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(state) {
        super();
        this.state = state;
        this.element = document.createElement('div');
        this.controlDisposer = undefined;
        const { controls } = state;
        this.registerDisposer(controls.changed.add(this.registerCancellable(lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(() => this.updateControls(), 0))));
        this.updateControls();
    }
    updateControls() {
        if (this.controlDisposer !== undefined) {
            this.controlDisposer.dispose();
            Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeChildren"])(this.element);
        }
        const controlDisposer = this.controlDisposer = new neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"]();
        for (const [name, controlState] of this.state.state) {
            const { control } = controlState;
            switch (control.type) {
                case 'slider': {
                    const widget = controlDisposer.registerDisposer(new neuroglancer_widget_range__WEBPACK_IMPORTED_MODULE_4__["RangeWidget"](controlState.trackable, { min: control.min, max: control.max, step: control.step }));
                    widget.promptElement.textContent = name;
                    this.element.appendChild(widget.element);
                    break;
                }
                case 'color': {
                    const label = document.createElement('label');
                    label.textContent = name;
                    const widget = controlDisposer.registerDisposer(new neuroglancer_widget_color__WEBPACK_IMPORTED_MODULE_3__["ColorWidget"](controlState.trackable));
                    this.element.appendChild(label);
                    label.appendChild(widget.element);
                    break;
                }
            }
        }
    }
    disposed() {
        const { controlDisposer } = this;
        if (controlDisposer !== undefined) {
            controlDisposer.dispose();
        }
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/tab_view.css":
/*!**********************************************!*\
  !*** ./src/neuroglancer/widget/tab_view.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/tab_view.ts":
/*!*********************************************!*\
  !*** ./src/neuroglancer/widget/tab_view.ts ***!
  \*********************************************/
/*! exports provided: Tab, OptionSpecification, StackView, TabSpecification, TabView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tab", function() { return Tab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OptionSpecification", function() { return OptionSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StackView", function() { return StackView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabSpecification", function() { return TabSpecification; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabView", function() { return TabView; });
/* harmony import */ var neuroglancer_widget_tab_view_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/widget/tab_view.css */ "./src/neuroglancer/widget/tab_view.css");
/* harmony import */ var neuroglancer_widget_tab_view_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_widget_tab_view_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/visibility_priority/frontend */ "./src/neuroglancer/visibility_priority/frontend.ts");
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Tabbed view widget.
 */





class Tab extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(visibility = new neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_4__["WatchableVisibilityPriority"]()) {
        super();
        this.visibility = visibility;
        this.element = document.createElement('div');
        const { element } = this;
        element.classList.add('neuroglancer-tab-content');
    }
    get visible() {
        return this.visibility.visible;
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeFromParent"])(this.element);
        super.disposed();
    }
}
class OptionSpecification extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor() {
        super(...arguments);
        this.changed = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
        this.options = new Map();
        this.optionsChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["NullarySignal"]();
        this.selectedValue = undefined;
        this.defaultValue = undefined;
        this.ready_ = true;
    }
    get value() {
        const { selectedValue } = this;
        if (selectedValue !== undefined) {
            return selectedValue;
        }
        return this.defaultValue;
    }
    set default(value) {
        if (this.defaultValue !== value) {
            this.defaultValue = value;
            this.changed.dispatch();
        }
    }
    get default() {
        return this.defaultValue;
    }
    set value(value) {
        if (value !== undefined && this.ready_ && !this.options.has(value)) {
            value = undefined;
        }
        const { selectedValue } = this;
        if (selectedValue !== value) {
            this.selectedValue = value;
            this.changed.dispatch();
        }
    }
    get validValue() {
        const value = this.selectedValue;
        if (value === undefined || !this.options.has(value)) {
            return this.defaultValue;
        }
        return value;
    }
    add(id, value) {
        const { options } = this;
        if (options.has(id)) {
            throw new Error(`Option already defined: ${JSON.stringify(id)}.`);
        }
        options.set(id, value);
        this.optionsChanged.dispatch();
        if (this.defaultValue === undefined) {
            this.default = id;
        }
    }
    toJSON() {
        const { value, defaultValue } = this;
        if (value === defaultValue) {
            return undefined;
        }
        return value;
    }
    reset() {
        this.value = undefined;
    }
    /**
     * When `ready` is `false`, the selected `value` may be set to an unknown option.
     */
    get ready() {
        return this.ready_;
    }
    set ready(value) {
        if (value !== this.ready_) {
            this.ready_ = value;
            if (value) {
                this.value = this.value;
            }
            this.changed.dispatch();
        }
    }
    restoreState(obj) {
        if (typeof obj !== 'string') {
            obj = undefined;
        }
        this.value = obj;
    }
}
class StackView extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(getter, visibility = new neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_4__["WatchableVisibilityPriority"]()) {
        super();
        this.getter = getter;
        this.visibility = visibility;
        this.element = document.createElement('div');
        this.tabs = new Map();
        this.tabVisibilityChanged = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["Signal"]();
        const { element } = this;
        element.className = 'neuroglancer-stack-view';
        this.registerDisposer(visibility.changed.add(() => this.updateSelectedTab()));
        this.updateSelectedTab();
    }
    get visible() {
        return this.visibility.visible;
    }
    get selected() {
        return this.selectedTabValue;
    }
    set selected(id) {
        this.selectedTabValue = id;
        this.updateSelectedTab();
    }
    invalidate(id) {
        const { tabs } = this;
        const tab = tabs.get(id);
        if (tab === undefined) {
            return;
        }
        tab.dispose();
        tabs.delete(id);
        if (id === this.displayedTab) {
            this.displayedTab = undefined;
            this.updateSelectedTab();
        }
    }
    hideTab(id) {
        const tab = this.tabs.get(id);
        if (tab !== undefined) {
            tab.visibility.value = neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_4__["WatchableVisibilityPriority"].IGNORED;
            tab.element.style.display = 'none';
        }
        this.tabVisibilityChanged.dispatch(id, false);
    }
    showTab(id) {
        const { tabs } = this;
        let tab = tabs.get(id);
        if (tab === undefined) {
            tab = this.getter(id);
            this.element.appendChild(tab.element);
            tabs.set(id, tab);
        }
        tab.element.style.display = null;
        tab.visibility.value = neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_4__["WatchableVisibilityPriority"].VISIBLE;
        this.tabVisibilityChanged.dispatch(id, true);
    }
    updateSelectedTab() {
        const { displayedTab } = this;
        const newTab = this.visible ? this.selectedTabValue : undefined;
        if (newTab === displayedTab) {
            return;
        }
        if (displayedTab !== undefined) {
            this.hideTab(displayedTab);
        }
        this.displayedTab = newTab;
        if (newTab === undefined) {
            return;
        }
        this.showTab(newTab);
    }
    invalidateAll() {
        const { tabs } = this;
        for (const tab of tabs.values()) {
            tab.dispose();
        }
        tabs.clear();
        this.updateSelectedTab();
    }
    disposed() {
        this.selectedTabValue = undefined;
        this.invalidateAll();
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeFromParent"])(this.element);
        super.disposed();
    }
}
class TabSpecification extends OptionSpecification {
}
class TabView extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor(state, visibility = new neuroglancer_visibility_priority_frontend__WEBPACK_IMPORTED_MODULE_4__["WatchableVisibilityPriority"]()) {
        super();
        this.state = state;
        this.visibility = visibility;
        this.element = document.createElement('div');
        this.tabBar = document.createElement('div');
        this.tabLabels = new Map();
        this.tabsGeneration = -1;
        const { element, tabBar } = this;
        element.className = 'neuroglancer-tab-view';
        tabBar.className = 'neuroglancer-tab-view-bar';
        element.appendChild(tabBar);
        // It is important to register our visibility changed handler before the StackView registers its
        // visibility changed handler, so that tab labels are created before tabVisibilityChanged
        // signals are received.
        this.registerDisposer(visibility.changed.add(() => {
            this.updateTabs();
        }));
        const stack = this.stack = this.registerDisposer(new StackView(id => this.state.options.get(id).getter(), this.visibility));
        element.appendChild(stack.element);
        this.registerDisposer(this.state.changed.add(() => this.updateSelectedTab()));
        this.registerDisposer(this.state.optionsChanged.add(() => this.updateTabs()));
        this.stack.tabVisibilityChanged.add((id, visible) => {
            const labelElement = this.tabLabels.get(id);
            const className = 'neuroglancer-selected-tab-label';
            if (visible) {
                labelElement.classList.add(className);
            }
            else {
                labelElement.classList.remove(className);
            }
        });
        this.updateTabs();
    }
    get visible() {
        return this.visibility.visible;
    }
    updateTabs() {
        if (this.tabsGeneration !== this.state.optionsChanged.count) {
            this.destroyTabs();
            if (this.visible) {
                this.makeTabs();
            }
            this.updateSelectedTab();
        }
    }
    updateSelectedTab() {
        this.stack.selected = this.state.value;
    }
    destroyTabs() {
        if (this.tabsGeneration === -1) {
            return;
        }
        this.stack.selected = undefined;
        this.tabLabels.clear();
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeChildren"])(this.tabBar);
        this.tabsGeneration = -1;
        this.stack.invalidateAll();
    }
    makeTabs() {
        const { tabBar, tabLabels } = this;
        const optionsArray = Array.from(this.state.options);
        optionsArray.sort(([, { order: aOrder = 0 }], [, { order: bOrder = 0 }]) => {
            return aOrder - bOrder;
        });
        for (const [id, { label }] of optionsArray) {
            const labelElement = document.createElement('div');
            labelElement.classList.add('neuroglancer-tab-label');
            labelElement.textContent = label;
            labelElement.addEventListener('click', () => {
                this.state.value = id;
            });
            tabLabels.set(id, labelElement);
            tabBar.appendChild(labelElement);
        }
        this.tabsGeneration = this.state.optionsChanged.count;
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeChildren"])(this.tabBar);
        this.tabLabels.clear();
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeFromParent"])(this.element);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/text_icon_button.css":
/*!******************************************************!*\
  !*** ./src/neuroglancer/widget/text_icon_button.css ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/text_icon_button.ts":
/*!*****************************************************!*\
  !*** ./src/neuroglancer/widget/text_icon_button.ts ***!
  \*****************************************************/
/*! exports provided: makeTextIconButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTextIconButton", function() { return makeTextIconButton; });
/* harmony import */ var _text_icon_button_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text_icon_button.css */ "./src/neuroglancer/widget/text_icon_button.css");
/* harmony import */ var _text_icon_button_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_text_icon_button_css__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Copyright 2018 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function makeTextIconButton(iconText, title) {
    const element = document.createElement('div');
    const innerElement = document.createElement('div');
    innerElement.textContent = iconText;
    element.className = 'neuroglancer-icon-button';
    element.appendChild(innerElement);
    if (title !== undefined) {
        element.title = title;
    }
    return element;
}


/***/ }),

/***/ "./src/neuroglancer/widget/tooltip.css":
/*!*********************************************!*\
  !*** ./src/neuroglancer/widget/tooltip.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/tooltip.ts":
/*!********************************************!*\
  !*** ./src/neuroglancer/widget/tooltip.ts ***!
  \********************************************/
/*! exports provided: Tooltip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tooltip", function() { return Tooltip; });
/* harmony import */ var _tooltip_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tooltip.css */ "./src/neuroglancer/widget/tooltip.css");
/* harmony import */ var _tooltip_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tooltip_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Facilities for creating tooltips.
 */



class Tooltip extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor() {
        super();
        this.element = document.createElement('div');
        const { element } = this;
        element.className = 'neuroglancer-tooltip';
        element.style.visibility = 'hidden';
        document.body.appendChild(element);
    }
    updatePosition(pageX, pageY) {
        const { element } = this;
        element.style.left = pageX + 'px';
        element.style.top = pageY + 'px';
        element.style.visibility = 'inherit';
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_2__["removeFromParent"])(this.element);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/uint64_entry_widget.css":
/*!*********************************************************!*\
  !*** ./src/neuroglancer/widget/uint64_entry_widget.css ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/uint64_entry_widget.ts":
/*!********************************************************!*\
  !*** ./src/neuroglancer/widget/uint64_entry_widget.ts ***!
  \********************************************************/
/*! exports provided: Uint64EntryWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint64EntryWidget", function() { return Uint64EntryWidget; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/dom */ "./src/neuroglancer/util/dom.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/uint64 */ "./src/neuroglancer/util/uint64.ts");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! neuroglancer/noselect.css */ "./src/neuroglancer/noselect.css");
/* harmony import */ var neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(neuroglancer_noselect_css__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _uint64_entry_widget_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./uint64_entry_widget.css */ "./src/neuroglancer/widget/uint64_entry_widget.css");
/* harmony import */ var _uint64_entry_widget_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_uint64_entry_widget_css__WEBPACK_IMPORTED_MODULE_5__);
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class Uint64EntryWidget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor() {
        super();
        this.element = document.createElement('form');
        this.label = document.createElement('label');
        this.input = document.createElement('input');
        this.valuesEntered = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_2__["Signal"]();
        let { element, label, input } = this;
        element.className = 'uint64-entry neuroglancer-noselect';
        element.appendChild(label);
        label.appendChild(input);
        this.registerEventListener(element, 'submit', (event) => {
            event.preventDefault();
            const values = this.validateInput();
            if (values !== undefined) {
                this.input.value = '';
                this.input.classList.remove('valid-input', 'invalid-input');
                this.valuesEntered.dispatch(values);
            }
        });
        this.registerEventListener(element, 'input', () => {
            if (this.input.value === '') {
                this.input.classList.remove('valid-input', 'invalid-input');
                return;
            }
            if (this.validateInput()) {
                this.input.classList.remove('invalid-input');
            }
            else {
                this.input.classList.add('invalid-input');
            }
        });
    }
    validateInput() {
        let value = this.input.value;
        value = value.replace(/[\s,\(\)\[\]\{\};]+/g, ' ');
        value = value.trim();
        const parts = value.split(' ');
        if (parts.length === 0) {
            return undefined;
        }
        const results = [];
        for (const part of parts) {
            const x = new neuroglancer_util_uint64__WEBPACK_IMPORTED_MODULE_3__["Uint64"]();
            if (!x.tryParseString(part)) {
                return undefined;
            }
            results.push(x);
        }
        return results;
    }
    disposed() {
        Object(neuroglancer_util_dom__WEBPACK_IMPORTED_MODULE_1__["removeFromParent"])(this.element);
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/widget/vec3.css":
/*!******************************************!*\
  !*** ./src/neuroglancer/widget/vec3.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/neuroglancer/widget/vec3_entry_widget.ts":
/*!******************************************************!*\
  !*** ./src/neuroglancer/widget/vec3_entry_widget.ts ***!
  \******************************************************/
/*! exports provided: Vec3Widget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vec3Widget", function() { return Vec3Widget; });
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/* harmony import */ var neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/geom */ "./src/neuroglancer/util/geom.ts");
/* harmony import */ var neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! neuroglancer/util/json */ "./src/neuroglancer/util/json.ts");
/* harmony import */ var neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! neuroglancer/util/signal */ "./src/neuroglancer/util/signal.ts");
/* harmony import */ var _vec3_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vec3.css */ "./src/neuroglancer/widget/vec3.css");
/* harmony import */ var _vec3_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_vec3_css__WEBPACK_IMPORTED_MODULE_4__);
/**
 * @license
 * Copyright 2017 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class Vec3Widget extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_0__["RefCounted"] {
    constructor(model) {
        super();
        this.model = model;
        this.promptElement = document.createElement('span');
        this.element = document.createElement('label');
        this.inputx = document.createElement('input');
        this.inputy = document.createElement('input');
        this.inputz = document.createElement('input');
        this.valueEntered = new neuroglancer_util_signal__WEBPACK_IMPORTED_MODULE_3__["Signal"]();
        let { inputx, inputy, inputz, element, promptElement } = this;
        element.className = 'vec3-input-row';
        promptElement.className = 'vec3-input-label';
        element.appendChild(promptElement);
        element.appendChild(inputx);
        element.appendChild(inputy);
        element.appendChild(inputz);
        inputx.type = inputy.type = inputz.type = 'number';
        this.updateInput();
        const inputValueChanged = () => {
            this.model.value = this.getVec3Values();
        };
        this.registerEventListener(inputx, 'change', inputValueChanged);
        this.registerEventListener(inputy, 'change', inputValueChanged);
        this.registerEventListener(inputz, 'change', inputValueChanged);
        this.model.changed.add(() => {
            this.updateInput();
        });
    }
    getVec3Values() {
        let ret = neuroglancer_util_geom__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
        ret[0] = this.verifyValue(this.inputx.valueAsNumber);
        ret[1] = this.verifyValue(this.inputy.valueAsNumber);
        ret[2] = this.verifyValue(this.inputz.valueAsNumber);
        return ret;
    }
    verifyValue(value) {
        return Object(neuroglancer_util_json__WEBPACK_IMPORTED_MODULE_2__["verifyFiniteFloat"])(value);
    }
    updateInput() {
        this.inputx.valueAsNumber = this.model.value[0];
        this.inputy.valueAsNumber = this.model.value[1];
        this.inputz.valueAsNumber = this.model.value[2];
    }
    disposed() {
        let { inputx, inputy, inputz, element } = this;
        if (inputx.parentElement) {
            inputx.parentElement.removeChild(inputx);
        }
        if (inputy.parentElement) {
            inputy.parentElement.removeChild(inputy);
        }
        if (inputz.parentElement) {
            inputz.parentElement.removeChild(inputz);
        }
        if (element.parentElement) {
            element.parentElement.removeChild(element);
        }
        super.disposed();
    }
}


/***/ }),

/***/ "./src/neuroglancer/worker_rpc.ts":
/*!****************************************!*\
  !*** ./src/neuroglancer/worker_rpc.ts ***!
  \****************************************/
/*! exports provided: registerRPC, RPCError, registerPromiseRPC, RPC, SharedObject, initializeSharedObjectCounterpart, SharedObjectCounterpart, registerSharedObjectOwner, registerSharedObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerRPC", function() { return registerRPC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RPCError", function() { return RPCError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerPromiseRPC", function() { return registerPromiseRPC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return RPC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedObject", function() { return SharedObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeSharedObjectCounterpart", function() { return initializeSharedObjectCounterpart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedObjectCounterpart", function() { return SharedObjectCounterpart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerSharedObjectOwner", function() { return registerSharedObjectOwner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerSharedObject", function() { return registerSharedObject; });
/* harmony import */ var neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! neuroglancer/util/cancellation */ "./src/neuroglancer/util/cancellation.ts");
/* harmony import */ var neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! neuroglancer/util/disposable */ "./src/neuroglancer/util/disposable.ts");
/**
 * @license
 * Copyright 2016 Google Inc.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const IS_WORKER = !(typeof Window !== 'undefined' && self instanceof Window);
const DEBUG = false;
const DEBUG_MESSAGES = false;
const PROMISE_RESPONSE_ID = 'rpc.promise.response';
const PROMISE_CANCEL_ID = 'rpc.promise.cancel';
var handlers = new Map();
function registerRPC(key, handler) {
    handlers.set(key, handler);
}
class RPCError extends Error {
    constructor(name, message) {
        super(message);
        this.name = name;
        this.message = message;
    }
}
function registerPromiseRPC(key, handler) {
    registerRPC(key, function (x) {
        let id = x['id'];
        const cancellationToken = new neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["CancellationTokenSource"]();
        let promise = handler.call(this, x, cancellationToken);
        this.set(id, { promise, cancellationToken });
        promise.then(({ value, transfers }) => {
            this.delete(id);
            this.invoke(PROMISE_RESPONSE_ID, { 'id': id, 'value': value }, transfers);
        }, error => {
            this.delete(id);
            this.invoke(PROMISE_RESPONSE_ID, { 'id': id, 'error': error.message, 'errorName': error.name });
        });
    });
}
registerRPC(PROMISE_CANCEL_ID, function (x) {
    let id = x['id'];
    const request = this.get(id);
    if (request !== undefined) {
        let { cancellationToken } = request;
        cancellationToken.cancel();
    }
});
registerRPC(PROMISE_RESPONSE_ID, function (x) {
    let id = x['id'];
    let { resolve, reject } = this.get(id);
    this.delete(id);
    if (x.hasOwnProperty('value')) {
        resolve(x['value']);
    }
    else {
        const errorName = x['errorName'];
        if (errorName === neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["CANCELED"].name) {
            reject(neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["CANCELED"]);
        }
        else {
            reject(new RPCError(x['errorName'], x['error']));
        }
    }
});
const INITIAL_RPC_ID = IS_WORKER ? -1 : 0;
class RPC {
    constructor(target) {
        this.target = target;
        this.objects = new Map();
        this.nextId = INITIAL_RPC_ID;
        target.onmessage = (e) => {
            let data = e.data;
            if (DEBUG_MESSAGES) {
                console.log('Received message', data);
            }
            handlers.get(data.functionName).call(this, data);
        };
    }
    get numObjects() {
        return this.objects.size;
    }
    set(id, value) {
        this.objects.set(id, value);
    }
    delete(id) {
        this.objects.delete(id);
    }
    get(id) {
        return this.objects.get(id);
    }
    getRef(x) {
        let rpcId = x['id'];
        let obj = this.get(rpcId);
        obj.referencedGeneration = x['gen'];
        obj.addRef();
        return obj;
    }
    invoke(name, x, transfers) {
        x.functionName = name;
        if (DEBUG_MESSAGES) {
            console.trace('Sending message', x);
        }
        this.target.postMessage(x, transfers);
    }
    promiseInvoke(name, x, cancellationToken = neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["uncancelableToken"], transfers) {
        return Object(neuroglancer_util_cancellation__WEBPACK_IMPORTED_MODULE_0__["makeCancelablePromise"])(cancellationToken, (resolve, reject, token) => {
            const id = x['id'] = this.newId();
            this.set(id, { resolve, reject });
            this.invoke(name, x, transfers);
            token.add(() => {
                this.invoke(PROMISE_CANCEL_ID, { 'id': id });
            });
        });
    }
    newId() {
        return IS_WORKER ? this.nextId-- : this.nextId++;
    }
}
class SharedObject extends neuroglancer_util_disposable__WEBPACK_IMPORTED_MODULE_1__["RefCounted"] {
    constructor() {
        super(...arguments);
        this.rpc = null;
        this.rpcId = null;
    }
    initializeSharedObject(rpc, rpcId = rpc.newId()) {
        this.rpc = rpc;
        this.rpcId = rpcId;
        this.isOwner = false;
        rpc.set(rpcId, this);
    }
    initializeCounterpart(rpc, options = {}) {
        this.initializeSharedObject(rpc);
        this.unreferencedGeneration = 0;
        this.referencedGeneration = 0;
        this.isOwner = true;
        options['id'] = this.rpcId;
        options['type'] = this.RPC_TYPE_ID;
        rpc.invoke('SharedObject.new', options);
    }
    dispose() {
        super.dispose();
    }
    /**
     * Precondition: this.isOwner === true.
     */
    addCounterpartRef() {
        return { 'id': this.rpcId, 'gen': ++this.referencedGeneration };
    }
    refCountReachedZero() {
        if (this.isOwner === true) {
            if (this.referencedGeneration === this.unreferencedGeneration) {
                this.ownerDispose();
            }
        }
        else if (this.isOwner === false) {
            this.rpc.invoke('SharedObject.refCountReachedZero', { 'id': this.rpcId, 'gen': this.referencedGeneration });
        }
        else {
            super.refCountReachedZero();
        }
    }
    /**
     * Precondition: this.isOwner === true.
     */
    ownerDispose() {
        if (DEBUG) {
            console.log(`[${IS_WORKER}] #rpc object = ${this.rpc.numObjects}`);
        }
        let { rpc, rpcId } = this;
        super.refCountReachedZero();
        rpc.delete(rpcId);
        rpc.invoke('SharedObject.dispose', { 'id': rpcId });
    }
    /**
     * Precondition: this.isOwner === true.
     *
     * This should be called when the counterpart's refCount is decremented and reaches zero.
     */
    counterpartRefCountReachedZero(generation) {
        this.unreferencedGeneration = generation;
        if (this.refCount === 0 && generation === this.referencedGeneration) {
            this.ownerDispose();
        }
    }
}
function initializeSharedObjectCounterpart(obj, rpc, options = {}) {
    if (rpc != null) {
        obj.initializeSharedObject(rpc, options['id']);
    }
}
/**
 * Base class for defining a SharedObject type that will never be owned.
 */
class SharedObjectCounterpart extends SharedObject {
    constructor(rpc, options = {}) {
        super();
        initializeSharedObjectCounterpart(this, rpc, options);
    }
}
registerRPC('SharedObject.dispose', function (x) {
    let obj = this.get(x['id']);
    if (obj.refCount !== 0) {
        throw new Error(`Attempted to dispose object with non-zero reference count.`);
    }
    if (DEBUG) {
        console.log(`[${IS_WORKER}] #rpc objects: ${this.numObjects}`);
    }
    obj.disposed();
    this.delete(obj.rpcId);
    obj.rpcId = null;
    obj.rpc = null;
});
registerRPC('SharedObject.refCountReachedZero', function (x) {
    let obj = this.get(x['id']);
    let generation = x['gen'];
    obj.counterpartRefCountReachedZero(generation);
});
const sharedObjectConstructors = new Map();
/**
 * Register a class as a SharedObject owner type under the specified identifier.
 *
 * This is intended to be used as a decorator.
 */
function registerSharedObjectOwner(identifier) {
    return (constructorFunction) => {
        constructorFunction.prototype.RPC_TYPE_ID = identifier;
    };
}
/**
 * Register a class as a SharedObject counterpart type under the specified identifier.
 *
 * This is intended to be used as a decorator.
 *
 * Also register the type as a SharedObject owner, which is useful if this type is also used as a
 * SharedObject owner.
 */
function registerSharedObject(identifier) {
    return (constructorFunction) => {
        if (identifier !== undefined) {
            constructorFunction.prototype.RPC_TYPE_ID = identifier;
        }
        else {
            identifier = constructorFunction.prototype.RPC_TYPE_ID;
            if (identifier === undefined) {
                throw new Error('RPC_TYPE_ID should have already been defined');
            }
        }
        sharedObjectConstructors.set(identifier, constructorFunction);
    };
}
registerRPC('SharedObject.new', function (x) {
    let rpc = this;
    let typeName = x['type'];
    let constructorFunction = sharedObjectConstructors.get(typeName);
    let obj = new constructorFunction(rpc, x);
    // Counterpart objects start with a reference count of zero.
    --obj.refCount;
});


/***/ }),

/***/ 0:
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi neuroglancer/datasource/brainmaps/frontend neuroglancer/datasource/brainmaps/register_credentials_provider neuroglancer/datasource/brainmaps/register_default neuroglancer/datasource/boss/frontend neuroglancer/datasource/boss/register_credentials_provider neuroglancer/datasource/boss/register_default neuroglancer/datasource/dvid/frontend neuroglancer/datasource/dvid/register_default neuroglancer/datasource/render/frontend neuroglancer/datasource/render/register_default neuroglancer/datasource/precomputed/frontend neuroglancer/datasource/precomputed/register_default neuroglancer/datasource/nifti/frontend neuroglancer/datasource/nifti/register_default neuroglancer/datasource/n5/frontend neuroglancer/datasource/n5/register_default neuroglancer/datasource/computed/frontend neuroglancer/datasource/computed/register_default neuroglancer/datasource/computed/example/frontend neuroglancer/datasource/computed/example/register_default neuroglancer/datasource/computed/tensorflow/frontend neuroglancer/datasource/computed/tensorflow/register_default neuroglancer/datasource/vtk/frontend neuroglancer/datasource/csv/frontend neuroglancer/image_user_layer neuroglancer/vector_graphics_user_layer neuroglancer/segmentation_user_layer neuroglancer/single_mesh_user_layer neuroglancer/annotation/user_layer ./src/main.ts ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! neuroglancer/datasource/brainmaps/frontend */"./src/neuroglancer/datasource/brainmaps/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/brainmaps/register_credentials_provider */"./src/neuroglancer/datasource/brainmaps/register_credentials_provider.ts");
__webpack_require__(/*! neuroglancer/datasource/brainmaps/register_default */"./src/neuroglancer/datasource/brainmaps/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/boss/frontend */"./src/neuroglancer/datasource/boss/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/boss/register_credentials_provider */"./src/neuroglancer/datasource/boss/register_credentials_provider.ts");
__webpack_require__(/*! neuroglancer/datasource/boss/register_default */"./src/neuroglancer/datasource/boss/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/dvid/frontend */"./src/neuroglancer/datasource/dvid/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/dvid/register_default */"./src/neuroglancer/datasource/dvid/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/render/frontend */"./src/neuroglancer/datasource/render/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/render/register_default */"./src/neuroglancer/datasource/render/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/precomputed/frontend */"./src/neuroglancer/datasource/precomputed/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/precomputed/register_default */"./src/neuroglancer/datasource/precomputed/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/nifti/frontend */"./src/neuroglancer/datasource/nifti/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/nifti/register_default */"./src/neuroglancer/datasource/nifti/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/n5/frontend */"./src/neuroglancer/datasource/n5/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/n5/register_default */"./src/neuroglancer/datasource/n5/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/computed/frontend */"./src/neuroglancer/datasource/computed/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/computed/register_default */"./src/neuroglancer/datasource/computed/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/computed/example/frontend */"./src/neuroglancer/datasource/computed/example/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/computed/example/register_default */"./src/neuroglancer/datasource/computed/example/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/computed/tensorflow/frontend */"./src/neuroglancer/datasource/computed/tensorflow/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/computed/tensorflow/register_default */"./src/neuroglancer/datasource/computed/tensorflow/register_default.ts");
__webpack_require__(/*! neuroglancer/datasource/vtk/frontend */"./src/neuroglancer/datasource/vtk/frontend.ts");
__webpack_require__(/*! neuroglancer/datasource/csv/frontend */"./src/neuroglancer/datasource/csv/frontend.ts");
__webpack_require__(/*! neuroglancer/image_user_layer */"./src/neuroglancer/image_user_layer.ts");
__webpack_require__(/*! neuroglancer/vector_graphics_user_layer */"./src/neuroglancer/vector_graphics_user_layer.ts");
__webpack_require__(/*! neuroglancer/segmentation_user_layer */"./src/neuroglancer/segmentation_user_layer.ts");
__webpack_require__(/*! neuroglancer/single_mesh_user_layer */"./src/neuroglancer/single_mesh_user_layer.ts");
__webpack_require__(/*! neuroglancer/annotation/user_layer */"./src/neuroglancer/annotation/user_layer.ts");
module.exports = __webpack_require__(/*! /home/tomaz/source/master_neuroglancer/src/main.ts */"./src/main.ts");


/***/ })

/******/ });
//# sourceMappingURL=main.bundle.js.map