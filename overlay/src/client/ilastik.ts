import { vec3 } from "gl-matrix"
import { DatasetNameComponent, ExportPattern, ExtensionComponent, OutputTypeComponent, TimestampComponent } from "../util/export_pattern"
import { assertUnreachable, fetchJson, parseJson, PermissionError, RequestFailure, sleep, UnauthorizedRequestError } from "../util/misc"
import { Path, Url } from "../util/parsed_url"
import { DataType, ensureDataType } from "../util/precomputed_chunks"
import {
    ensureJsonObject, ensureJsonString, fromBase64, JsonableValue, JsonValue, toBase64, toJsonValue
} from "../util/serialization"
import {
    BucketFSDto,
    ZipFsDto,
    CloseComputeSessionParamsDto,
    ColorDto,
    ComputeSessionStatusDto,
    CreateComputeSessionParamsDto,
    PrecomputedChunksDataSourceDto,
    GetAvailableHpcSitesResponseDto,
    GetComputeSessionStatusParamsDto,
    GetDatasourcesFromUrlParamsDto,
    GetDatasourcesFromUrlResponseDto,
    HttpFsDto,
    IlpFeatureExtractorDto,
    Interval5DDto,
    ListComputeSessionsParamsDto,
    ListComputeSessionsResponseDto,
    LoadProjectParamsDto,
    OsfsDto,
    Point5DDto,
    PrecomputedChunksSinkDto,
    SaveProjectParamsDto,
    Shape5DDto,
    N5DataSinkDto,
    SkimageDataSourceDto,
    ListFsDirRequest,
    ListFsDirResponse,
    parse_as_Union_of_PrecomputedChunksDataSourceDto0N5DataSourceDto0SkimageDataSourceDto0DziLevelDataSourceDto_endof_,
    PixelAnnotationDto,
    N5Bzip2CompressorDto,
    N5GzipCompressorDto,
    N5RawCompressorDto,
    N5XzCompressorDto,
    N5DataSourceDto,
    DziLevelDataSourceDto,
    DziImageElementDto,
    DziLevelSinkDto,
    GetFileSystemAndPathFromUrlParamsDto,
    GetFileSystemAndPathFromUrlResponseDto,
    DziSizeElementDto,
    EbrainsAccessTokenDto,
    MessageParsingError,
    ensureJsonBoolean,
} from "./dto"

export type HpcSiteName = ComputeSessionStatusDto["hpc_site"] //FIXME?

export const SESSION_DONE_STATES = [
    "BOOT_FAIL",
    "CANCELLED",
    "DEADLINE",
    "FAILED",
    "NODE_FAIL",
    "OUT_OF_MEMORY",
    "PREEMPTED",
    "REVOKED",
    "TIMEOUT",
    "COMPLETED",
]; //FIXME: shouldn't this be autogenerated?

export function makeAuthHeaders(token: EbrainsAccessTokenDto){
    return {
        "Authorization": `Bearer ${token.access_token}`,
        "X-Authorization-Refresh": token.refresh_token,
    }
}

export class StartupConfigs{
    project_file_url: Url | undefined
    ebrains_bucket_name?: string
    ebrains_bucket_path: Path
    clb_collab_id?: string
    output_path_pattern?: ExportPattern
    confirm_exit_when_session_running: boolean
    autorejoin_session_id?: string

    public constructor(params: {
        project_file_url: Url | undefined,
        ebrains_bucket_name?: string,
        ebrains_bucket_path: Path,
        clb_collab_id?: string,
        output_path_pattern?: ExportPattern,
        confirm_exit_when_session_running: boolean,
        autorejoin_session_id?: string,
    }){
        this.project_file_url = params.project_file_url
        this.ebrains_bucket_name = params.ebrains_bucket_name
        this.ebrains_bucket_path = params.ebrains_bucket_path
        this.clb_collab_id = params.clb_collab_id
        this.output_path_pattern = params.output_path_pattern
        this.confirm_exit_when_session_running = params.confirm_exit_when_session_running
        this.autorejoin_session_id = params.autorejoin_session_id
    }

    public static getDefault(): StartupConfigs{
        return new StartupConfigs({
            project_file_url: undefined,
            ebrains_bucket_path: Path.root,
            confirm_exit_when_session_running: true,
        })
    }

    public static tryFromWindowLocation(): StartupConfigs | Error{
        let locationUrlResult = Url.safe_parse(window.location.href)
        if(locationUrlResult instanceof Error){
            return locationUrlResult
        }

        const project_file_url__key = "project_file_url";
        const projectFileUrlRaw = locationUrlResult.search.get(project_file_url__key);
        const projectFileUrlResult = projectFileUrlRaw === undefined ? undefined : Url.safe_parse(projectFileUrlRaw);
        if(projectFileUrlResult instanceof Error){
            return projectFileUrlResult
        }

        const ebrains_bucket_name__key = "ebrains_bucket_name"
        const ebrainsBucketNameRaw = locationUrlResult.search.get(ebrains_bucket_name__key)

        const ebrains_bucket_path_key = "ebrains_bucket_path"
        const ebrainsBucketPathRaw = locationUrlResult.search.get(ebrains_bucket_path_key)

        const output_path_pattern = "output_path_pattern"
        const rawOutputPathPattern = locationUrlResult.search.get(output_path_pattern)
        const outputPathPattern = rawOutputPathPattern ? ExportPattern.parse(rawOutputPathPattern) : undefined
        if(outputPathPattern instanceof Error){
            return outputPathPattern
        }

        const confirm_exit_when_session_running__key = "confirm_exit_when_session_running";
        const confirmExitWhenSessionRunningRaw = locationUrlResult.search.get(confirm_exit_when_session_running__key)
        let confirmExitWhenSessionRunning: boolean = true;
        if(confirmExitWhenSessionRunningRaw){
            const parsingResult = parseJson(confirmExitWhenSessionRunningRaw)
            if(parsingResult instanceof Error){
                return parsingResult
            }
            const result = ensureJsonBoolean(parsingResult)
            if(result instanceof Error){
                return result
            }
            confirmExitWhenSessionRunning = result
        }

        const autorejoin_session_id__key = "autorejoin_session_id"
        const autorejoin_session_id = locationUrlResult.search.get(autorejoin_session_id__key)

        const collabId = locationUrlResult.search.get("clb-collab-id")

        return new StartupConfigs({
            [project_file_url__key]: projectFileUrlResult,
            [ebrains_bucket_name__key]: ebrainsBucketNameRaw,
            [ebrains_bucket_path_key]: ebrainsBucketPathRaw ? Path.parse(ebrainsBucketPathRaw) : Path.root,
            clb_collab_id: collabId,
            [output_path_pattern]: outputPathPattern,
            [confirm_exit_when_session_running__key]: confirmExitWhenSessionRunning,
            [autorejoin_session_id__key]: autorejoin_session_id,
        })
    }

    public get effectiveBucketName(): string{
        return this.ebrains_bucket_name || this.clb_collab_id || "hbp-image-service"
    }

    public get effectiveOutputPathPattern(): ExportPattern{
        if(this.output_path_pattern){
            return this.output_path_pattern
        }
        return new ExportPattern([
            this.ebrains_bucket_path.joinPath("ilastik_exports").raw,
            "/",
            new TimestampComponent(),
            "/",
            new DatasetNameComponent(), "_", new OutputTypeComponent(), ".", new ExtensionComponent()
        ])
    }
}

export class Session{
    public readonly ilastikUrl: Url
    public readonly sessionStatus: ComputeSessionStatusDto
    private websocket: WebSocket
    private messageHandlers = new Array<(ev: MessageEvent) => void>();
    private readonly onUsageError: (message: string) => void
    public token: EbrainsAccessTokenDto | Promise<EbrainsAccessTokenDto>

    protected constructor(params: {
        ilastikUrl: Url,
        token: EbrainsAccessTokenDto,
        sessionStatus: ComputeSessionStatusDto,
        onUsageError: (message: string) => void,
    }){
        this.ilastikUrl = params.ilastikUrl
        this.token = params.token
        this.sessionStatus = params.sessionStatus
        this.onUsageError = params.onUsageError
        this.websocket = this.openWebsocket()
    }

    public static async getEbrainsUserToken({ilastikUrl, timeoutMs=60 * 1000}: {
        ilastikUrl: Url,
        timeoutMs?: number
    }): Promise<EbrainsAccessTokenDto | PermissionError | MessageParsingError>{
        const loginUrl = ilastikUrl.joinPath("api/prompt_user_for_login") //FIXME: add a nonce query param?
        const loginWindow = window.open(loginUrl.raw, "popup")
        if(!loginWindow){
            return new PermissionError("Could not open login popup window")
        }
        return new Promise<EbrainsAccessTokenDto | MessageParsingError>(resolve => {
            const listener = (ev: MessageEvent) => {
                window.removeEventListener("message", listener)
                console.log("Got this message from helper:")
                console.log(ev.data)
                resolve(EbrainsAccessTokenDto.fromJsonValue(ev.data))
            }
            window.addEventListener("message", listener)
            setTimeout(
                () => window.removeEventListener("message", listener),
                timeoutMs
            )
        })
    }

    public get sessionUrl(): Url{
        return Url.fromDto(this.sessionStatus.session_url)
    }

    public get startTime(): Date | undefined{
        const {start_time_utc_sec} = this.sessionStatus.compute_session
        if(start_time_utc_sec === undefined){
            return undefined
        }
        return new Date(start_time_utc_sec * 1000)
    }

    public get timeLimitMinutes(): number{
        return this.sessionStatus.compute_session.time_limit_minutes
    }

    public get sessionId(): string{
        return this.sessionStatus.compute_session.compute_session_id
    }

    private openWebsocket(): WebSocket{
        const wsUrl = this.sessionUrl.updatedWith({
            protocol: this.sessionUrl.protocol == "http" ? "ws" : "wss"
        }).joinPath("ws")
        let websocket = new WebSocket(wsUrl.schemeless_raw)
        websocket.addEventListener("error", this.refreshWebsocket)
        websocket.addEventListener("close", this.refreshWebsocket)
        websocket.addEventListener("message", (ev: MessageEvent) => {
            let payload = JSON.parse(ev.data)
            let payload_obj = ensureJsonObject(payload)
            if("error" in payload_obj){
                this.onUsageError(ensureJsonString(payload_obj.error))
            }
        })
        for(let handler of this.messageHandlers){
            websocket.addEventListener("message", handler)
        }
        return websocket
    }

    public closeWebsocket(){
        this.websocket.removeEventListener("close", this.refreshWebsocket)
        this.websocket.removeEventListener("error", this.refreshWebsocket)
        for(let handler of this.messageHandlers){
            this.websocket.removeEventListener("message", handler)
        }
        this.websocket.close()
    }

    private refreshWebsocket = (ev: Event) => {
        console.warn("Refreshing socket because of this:", ev)
        this.closeWebsocket()
        this.websocket = this.openWebsocket()
    }

    public addMessageListener(handler: (ev: MessageEvent) => void){
        this.messageHandlers.push(handler)
        this.websocket.addEventListener("message", handler)
    }

    public async terminate(): Promise<RequestFailure | undefined>{
        this.closeWebsocket()
        const result = await this.authenticatedFetchJson({
            url: this.sessionUrl.joinPath("close"), jsonablePayload: null
        })
        if(result instanceof Error){
            return result
        }
        return undefined
    }

    public async saveProject(params: SaveProjectParamsDto): Promise<Error | undefined>{
        let response = await this.authenticatedFetchJson({
            url: this.sessionUrl.joinPath("save_project"),
            jsonablePayload: params,
        })
        if(response instanceof Error){
            return response
        }
        return undefined
    }

    public async loadProject(params: LoadProjectParamsDto): Promise<Error | undefined>{
        let response = await this.authenticatedFetchJson({
            url: this.sessionUrl.joinPath("load_project"),
            jsonablePayload: params
        })
        if(response instanceof Error){
            return response
        }
        return undefined
    }

    public doRPC(params: {applet_name: string, method_name: string, method_arguments: JsonableValue}){
        return this.websocket.send(JSON.stringify({
            applet_name: params.applet_name,
            method_name: params.method_name,
            arguments: toJsonValue(params.method_arguments),
        }))
    }

    public async doHttpRpc(
        params: Array<{applet_name: string, method_name: string, arguments: JsonableValue}>
    ): Promise<undefined | Error>{
        const resp = await this.authenticatedFetchJson({
            url: this.sessionUrl.joinPath("http_rpc"),
            jsonablePayload: params
        })
        if(resp instanceof Error){
            return resp
        }
        return undefined
    }

    public static btoa(url: String): string{
        return btoa(url.toString()).replace("+", "-").replace("/", "_")
    }

    public static atob(encoded: String): string{
        return atob(encoded.replace("-", "+").replace("_", "/"))
    }

    public static async getStatus(
        params: {ilastikUrl: Url, rpcParams: GetComputeSessionStatusParamsDto, token: EbrainsAccessTokenDto}
    ): Promise<ComputeSessionStatusDto | Error>{
        let result = await Session.authenticatedFetchJson({
            url: params.ilastikUrl.joinPath(`/api/get_session_status`),
            token: params.token,
            jsonablePayload: params.rpcParams,
        })
        if(result instanceof Error){
            return result
        }
        return ComputeSessionStatusDto.fromJsonValue(result)
    }

    public static async authenticatedFetchJson(params: {
        url: Url,
        token: EbrainsAccessTokenDto,
        jsonablePayload: JsonableValue,
    }): Promise<JsonValue | RequestFailure>{
        return fetchJson(
            params.url.raw,
            {
                cache: "no-store",
                method: "POST",
                headers: makeAuthHeaders(params.token),
                body: JSON.stringify(toJsonValue(params.jsonablePayload)),
            },
        )
    }

    public async authenticatedFetchJson(params: {
        url: Url,
        jsonablePayload: JsonableValue,
        retryOn401?: boolean,
    }): Promise<JsonValue | RequestFailure>{
        const token = this.token instanceof Promise ? await this.token : this.token
        const result =  await Session.authenticatedFetchJson({
            url: params.url,
            token,
            jsonablePayload: params.jsonablePayload,
        })
        const retryOn401 = params.retryOn401 === undefined ? true : params.retryOn401
        const shouldRetry = result instanceof UnauthorizedRequestError && retryOn401
        if(!shouldRetry){
            return result
        }

        if(this.token == token){ //if nothing else updated or is updating the token during last await
            this.token = Session.refreshToken({ilastikUrl: this.ilastikUrl, token}).then(tokenResult => {
                return tokenResult instanceof Error ? token : tokenResult
            })
        }
        const refreshedToken = this.token instanceof Promise ? await this.token : this.token

        if(refreshedToken != token){ //if we managed to grab a new token
            return this.authenticatedFetchJson({url: params.url, jsonablePayload: params.jsonablePayload, retryOn401: false})
        }else{
            return result //FIXME: we lose a result here if we just failed to refresh the token
        }
    }

    public static async refreshToken(params: {
        ilastikUrl: Url,
        token: EbrainsAccessTokenDto,
    }): Promise<EbrainsAccessTokenDto | RequestFailure | MessageParsingError >{
        const result = await Session.authenticatedFetchJson({
            url: params.ilastikUrl.joinPath("api/refresh_token"),
            token: params.token,
            jsonablePayload: null,
        })
        if(result instanceof Error){
            return result
        }
        return EbrainsAccessTokenDto.fromJsonValue(result)
    }

    public static async listSessions(params: {
        ilastikUrl: Url, token: EbrainsAccessTokenDto, rpcParams: ListComputeSessionsParamsDto
    }): Promise<ListComputeSessionsResponseDto | Error>{
        let payload_result = await Session.authenticatedFetchJson({
            url: params.ilastikUrl.joinPath("/api/list_sessions"),
            token: params.token,
            jsonablePayload: params.rpcParams
        })
        if(payload_result instanceof Error){
            return payload_result
        }
        return ListComputeSessionsResponseDto.fromJsonValue(payload_result)
    }

    public static async getAvailableHpcSites(params: {ilastikUrl: Url}): Promise<GetAvailableHpcSitesResponseDto | Error>{
        let payload_result = await fetchJson(
            params.ilastikUrl.joinPath("/api/get_available_hpc_sites").raw,
            {
                cache: "no-store",
                method: "POST",
            },
        )
        if(payload_result instanceof Error){
            return payload_result
        }
        return GetAvailableHpcSitesResponseDto.fromJsonValue(payload_result)
    }

    public static async create(params: {
        ilastikUrl: Url,
        token: EbrainsAccessTokenDto,
        rpcParams: CreateComputeSessionParamsDto,
        timeout_minutes: number,
        onProgress?: (message: string) => void,
        onUsageError: (message: string) => void,
        autoCloseOnTimeout: boolean,
    }): Promise<Session | Error>{
        const onProgress = params.onProgress || (() => {})
        const newSessionUrl = params.ilastikUrl.joinPath("/api/create_compute_session")
        onProgress("Requesting session...")

        let session_creation_response = await Session.authenticatedFetchJson({
            url: newSessionUrl,
            token: params.token,
            jsonablePayload: params.rpcParams,
        })
        if(session_creation_response instanceof Error){
            return session_creation_response
        }
        const sessionStatusMsg = ComputeSessionStatusDto.fromJsonValue(session_creation_response)
        if(sessionStatusMsg instanceof Error){
            return sessionStatusMsg
        }
        onProgress(`Successfully requested a session! Waiting for it to be ready...`)
        return Session.load({
            ilastikUrl: params.ilastikUrl,
            token: params.token,
            getStatusRpcParams: new GetComputeSessionStatusParamsDto({
                compute_session_id: sessionStatusMsg.compute_session.compute_session_id,
                hpc_site: params.rpcParams.hpc_site,
            }),
            timeout_minutes: params.timeout_minutes,
            onProgress,
            onUsageError: params.onUsageError,
            autoCloseOnTimeout: params.autoCloseOnTimeout,
        })
    }

    public static async load(params: {
        ilastikUrl: Url,
        token: EbrainsAccessTokenDto,
        getStatusRpcParams: GetComputeSessionStatusParamsDto,
        timeout_minutes: number,
        onProgress?: (message: string) => void,
        onUsageError: (message: string) => void,
        autoCloseOnTimeout: boolean,
    }): Promise<Session | Error>{
        const start_time_ms = Date.now()
        const timeout_ms = params.timeout_minutes * 60 * 1000
        const onProgress = params.onProgress || (() => {})
        while(Date.now() - start_time_ms < timeout_ms){
            let sessionStatus = await Session.getStatus({
                ilastikUrl: params.ilastikUrl, rpcParams: params.getStatusRpcParams, token: params.token
            })
            if(sessionStatus instanceof Error){
                return sessionStatus
            }
            if(SESSION_DONE_STATES.includes(sessionStatus.compute_session.state)){ //FIXME
                return Error(`Session ${params.getStatusRpcParams.compute_session_id} is already closed`)
            }
            if(sessionStatus.compute_session.state == "CONFIGURING"){
                onProgress(`Session has been allocated, but some compute nodes might be still sleeping. Configuring...`)
                await sleep(2000)
                continue
            }
            if(sessionStatus.compute_session.state != "RUNNING"){
                onProgress(`Session has not started yet`)
                await sleep(2000)
                continue
            }
            if(!sessionStatus.connected){
                onProgress(`Session is running. Connecting...`)
                await sleep(2000)
                continue
            }
            onProgress(`Session is ready!`)
            let session = new Session({
                ilastikUrl: params.ilastikUrl,
                token: params.token,
                sessionStatus,
                onUsageError: params.onUsageError,
            })

            //FIXME
            return new Promise((resolve) => {
                let websocket = session.websocket
                let resolveThenClean = () => {
                    resolve(session)
                    websocket.removeEventListener("open", resolveThenClean)
                }
                websocket.addEventListener("open", resolveThenClean)
            })
        }
        onProgress(`Timed out waiting for session ${params.getStatusRpcParams.compute_session_id}`)
        if(params.autoCloseOnTimeout){
            onProgress(`Cancelling session ${params.getStatusRpcParams.compute_session_id}`)
            const cancellation_result = await Session.cancel({
                ilastikUrl: params.ilastikUrl,
                token: params.token,
                rpcParams: new CloseComputeSessionParamsDto({
                    compute_session_id: params.getStatusRpcParams.compute_session_id,
                    hpc_site: params.getStatusRpcParams.hpc_site,
                })
            })
            if(cancellation_result instanceof Error){
                onProgress(`Could not cancel session ${params.getStatusRpcParams.compute_session_id}: ${cancellation_result.message}`)
            }else{
                onProgress(`Cancelled session ${params.getStatusRpcParams.compute_session_id}`)
            }
        }
        return Error(`Could not create a session: timeout`)
    }

    public static async cancel(
        params: {ilastikUrl: Url, rpcParams: CloseComputeSessionParamsDto, token: EbrainsAccessTokenDto}
    ): Promise<Error | undefined>{
        let result = await Session.authenticatedFetchJson({
            url: params.ilastikUrl.joinPath(`api/close_session`),
            token: params.token,
            jsonablePayload: params.rpcParams
        })
        if(result instanceof Error){
            return result
        }
        return undefined
    }

    public async getDatasourcesFromUrl(params: GetDatasourcesFromUrlParamsDto): Promise<Array<FsDataSource> | Error>{
        let result = await this.authenticatedFetchJson({
            url: this.sessionUrl.joinPath("get_datasources_from_url"),
            jsonablePayload: params,
        })
        if(result instanceof Error){
            return result
        }
        const responseDto =  GetDatasourcesFromUrlResponseDto.fromJsonValue(result);
        if(responseDto instanceof Error){
            return responseDto
        }
        return responseDto.datasources.map(msg => FsDataSource.fromDto(msg))
    }

    public async tryGetFsAndPathFromUrl(params: GetFileSystemAndPathFromUrlParamsDto): Promise<{fs: Filesystem, path: Path} | Error>{
        //try_get_fs_and_path_from_url
        let result = await this.authenticatedFetchJson({
            url: this.sessionUrl.joinPath("try_get_fs_and_path_from_url"),
            jsonablePayload: params,
        })
        if(result instanceof Error){
            return result
        }
        const responseDto =  GetFileSystemAndPathFromUrlResponseDto.fromJsonValue(result);
        if(responseDto instanceof Error){
            return responseDto
        }
        return {
            fs: Filesystem.fromDto(responseDto.fs),
            path: Path.parse(responseDto.path),
        }
    }

    public async listFsDir(params: ListFsDirRequest): Promise<ListFsDirResponse | Error> {
        let response = await this.authenticatedFetchJson({
            url: this.sessionUrl.joinPath("list_fs_dir"),
            jsonablePayload: params,
        })
        if(response instanceof Error){
            return response
        }
        return ListFsDirResponse.fromJsonValue(response)
    }
}

export type AxisKey = "x" | "y" | "z" | "t" | "c";
export type AxesKeys = [AxisKey, AxisKey, AxisKey, AxisKey, AxisKey]

export type FeatureClassName = IlpFeatureExtractorDto["class_name"]

export class IlpFeatureExtractor{
    public readonly ilp_scale: number
    public readonly axis_2d: "x" | "y" | "z" | undefined
    public readonly __class__: FeatureClassName

    constructor(params: {ilp_scale: number, axis_2d: "x" | "y" | "z" | undefined, __class__: FeatureClassName}){
        this.ilp_scale = params.ilp_scale
        this.axis_2d = params.axis_2d
        this.__class__ = params.__class__
    }

    public static fromDto(message: IlpFeatureExtractorDto): IlpFeatureExtractor{
        return new IlpFeatureExtractor({
            ilp_scale: message.ilp_scale,
            axis_2d: message.axis_2d || "z",
            __class__: message.class_name
        })
    }

    public toDto(): IlpFeatureExtractorDto{
        return new IlpFeatureExtractorDto({
            ilp_scale: this.ilp_scale,
            axis_2d: this.axis_2d,
            class_name: this.__class__,
        })
    }

    public equals(other: IlpFeatureExtractor) : boolean{
        return this.ilp_scale == other.ilp_scale && this.axis_2d == other.axis_2d && this.__class__ == other.__class__
    }
}

export class Color{
    public readonly r: number;
    public readonly g: number;
    public readonly b: number;
    public readonly vec3f: vec3;
    public readonly vec3i: vec3;
    public readonly hashValue: number
    public readonly hexCode: string

    public constructor({r=0, g=0, b=0}: {r: number, g: number, b: number}){
        this.r = r; this.g = g; this.b = b;
        this.vec3f = vec3.fromValues(r/255, g/255, b/255) // FIXME: rounding errors?
        this.vec3i = vec3.fromValues(r, g, b) // FIXME: rounding errors?
        this.hashValue = r * 256 * 256 + g * 256 + b
        this.hexCode = "#" + [r,g,b].map((val) => {
            const val_str = val.toString(16)
            return val_str.length < 2 ? "0" + val_str : val_str
        }).join("")
    }

    public static fromHexCode(hexCode: string): Color{
        let channels = hexCode.slice(1).match(/../g)!.map(c => parseInt(c, 16))
        return new Color({r: channels[0], g: channels[1], b: channels[2]})
    }

    public static fromDto(message: ColorDto): Color{
        return new Color({
            r: message.r,
            g: message.g,
            b: message.b,
        })
    }

    public toDto(): ColorDto{
        return new ColorDto({
            r: this.r,
            g: this.g,
            b: this.b,
        })
    }

    public equals(other: Color): boolean{
        return this.hashValue == other.hashValue
    }

    public inverse(): Color{
        return new Color({r: 255 - this.r, g: 255 - this.g, b: 255 - this.b})
    }
}

export class Point5D{
    public readonly x: number;
    public readonly y: number;
    public readonly z: number;
    public readonly t: number;
    public readonly c: number;

    constructor({x=0, y=0, z=0, t=0, c=0}: {
        x?: number, y?: number, z?: number,t?: number, c?: number
    }){
        this.x = x; this.y = y; this.z = z; this.t = t; this.c = c;
    }

    public static fromVec3(value: vec3){
        return new Point5D({x: value[0], y: value[1], z: value[2]})
    }

    public static fromDto(message: Point5DDto): Point5D{
        return new this({
            x: message.x,
            y: message.y,
            z: message.z,
            t: message.t,
            c: message.c,
        })
    }

    public toDto(): Point5DDto {
        return new Point5DDto({x: this.x, y: this.y, z: this.z, t: this.t, c: this.c})
    }

    public plus(other: Point5D): Point5D{
        return new Point5D({
            x: this.x + other.x,
            y: this.y + other.y,
            z: this.z + other.z,
            t: this.t + other.t,
            c: this.c + other.c,
        })
    }
}

export class Shape5D extends Point5D{
    constructor({x=1, y=1, z=1, t=1, c=1}: {
        x?: number, y?: number, z?: number, t?: number, c?: number
    }){
        super({x, y, z, t, c})
    }

    public static fromDto(message: Shape5DDto): Shape5D{
        return new this({
            x: message.x,
            y: message.y,
            z: message.z,
            t: message.t,
            c: message.c,
        })
    }

    public toDto(): Shape5DDto {
        return new Shape5DDto({x: this.x, y: this.y, z: this.z, t: this.t, c: this.c})
    }

    public updated(params: {x?: number, y?: number, z?: number, t?: number, c?: number}): Shape5D{
        return new Shape5D({
            x: params.x !== undefined ? params.x : this.x,
            y: params.y !== undefined ? params.y : this.y,
            z: params.z !== undefined ? params.z : this.z,
            t: params.t !== undefined ? params.t : this.t,
            c: params.c !== undefined ? params.c : this.c,
        })
    }

    public clampedWith(limits: Shape5D): Shape5D{
        return new Shape5D({
            x: Math.min(this.x, limits.x),
            y: Math.min(this.y, limits.y),
            z: Math.min(this.z, limits.z),
            t: Math.min(this.t, limits.t),
            c: Math.min(this.c, limits.c),
        })
    }

    public toInterval5D({offset=new Point5D({})}: {offset?: Point5D}): Interval5D{
        return new Interval5D({
            x: [offset.x, offset.x + this.x],
            y: [offset.y, offset.y + this.y],
            z: [offset.z, offset.z + this.z],
            t: [offset.t, offset.t + this.t],
            c: [offset.c, offset.c + this.c],
        })
    }

    public toXyzVec3(): vec3{
        return vec3.fromValues(this.x, this.y, this.z)
    }

    public get volume(): number{
        return this.x * this.y * this.z
    }
}

export class Interval5D{
    public readonly x: [number, number];
    public readonly y: [number, number];
    public readonly z: [number, number];
    public readonly t: [number, number];
    public readonly c: [number, number];
    public readonly shape: Shape5D
    public readonly start: Point5D
    public readonly stop: Point5D

    constructor({x, y, z, t, c}: {
        x: [number, number],
        y: [number, number],
        z: [number, number],
        t: [number, number],
        c: [number, number],
    }){
        this.x = x; this.y = y; this.z = z; this.t = t; this.c = c;
        this.shape = new Shape5D({
            x: x[1] - x[0],
            y: y[1] - y[0],
            z: z[1] - z[0],
            t: t[1] - t[0],
            c: c[1] - c[0],
        })
        this.start = new Point5D({x: x[0], y: y[0], z: z[0], t: t[0], c: c[0]})
        this.stop = new Point5D({x: x[1], y: y[1], z: z[1], t: t[1], c: c[1]})
    }

    public static fromStartStop(params: {start: Point5D, stop: Point5D}): Interval5D{
        return new Interval5D({
            x: [params.start.x, params.stop.x],
            y: [params.start.y, params.stop.y],
            z: [params.start.z, params.stop.z],
            t: [params.start.t, params.stop.t],
            c: [params.start.c, params.stop.c],
        })
    }

    public updated(params: {
        x?: [number, number],
        y?: [number, number],
        z?: [number, number],
        t?: [number, number],
        c?: [number, number],
    }): Interval5D{
        return new Interval5D({
            x: params.x || this.x,
            y: params.y || this.y,
            z: params.z || this.z,
            t: params.t || this.t,
            c: params.c || this.c,
        })
    }

    public static fromDto(message: Interval5DDto){
        return new this({
            x: [message.start.x, message.stop.x],
            y: [message.start.y, message.stop.y],
            z: [message.start.z, message.stop.z],
            t: [message.start.t, message.stop.t],
            c: [message.start.c, message.stop.c],
        })
    }

    public toDto(): Interval5DDto{
        return new Interval5DDto({
            start: this.start.toDto(), stop: this.stop.toDto(),
        })
    }
}

export type FsDataSourceDto = PixelAnnotationDto["raw_data"]; //FIXME: define this alias automatically

export type DataSourceUnion = PrecomputedChunksDataSource | N5DataSource | SkimageDataSource | DziLevelDataSource

export abstract class FsDataSource{
    public readonly url: Url
    public readonly filesystem: Filesystem
    public readonly path: Path
    public readonly interval: Interval5D
    public readonly tile_shape: Shape5D
    public readonly spatial_resolution: [number, number, number]
    public readonly dtype: DataType

    constructor(params: {
        url: Url,
        filesystem: Filesystem,
        path: Path,
        interval: Interval5D,
        tile_shape: Shape5D,
        spatial_resolution: [number, number, number],
        dtype: DataType,
    }){
        this.url = params.url;
        this.filesystem = params.filesystem;
        this.path = params.path;
        this.interval = params.interval;
        this.tile_shape = params.tile_shape;
        this.spatial_resolution = params.spatial_resolution;
        this.dtype = params.dtype;
    }

    public hasSameScaleAs(_other: FsDataSource): boolean{
        return false
    }

    public get shape(): Shape5D{
        return this.interval.shape
    }

    public get hashValue(): string{
        return this.url.raw
    }

    public static fromDto(dto: FsDataSourceDto) : DataSourceUnion{
        if(dto instanceof PrecomputedChunksDataSourceDto){
            return PrecomputedChunksDataSource.fromDto(dto)
        }
        if(dto instanceof SkimageDataSourceDto){
            return SkimageDataSource.fromDto(dto)
        }
        if(dto instanceof N5DataSourceDto){
            return N5DataSource.fromDto(dto)
        }
        if(dto instanceof DziLevelDataSourceDto){
            return DziLevelDataSource.fromDto(dto)
        }
        assertUnreachable(dto)
    }

    public static fromBase64(encoded: string): Error | ReturnType<typeof FsDataSource.fromDto>{
        const dtoResult = parse_as_Union_of_PrecomputedChunksDataSourceDto0N5DataSourceDto0SkimageDataSourceDto0DziLevelDataSourceDto_endof_(
            JSON.parse(fromBase64(encoded))
        )
        if(dtoResult instanceof Error){
            return dtoResult
        }
        return FsDataSource.fromDto(dtoResult)
    }

    public abstract toDto(): FsDataSourceDto;

    public toBase64(): string{
        return toBase64(JSON.stringify(this.toDto().toJsonValue()))
    }

    public get resolutionString(): string{
        return `${this.spatial_resolution[0]}x${this.spatial_resolution[1]}x${this.spatial_resolution[2]} nm`
    }

    public getDisplayString() : string{
        return `${this.url.name} (${this.resolutionString})`
    }

    public equals(other: FsDataSource): boolean{
        return (
            this.url.equals(other.url) && vec3.equals(this.spatial_resolution, other.spatial_resolution)
        )
    }
}

export class PrecomputedChunksDataSource extends FsDataSource{
    public readonly encoder: "jpeg" | "raw"
    public readonly scale_key: Path

    public constructor(params: ConstructorParameters<typeof FsDataSource>[0] & {
        encoder: "jpeg" | "raw",
        scale_key: Path,
    }){
        super(params)
        this.encoder = params.encoder
        this.scale_key = params.scale_key
    }

    public hasSameScaleAs(other: FsDataSource): boolean {
        return other instanceof PrecomputedChunksDataSource &&
            this.spatial_resolution.every((val, idx) => val == other.spatial_resolution[idx])
    }

    public static fromDto(dto: PrecomputedChunksDataSourceDto) : PrecomputedChunksDataSource{
        return new PrecomputedChunksDataSource({
            filesystem: Filesystem.fromDto(dto.filesystem),
            path: Path.fromDto(dto.path),
            url: Url.fromDto(dto.url),
            interval: Interval5D.fromDto(dto.interval),
            tile_shape: Shape5D.fromDto(dto.tile_shape),
            spatial_resolution: dto.spatial_resolution,
            dtype: ensureDataType(dto.dtype), //FIXME?
            encoder: dto.encoder,
            scale_key: Path.parse(dto.scale_key)
        })
    }

    public toDto(): PrecomputedChunksDataSourceDto{
        return new PrecomputedChunksDataSourceDto({
            filesystem: this.filesystem.toDto(),
            path: this.path.toDto(),
            url: this.url.toDto(),
            interval: this.interval.toDto(),
            tile_shape: this.tile_shape.toDto(),
            spatial_resolution: this.spatial_resolution,
            dtype: this.dtype,
            encoder: this.encoder,
            scale_key: this.scale_key.raw,
        })
    }
}

export class SkimageDataSource extends FsDataSource{
    public toDto(): SkimageDataSourceDto {
        return new  SkimageDataSourceDto({
            filesystem: this.filesystem.toDto(),
            path: this.path.toDto(),
            url: this.url.toDto(),
            interval: this.interval.toDto(),
            tile_shape: this.tile_shape.toDto(),
            spatial_resolution: this.spatial_resolution,
            dtype: this.dtype,
        })
    }
    public static fromDto(dto: SkimageDataSourceDto) : SkimageDataSource{
        return new SkimageDataSource({
            filesystem: Filesystem.fromDto(dto.filesystem),
            path: Path.fromDto(dto.path),
            url: Url.fromDto(dto.url),
            interval: Interval5D.fromDto(dto.interval),
            tile_shape: Shape5D.fromDto(dto.tile_shape),
            spatial_resolution: dto.spatial_resolution,
            dtype: ensureDataType(dto.dtype), //FIXME?
        })
    }
}

export class N5DataSource extends FsDataSource{
    public readonly compressor: N5Compressor
    public readonly c_axiskeys: string

    public constructor(params: ConstructorParameters<typeof FsDataSource>[0] & {
        compressor: N5Compressor,
        c_axiskeys: string,
    }){
        super(params)
        this.compressor = params.compressor
        this.c_axiskeys = params.c_axiskeys
    }

    public static fromDto(dto: N5DataSourceDto) : N5DataSource{
        return new N5DataSource({
            filesystem: Filesystem.fromDto(dto.filesystem),
            path: Path.fromDto(dto.path),
            url: Url.fromDto(dto.url),
            interval: Interval5D.fromDto(dto.interval),
            tile_shape: Shape5D.fromDto(dto.tile_shape),
            spatial_resolution: dto.spatial_resolution,
            dtype: ensureDataType(dto.dtype), //FIXME?
            compressor: N5Compressor.create_from_dto(dto.compressor),
            c_axiskeys: dto.c_axiskeys_on_disk,
        })
    }

    public toDto(): N5DataSourceDto{
        return new N5DataSourceDto({
            filesystem: this.filesystem.toDto(),
            path: this.path.toDto(),
            url: this.url.toDto(),
            interval: this.interval.toDto(),
            tile_shape: this.tile_shape.toDto(),
            spatial_resolution: this.spatial_resolution,
            dtype: this.dtype,
            compressor: this.compressor.to_dto(),
            c_axiskeys_on_disk: this.c_axiskeys,
        })
    }
}

export class DziSizeElement{
    public readonly Width: number
    public readonly Height: number

    public constructor(params: {Width: number, Height: number}){
        this.Width = params.Width
        this.Height = params.Height
    }

    public static fromDto(dto: DziSizeElementDto): DziSizeElement{
        return new DziSizeElement(dto)
    }

    public toDto(): DziSizeElementDto{
        return new DziSizeElementDto(this)
    }
}

export class DziImageElement{
    public readonly Format: "jpeg" | "jpg" | "png"
    public readonly Overlap: number
    public readonly TileSize: number
    public readonly Size: DziSizeElement

    public readonly max_level_index: number
    public readonly num_levels: number
    private levels: Array<{width: number, height: number}>

    public constructor(params: {
        Format: "jpeg" | "jpg" | "png",
        Overlap: number,
        TileSize: number,
        Size: DziSizeElement,
    }){
        this.Format = params.Format
        this.Overlap = params.Overlap
        this.TileSize = params.TileSize
        this.Size = params.Size

        this.max_level_index = Math.ceil(Math.log2(Math.max(this.Size.Height, this.Size.Width)))
        this.num_levels = this.max_level_index + 1

        this.levels = []

        let width: number = this.Size.Width
        let height: number = this.Size.Height
        for(let i=0; i<this.num_levels; i++){
            this.levels.unshift({width, height})
            width = Math.ceil(width / 2)
            height = Math.ceil(height / 2)
        }

    }

    public get_shape(params: {num_channels: number, level_index: number}): Shape5D{
        return new Shape5D({
            x: this.levels[params.level_index].width,
            y: this.levels[params.level_index].height,
            c: params.num_channels
        })
    }

    public get_tile_shape(num_channels: number): Shape5D{
        return new Shape5D({x: this.TileSize, y: this.TileSize, c: num_channels})
    }

    public static make_level_path(xml_path: Path, level_index: number): Path{
        return xml_path.parent.joinPath(`${xml_path.stem}_files/${level_index}`)
    }

    public static fromDto(dto: DziImageElementDto): DziImageElement{
        return new DziImageElement({
            Format: dto.Format,
            Overlap: dto.Overlap,
            TileSize: dto.TileSize,
            Size: DziSizeElement.fromDto(dto.Size)
        })
    }

    public toDto(): DziImageElementDto{
        return new DziImageElementDto({
            Format: this.Format,
            Overlap: this.Overlap,
            TileSize: this.TileSize,
            Size: this.Size.toDto(),
        })
    }
}

export class DziLevelDataSource extends FsDataSource{
    public readonly dzi_image: DziImageElement
    public readonly level_index: number
    public readonly xml_path: Path
    public readonly num_channels: 1 | 3

    public constructor(params: {
        filesystem: Filesystem,
        xml_path: Path,
        dzi_image: DziImageElement,
        num_channels: 1 | 3,
        level_index: number,
    }){
        let width = params.dzi_image.Size.Width;
        let height = params.dzi_image.Size.Height;

        for(let i=0; i<params.dzi_image.max_level_index - params.level_index; i++){
            width = Math.ceil(width / 2)
            height = Math.ceil(height / 2)
        }

        super({
            dtype: "uint8",
            filesystem: params.filesystem,
            interval: new Shape5D({x: width, y: height, c: params.num_channels}).toInterval5D({}),
            path: params.xml_path,
            spatial_resolution: [1,1,1], //FIXME
            tile_shape: params.dzi_image.get_tile_shape(params.num_channels),
            url: params.filesystem.getUrl(params.xml_path).updatedWith({datascheme: "deepzoom", hash: `level=${params.level_index}`}),
        })
        this.xml_path = params.xml_path
        this.level_index = params.level_index
        this.dzi_image = params.dzi_image
        this.num_channels = params.num_channels
    }

    public get scale(): number{
        return 1 / Math.pow(2, this.dzi_image.max_level_index - this.level_index)
    }

    public hasSameScaleAs(other: FsDataSource): boolean{
        return other instanceof DziLevelDataSource && this.scale == other.scale
    }

    public getDisplayString(): string {
        let name = this.url.path.name
        for(let comp of this.url.path.components){
            if(comp.toLowerCase().endsWith(".dzip")){
                name = comp
                break
            }
        }
        return `${name} ${this.resolutionString}`
    }

    public get resolutionString(): string {
        return `${(this.scale * 100).toFixed(2)}%`
    }

    public static fromDto(dto: DziLevelDataSourceDto) : DziLevelDataSource{
        return new DziLevelDataSource({
            filesystem: Filesystem.fromDto(dto.filesystem),
            dzi_image: DziImageElement.fromDto(dto.dzi_image),
            xml_path: Path.fromDto(dto.xml_path),
            level_index: dto.level_index,
            num_channels: dto.num_channels,
        })
    }

    public toDto(): DziLevelDataSourceDto{
        return new DziLevelDataSourceDto({
            xml_path: this.xml_path.toDto(),
            dzi_image: this.dzi_image.toDto(),
            filesystem: this.filesystem.toDto(),
            level_index: this.level_index,
            num_channels: this.num_channels,
        })
    }
}

export abstract class Filesystem{
    public constructor(public readonly url: Url){}

    //FIXME: this should take a FsDto, whose type should be auto-generated
    public static fromDto(message: PrecomputedChunksDataSourceDto["filesystem"]): Filesystem{
        if(message instanceof BucketFSDto){
            return BucketFs.fromDto(message)
        }
        if(message instanceof HttpFsDto){
            return HttpFs.fromDto(message)
        }
        if(message instanceof OsfsDto){
            return OsFs.fromDto(message)
        }
        if(message instanceof ZipFsDto){
            return ZipFs.fromDto(message)
        }
        assertUnreachable(message)
    }

    //FIXME: this should take a FsDto, whose type should be auto-generated
    public abstract toDto(): PrecomputedChunksDataSourceDto["filesystem"];

    public abstract getUrl(path: Path): Url;
}

export class ZipFs extends Filesystem{
    public constructor(
        public readonly zip_file_fs: OsFs | HttpFs | BucketFs,
        public readonly zip_file_path: Path
    ){
        super(zip_file_fs.getUrl(zip_file_path))
    }
    public getUrl(path: Path): Url {
        return this.zip_file_fs.getUrl(this.zip_file_path).joinPath(path)
    }
    public toDto(): ZipFsDto {
        return new ZipFsDto({
            zip_file_fs: this.zip_file_fs.toDto(), zip_file_path: this.zip_file_path.toDto()
        })
    }
    public static fromDto(dto: ZipFsDto): ZipFs{
        return new ZipFs(
            Filesystem.fromDto(dto.zip_file_fs),
            Path.parse(dto.zip_file_path)
        )
    }
}

export class OsFs extends Filesystem{
    public constructor(){
        super(new Url({
            protocol: "file",
            hostname: "localhost", //FIXME?
            path: Path.parse("/"),
        }))
    }

    public static fromDto(_message: OsfsDto): OsFs {
        return new OsFs()
    }
    public toDto(): OsfsDto {
        return new OsfsDto({path: this.url.path.raw})
    }
    public getUrl(_path: Path): Url {
        throw `not implemented`
    }
}

export class HttpFs extends Filesystem{
    public readonly protocol: "http" | "https"
    public constructor(params: {
        protocol: "http" | "https",
        hostname: string,
        port?: number,
        path: Path,
        search?: Map<string, string>
    }){
        super(new Url({
            protocol: params.protocol,
            hostname: params.hostname,
            port: params.port,
            path: params.path,
            search: params.search
        }))
        this.protocol = params.protocol
    }
    public static fromDto(message: HttpFsDto): HttpFs {
        const search = new Map<string, string>();
        for(let key in message.search){
            search.set(key, message.search[key])
        }
        return new HttpFs({
            protocol: message.protocol,
            hostname: message.hostname,
            path: Path.parse(message.path),
            port: message.port,
            search,
        })
    }
    public toDto(): HttpFsDto {
        let search: {[key: string]: string} = {}
        for(let [key, value] of this.url.search){
            search[key] = value
        }
        return new HttpFsDto({
            protocol: this.protocol,
            hostname: this.url.hostname,
            path: this.url.path.toDto(),
            port: this.url.port,
            search
        })

    }
    public getUrl(path: Path): Url{
        return this.url.joinPath(path)
    }
}

export class BucketFs extends Filesystem{
    public static readonly API_URL = new Url({
        protocol: "https",
        hostname: "data-proxy.ebrains.eu",
        path: Path.parse('/api/v1/buckets/'),
    })
    public readonly bucket_name: string

    public constructor(params: {
        bucket_name: string,
    }){
        super(new Url({
            protocol: "https",
            hostname: "data-proxy.ebrains.eu",
            path: Path.parse(`/api/v1/buckets/${params.bucket_name}`),
        }))
        this.bucket_name = params.bucket_name
    }
    public static fromDto(message: BucketFSDto): BucketFs{
        return new BucketFs({bucket_name: message.bucket_name})
    }
    public toDto(): BucketFSDto{
        return new BucketFSDto({
            bucket_name: this.bucket_name,
        })
    }
    public getUrl(path: Path): Url{
        return this.url.joinPath(path)
    }
    public getDataProxyGuiUrl(params: {dirPath: Path}): Url{
        let prefix = params.dirPath.toDto().replace(/^\//, "") + "/"

        return new Url({
            protocol: "https",
            hostname: "data-proxy.ebrains.eu",
            path: new Path({components: [this.bucket_name]}),
            search: new Map([
                ["prefix", prefix],
            ]),
        })
    }
    public static tryGetDataProxyGuiUrl(params: {url: Url}): Url | undefined{
        if(!this.API_URL.isParentOf(params.url)){
            return undefined
        }
        const components = params.url.path.components;
        const bucketComponentIndex = this.API_URL.path.components.length
        const bucketName = components[bucketComponentIndex]
        const prefix = components.slice(bucketComponentIndex + 1).join("/") + "/"

        return new Url({
            protocol: "https",
            hostname: "data-proxy.ebrains.eu",
            path: new Path({components: [bucketName]}),
            search: new Map([
                ["prefix", prefix],
            ]),
        })
    }

}

export type DataSinkUnion = PrecomputedChunksSink | N5DataSink | DziLevelSink

export abstract class FsDataSink{
    public readonly filesystem: Filesystem
    public readonly path: Path
    public readonly tile_shape: Shape5D
    public readonly interval: Interval5D
    public readonly dtype: DataType
    public readonly resolution: [number, number, number]

    public constructor(params: {
        filesystem: Filesystem,
        path: Path,
        dtype: DataType,
        tile_shape: Shape5D,
        interval: Interval5D,
        resolution: [number, number, number]
    }){
        this.tile_shape = params.tile_shape
        this.interval = params.interval
        this.dtype = params.dtype
        this.filesystem = params.filesystem
        this.path = params.path
        this.resolution = params.resolution
    }

    public static fromDto(message: PrecomputedChunksSinkDto | N5DataSinkDto | DziLevelSinkDto): DataSinkUnion{
        if(message instanceof PrecomputedChunksSinkDto){
            return PrecomputedChunksSink.fromDto(message)
        }
        if(message instanceof N5DataSinkDto){
            return N5DataSink.fromDto(message)
        }
        if(message instanceof DziLevelSinkDto){
            return DziLevelSink.fromDto(message)
        }
        assertUnreachable(message)
    }

    public abstract toDataSource(): FsDataSource;
}

export class PrecomputedChunksSink extends FsDataSink{
    public readonly scale_key: Path
    public readonly encoding: "raw" | "jpeg"

    public constructor(params: ConstructorParameters<typeof FsDataSink>[0] & {
        scale_key: Path,
        encoding: "raw" | "jpeg",
    }){
        super(params)
        this.scale_key = params.scale_key
        this.encoding = params.encoding
    }

    public static fromDto(message: PrecomputedChunksSinkDto): PrecomputedChunksSink{
        return new PrecomputedChunksSink({
            filesystem: Filesystem.fromDto(message.filesystem),
            path: Path.parse(message.path),
            dtype: message.dtype,
            tile_shape: Shape5D.fromDto(message.tile_shape),
            interval: Interval5D.fromDto(message.interval),
            scale_key: Path.parse(message.scale_key),
            resolution: message.resolution,
            encoding: message.encoding,
        })
    }

    public toDto(): PrecomputedChunksSinkDto{
        return new PrecomputedChunksSinkDto({
            filesystem: this.filesystem.toDto(),
            path: this.path.toDto(),
            dtype: this.dtype,
            encoding: this.encoding,
            interval: this.interval.toDto(),
            resolution: this.resolution,
            scale_key: this.scale_key.toDto(),
            tile_shape: this.tile_shape.toDto(),
        })
    }

    public toDataSource(): PrecomputedChunksDataSource{
        //FIXME: stop using URLs; have datasources encode al the stuff they need in properties
        const datasourceUrl = this.filesystem.url.joinPath(this.path).updatedWith({
            datascheme: "precomputed",
            hash: `resolution=${this.resolution[0]}_${this.resolution[1]}_${this.resolution[2]}`
        })
        return new PrecomputedChunksDataSource({
            url: datasourceUrl,
            filesystem: this.filesystem,
            path: this.path,
            interval: this.interval,
            spatial_resolution: this.resolution,
            tile_shape: this.tile_shape,
            dtype: this.dtype,
            encoder: this.encoding,
            scale_key: this.scale_key,
        })
    }
}

export type N5CompressorDto = N5GzipCompressorDto | N5Bzip2CompressorDto | N5XzCompressorDto | N5RawCompressorDto;

export abstract class N5Compressor{
    public abstract to_dto(): N5CompressorDto;

    public static create_from_dto(dto: N5CompressorDto): N5Compressor{
        if(dto instanceof N5GzipCompressorDto){
            return GzipCompressor.from_dto(dto)
        }
        if(dto instanceof N5Bzip2CompressorDto){
            return Bzip2Compressor.from_dto(dto)
        }
        if(dto instanceof N5XzCompressorDto){
            return XzCompressor.from_dto(dto)
        }
        return RawCompressor.from_dto(dto)
    }
}

export class GzipCompressor extends N5Compressor{
    level: number
    constructor(params: {level: number}){
        super()
        this.level = params.level
    }

    public to_dto(): N5GzipCompressorDto{
        return new N5GzipCompressorDto({level: this.level})
    }

    public static from_dto(dto: N5GzipCompressorDto): GzipCompressor{
        return new GzipCompressor({level: dto.level})
    }
}

export class Bzip2Compressor extends N5Compressor{
    compressionLevel: number
    constructor(params: {compressionLevel: number}){
        super()
        this.compressionLevel = params.compressionLevel
    }

    public to_dto(): N5Bzip2CompressorDto{
        return new N5Bzip2CompressorDto({blockSize: this.compressionLevel})
    }

    public static from_dto(dto: N5Bzip2CompressorDto): Bzip2Compressor{
        return new Bzip2Compressor({compressionLevel: dto.blockSize})
    }
}

export class XzCompressor extends N5Compressor{
    preset: number
    constructor(params: {preset: number}){
        super()
        this.preset = params.preset
    }

    public to_dto(): N5XzCompressorDto{
        return new N5XzCompressorDto({preset: this.preset})
    }

    public static from_dto(dto: N5XzCompressorDto): XzCompressor{
        return new XzCompressor({preset: dto.preset})
    }
}

export class RawCompressor extends N5Compressor{
    public to_dto(): N5RawCompressorDto{
        return new N5RawCompressorDto({})
    }

    public static from_dto(_dto: N5RawCompressorDto): RawCompressor{
        return new RawCompressor()
    }
}


export class N5DataSink extends FsDataSink{
    public readonly compressor: N5Compressor
    public readonly c_axiskeys: string

    public constructor(params: ConstructorParameters<typeof FsDataSink>[0] & {
        c_axiskeys: string,
        compressor: N5Compressor,
    }){
        super(params)
        this.c_axiskeys = params.c_axiskeys
        this.compressor = params.compressor
    }
    public static fromDto(message: N5DataSinkDto): N5DataSink{
        return new N5DataSink({
            filesystem: Filesystem.fromDto(message.filesystem),
            path: Path.parse(message.path),
            dtype: message.dtype,
            tile_shape: Shape5D.fromDto(message.tile_shape),
            interval: Interval5D.fromDto(message.interval),
            resolution: message.spatial_resolution,
            compressor: N5Compressor.create_from_dto(message.compressor),
            c_axiskeys: message.c_axiskeys,
        })
    }
    public toDto(): N5DataSinkDto{
        return new N5DataSinkDto({
            filesystem: this.filesystem.toDto(),
            path: this.path.toDto(),
            dtype: this.dtype,
            compressor: this.compressor.to_dto(),
            interval: this.interval.toDto(),
            spatial_resolution: this.resolution,
            tile_shape: this.tile_shape.toDto(),
            c_axiskeys: this.c_axiskeys,
        })
    }
    public toDataSource(): N5DataSource{
        //FIXME: stop using URLs; have datasources encode al the stuff they need in properties
        const datasourceUrl = this.filesystem.url.joinPath(this.path).updatedWith({
            datascheme: "n5",
        })
        return new N5DataSource({
            url: datasourceUrl,
            filesystem: this.filesystem,
            path: this.path,
            interval: this.interval,
            spatial_resolution: this.resolution,
            tile_shape: this.tile_shape,
            dtype: this.dtype,
            compressor: this.compressor,
            c_axiskeys: this.c_axiskeys,
        })
    }
}

export class DziLevelSink extends FsDataSink{
    public readonly dzi_image: DziImageElement
    public readonly level_index: number
    public readonly xml_path: Path
    public readonly num_channels: 1 | 3

    public constructor(params: {
        filesystem: Filesystem,
        xml_path: Path,
        dzi_image: DziImageElement,
        num_channels: 1 | 3,
        level_index: number,
    }){
        let level_path = DziImageElement.make_level_path(params.xml_path, params.level_index)
        super({
            dtype: "uint8",
            filesystem: params.filesystem,
            interval: new Shape5D({x: params.dzi_image.Size.Width, y: params.dzi_image.Size.Height, c: params.num_channels}).toInterval5D({}),
            path: level_path,
            tile_shape: params.dzi_image.get_tile_shape(params.num_channels),
            resolution: [1,1,1],
        })
        this.xml_path = params.xml_path
        this.level_index = params.level_index
        this.dzi_image = params.dzi_image
        this.num_channels = params.num_channels
    }

    public static fromDto(dto: DziLevelSinkDto) : DziLevelSink{
        return new DziLevelSink({
            filesystem: Filesystem.fromDto(dto.filesystem),
            dzi_image: DziImageElement.fromDto(dto.dzi_image),
            xml_path: Path.fromDto(dto.xml_path),
            level_index: dto.level_index,
            num_channels: dto.num_channels,
        })
    }

    public toDto(): DziLevelSinkDto{
        return new DziLevelSinkDto({
            xml_path: this.xml_path.toDto(),
            dzi_image: this.dzi_image.toDto(),
            filesystem: this.filesystem.toDto(),
            level_index: this.level_index,
            num_channels: this.num_channels,
        })
    }

    public toDataSource(): FsDataSource {
        return new DziLevelDataSource({
            dzi_image: this.dzi_image,
            filesystem: this.filesystem,
            level_index: this.level_index,
            num_channels: this.num_channels,
            xml_path: this.xml_path,
        })
    }
}