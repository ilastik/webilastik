"""
This type stub file was generated by pyright.
"""

from .. import h5, h5d
from .base import HLObject, with_phil
from .vds import vds_support
from typing import Any, Optional

"""
    Implements support for high-level dataset access.
"""
_LEGACY_GZIP_COMPRESSION_VALS = frozenset(range(10))
MPI = h5.get_config().mpi
def readtime_dtype(basetype, names):
    """ Make a NumPy dtype appropriate for reading """
    ...

def make_new_dset(parent, shape: Optional[Any] = ..., dtype: Optional[Any] = ..., data: Optional[Any] = ..., chunks: Optional[Any] = ..., compression: Optional[Any] = ..., shuffle: Optional[Any] = ..., fletcher32: Optional[Any] = ..., maxshape: Optional[Any] = ..., compression_opts: Optional[Any] = ..., fillvalue: Optional[Any] = ..., scaleoffset: Optional[Any] = ..., track_times: Optional[Any] = ..., external: Optional[Any] = ..., track_order: Optional[Any] = ..., dcpl: Optional[Any] = ...):
    """ Return a new low-level dataset identifier

    Only creates anonymous datasets.
    """
    ...

def make_new_virtual_dset(parent, shape, sources, dtype: Optional[Any] = ..., maxshape: Optional[Any] = ..., fillvalue: Optional[Any] = ...):
    """Return a new low-level dataset identifier for a virtual dataset

    Like make_new_dset(), this creates an anonymous dataset, which can be given
    a name later.
    """
    ...

class AstypeContext(object):
    """
        Context manager which allows changing the type read from a dataset.
    """
    def __init__(self, dset, dtype):
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *args):
        ...
    


if MPI:
    class CollectiveContext(object):
        """ Manages collective I/O in MPI mode """
        def __init__(self, dset):
            ...
        
        def __enter__(self):
            ...
        
        def __exit__(self, *args):
            ...
        
    
    
class Dataset(HLObject):
    """
        Represents an HDF5 dataset
    """
    def astype(self, dtype):
        """ Get a context manager allowing you to perform reads to a
        different destination type, e.g.:

        >>> with dataset.astype('f8'):
        ...     double_precision = dataset[0:100:2]
        """
        ...
    
    if MPI:
        @property
        @with_phil
        def collective(self):
            """ Context manager for MPI collective reads & writes """
            ...
        
    @property
    def dims(self):
        """ Access dimension scales attached to this dataset. """
        ...
    
    @property
    @with_phil
    def ndim(self):
        """Numpy-style attribute giving the number of dimensions"""
        ...
    
    @property
    @with_phil
    def shape(self):
        """Numpy-style shape tuple giving dataset dimensions"""
        ...
    
    @shape.setter
    @with_phil
    def shape(self, shape):
        ...
    
    @property
    @with_phil
    def size(self):
        """Numpy-style attribute giving the total dataset size"""
        ...
    
    @property
    @with_phil
    def dtype(self):
        """Numpy dtype representing the datatype"""
        ...
    
    @property
    @with_phil
    def value(self):
        """  Alias for dataset[()] """
        ...
    
    @property
    @with_phil
    def chunks(self):
        """Dataset chunks (or None)"""
        ...
    
    @property
    @with_phil
    def compression(self):
        """Compression strategy (or None)"""
        ...
    
    @property
    @with_phil
    def compression_opts(self):
        """ Compression setting.  Int(0-9) for gzip, 2-tuple for szip. """
        ...
    
    @property
    @with_phil
    def shuffle(self):
        """Shuffle filter present (T/F)"""
        ...
    
    @property
    @with_phil
    def fletcher32(self):
        """Fletcher32 filter is present (T/F)"""
        ...
    
    @property
    @with_phil
    def scaleoffset(self):
        """Scale/offset filter settings. For integer data types, this is
        the number of bits stored, or 0 for auto-detected. For floating
        point data types, this is the number of decimal places retained.
        If the scale/offset filter is not in use, this is None."""
        ...
    
    @property
    @with_phil
    def external(self):
        """External file settings. Returns a list of tuples of
        (name, offset, size) for each external file entry, or returns None
        if no external files are used."""
        ...
    
    @property
    @with_phil
    def maxshape(self):
        """Shape up to which this dataset can be resized.  Axes with value
        None have no resize limit. """
        ...
    
    @property
    @with_phil
    def fillvalue(self):
        """Fill value for this dataset (0 by default)"""
        ...
    
    @with_phil
    def __init__(self, bind):
        """ Create a new Dataset object by binding to a low-level DatasetID.
        """
        ...
    
    def resize(self, size, axis: Optional[Any] = ...):
        """ Resize the dataset, or the specified axis.

        The dataset must be stored in chunked format; it can be resized up to
        the "maximum shape" (keyword maxshape) specified at creation time.
        The rank of the dataset cannot be changed.

        "Size" should be a shape tuple, or if an axis is specified, an integer.

        BEWARE: This functions differently than the NumPy resize() method!
        The data is not "reshuffled" to fit in the new shape; each axis is
        grown or shrunk independently.  The coordinates of existing data are
        fixed.
        """
        ...
    
    @with_phil
    def __len__(self):
        """ The size of the first axis.  TypeError if scalar.

        Limited to 2**32 on 32-bit systems; Dataset.len() is preferred.
        """
        ...
    
    def len(self):
        """ The size of the first axis.  TypeError if scalar.

        Use of this method is preferred to len(dset), as Python's built-in
        len() cannot handle values greater then 2**32 on 32-bit systems.
        """
        ...
    
    @with_phil
    def __iter__(self):
        """ Iterate over the first axis.  TypeError if scalar.

        BEWARE: Modifications to the yielded data are *NOT* written to file.
        """
        ...
    
    @with_phil
    def __getitem__(self, args):
        """ Read a slice from the HDF5 dataset.

        Takes slices and recarray-style field names (more than one is
        allowed!) in any order.  Obeys basic NumPy rules, including
        broadcasting.

        Also supports:

        * Boolean "mask" array indexing
        """
        ...
    
    @with_phil
    def __setitem__(self, args, val):
        """ Write to the HDF5 dataset from a Numpy array.

        NumPy's broadcasting rules are honored, for "simple" indexing
        (slices and integers).  For advanced indexing, the shapes must
        match.
        """
        ...
    
    def read_direct(self, dest, source_sel: Optional[Any] = ..., dest_sel: Optional[Any] = ...):
        """ Read data directly from HDF5 into an existing NumPy array.

        The destination array must be C-contiguous and writable.
        Selections must be the output of numpy.s_[<args>].

        Broadcasting is supported for simple indexing.
        """
        ...
    
    def write_direct(self, source, source_sel: Optional[Any] = ..., dest_sel: Optional[Any] = ...):
        """ Write data directly to HDF5 from a NumPy array.

        The source array must be C-contiguous.  Selections must be
        the output of numpy.s_[<args>].

        Broadcasting is supported for simple indexing.
        """
        ...
    
    @with_phil
    def __array__(self, dtype: Optional[Any] = ...):
        """ Create a Numpy array containing the whole dataset.  DON'T THINK
        THIS MEANS DATASETS ARE INTERCHANGEABLE WITH ARRAYS.  For one thing,
        you have to read the whole dataset every time this method is called.
        """
        ...
    
    @with_phil
    def __repr__(self):
        ...
    
    if hasattr(h5d.DatasetID, "refresh"):
        @with_phil
        def refresh(self):
            """ Refresh the dataset metadata by reloading from the file.

            This is part of the SWMR features and only exist when the HDF5
            library version >=1.9.178
            """
            ...
        
    if hasattr(h5d.DatasetID, "flush"):
        @with_phil
        def flush(self):
            """ Flush the dataset data and metadata to the file.
            If the dataset is chunked, raw data chunks are written to the file.

            This is part of the SWMR features and only exist when the HDF5
            library version >=1.9.178
            """
            ...
        
    if vds_support:
        @property
        @with_phil
        def is_virtual(self):
            ...
        
        @with_phil
        def virtual_sources(self):
            ...
        
    @with_phil
    def make_scale(self, name=...):
        """Make this dataset an HDF5 dimension scale.

        You can then attach it to dimensions of other datasets like this::

            other_ds.dims[0].attach_scale(ds)

        You can optionally pass a name to associate with this scale.
        """
        ...
    


